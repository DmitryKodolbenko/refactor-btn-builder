{"ast":null,"code":"import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { flow, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\nvar _map = function _map(fa, f) {\n  return pipe(fa, map(f));\n};\nvar _ap = function _ap(fab, fa) {\n  return pipe(fab, ap(fa));\n};\n/* istanbul ignore next */\nvar _chain = function _chain(ma, f) {\n  return pipe(ma, chain(f));\n};\n/* istanbul ignore next */\nvar _reduce = function _reduce(fa, b, f) {\n  return pipe(fa, reduce(b, f));\n};\n/* istanbul ignore next */\nvar _foldMap = function _foldMap(M) {\n  return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n  };\n};\n/* istanbul ignore next */\nvar _reduceRight = function _reduceRight(fa, b, f) {\n  return pipe(fa, reduceRight(b, f));\n};\nvar _traverse = function _traverse(F) {\n  var traverseF = traverse(F);\n  return function (ta, f) {\n    return pipe(ta, traverseF(f));\n  };\n};\nvar _bimap = function _bimap(fa, f, g) {\n  return pipe(fa, bimap(f, g));\n};\nvar _mapLeft = function _mapLeft(fa, f) {\n  return pipe(fa, mapLeft(f));\n};\n/* istanbul ignore next */\nvar _alt = function _alt(fa, that) {\n  return pipe(fa, alt(that));\n};\n/* istanbul ignore next */\nvar _extend = function _extend(wa, f) {\n  return pipe(wa, extend(f));\n};\nvar _chainRec = function _chainRec(a, f) {\n  return tailRec(f(a), function (e) {\n    return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n  });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function getShow(SE, SA) {\n  return {\n    show: function show(ma) {\n      return isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\");\n    }\n  };\n};\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function getEq(EL, EA) {\n  return {\n    equals: function equals(x, y) {\n      return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n  };\n};\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function getSemigroup(S) {\n  return {\n    concat: function concat(x, y) {\n      return isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right));\n    }\n  };\n};\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function getCompactable(M) {\n  var empty = left(M.empty);\n  return {\n    URI: URI,\n    _E: undefined,\n    compact: function compact(ma) {\n      return isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value);\n    },\n    separate: function separate(ma) {\n      return isLeft(ma) ? separated(ma, ma) : isLeft(ma.right) ? separated(right(ma.right.left), empty) : separated(empty, right(ma.right.right));\n    }\n  };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function getFilterable(M) {\n  var empty = left(M.empty);\n  var _a = getCompactable(M),\n    compact = _a.compact,\n    separate = _a.separate;\n  var filter = function filter(ma, predicate) {\n    return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n  };\n  var partition = function partition(ma, p) {\n    return isLeft(ma) ? separated(ma, ma) : p(ma.right) ? separated(empty, right(ma.right)) : separated(right(ma.right), empty);\n  };\n  return {\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: filter,\n    filterMap: function filterMap(ma, f) {\n      if (isLeft(ma)) {\n        return ma;\n      }\n      var ob = f(ma.right);\n      return ob._tag === 'None' ? empty : right(ob.value);\n    },\n    partition: partition,\n    partitionMap: function partitionMap(ma, f) {\n      if (isLeft(ma)) {\n        return separated(ma, ma);\n      }\n      var e = f(ma.right);\n      return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n    }\n  };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function getWitherable(M) {\n  var F_ = getFilterable(M);\n  var C = getCompactable(M);\n  return {\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    compact: F_.compact,\n    separate: F_.separate,\n    filter: F_.filter,\n    filterMap: F_.filterMap,\n    partition: F_.partition,\n    partitionMap: F_.partitionMap,\n    traverse: _traverse,\n    sequence: sequence,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    wither: witherDefault(Traversable, C),\n    wilt: wiltDefault(Traversable, C)\n  };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function getApplicativeValidation(SE) {\n  return {\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function ap(fab, fa) {\n      return isLeft(fab) ? isLeft(fa) ? left(SE.concat(fab.left, fa.left)) : fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n    },\n    of: of\n  };\n};\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function getAltValidation(SE) {\n  return {\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function alt(me, that) {\n      if (isRight(me)) {\n        return me;\n      }\n      var ea = that();\n      return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n  };\n};\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function map(f) {\n  return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n  };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n  URI: URI,\n  map: _map\n};\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n  URI: URI,\n  of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function apW(fa) {\n  return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n  };\n};\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n  URI: URI,\n  map: _map,\n  ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n  URI: URI,\n  map: _map,\n  ap: _ap,\n  of: of\n};\n/**\n * Less strict version of [`chain`](#chain).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * const e1: E.Either<string, number> = E.right(1)\n * const e2: E.Either<number, number> = E.right(2)\n *\n * export const result1 = pipe(\n *   // @ts-expect-error\n *   e1,\n *   E.chain(() => e2)\n * )\n *\n * // merged error types -----v-------------v\n * // const result2: E.Either<string | number, number>\n * export const result2 = pipe(\n *   e1, // no error\n *   E.chainW(() => e2)\n * )\n *\n * @category sequencing\n * @since 2.6.0\n */\nexport var chainW = function chainW(f) {\n  return function (ma) {\n    return isLeft(ma) ? ma : f(ma.right);\n  };\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var chain = chainW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n  URI: URI,\n  map: _map,\n  ap: _ap,\n  chain: _chain\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n  URI: URI,\n  map: _map,\n  ap: _ap,\n  of: of,\n  chain: _chain\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function reduce(b, f) {\n  return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n  };\n};\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function foldMap(M) {\n  return function (f) {\n    return function (fa) {\n      return isLeft(fa) ? M.empty : f(fa.right);\n    };\n  };\n};\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function reduceRight(b, f) {\n  return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n  };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n  URI: URI,\n  reduce: _reduce,\n  foldMap: _foldMap,\n  reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function traverse(F) {\n  return function (f) {\n    return function (ta) {\n      return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n    };\n  };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function sequence(F) {\n  return function (ma) {\n    return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n  };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n  URI: URI,\n  map: _map,\n  reduce: _reduce,\n  foldMap: _foldMap,\n  reduceRight: _reduceRight,\n  traverse: _traverse,\n  sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function bimap(f, g) {\n  return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n  };\n};\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function mapLeft(f) {\n  return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n  };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n  URI: URI,\n  bimap: _bimap,\n  mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function altW(that) {\n  return function (fa) {\n    return isLeft(fa) ? that() : fa;\n  };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n  URI: URI,\n  map: _map,\n  alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function extend(f) {\n  return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n  };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n  URI: URI,\n  map: _map,\n  extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n  URI: URI,\n  map: _map,\n  ap: _ap,\n  chain: _chain,\n  chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n  URI: URI,\n  map: _map,\n  ap: _ap,\n  of: of,\n  chain: _chain,\n  throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n  URI: URI,\n  fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = /*#__PURE__*/fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function matchW(onLeft, onRight) {\n  return function (ma) {\n    return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n  };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function getOrElseW(onLeft) {\n  return function (ma) {\n    return isLeft(ma) ? onLeft(ma.left) : ma.right;\n  };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var chainFirst = /*#__PURE__*/chainFirst_(Chain);\n/**\n * Less strict version of [`chainFirst`](#chainfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.8.0\n */\nexport var chainFirstW = chainFirst;\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = /*#__PURE__*/chainW(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/extend(identity);\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromOptionK = /*#__PURE__*/fromOptionK_(FromEither);\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/chainOptionK_(FromEither, Chain);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function swap(ma) {\n  return isLeft(ma) ? right(ma.left) : left(ma.right);\n};\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function orElseW(onLeft) {\n  return function (ma) {\n    return isLeft(ma) ? onLeft(ma.left) : ma;\n  };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function fromNullable(e) {\n  return function (a) {\n    return a == null ? left(e) : right(a);\n  };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function tryCatch(f, onThrow) {\n  try {\n    return right(f());\n  } catch (e) {\n    return left(onThrow(e));\n  }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function tryCatchK(f, onThrow) {\n  return function () {\n    var a = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      a[_i] = arguments[_i];\n    }\n    return tryCatch(function () {\n      return f.apply(void 0, a);\n    }, onThrow);\n  };\n};\n/**\n * @category lifting\n * @since 2.9.0\n */\nexport var fromNullableK = function fromNullableK(e) {\n  var from = fromNullable(e);\n  return function (f) {\n    return flow(f, from);\n  };\n};\n/**\n * @category sequencing\n * @since 2.9.0\n */\nexport var chainNullableK = function chainNullableK(e) {\n  var from = fromNullableK(e);\n  return function (f) {\n    return chain(from(f));\n  };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n  return e instanceof Error ? e : new Error(String(e));\n}\nexport function elem(E) {\n  return function (a, ma) {\n    if (ma === undefined) {\n      var elemE_1 = elem(E);\n      return function (ma) {\n        return elemE_1(a, ma);\n      };\n    }\n    return isLeft(ma) ? false : E.equals(a, ma.right);\n  };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function exists(predicate) {\n  return function (ma) {\n    return isLeft(ma) ? false : predicate(ma.right);\n  };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/bindTo_(Functor);\nvar let_ = /*#__PURE__*/let__(Functor);\nexport {\n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/bind_(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function traverseReadonlyNonEmptyArrayWithIndex(f) {\n  return function (as) {\n    var e = f(0, _.head(as));\n    if (isLeft(e)) {\n      return e;\n    }\n    var out = [e.right];\n    for (var i = 1; i < as.length; i++) {\n      var e_1 = f(i, as[i]);\n      if (isLeft(e_1)) {\n        return e_1;\n      }\n      out.push(e_1.right);\n    }\n    return right(out);\n  };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function traverseReadonlyArrayWithIndex(f) {\n  var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n  return function (as) {\n    return _.isNonEmpty(as) ? g(as) : ApT;\n  };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function traverseArray(f) {\n  return traverseReadonlyArrayWithIndex(function (_, a) {\n    return f(a);\n  });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = /*#__PURE__*/traverseArray(identity);\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n  return tryCatch(function () {\n    return JSON.parse(s);\n  }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function stringifyJSON(u, onError) {\n  return tryCatch(function () {\n    var s = JSON.stringify(u);\n    if (typeof s !== 'string') {\n      throw new Error('Converting unsupported structure to JSON');\n    }\n    return s;\n  }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n  URI: URI,\n  map: _map,\n  of: of,\n  ap: _ap,\n  chain: _chain,\n  reduce: _reduce,\n  foldMap: _foldMap,\n  reduceRight: _reduceRight,\n  traverse: _traverse,\n  sequence: sequence,\n  bimap: _bimap,\n  mapLeft: _mapLeft,\n  alt: _alt,\n  extend: _extend,\n  chainRec: _chainRec,\n  throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = /*#__PURE__*/getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = /*#__PURE__*/getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function getValidationSemigroup(SE, SA) {\n  return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function getValidationMonoid(SE, MA) {\n  return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n  var ap = getApplicativeValidation(SE).ap;\n  var alt = getAltValidation(SE).alt;\n  return {\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    of: of,\n    chain: _chain,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    extend: _extend,\n    traverse: _traverse,\n    sequence: sequence,\n    chainRec: _chainRec,\n    throwError: throwError,\n    ap: ap,\n    alt: alt\n  };\n}","map":{"version":3,"names":["getApplicativeMonoid","apFirst","apFirst_","apS","apS_","apSecond","apSecond_","getApplySemigroup","getApplySemigroup_","bind","bind_","chainFirst","chainFirst_","tailRec","chainOptionK","chainOptionK_","filterOrElse","filterOrElse_","fromOption","fromOption_","fromOptionK","fromOptionK_","fromPredicate","fromPredicate_","flow","identity","pipe","bindTo","bindTo_","flap","flap_","let","let__","_","separated","wiltDefault","witherDefault","left","right","_map","fa","f","map","_ap","fab","ap","_chain","ma","chain","_reduce","b","reduce","_foldMap","M","foldMapM","foldMap","_reduceRight","reduceRight","_traverse","F","traverseF","traverse","ta","_bimap","g","bimap","_mapLeft","mapLeft","_alt","that","alt","_extend","wa","extend","_chainRec","a","e","isLeft","URI","getShow","SE","SA","show","concat","getEq","EL","EA","equals","x","y","isRight","getSemigroup","S","getCompactable","empty","_E","undefined","compact","_tag","value","separate","getFilterable","_a","filter","predicate","partition","p","filterMap","ob","partitionMap","getWitherable","F_","C","sequence","wither","Traversable","wilt","getApplicativeValidation","of","getAltValidation","me","ea","Functor","Pointed","apW","Apply","Applicative","chainW","Chain","Monad","Foldable","Bifunctor","altW","Alt","Extend","ChainRec","chainRec","throwError","MonadThrow","FromEither","fromEither","matchW","onLeft","onRight","foldW","match","fold","getOrElseW","getOrElse","apFirstW","apSecondW","chainFirstW","flattenW","flatten","duplicate","filterOrElseW","swap","orElseW","orElse","fromNullable","tryCatch","onThrow","tryCatchK","_i","arguments","length","apply","fromNullableK","from","chainNullableK","toUnion","toError","Error","String","elem","E","elemE_1","exists","Do","emptyRecord","let_","bindW","apSW","ApT","emptyReadonlyArray","traverseReadonlyNonEmptyArrayWithIndex","as","head","out","i","e_1","push","traverseReadonlyArrayWithIndex","isNonEmpty","traverseArrayWithIndex","traverseArray","sequenceArray","parseJSON","s","onError","JSON","parse","stringifyJSON","u","stringify","either","getApplyMonoid","getValidationSemigroup","getValidationMonoid","MA","getValidation"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/fp-ts/es6/Either.js"],"sourcesContent":["import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { flow, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _chain = function (ma, f) { return pipe(ma, chain(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * Less strict version of [`chain`](#chain).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * const e1: E.Either<string, number> = E.right(1)\n * const e2: E.Either<number, number> = E.right(2)\n *\n * export const result1 = pipe(\n *   // @ts-expect-error\n *   e1,\n *   E.chain(() => e2)\n * )\n *\n * // merged error types -----v-------------v\n * // const result2: E.Either<string | number, number>\n * export const result2 = pipe(\n *   e1, // no error\n *   E.chainW(() => e2)\n * )\n *\n * @category sequencing\n * @since 2.6.0\n */\nexport var chainW = function (f) {\n    return function (ma) {\n        return isLeft(ma) ? ma : f(ma.right);\n    };\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var chain = chainW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: _chain\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: _chain\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: _chain,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: _chain,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * Less strict version of [`chainFirst`](#chainfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.8.0\n */\nexport var chainFirstW = chainFirst;\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ chainW(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * @category lifting\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * @category sequencing\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return chain(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: _chain,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: _chain,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n"],"mappings":"AAAA,SAASA,oBAAoB,QAAQ,eAAe;AACpD,SAASC,OAAO,IAAIC,QAAQ,EAAEC,GAAG,IAAIC,IAAI,EAAEC,QAAQ,IAAIC,SAAS,EAAEC,iBAAiB,IAAIC,kBAAkB,QAAQ,SAAS;AAC1H,SAASC,IAAI,IAAIC,KAAK,EAAEC,UAAU,IAAIC,WAAW,QAAQ,SAAS;AAClE,SAASC,OAAO,QAAQ,YAAY;AACpC,SAASC,YAAY,IAAIC,aAAa,EAAEC,YAAY,IAAIC,aAAa,EAAEC,UAAU,IAAIC,WAAW,EAAEC,WAAW,IAAIC,YAAY,EAAEC,aAAa,IAAIC,cAAc,QAAQ,cAAc;AACpL,SAASC,IAAI,EAAEC,QAAQ,EAAEC,IAAI,QAAQ,YAAY;AACjD,SAASC,MAAM,IAAIC,OAAO,EAAEC,IAAI,IAAIC,KAAK,EAAEC,GAAG,IAAIC,KAAK,QAAQ,WAAW;AAC1E,OAAO,KAAKC,CAAC,MAAM,YAAY;AAC/B,SAASC,SAAS,QAAQ,aAAa;AACvC,SAASC,WAAW,EAAEC,aAAa,QAAQ,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,IAAI,GAAGJ,CAAC,CAACI,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,KAAK,GAAGL,CAAC,CAACK,KAAK;AAC1B,IAAIC,IAAI,GAAG,SAAPA,IAAI,CAAaC,EAAE,EAAEC,CAAC,EAAE;EAAE,OAAOf,IAAI,CAACc,EAAE,EAAEE,GAAG,CAACD,CAAC,CAAC,CAAC;AAAE,CAAC;AACxD,IAAIE,GAAG,GAAG,SAANA,GAAG,CAAaC,GAAG,EAAEJ,EAAE,EAAE;EAAE,OAAOd,IAAI,CAACkB,GAAG,EAAEC,EAAE,CAACL,EAAE,CAAC,CAAC;AAAE,CAAC;AAC1D;AACA,IAAIM,MAAM,GAAG,SAATA,MAAM,CAAaC,EAAE,EAAEN,CAAC,EAAE;EAAE,OAAOf,IAAI,CAACqB,EAAE,EAAEC,KAAK,CAACP,CAAC,CAAC,CAAC;AAAE,CAAC;AAC5D;AACA,IAAIQ,OAAO,GAAG,SAAVA,OAAO,CAAaT,EAAE,EAAEU,CAAC,EAAET,CAAC,EAAE;EAAE,OAAOf,IAAI,CAACc,EAAE,EAAEW,MAAM,CAACD,CAAC,EAAET,CAAC,CAAC,CAAC;AAAE,CAAC;AACpE;AACA,IAAIW,QAAQ,GAAG,SAAXA,QAAQ,CAAaC,CAAC,EAAE;EAAE,OAAO,UAAUb,EAAE,EAAEC,CAAC,EAAE;IAClD,IAAIa,QAAQ,GAAGC,OAAO,CAACF,CAAC,CAAC;IACzB,OAAO3B,IAAI,CAACc,EAAE,EAAEc,QAAQ,CAACb,CAAC,CAAC,CAAC;EAChC,CAAC;AAAE,CAAC;AACJ;AACA,IAAIe,YAAY,GAAG,SAAfA,YAAY,CAAahB,EAAE,EAAEU,CAAC,EAAET,CAAC,EAAE;EAAE,OAAOf,IAAI,CAACc,EAAE,EAAEiB,WAAW,CAACP,CAAC,EAAET,CAAC,CAAC,CAAC;AAAE,CAAC;AAC9E,IAAIiB,SAAS,GAAG,SAAZA,SAAS,CAAaC,CAAC,EAAE;EACzB,IAAIC,SAAS,GAAGC,QAAQ,CAACF,CAAC,CAAC;EAC3B,OAAO,UAAUG,EAAE,EAAErB,CAAC,EAAE;IAAE,OAAOf,IAAI,CAACoC,EAAE,EAAEF,SAAS,CAACnB,CAAC,CAAC,CAAC;EAAE,CAAC;AAC9D,CAAC;AACD,IAAIsB,MAAM,GAAG,SAATA,MAAM,CAAavB,EAAE,EAAEC,CAAC,EAAEuB,CAAC,EAAE;EAAE,OAAOtC,IAAI,CAACc,EAAE,EAAEyB,KAAK,CAACxB,CAAC,EAAEuB,CAAC,CAAC,CAAC;AAAE,CAAC;AAClE,IAAIE,QAAQ,GAAG,SAAXA,QAAQ,CAAa1B,EAAE,EAAEC,CAAC,EAAE;EAAE,OAAOf,IAAI,CAACc,EAAE,EAAE2B,OAAO,CAAC1B,CAAC,CAAC,CAAC;AAAE,CAAC;AAChE;AACA,IAAI2B,IAAI,GAAG,SAAPA,IAAI,CAAa5B,EAAE,EAAE6B,IAAI,EAAE;EAAE,OAAO3C,IAAI,CAACc,EAAE,EAAE8B,GAAG,CAACD,IAAI,CAAC,CAAC;AAAE,CAAC;AAC9D;AACA,IAAIE,OAAO,GAAG,SAAVA,OAAO,CAAaC,EAAE,EAAE/B,CAAC,EAAE;EAAE,OAAOf,IAAI,CAAC8C,EAAE,EAAEC,MAAM,CAAChC,CAAC,CAAC,CAAC;AAAE,CAAC;AAC9D,IAAIiC,SAAS,GAAG,SAAZA,SAAS,CAAaC,CAAC,EAAElC,CAAC,EAAE;EAC5B,OAAO5B,OAAO,CAAC4B,CAAC,CAACkC,CAAC,CAAC,EAAE,UAAUC,CAAC,EAAE;IAC9B,OAAOC,MAAM,CAACD,CAAC,CAAC,GAAGtC,KAAK,CAACD,IAAI,CAACuC,CAAC,CAACvC,IAAI,CAAC,CAAC,GAAGwC,MAAM,CAACD,CAAC,CAACtC,KAAK,CAAC,GAAGD,IAAI,CAACI,CAAC,CAACmC,CAAC,CAACtC,KAAK,CAACD,IAAI,CAAC,CAAC,GAAGC,KAAK,CAACA,KAAK,CAACsC,CAAC,CAACtC,KAAK,CAACA,KAAK,CAAC,CAAC;EAClH,CAAC,CAAC;AACN,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,IAAIwC,GAAG,GAAG,QAAQ;AACzB;AACA;AACA;AACA;AACA,OAAO,IAAIC,OAAO,GAAG,SAAVA,OAAO,CAAaC,EAAE,EAAEC,EAAE,EAAE;EAAE,OAAQ;IAC7CC,IAAI,EAAE,cAAUnC,EAAE,EAAE;MAAE,OAAQ8B,MAAM,CAAC9B,EAAE,CAAC,GAAG,OAAO,CAACoC,MAAM,CAACH,EAAE,CAACE,IAAI,CAACnC,EAAE,CAACV,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,QAAQ,CAAC8C,MAAM,CAACF,EAAE,CAACC,IAAI,CAACnC,EAAE,CAACT,KAAK,CAAC,EAAE,GAAG,CAAC;IAAG;EACjI,CAAC;AAAG,CAAC;AACL;AACA;AACA;AACA;AACA,OAAO,IAAI8C,KAAK,GAAG,SAARA,KAAK,CAAaC,EAAE,EAAEC,EAAE,EAAE;EAAE,OAAQ;IAC3CC,MAAM,EAAE,gBAAUC,CAAC,EAAEC,CAAC,EAAE;MACpB,OAAOD,CAAC,KAAKC,CAAC,KAAKZ,MAAM,CAACW,CAAC,CAAC,GAAGX,MAAM,CAACY,CAAC,CAAC,IAAIJ,EAAE,CAACE,MAAM,CAACC,CAAC,CAACnD,IAAI,EAAEoD,CAAC,CAACpD,IAAI,CAAC,GAAGqD,OAAO,CAACD,CAAC,CAAC,IAAIH,EAAE,CAACC,MAAM,CAACC,CAAC,CAAClD,KAAK,EAAEmD,CAAC,CAACnD,KAAK,CAAC,CAAC;IACtH;EACJ,CAAC;AAAG,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIqD,YAAY,GAAG,SAAfA,YAAY,CAAaC,CAAC,EAAE;EAAE,OAAQ;IAC7CT,MAAM,EAAE,gBAAUK,CAAC,EAAEC,CAAC,EAAE;MAAE,OAAQZ,MAAM,CAACY,CAAC,CAAC,GAAGD,CAAC,GAAGX,MAAM,CAACW,CAAC,CAAC,GAAGC,CAAC,GAAGnD,KAAK,CAACsD,CAAC,CAACT,MAAM,CAACK,CAAC,CAAClD,KAAK,EAAEmD,CAAC,CAACnD,KAAK,CAAC,CAAC;IAAG;EAC1G,CAAC;AAAG,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIuD,cAAc,GAAG,SAAjBA,cAAc,CAAaxC,CAAC,EAAE;EACrC,IAAIyC,KAAK,GAAGzD,IAAI,CAACgB,CAAC,CAACyC,KAAK,CAAC;EACzB,OAAO;IACHhB,GAAG,EAAEA,GAAG;IACRiB,EAAE,EAAEC,SAAS;IACbC,OAAO,EAAE,iBAAUlD,EAAE,EAAE;MAAE,OAAQ8B,MAAM,CAAC9B,EAAE,CAAC,GAAGA,EAAE,GAAGA,EAAE,CAACT,KAAK,CAAC4D,IAAI,KAAK,MAAM,GAAGJ,KAAK,GAAGxD,KAAK,CAACS,EAAE,CAACT,KAAK,CAAC6D,KAAK,CAAC;IAAG,CAAC;IAC/GC,QAAQ,EAAE,kBAAUrD,EAAE,EAAE;MACpB,OAAO8B,MAAM,CAAC9B,EAAE,CAAC,GACXb,SAAS,CAACa,EAAE,EAAEA,EAAE,CAAC,GACjB8B,MAAM,CAAC9B,EAAE,CAACT,KAAK,CAAC,GACZJ,SAAS,CAACI,KAAK,CAACS,EAAE,CAACT,KAAK,CAACD,IAAI,CAAC,EAAEyD,KAAK,CAAC,GACtC5D,SAAS,CAAC4D,KAAK,EAAExD,KAAK,CAACS,EAAE,CAACT,KAAK,CAACA,KAAK,CAAC,CAAC;IACrD;EACJ,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI+D,aAAa,GAAG,SAAhBA,aAAa,CAAahD,CAAC,EAAE;EACpC,IAAIyC,KAAK,GAAGzD,IAAI,CAACgB,CAAC,CAACyC,KAAK,CAAC;EACzB,IAAIQ,EAAE,GAAGT,cAAc,CAACxC,CAAC,CAAC;IAAE4C,OAAO,GAAGK,EAAE,CAACL,OAAO;IAAEG,QAAQ,GAAGE,EAAE,CAACF,QAAQ;EACxE,IAAIG,MAAM,GAAG,SAATA,MAAM,CAAaxD,EAAE,EAAEyD,SAAS,EAAE;IAClC,OAAO3B,MAAM,CAAC9B,EAAE,CAAC,GAAGA,EAAE,GAAGyD,SAAS,CAACzD,EAAE,CAACT,KAAK,CAAC,GAAGS,EAAE,GAAG+C,KAAK;EAC7D,CAAC;EACD,IAAIW,SAAS,GAAG,SAAZA,SAAS,CAAa1D,EAAE,EAAE2D,CAAC,EAAE;IAC7B,OAAO7B,MAAM,CAAC9B,EAAE,CAAC,GACXb,SAAS,CAACa,EAAE,EAAEA,EAAE,CAAC,GACjB2D,CAAC,CAAC3D,EAAE,CAACT,KAAK,CAAC,GACPJ,SAAS,CAAC4D,KAAK,EAAExD,KAAK,CAACS,EAAE,CAACT,KAAK,CAAC,CAAC,GACjCJ,SAAS,CAACI,KAAK,CAACS,EAAE,CAACT,KAAK,CAAC,EAAEwD,KAAK,CAAC;EAC/C,CAAC;EACD,OAAO;IACHhB,GAAG,EAAEA,GAAG;IACRiB,EAAE,EAAEC,SAAS;IACbtD,GAAG,EAAEH,IAAI;IACT0D,OAAO,EAAEA,OAAO;IAChBG,QAAQ,EAAEA,QAAQ;IAClBG,MAAM,EAAEA,MAAM;IACdI,SAAS,EAAE,mBAAU5D,EAAE,EAAEN,CAAC,EAAE;MACxB,IAAIoC,MAAM,CAAC9B,EAAE,CAAC,EAAE;QACZ,OAAOA,EAAE;MACb;MACA,IAAI6D,EAAE,GAAGnE,CAAC,CAACM,EAAE,CAACT,KAAK,CAAC;MACpB,OAAOsE,EAAE,CAACV,IAAI,KAAK,MAAM,GAAGJ,KAAK,GAAGxD,KAAK,CAACsE,EAAE,CAACT,KAAK,CAAC;IACvD,CAAC;IACDM,SAAS,EAAEA,SAAS;IACpBI,YAAY,EAAE,sBAAU9D,EAAE,EAAEN,CAAC,EAAE;MAC3B,IAAIoC,MAAM,CAAC9B,EAAE,CAAC,EAAE;QACZ,OAAOb,SAAS,CAACa,EAAE,EAAEA,EAAE,CAAC;MAC5B;MACA,IAAI6B,CAAC,GAAGnC,CAAC,CAACM,EAAE,CAACT,KAAK,CAAC;MACnB,OAAOuC,MAAM,CAACD,CAAC,CAAC,GAAG1C,SAAS,CAACI,KAAK,CAACsC,CAAC,CAACvC,IAAI,CAAC,EAAEyD,KAAK,CAAC,GAAG5D,SAAS,CAAC4D,KAAK,EAAExD,KAAK,CAACsC,CAAC,CAACtC,KAAK,CAAC,CAAC;IACzF;EACJ,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIwE,aAAa,GAAG,SAAhBA,aAAa,CAAazD,CAAC,EAAE;EACpC,IAAI0D,EAAE,GAAGV,aAAa,CAAChD,CAAC,CAAC;EACzB,IAAI2D,CAAC,GAAGnB,cAAc,CAACxC,CAAC,CAAC;EACzB,OAAO;IACHyB,GAAG,EAAEA,GAAG;IACRiB,EAAE,EAAEC,SAAS;IACbtD,GAAG,EAAEH,IAAI;IACT0D,OAAO,EAAEc,EAAE,CAACd,OAAO;IACnBG,QAAQ,EAAEW,EAAE,CAACX,QAAQ;IACrBG,MAAM,EAAEQ,EAAE,CAACR,MAAM;IACjBI,SAAS,EAAEI,EAAE,CAACJ,SAAS;IACvBF,SAAS,EAAEM,EAAE,CAACN,SAAS;IACvBI,YAAY,EAAEE,EAAE,CAACF,YAAY;IAC7BhD,QAAQ,EAAEH,SAAS;IACnBuD,QAAQ,EAAEA,QAAQ;IAClB9D,MAAM,EAAEF,OAAO;IACfM,OAAO,EAAEH,QAAQ;IACjBK,WAAW,EAAED,YAAY;IACzB0D,MAAM,EAAE9E,aAAa,CAAC+E,WAAW,EAAEH,CAAC,CAAC;IACrCI,IAAI,EAAEjF,WAAW,CAACgF,WAAW,EAAEH,CAAC;EACpC,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIK,wBAAwB,GAAG,SAA3BA,wBAAwB,CAAarC,EAAE,EAAE;EAAE,OAAQ;IAC1DF,GAAG,EAAEA,GAAG;IACRiB,EAAE,EAAEC,SAAS;IACbtD,GAAG,EAAEH,IAAI;IACTM,EAAE,EAAE,YAAUD,GAAG,EAAEJ,EAAE,EAAE;MACnB,OAAOqC,MAAM,CAACjC,GAAG,CAAC,GACZiC,MAAM,CAACrC,EAAE,CAAC,GACNH,IAAI,CAAC2C,EAAE,CAACG,MAAM,CAACvC,GAAG,CAACP,IAAI,EAAEG,EAAE,CAACH,IAAI,CAAC,CAAC,GAClCO,GAAG,GACPiC,MAAM,CAACrC,EAAE,CAAC,GACNA,EAAE,GACFF,KAAK,CAACM,GAAG,CAACN,KAAK,CAACE,EAAE,CAACF,KAAK,CAAC,CAAC;IACxC,CAAC;IACDgF,EAAE,EAAEA;EACR,CAAC;AAAG,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,gBAAgB,GAAG,SAAnBA,gBAAgB,CAAavC,EAAE,EAAE;EAAE,OAAQ;IAClDF,GAAG,EAAEA,GAAG;IACRiB,EAAE,EAAEC,SAAS;IACbtD,GAAG,EAAEH,IAAI;IACT+B,GAAG,EAAE,aAAUkD,EAAE,EAAEnD,IAAI,EAAE;MACrB,IAAIqB,OAAO,CAAC8B,EAAE,CAAC,EAAE;QACb,OAAOA,EAAE;MACb;MACA,IAAIC,EAAE,GAAGpD,IAAI,EAAE;MACf,OAAOQ,MAAM,CAAC4C,EAAE,CAAC,GAAGpF,IAAI,CAAC2C,EAAE,CAACG,MAAM,CAACqC,EAAE,CAACnF,IAAI,EAAEoF,EAAE,CAACpF,IAAI,CAAC,CAAC,GAAGoF,EAAE;IAC9D;EACJ,CAAC;AAAG,CAAC;AACL;AACA;AACA;AACA;AACA,OAAO,IAAI/E,GAAG,GAAG,SAANA,GAAG,CAAaD,CAAC,EAAE;EAAE,OAAO,UAAUD,EAAE,EAAE;IACjD,OAAOqC,MAAM,CAACrC,EAAE,CAAC,GAAGA,EAAE,GAAGF,KAAK,CAACG,CAAC,CAACD,EAAE,CAACF,KAAK,CAAC,CAAC;EAC/C,CAAC;AAAE,CAAC;AACJ;AACA;AACA;AACA;AACA,OAAO,IAAIoF,OAAO,GAAG;EACjB5C,GAAG,EAAEA,GAAG;EACRpC,GAAG,EAAEH;AACT,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,IAAI+E,EAAE,GAAGhF,KAAK;AACrB;AACA;AACA;AACA;AACA,OAAO,IAAIqF,OAAO,GAAG;EACjB7C,GAAG,EAAEA,GAAG;EACRwC,EAAE,EAAEA;AACR,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIM,GAAG,GAAG,SAANA,GAAG,CAAapF,EAAE,EAAE;EAAE,OAAO,UAAUI,GAAG,EAAE;IACnD,OAAOiC,MAAM,CAACjC,GAAG,CAAC,GAAGA,GAAG,GAAGiC,MAAM,CAACrC,EAAE,CAAC,GAAGA,EAAE,GAAGF,KAAK,CAACM,GAAG,CAACN,KAAK,CAACE,EAAE,CAACF,KAAK,CAAC,CAAC;EAC3E,CAAC;AAAE,CAAC;AACJ;AACA;AACA;AACA,OAAO,IAAIO,EAAE,GAAG+E,GAAG;AACnB;AACA;AACA;AACA;AACA,OAAO,IAAIC,KAAK,GAAG;EACf/C,GAAG,EAAEA,GAAG;EACRpC,GAAG,EAAEH,IAAI;EACTM,EAAE,EAAEF;AACR,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,IAAImF,WAAW,GAAG;EACrBhD,GAAG,EAAEA,GAAG;EACRpC,GAAG,EAAEH,IAAI;EACTM,EAAE,EAAEF,GAAG;EACP2E,EAAE,EAAEA;AACR,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIS,MAAM,GAAG,SAATA,MAAM,CAAatF,CAAC,EAAE;EAC7B,OAAO,UAAUM,EAAE,EAAE;IACjB,OAAO8B,MAAM,CAAC9B,EAAE,CAAC,GAAGA,EAAE,GAAGN,CAAC,CAACM,EAAE,CAACT,KAAK,CAAC;EACxC,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIU,KAAK,GAAG+E,MAAM;AACzB;AACA;AACA;AACA;AACA,OAAO,IAAIC,KAAK,GAAG;EACflD,GAAG,EAAEA,GAAG;EACRpC,GAAG,EAAEH,IAAI;EACTM,EAAE,EAAEF,GAAG;EACPK,KAAK,EAAEF;AACX,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,IAAImF,KAAK,GAAG;EACfnD,GAAG,EAAEA,GAAG;EACRpC,GAAG,EAAEH,IAAI;EACTM,EAAE,EAAEF,GAAG;EACP2E,EAAE,EAAEA,EAAE;EACNtE,KAAK,EAAEF;AACX,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIK,MAAM,GAAG,SAATA,MAAM,CAAaD,CAAC,EAAET,CAAC,EAAE;EAAE,OAAO,UAAUD,EAAE,EAAE;IACvD,OAAOqC,MAAM,CAACrC,EAAE,CAAC,GAAGU,CAAC,GAAGT,CAAC,CAACS,CAAC,EAAEV,EAAE,CAACF,KAAK,CAAC;EAC1C,CAAC;AAAE,CAAC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIiB,OAAO,GAAG,SAAVA,OAAO,CAAaF,CAAC,EAAE;EAAE,OAAO,UAAUZ,CAAC,EAAE;IAAE,OAAO,UAAU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ChB,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,IAAIE,UAAU,GAAG;EACpB7D,GAAG,EAAEA,GAAG;EACR8D,UAAU,EAAEnH;AAChB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIH,aAAa,GAAG,aAAcC,cAAc,CAACoH,UAAU,CAAC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIzH,UAAU,GACrB,aAAcC,WAAW,CAACwH,UAAU,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI9D,MAAM,GAAG5C,CAAC,CAAC4C,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIa,OAAO,GAAGzD,CAAC,CAACyD,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAImD,MAAM,GAAG,SAATA,MAAM,CAAaC,MAAM,EAAEC,OAAO,EAAE;EAC3C,OAAO,UAAUhG,EAAE,EAAE;IACjB,OAAO8B,MAAM,CAAC9B,EAAE,CAAC,GAAG+F,MAAM,CAAC/F,EAAE,CAACV,IAAI,CAAC,GAAG0G,OAAO,CAAChG,EAAE,CAACT,KAAK,CAAC;EAC3D,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI0G,KAAK,GAAGH,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAII,KAAK,GAAGJ,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIK,IAAI,GAAGD,KAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIE,UAAU,GAAG,SAAbA,UAAU,CAAaL,MAAM,EAAE;EACtC,OAAO,UAAU/F,EAAE,EAAE;IACjB,OAAO8B,MAAM,CAAC9B,EAAE,CAAC,GAAG+F,MAAM,CAAC/F,EAAE,CAACV,IAAI,CAAC,GAAGU,EAAE,CAACT,KAAK;EAClD,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI8G,SAAS,GAAGD,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAItH,IAAI,GAAG,aAAcC,KAAK,CAAC4F,OAAO,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIzH,OAAO,GAAG,aAAcC,QAAQ,CAAC2H,KAAK,CAAC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIwB,QAAQ,GAAGpJ,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,OAAO,IAAII,QAAQ,GAAG,aAAcC,SAAS,CAACuH,KAAK,CAAC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIyB,SAAS,GAAGjJ,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIM,UAAU,GACrB,aAAcC,WAAW,CAACoH,KAAK,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIuB,WAAW,GAAG5I,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI6I,QAAQ,GACnB,aAAczB,MAAM,CAACtG,QAAQ,CAAC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAA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"},"metadata":{},"sourceType":"module"}