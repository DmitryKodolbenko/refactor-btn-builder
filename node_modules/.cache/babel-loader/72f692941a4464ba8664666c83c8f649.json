{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Registry = exports.isTxBodyEncodeObject = exports.isPbjsGeneratedType = exports.isTsProtoGeneratedType = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst tx_1 = require(\"cosmjs-types/cosmos/bank/v1beta1/tx\");\nconst coin_1 = require(\"cosmjs-types/cosmos/base/v1beta1/coin\");\nconst tx_2 = require(\"cosmjs-types/cosmos/tx/v1beta1/tx\");\nconst any_1 = require(\"cosmjs-types/google/protobuf/any\");\nfunction isTsProtoGeneratedType(type) {\n  return typeof type.fromPartial === \"function\";\n}\nexports.isTsProtoGeneratedType = isTsProtoGeneratedType;\nfunction isPbjsGeneratedType(type) {\n  return !isTsProtoGeneratedType(type);\n}\nexports.isPbjsGeneratedType = isPbjsGeneratedType;\nconst defaultTypeUrls = {\n  cosmosCoin: \"/cosmos.base.v1beta1.Coin\",\n  cosmosMsgSend: \"/cosmos.bank.v1beta1.MsgSend\",\n  cosmosTxBody: \"/cosmos.tx.v1beta1.TxBody\",\n  googleAny: \"/google.protobuf.Any\"\n};\nfunction isTxBodyEncodeObject(encodeObject) {\n  return encodeObject.typeUrl === \"/cosmos.tx.v1beta1.TxBody\";\n}\nexports.isTxBodyEncodeObject = isTxBodyEncodeObject;\nclass Registry {\n  /**\n   * Creates a new Registry for mapping protobuf type identifiers/type URLs to\n   * actual implementations. Those implementations are typically generated with ts-proto\n   * but we also support protobuf.js as a type generator.\n   *\n   * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`\n   * for historic reasons. Those can be overriden by customTypes.\n   *\n   * There are currently two methods for adding new types:\n   * 1. Passing types to the constructor.\n   * 2. Using the `register()` method\n   */\n  constructor(customTypes) {\n    const {\n      cosmosCoin,\n      cosmosMsgSend\n    } = defaultTypeUrls;\n    this.types = customTypes ? new Map([...customTypes]) : new Map([[cosmosCoin, coin_1.Coin], [cosmosMsgSend, tx_1.MsgSend]]);\n  }\n  register(typeUrl, type) {\n    this.types.set(typeUrl, type);\n  }\n  /**\n   * Looks up a type that was previously added to the registry.\n   *\n   * The generator information (ts-proto or pbjs) gets lost along the way.\n   * If you need to work with the result type in TypeScript, you can use:\n   *\n   * ```\n   * import { assert } from \"@cosmjs/utils\";\n   *\n   * const Coin = registry.lookupType(\"/cosmos.base.v1beta1.Coin\");\n   * assert(Coin); // Ensures not unset\n   * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect\n   *\n   * // Coin is typed TsProtoGeneratedType now.\n   * ```\n   */\n  lookupType(typeUrl) {\n    return this.types.get(typeUrl);\n  }\n  lookupTypeWithError(typeUrl) {\n    const type = this.lookupType(typeUrl);\n    if (!type) {\n      throw new Error(`Unregistered type url: ${typeUrl}`);\n    }\n    return type;\n  }\n  /**\n   * Takes a typeUrl/value pair and encodes the value to protobuf if\n   * the given type was previously registered.\n   *\n   * If the value has to be wrapped in an Any, this needs to be done\n   * manually after this call. Or use `encodeAsAny` instead.\n   */\n  encode(encodeObject) {\n    const {\n      value,\n      typeUrl\n    } = encodeObject;\n    if (isTxBodyEncodeObject(encodeObject)) {\n      return this.encodeTxBody(value);\n    }\n    const type = this.lookupTypeWithError(typeUrl);\n    const instance = isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);\n    return type.encode(instance).finish();\n  }\n  /**\n   * Takes a typeUrl/value pair and encodes the value to an Any if\n   * the given type was previously registered.\n   */\n  encodeAsAny(encodeObject) {\n    const binaryValue = this.encode(encodeObject);\n    return any_1.Any.fromPartial({\n      typeUrl: encodeObject.typeUrl,\n      value: binaryValue\n    });\n  }\n  encodeTxBody(txBodyFields) {\n    const wrappedMessages = txBodyFields.messages.map(message => this.encodeAsAny(message));\n    const txBody = tx_2.TxBody.fromPartial({\n      ...txBodyFields,\n      messages: wrappedMessages\n    });\n    return tx_2.TxBody.encode(txBody).finish();\n  }\n  decode(_ref) {\n    let {\n      typeUrl,\n      value\n    } = _ref;\n    if (typeUrl === defaultTypeUrls.cosmosTxBody) {\n      return this.decodeTxBody(value);\n    }\n    const type = this.lookupTypeWithError(typeUrl);\n    const decoded = type.decode(value);\n    Object.entries(decoded).forEach(_ref2 => {\n      let [key, val] = _ref2;\n      if (typeof Buffer !== \"undefined\" && typeof Buffer.isBuffer !== \"undefined\" && Buffer.isBuffer(val)) {\n        decoded[key] = Uint8Array.from(val);\n      }\n    });\n    return decoded;\n  }\n  decodeTxBody(txBody) {\n    const decodedTxBody = tx_2.TxBody.decode(txBody);\n    return {\n      ...decodedTxBody,\n      messages: decodedTxBody.messages.map(_ref3 => {\n        let {\n          typeUrl: typeUrl,\n          value\n        } = _ref3;\n        if (!typeUrl) {\n          throw new Error(\"Missing type_url in Any\");\n        }\n        if (!value) {\n          throw new Error(\"Missing value in Any\");\n        }\n        return this.decode({\n          typeUrl,\n          value\n        });\n      })\n    };\n  }\n}\nexports.Registry = Registry;","map":{"version":3,"sources":["../src/registry.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Registry = exports.isTxBodyEncodeObject = exports.isPbjsGeneratedType = exports.isTsProtoGeneratedType = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst tx_1 = require(\"cosmjs-types/cosmos/bank/v1beta1/tx\");\nconst coin_1 = require(\"cosmjs-types/cosmos/base/v1beta1/coin\");\nconst tx_2 = require(\"cosmjs-types/cosmos/tx/v1beta1/tx\");\nconst any_1 = require(\"cosmjs-types/google/protobuf/any\");\nfunction isTsProtoGeneratedType(type) {\n    return typeof type.fromPartial === \"function\";\n}\nexports.isTsProtoGeneratedType = isTsProtoGeneratedType;\nfunction isPbjsGeneratedType(type) {\n    return !isTsProtoGeneratedType(type);\n}\nexports.isPbjsGeneratedType = isPbjsGeneratedType;\nconst defaultTypeUrls = {\n    cosmosCoin: \"/cosmos.base.v1beta1.Coin\",\n    cosmosMsgSend: \"/cosmos.bank.v1beta1.MsgSend\",\n    cosmosTxBody: \"/cosmos.tx.v1beta1.TxBody\",\n    googleAny: \"/google.protobuf.Any\",\n};\nfunction isTxBodyEncodeObject(encodeObject) {\n    return encodeObject.typeUrl === \"/cosmos.tx.v1beta1.TxBody\";\n}\nexports.isTxBodyEncodeObject = isTxBodyEncodeObject;\nclass Registry {\n    /**\n     * Creates a new Registry for mapping protobuf type identifiers/type URLs to\n     * actual implementations. Those implementations are typically generated with ts-proto\n     * but we also support protobuf.js as a type generator.\n     *\n     * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`\n     * for historic reasons. Those can be overriden by customTypes.\n     *\n     * There are currently two methods for adding new types:\n     * 1. Passing types to the constructor.\n     * 2. Using the `register()` method\n     */\n    constructor(customTypes) {\n        const { cosmosCoin, cosmosMsgSend } = defaultTypeUrls;\n        this.types = customTypes\n            ? new Map([...customTypes])\n            : new Map([\n                [cosmosCoin, coin_1.Coin],\n                [cosmosMsgSend, tx_1.MsgSend],\n            ]);\n    }\n    register(typeUrl, type) {\n        this.types.set(typeUrl, type);\n    }\n    /**\n     * Looks up a type that was previously added to the registry.\n     *\n     * The generator information (ts-proto or pbjs) gets lost along the way.\n     * If you need to work with the result type in TypeScript, you can use:\n     *\n     * ```\n     * import { assert } from \"@cosmjs/utils\";\n     *\n     * const Coin = registry.lookupType(\"/cosmos.base.v1beta1.Coin\");\n     * assert(Coin); // Ensures not unset\n     * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect\n     *\n     * // Coin is typed TsProtoGeneratedType now.\n     * ```\n     */\n    lookupType(typeUrl) {\n        return this.types.get(typeUrl);\n    }\n    lookupTypeWithError(typeUrl) {\n        const type = this.lookupType(typeUrl);\n        if (!type) {\n            throw new Error(`Unregistered type url: ${typeUrl}`);\n        }\n        return type;\n    }\n    /**\n     * Takes a typeUrl/value pair and encodes the value to protobuf if\n     * the given type was previously registered.\n     *\n     * If the value has to be wrapped in an Any, this needs to be done\n     * manually after this call. Or use `encodeAsAny` instead.\n     */\n    encode(encodeObject) {\n        const { value, typeUrl } = encodeObject;\n        if (isTxBodyEncodeObject(encodeObject)) {\n            return this.encodeTxBody(value);\n        }\n        const type = this.lookupTypeWithError(typeUrl);\n        const instance = isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);\n        return type.encode(instance).finish();\n    }\n    /**\n     * Takes a typeUrl/value pair and encodes the value to an Any if\n     * the given type was previously registered.\n     */\n    encodeAsAny(encodeObject) {\n        const binaryValue = this.encode(encodeObject);\n        return any_1.Any.fromPartial({\n            typeUrl: encodeObject.typeUrl,\n            value: binaryValue,\n        });\n    }\n    encodeTxBody(txBodyFields) {\n        const wrappedMessages = txBodyFields.messages.map((message) => this.encodeAsAny(message));\n        const txBody = tx_2.TxBody.fromPartial({\n            ...txBodyFields,\n            messages: wrappedMessages,\n        });\n        return tx_2.TxBody.encode(txBody).finish();\n    }\n    decode({ typeUrl, value }) {\n        if (typeUrl === defaultTypeUrls.cosmosTxBody) {\n            return this.decodeTxBody(value);\n        }\n        const type = this.lookupTypeWithError(typeUrl);\n        const decoded = type.decode(value);\n        Object.entries(decoded).forEach(([key, val]) => {\n            if (typeof Buffer !== \"undefined\" && typeof Buffer.isBuffer !== \"undefined\" && Buffer.isBuffer(val)) {\n                decoded[key] = Uint8Array.from(val);\n            }\n        });\n        return decoded;\n    }\n    decodeTxBody(txBody) {\n        const decodedTxBody = tx_2.TxBody.decode(txBody);\n        return {\n            ...decodedTxBody,\n            messages: decodedTxBody.messages.map(({ typeUrl: typeUrl, value }) => {\n                if (!typeUrl) {\n                    throw new Error(\"Missing type_url in Any\");\n                }\n                if (!value) {\n                    throw new Error(\"Missing value in Any\");\n                }\n                return this.decode({ typeUrl, value });\n            }),\n        };\n    }\n}\nexports.Registry = Registry;\n//# sourceMappingURL=registry.js.map"]},"metadata":{},"sourceType":"script"}