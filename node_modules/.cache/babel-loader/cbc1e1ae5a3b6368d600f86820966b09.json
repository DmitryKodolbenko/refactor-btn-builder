{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Hmac = void 0;\nvar Hmac = /*#__PURE__*/function () {\n  function Hmac(hashFunctionConstructor, originalKey) {\n    _classCallCheck(this, Hmac);\n    // This implementation is based on https://en.wikipedia.org/wiki/HMAC#Implementation\n    // with the addition of incremental hashing support. Thus part of the algorithm\n    // is in the constructor and the rest in digest().\n    var blockSize = new hashFunctionConstructor().blockSize;\n    this.hash = function (data) {\n      return new hashFunctionConstructor().update(data).digest();\n    };\n    var key = originalKey;\n    if (key.length > blockSize) {\n      key = this.hash(key);\n    }\n    if (key.length < blockSize) {\n      var zeroPadding = new Uint8Array(blockSize - key.length);\n      key = new Uint8Array([].concat(_toConsumableArray(key), _toConsumableArray(zeroPadding)));\n    }\n    // eslint-disable-next-line no-bitwise\n    this.oKeyPad = key.map(function (keyByte) {\n      return keyByte ^ 0x5c;\n    });\n    // eslint-disable-next-line no-bitwise\n    this.iKeyPad = key.map(function (keyByte) {\n      return keyByte ^ 0x36;\n    });\n    this.messageHasher = new hashFunctionConstructor();\n    this.blockSize = blockSize;\n    this.update(this.iKeyPad);\n  }\n  _createClass(Hmac, [{\n    key: \"update\",\n    value: function update(data) {\n      this.messageHasher.update(data);\n      return this;\n    }\n  }, {\n    key: \"digest\",\n    value: function digest() {\n      var innerHash = this.messageHasher.digest();\n      return this.hash(new Uint8Array([].concat(_toConsumableArray(this.oKeyPad), _toConsumableArray(innerHash))));\n    }\n  }]);\n  return Hmac;\n}();\nexports.Hmac = Hmac;","map":{"version":3,"sources":["../src/hmac.ts"],"names":[],"mappings":";;;;;;;;;IAEa,IAAI;EAQf,cAAmB,uBAAoC,EAAE,WAAuB,EAAA;IAAA;IAC9E;IACA;IACA;IAEA,IAAM,SAAS,GAAG,IAAI,uBAAuB,EAAE,CAAC,SAAS;IAEzD,IAAI,CAAC,IAAI,GAAG,UAAC,IAAI;MAAA,OAAK,IAAI,uBAAuB,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE;IAAA;IAEzE,IAAI,GAAG,GAAG,WAAW;IACrB,IAAI,GAAG,CAAC,MAAM,GAAG,SAAS,EAAE;MAC1B,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;IACrB;IAED,IAAI,GAAG,CAAC,MAAM,GAAG,SAAS,EAAE;MAC1B,IAAM,WAAW,GAAG,IAAI,UAAU,CAAC,SAAS,GAAG,GAAG,CAAC,MAAM,CAAC;MAC1D,GAAG,GAAG,IAAI,UAAU,8BAAK,GAAG,sBAAK,WAAW,GAAE;IAC/C;IAED;IACA,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC,GAAG,CAAC,UAAC,OAAO;MAAA,OAAK,OAAO,GAAG,IAAI;IAAA,EAAC;IACnD;IACA,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC,GAAG,CAAC,UAAC,OAAO;MAAA,OAAK,OAAO,GAAG,IAAI;IAAA,EAAC;IACnD,IAAI,CAAC,aAAa,GAAG,IAAI,uBAAuB,EAAE;IAClD,IAAI,CAAC,SAAS,GAAG,SAAS;IAE1B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;EAC3B;EAAC;IAAA;IAAA,OAEM,gBAAO,IAAgB,EAAA;MAC5B,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC;MAC/B,OAAO,IAAI;IACb;EAAC;IAAA;IAAA,OAEM,kBAAM;MACX,IAAM,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE;MAC7C,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,UAAU,8BAAK,IAAI,CAAC,OAAO,sBAAK,SAAS,GAAE,CAAC;IACnE;EAAC;EAAA;AAAA;AA7CH,OAAA,CAAA,IAAA,GAAA,IAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Hmac = void 0;\nclass Hmac {\n    constructor(hashFunctionConstructor, originalKey) {\n        // This implementation is based on https://en.wikipedia.org/wiki/HMAC#Implementation\n        // with the addition of incremental hashing support. Thus part of the algorithm\n        // is in the constructor and the rest in digest().\n        const blockSize = new hashFunctionConstructor().blockSize;\n        this.hash = (data) => new hashFunctionConstructor().update(data).digest();\n        let key = originalKey;\n        if (key.length > blockSize) {\n            key = this.hash(key);\n        }\n        if (key.length < blockSize) {\n            const zeroPadding = new Uint8Array(blockSize - key.length);\n            key = new Uint8Array([...key, ...zeroPadding]);\n        }\n        // eslint-disable-next-line no-bitwise\n        this.oKeyPad = key.map((keyByte) => keyByte ^ 0x5c);\n        // eslint-disable-next-line no-bitwise\n        this.iKeyPad = key.map((keyByte) => keyByte ^ 0x36);\n        this.messageHasher = new hashFunctionConstructor();\n        this.blockSize = blockSize;\n        this.update(this.iKeyPad);\n    }\n    update(data) {\n        this.messageHasher.update(data);\n        return this;\n    }\n    digest() {\n        const innerHash = this.messageHasher.digest();\n        return this.hash(new Uint8Array([...this.oKeyPad, ...innerHash]));\n    }\n}\nexports.Hmac = Hmac;\n//# sourceMappingURL=hmac.js.map"]},"metadata":{},"sourceType":"script"}