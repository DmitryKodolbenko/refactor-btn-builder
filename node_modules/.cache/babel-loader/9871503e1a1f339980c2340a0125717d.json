{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pubkeyToAddress = exports.pubkeyToRawAddress = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = void 0;\nvar crypto_1 = require(\"@cosmjs/crypto\");\nvar encoding_1 = require(\"@cosmjs/encoding\");\nfunction rawEd25519PubkeyToRawAddress(pubkeyData) {\n  if (pubkeyData.length !== 32) {\n    throw new Error(\"Invalid Ed25519 pubkey length: \".concat(pubkeyData.length));\n  }\n  return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);\n}\nexports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;\nfunction rawSecp256k1PubkeyToRawAddress(pubkeyData) {\n  if (pubkeyData.length !== 33) {\n    throw new Error(\"Invalid Secp256k1 pubkey length (compressed): \".concat(pubkeyData.length));\n  }\n  return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));\n}\nexports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;\n// For secp256k1 this assumes we already have a compressed pubkey.\nfunction pubkeyToRawAddress(type, data) {\n  switch (type) {\n    case \"ed25519\":\n      return rawEd25519PubkeyToRawAddress(data);\n    case \"secp256k1\":\n      return rawSecp256k1PubkeyToRawAddress(data);\n    default:\n      // Keep this case here to guard against new types being added but not handled\n      throw new Error(\"Pubkey type \".concat(type, \" not supported\"));\n  }\n}\nexports.pubkeyToRawAddress = pubkeyToRawAddress;\nfunction pubkeyToAddress(type, data) {\n  return (0, encoding_1.toHex)(pubkeyToRawAddress(type, data)).toUpperCase();\n}\nexports.pubkeyToAddress = pubkeyToAddress;","map":{"version":3,"sources":["../src/addresses.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAEA,SAAgB,4BAA4B,CAAC,UAAsB,EAAA;EACjE,IAAI,UAAU,CAAC,MAAM,KAAK,EAAE,EAAE;IAC5B,MAAM,IAAI,KAAK,0CAAmC,UAAU,CAAC,MAAM,EAAG;EACvE;EACD,OAAO,CAAA,CAAA,EAAA,QAAA,CAAA,MAAM,EAAC,UAAU,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;AACxC;AALA,OAAA,CAAA,4BAAA,GAAA,4BAAA;AAOA,SAAgB,8BAA8B,CAAC,UAAsB,EAAA;EACnE,IAAI,UAAU,CAAC,MAAM,KAAK,EAAE,EAAE;IAC5B,MAAM,IAAI,KAAK,yDAAkD,UAAU,CAAC,MAAM,EAAG;EACtF;EACD,OAAO,CAAA,CAAA,EAAA,QAAA,CAAA,SAAS,EAAC,CAAA,CAAA,EAAA,QAAA,CAAA,MAAM,EAAC,UAAU,CAAC,CAAC;AACtC;AALA,OAAA,CAAA,8BAAA,GAAA,8BAAA;AAOA;AACA,SAAgB,kBAAkB,CAAC,IAA6B,EAAE,IAAgB,EAAA;EAChF,QAAQ,IAAI;IACV,KAAK,SAAS;MACZ,OAAO,4BAA4B,CAAC,IAAI,CAAC;IAC3C,KAAK,WAAW;MACd,OAAO,8BAA8B,CAAC,IAAI,CAAC;IAC7C;MACE;MACA,MAAM,IAAI,KAAK,uBAAgB,IAAI,oBAAiB;EAAC;AAE3D;AAVA,OAAA,CAAA,kBAAA,GAAA,kBAAA;AAYA,SAAgB,eAAe,CAAC,IAA6B,EAAE,IAAgB,EAAA;EAC7E,OAAO,CAAA,CAAA,EAAA,UAAA,CAAA,KAAK,EAAC,kBAAkB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,WAAW,EAAE;AAC5D;AAFA,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pubkeyToAddress = exports.pubkeyToRawAddress = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nfunction rawEd25519PubkeyToRawAddress(pubkeyData) {\n    if (pubkeyData.length !== 32) {\n        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);\n    }\n    return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);\n}\nexports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;\nfunction rawSecp256k1PubkeyToRawAddress(pubkeyData) {\n    if (pubkeyData.length !== 33) {\n        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);\n    }\n    return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));\n}\nexports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;\n// For secp256k1 this assumes we already have a compressed pubkey.\nfunction pubkeyToRawAddress(type, data) {\n    switch (type) {\n        case \"ed25519\":\n            return rawEd25519PubkeyToRawAddress(data);\n        case \"secp256k1\":\n            return rawSecp256k1PubkeyToRawAddress(data);\n        default:\n            // Keep this case here to guard against new types being added but not handled\n            throw new Error(`Pubkey type ${type} not supported`);\n    }\n}\nexports.pubkeyToRawAddress = pubkeyToRawAddress;\nfunction pubkeyToAddress(type, data) {\n    return (0, encoding_1.toHex)(pubkeyToRawAddress(type, data)).toUpperCase();\n}\nexports.pubkeyToAddress = pubkeyToAddress;\n//# sourceMappingURL=addresses.js.map"]},"metadata":{},"sourceType":"script"}