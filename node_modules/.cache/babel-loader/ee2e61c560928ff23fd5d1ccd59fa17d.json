{"ast":null,"code":"/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\nimport { ap, getApplySemigroup } from './Apply';\nimport { pipe } from './function';\nimport { getFunctorComposition } from './Functor';\nexport function getApplicativeMonoid(F) {\n  var f = getApplySemigroup(F);\n  return function (M) {\n    return {\n      concat: f(M).concat,\n      empty: F.of(M.empty)\n    };\n  };\n}\n/** @deprecated */\nexport function getApplicativeComposition(F, G) {\n  var map = getFunctorComposition(F, G).map;\n  var _ap = ap(F, G);\n  return {\n    map: map,\n    of: function (a) {\n      return F.of(G.of(a));\n    },\n    ap: function (fgab, fga) {\n      return pipe(fgab, _ap(fga));\n    }\n  };\n}","map":{"version":3,"names":["ap","getApplySemigroup","pipe","getFunctorComposition","getApplicativeMonoid","F","f","M","concat","empty","of","getApplicativeComposition","G","map","_ap","a","fgab","fga"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/fp-ts/es6/Applicative.js"],"sourcesContent":["/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\nimport { ap, getApplySemigroup } from './Apply';\nimport { pipe } from './function';\nimport { getFunctorComposition } from './Functor';\nexport function getApplicativeMonoid(F) {\n    var f = getApplySemigroup(F);\n    return function (M) { return ({\n        concat: f(M).concat,\n        empty: F.of(M.empty)\n    }); };\n}\n/** @deprecated */\nexport function getApplicativeComposition(F, G) {\n    var map = getFunctorComposition(F, G).map;\n    var _ap = ap(F, G);\n    return {\n        map: map,\n        of: function (a) { return F.of(G.of(a)); },\n        ap: function (fgab, fga) { return pipe(fgab, _ap(fga)); }\n    };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,EAAE,EAAEC,iBAAiB,QAAQ,SAAS;AAC/C,SAASC,IAAI,QAAQ,YAAY;AACjC,SAASC,qBAAqB,QAAQ,WAAW;AACjD,OAAO,SAASC,oBAAoB,CAACC,CAAC,EAAE;EACpC,IAAIC,CAAC,GAAGL,iBAAiB,CAACI,CAAC,CAAC;EAC5B,OAAO,UAAUE,CAAC,EAAE;IAAE,OAAQ;MAC1BC,MAAM,EAAEF,CAAC,CAACC,CAAC,CAAC,CAACC,MAAM;MACnBC,KAAK,EAAEJ,CAAC,CAACK,EAAE,CAACH,CAAC,CAACE,KAAK;IACvB,CAAC;EAAG,CAAC;AACT;AACA;AACA,OAAO,SAASE,yBAAyB,CAACN,CAAC,EAAEO,CAAC,EAAE;EAC5C,IAAIC,GAAG,GAAGV,qBAAqB,CAACE,CAAC,EAAEO,CAAC,CAAC,CAACC,GAAG;EACzC,IAAIC,GAAG,GAAGd,EAAE,CAACK,CAAC,EAAEO,CAAC,CAAC;EAClB,OAAO;IACHC,GAAG,EAAEA,GAAG;IACRH,EAAE,EAAE,UAAUK,CAAC,EAAE;MAAE,OAAOV,CAAC,CAACK,EAAE,CAACE,CAAC,CAACF,EAAE,CAACK,CAAC,CAAC,CAAC;IAAE,CAAC;IAC1Cf,EAAE,EAAE,UAAUgB,IAAI,EAAEC,GAAG,EAAE;MAAE,OAAOf,IAAI,CAACc,IAAI,EAAEF,GAAG,CAACG,GAAG,CAAC,CAAC;IAAE;EAC5D,CAAC;AACL"},"metadata":{},"sourceType":"module"}