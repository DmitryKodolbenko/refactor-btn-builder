{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Decimal = void 0;\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n// Too large values lead to massive memory usage. Limit to something sensible.\n// The largest value we need is 18 (Ether).\nvar maxFractionalDigits = 100;\n/**\n * A type for arbitrary precision, non-negative decimals.\n *\n * Instances of this class are immutable.\n */\nvar Decimal = /*#__PURE__*/function () {\n  function Decimal(atomics, fractionalDigits) {\n    _classCallCheck(this, Decimal);\n    this.data = {\n      atomics: new bn_js_1.default(atomics),\n      fractionalDigits: fractionalDigits\n    };\n  }\n  _createClass(Decimal, [{\n    key: \"atomics\",\n    get: function get() {\n      return this.data.atomics.toString();\n    }\n  }, {\n    key: \"fractionalDigits\",\n    get: function get() {\n      return this.data.fractionalDigits;\n    }\n    /** Creates a new instance with the same value */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Decimal(this.atomics, this.fractionalDigits);\n    }\n    /** Returns the greatest decimal <= this which has no fractional part (rounding down) */\n  }, {\n    key: \"floor\",\n    value: function floor() {\n      var factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n      var whole = this.data.atomics.div(factor);\n      var fractional = this.data.atomics.mod(factor);\n      if (fractional.isZero()) {\n        return this.clone();\n      } else {\n        return Decimal.fromAtomics(whole.mul(factor).toString(), this.fractionalDigits);\n      }\n    }\n    /** Returns the smallest decimal >= this which has no fractional part (rounding up) */\n  }, {\n    key: \"ceil\",\n    value: function ceil() {\n      var factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n      var whole = this.data.atomics.div(factor);\n      var fractional = this.data.atomics.mod(factor);\n      if (fractional.isZero()) {\n        return this.clone();\n      } else {\n        return Decimal.fromAtomics(whole.addn(1).mul(factor).toString(), this.fractionalDigits);\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n      var whole = this.data.atomics.div(factor);\n      var fractional = this.data.atomics.mod(factor);\n      if (fractional.isZero()) {\n        return whole.toString();\n      } else {\n        var fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, \"0\");\n        var trimmedFractionalPart = fullFractionalPart.replace(/0+$/, \"\");\n        return \"\".concat(whole.toString(), \".\").concat(trimmedFractionalPart);\n      }\n    }\n    /**\n     * Returns an approximation as a float type. Only use this if no\n     * exact calculation is required.\n     */\n  }, {\n    key: \"toFloatApproximation\",\n    value: function toFloatApproximation() {\n      var out = Number(this.toString());\n      if (Number.isNaN(out)) throw new Error(\"Conversion to number failed\");\n      return out;\n    }\n    /**\n     * a.plus(b) returns a+b.\n     *\n     * Both values need to have the same fractional digits.\n     */\n  }, {\n    key: \"plus\",\n    value: function plus(b) {\n      if (this.fractionalDigits !== b.fractionalDigits) throw new Error(\"Fractional digits do not match\");\n      var sum = this.data.atomics.add(new bn_js_1.default(b.atomics));\n      return new Decimal(sum.toString(), this.fractionalDigits);\n    }\n    /**\n     * a.minus(b) returns a-b.\n     *\n     * Both values need to have the same fractional digits.\n     * The resulting difference needs to be non-negative.\n     */\n  }, {\n    key: \"minus\",\n    value: function minus(b) {\n      if (this.fractionalDigits !== b.fractionalDigits) throw new Error(\"Fractional digits do not match\");\n      var difference = this.data.atomics.sub(new bn_js_1.default(b.atomics));\n      if (difference.ltn(0)) throw new Error(\"Difference must not be negative\");\n      return new Decimal(difference.toString(), this.fractionalDigits);\n    }\n    /**\n     * a.multiply(b) returns a*b.\n     *\n     * We only allow multiplication by unsigned integers to avoid rounding errors.\n     */\n  }, {\n    key: \"multiply\",\n    value: function multiply(b) {\n      var product = this.data.atomics.mul(new bn_js_1.default(b.toString()));\n      return new Decimal(product.toString(), this.fractionalDigits);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(b) {\n      return Decimal.compare(this, b) === 0;\n    }\n  }, {\n    key: \"isLessThan\",\n    value: function isLessThan(b) {\n      return Decimal.compare(this, b) < 0;\n    }\n  }, {\n    key: \"isLessThanOrEqual\",\n    value: function isLessThanOrEqual(b) {\n      return Decimal.compare(this, b) <= 0;\n    }\n  }, {\n    key: \"isGreaterThan\",\n    value: function isGreaterThan(b) {\n      return Decimal.compare(this, b) > 0;\n    }\n  }, {\n    key: \"isGreaterThanOrEqual\",\n    value: function isGreaterThanOrEqual(b) {\n      return Decimal.compare(this, b) >= 0;\n    }\n  }], [{\n    key: \"fromUserInput\",\n    value: function fromUserInput(input, fractionalDigits) {\n      Decimal.verifyFractionalDigits(fractionalDigits);\n      var badCharacter = input.match(/[^0-9.]/);\n      if (badCharacter) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        throw new Error(\"Invalid character at position \".concat(badCharacter.index + 1));\n      }\n      var whole;\n      var fractional;\n      if (input.search(/\\./) === -1) {\n        // integer format, no separator\n        whole = input;\n        fractional = \"\";\n      } else {\n        var parts = input.split(\".\");\n        switch (parts.length) {\n          case 0:\n          case 1:\n            throw new Error(\"Fewer than two elements in split result. This must not happen here.\");\n          case 2:\n            if (!parts[1]) throw new Error(\"Fractional part missing\");\n            whole = parts[0];\n            fractional = parts[1].replace(/0+$/, \"\");\n            break;\n          default:\n            throw new Error(\"More than one separator found\");\n        }\n      }\n      if (fractional.length > fractionalDigits) {\n        throw new Error(\"Got more fractional digits than supported\");\n      }\n      var quantity = \"\".concat(whole).concat(fractional.padEnd(fractionalDigits, \"0\"));\n      return new Decimal(quantity, fractionalDigits);\n    }\n  }, {\n    key: \"fromAtomics\",\n    value: function fromAtomics(atomics, fractionalDigits) {\n      Decimal.verifyFractionalDigits(fractionalDigits);\n      return new Decimal(atomics, fractionalDigits);\n    }\n    /**\n     * Creates a Decimal with value 0.0 and the given number of fractial digits.\n     *\n     * Fractional digits are not relevant for the value but needed to be able\n     * to perform arithmetic operations with other decimals.\n     */\n  }, {\n    key: \"zero\",\n    value: function zero(fractionalDigits) {\n      Decimal.verifyFractionalDigits(fractionalDigits);\n      return new Decimal(\"0\", fractionalDigits);\n    }\n    /**\n     * Creates a Decimal with value 1.0 and the given number of fractial digits.\n     *\n     * Fractional digits are not relevant for the value but needed to be able\n     * to perform arithmetic operations with other decimals.\n     */\n  }, {\n    key: \"one\",\n    value: function one(fractionalDigits) {\n      Decimal.verifyFractionalDigits(fractionalDigits);\n      return new Decimal(\"1\" + \"0\".repeat(fractionalDigits), fractionalDigits);\n    }\n  }, {\n    key: \"verifyFractionalDigits\",\n    value: function verifyFractionalDigits(fractionalDigits) {\n      if (!Number.isInteger(fractionalDigits)) throw new Error(\"Fractional digits is not an integer\");\n      if (fractionalDigits < 0) throw new Error(\"Fractional digits must not be negative\");\n      if (fractionalDigits > maxFractionalDigits) {\n        throw new Error(\"Fractional digits must not exceed \".concat(maxFractionalDigits));\n      }\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(a, b) {\n      if (a.fractionalDigits !== b.fractionalDigits) throw new Error(\"Fractional digits do not match\");\n      return a.data.atomics.cmp(new bn_js_1.default(b.atomics));\n    }\n  }]);\n  return Decimal;\n}();\nexports.Decimal = Decimal;","map":{"version":3,"sources":["../src/decimal.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Decimal = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n// Too large values lead to massive memory usage. Limit to something sensible.\n// The largest value we need is 18 (Ether).\nconst maxFractionalDigits = 100;\n/**\n * A type for arbitrary precision, non-negative decimals.\n *\n * Instances of this class are immutable.\n */\nclass Decimal {\n    constructor(atomics, fractionalDigits) {\n        this.data = {\n            atomics: new bn_js_1.default(atomics),\n            fractionalDigits: fractionalDigits,\n        };\n    }\n    static fromUserInput(input, fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        const badCharacter = input.match(/[^0-9.]/);\n        if (badCharacter) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            throw new Error(`Invalid character at position ${badCharacter.index + 1}`);\n        }\n        let whole;\n        let fractional;\n        if (input.search(/\\./) === -1) {\n            // integer format, no separator\n            whole = input;\n            fractional = \"\";\n        }\n        else {\n            const parts = input.split(\".\");\n            switch (parts.length) {\n                case 0:\n                case 1:\n                    throw new Error(\"Fewer than two elements in split result. This must not happen here.\");\n                case 2:\n                    if (!parts[1])\n                        throw new Error(\"Fractional part missing\");\n                    whole = parts[0];\n                    fractional = parts[1].replace(/0+$/, \"\");\n                    break;\n                default:\n                    throw new Error(\"More than one separator found\");\n            }\n        }\n        if (fractional.length > fractionalDigits) {\n            throw new Error(\"Got more fractional digits than supported\");\n        }\n        const quantity = `${whole}${fractional.padEnd(fractionalDigits, \"0\")}`;\n        return new Decimal(quantity, fractionalDigits);\n    }\n    static fromAtomics(atomics, fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(atomics, fractionalDigits);\n    }\n    /**\n     * Creates a Decimal with value 0.0 and the given number of fractial digits.\n     *\n     * Fractional digits are not relevant for the value but needed to be able\n     * to perform arithmetic operations with other decimals.\n     */\n    static zero(fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(\"0\", fractionalDigits);\n    }\n    /**\n     * Creates a Decimal with value 1.0 and the given number of fractial digits.\n     *\n     * Fractional digits are not relevant for the value but needed to be able\n     * to perform arithmetic operations with other decimals.\n     */\n    static one(fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(\"1\" + \"0\".repeat(fractionalDigits), fractionalDigits);\n    }\n    static verifyFractionalDigits(fractionalDigits) {\n        if (!Number.isInteger(fractionalDigits))\n            throw new Error(\"Fractional digits is not an integer\");\n        if (fractionalDigits < 0)\n            throw new Error(\"Fractional digits must not be negative\");\n        if (fractionalDigits > maxFractionalDigits) {\n            throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);\n        }\n    }\n    static compare(a, b) {\n        if (a.fractionalDigits !== b.fractionalDigits)\n            throw new Error(\"Fractional digits do not match\");\n        return a.data.atomics.cmp(new bn_js_1.default(b.atomics));\n    }\n    get atomics() {\n        return this.data.atomics.toString();\n    }\n    get fractionalDigits() {\n        return this.data.fractionalDigits;\n    }\n    /** Creates a new instance with the same value */\n    clone() {\n        return new Decimal(this.atomics, this.fractionalDigits);\n    }\n    /** Returns the greatest decimal <= this which has no fractional part (rounding down) */\n    floor() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return this.clone();\n        }\n        else {\n            return Decimal.fromAtomics(whole.mul(factor).toString(), this.fractionalDigits);\n        }\n    }\n    /** Returns the smallest decimal >= this which has no fractional part (rounding up) */\n    ceil() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return this.clone();\n        }\n        else {\n            return Decimal.fromAtomics(whole.addn(1).mul(factor).toString(), this.fractionalDigits);\n        }\n    }\n    toString() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return whole.toString();\n        }\n        else {\n            const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, \"0\");\n            const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, \"\");\n            return `${whole.toString()}.${trimmedFractionalPart}`;\n        }\n    }\n    /**\n     * Returns an approximation as a float type. Only use this if no\n     * exact calculation is required.\n     */\n    toFloatApproximation() {\n        const out = Number(this.toString());\n        if (Number.isNaN(out))\n            throw new Error(\"Conversion to number failed\");\n        return out;\n    }\n    /**\n     * a.plus(b) returns a+b.\n     *\n     * Both values need to have the same fractional digits.\n     */\n    plus(b) {\n        if (this.fractionalDigits !== b.fractionalDigits)\n            throw new Error(\"Fractional digits do not match\");\n        const sum = this.data.atomics.add(new bn_js_1.default(b.atomics));\n        return new Decimal(sum.toString(), this.fractionalDigits);\n    }\n    /**\n     * a.minus(b) returns a-b.\n     *\n     * Both values need to have the same fractional digits.\n     * The resulting difference needs to be non-negative.\n     */\n    minus(b) {\n        if (this.fractionalDigits !== b.fractionalDigits)\n            throw new Error(\"Fractional digits do not match\");\n        const difference = this.data.atomics.sub(new bn_js_1.default(b.atomics));\n        if (difference.ltn(0))\n            throw new Error(\"Difference must not be negative\");\n        return new Decimal(difference.toString(), this.fractionalDigits);\n    }\n    /**\n     * a.multiply(b) returns a*b.\n     *\n     * We only allow multiplication by unsigned integers to avoid rounding errors.\n     */\n    multiply(b) {\n        const product = this.data.atomics.mul(new bn_js_1.default(b.toString()));\n        return new Decimal(product.toString(), this.fractionalDigits);\n    }\n    equals(b) {\n        return Decimal.compare(this, b) === 0;\n    }\n    isLessThan(b) {\n        return Decimal.compare(this, b) < 0;\n    }\n    isLessThanOrEqual(b) {\n        return Decimal.compare(this, b) <= 0;\n    }\n    isGreaterThan(b) {\n        return Decimal.compare(this, b) > 0;\n    }\n    isGreaterThanOrEqual(b) {\n        return Decimal.compare(this, b) >= 0;\n    }\n}\nexports.Decimal = Decimal;\n//# sourceMappingURL=decimal.js.map"]},"metadata":{},"sourceType":"script"}