{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SigningStargateClient = exports.defaultRegistryTypes = void 0;\nconst amino_1 = require(\"@cosmjs/amino\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nconst proto_signing_1 = require(\"@cosmjs/proto-signing\");\nconst tendermint_rpc_1 = require(\"@cosmjs/tendermint-rpc\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst coin_1 = require(\"cosmjs-types/cosmos/base/v1beta1/coin\");\nconst tx_1 = require(\"cosmjs-types/cosmos/distribution/v1beta1/tx\");\nconst tx_2 = require(\"cosmjs-types/cosmos/staking/v1beta1/tx\");\nconst signing_1 = require(\"cosmjs-types/cosmos/tx/signing/v1beta1/signing\");\nconst tx_3 = require(\"cosmjs-types/cosmos/tx/v1beta1/tx\");\nconst tx_4 = require(\"cosmjs-types/ibc/applications/transfer/v1/tx\");\nconst long_1 = __importDefault(require(\"long\"));\nconst aminotypes_1 = require(\"./aminotypes\");\nconst fee_1 = require(\"./fee\");\nconst modules_1 = require(\"./modules\");\nconst modules_2 = require(\"./modules\");\nconst stargateclient_1 = require(\"./stargateclient\");\nexports.defaultRegistryTypes = [[\"/cosmos.base.v1beta1.Coin\", coin_1.Coin], ...modules_1.authzTypes, ...modules_1.bankTypes, ...modules_1.distributionTypes, ...modules_1.feegrantTypes, ...modules_1.govTypes, ...modules_1.stakingTypes, ...modules_1.ibcTypes, ...modules_1.vestingTypes];\nfunction createDefaultRegistry() {\n  return new proto_signing_1.Registry(exports.defaultRegistryTypes);\n}\nfunction createDefaultTypes(prefix) {\n  return {\n    ...(0, modules_2.createAuthzAminoConverters)(),\n    ...(0, modules_2.createBankAminoConverters)(),\n    ...(0, modules_2.createDistributionAminoConverters)(),\n    ...(0, modules_2.createGovAminoConverters)(),\n    ...(0, modules_2.createStakingAminoConverters)(prefix),\n    ...(0, modules_2.createIbcAminoConverters)(),\n    ...(0, modules_2.createFreegrantAminoConverters)(),\n    ...(0, modules_2.createVestingAminoConverters)()\n  };\n}\nclass SigningStargateClient extends stargateclient_1.StargateClient {\n  constructor(tmClient, signer, options) {\n    var _a;\n    super(tmClient, options);\n    // TODO: do we really want to set a default here? Ideally we could get it from the signer such that users only have to set it once.\n    const prefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : \"cosmos\";\n    const {\n      registry = createDefaultRegistry(),\n      aminoTypes = new aminotypes_1.AminoTypes(createDefaultTypes(prefix))\n    } = options;\n    this.registry = registry;\n    this.aminoTypes = aminoTypes;\n    this.signer = signer;\n    this.broadcastTimeoutMs = options.broadcastTimeoutMs;\n    this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;\n    this.gasPrice = options.gasPrice;\n  }\n  static async connectWithSigner(endpoint, signer) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);\n    return new SigningStargateClient(tmClient, signer, options);\n  }\n  /**\n   * Creates a client in offline mode.\n   *\n   * This should only be used in niche cases where you know exactly what you're doing,\n   * e.g. when building an offline signing application.\n   *\n   * When you try to use online functionality with such a signer, an\n   * exception will be raised.\n   */\n  static async offline(signer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new SigningStargateClient(undefined, signer, options);\n  }\n  async simulate(signerAddress, messages, memo) {\n    const anyMsgs = messages.map(m => this.registry.encodeAsAny(m));\n    const accountFromSigner = (await this.signer.getAccounts()).find(account => account.address === signerAddress);\n    if (!accountFromSigner) {\n      throw new Error(\"Failed to retrieve account from signer\");\n    }\n    const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);\n    const {\n      sequence\n    } = await this.getSequence(signerAddress);\n    const {\n      gasInfo\n    } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);\n    (0, utils_1.assertDefined)(gasInfo);\n    return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();\n  }\n  async sendTokens(senderAddress, recipientAddress, amount, fee) {\n    let memo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    const sendMsg = {\n      typeUrl: \"/cosmos.bank.v1beta1.MsgSend\",\n      value: {\n        fromAddress: senderAddress,\n        toAddress: recipientAddress,\n        amount: [...amount]\n      }\n    };\n    return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);\n  }\n  async delegateTokens(delegatorAddress, validatorAddress, amount, fee) {\n    let memo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    const delegateMsg = {\n      typeUrl: \"/cosmos.staking.v1beta1.MsgDelegate\",\n      value: tx_2.MsgDelegate.fromPartial({\n        delegatorAddress: delegatorAddress,\n        validatorAddress: validatorAddress,\n        amount: amount\n      })\n    };\n    return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);\n  }\n  async undelegateTokens(delegatorAddress, validatorAddress, amount, fee) {\n    let memo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    const undelegateMsg = {\n      typeUrl: \"/cosmos.staking.v1beta1.MsgUndelegate\",\n      value: tx_2.MsgUndelegate.fromPartial({\n        delegatorAddress: delegatorAddress,\n        validatorAddress: validatorAddress,\n        amount: amount\n      })\n    };\n    return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);\n  }\n  async withdrawRewards(delegatorAddress, validatorAddress, fee) {\n    let memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    const withdrawMsg = {\n      typeUrl: \"/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward\",\n      value: tx_1.MsgWithdrawDelegatorReward.fromPartial({\n        delegatorAddress: delegatorAddress,\n        validatorAddress: validatorAddress\n      })\n    };\n    return this.signAndBroadcast(delegatorAddress, [withdrawMsg], fee, memo);\n  }\n  async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, /** timeout in seconds */\n  timeoutTimestamp, fee) {\n    let memo = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : \"\";\n    const timeoutTimestampNanoseconds = timeoutTimestamp ? long_1.default.fromNumber(timeoutTimestamp).multiply(1000000000) : undefined;\n    const transferMsg = {\n      typeUrl: \"/ibc.applications.transfer.v1.MsgTransfer\",\n      value: tx_4.MsgTransfer.fromPartial({\n        sourcePort: sourcePort,\n        sourceChannel: sourceChannel,\n        sender: senderAddress,\n        receiver: recipientAddress,\n        token: transferAmount,\n        timeoutHeight: timeoutHeight,\n        timeoutTimestamp: timeoutTimestampNanoseconds\n      })\n    };\n    return this.signAndBroadcast(senderAddress, [transferMsg], fee, memo);\n  }\n  async signAndBroadcast(signerAddress, messages, fee) {\n    let memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    let usedFee;\n    if (fee == \"auto\" || typeof fee === \"number\") {\n      (0, utils_1.assertDefined)(this.gasPrice, \"Gas price must be set in the client options when auto gas is used.\");\n      const gasEstimation = await this.simulate(signerAddress, messages, memo);\n      const multiplier = typeof fee === \"number\" ? fee : 1.3;\n      usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);\n    } else {\n      usedFee = fee;\n    }\n    const txRaw = await this.sign(signerAddress, messages, usedFee, memo);\n    const txBytes = tx_3.TxRaw.encode(txRaw).finish();\n    return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);\n  }\n  /**\n   * Gets account number and sequence from the API, creates a sign doc,\n   * creates a single signature and assembles the signed transaction.\n   *\n   * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.\n   *\n   * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them\n   * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing\n   * (See the SigningStargateClient.offline constructor).\n   */\n  async sign(signerAddress, messages, fee, memo, explicitSignerData) {\n    let signerData;\n    if (explicitSignerData) {\n      signerData = explicitSignerData;\n    } else {\n      const {\n        accountNumber,\n        sequence\n      } = await this.getSequence(signerAddress);\n      const chainId = await this.getChainId();\n      signerData = {\n        accountNumber: accountNumber,\n        sequence: sequence,\n        chainId: chainId\n      };\n    }\n    return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData) : this.signAmino(signerAddress, messages, fee, memo, signerData);\n  }\n  async signAmino(signerAddress, messages, fee, memo, _ref) {\n    let {\n      accountNumber,\n      sequence,\n      chainId\n    } = _ref;\n    (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));\n    const accountFromSigner = (await this.signer.getAccounts()).find(account => account.address === signerAddress);\n    if (!accountFromSigner) {\n      throw new Error(\"Failed to retrieve account from signer\");\n    }\n    const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));\n    const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;\n    const msgs = messages.map(msg => this.aminoTypes.toAmino(msg));\n    const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence);\n    const {\n      signature,\n      signed\n    } = await this.signer.signAmino(signerAddress, signDoc);\n    const signedTxBody = {\n      messages: signed.msgs.map(msg => this.aminoTypes.fromAmino(msg)),\n      memo: signed.memo\n    };\n    const signedTxBodyEncodeObject = {\n      typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n      value: signedTxBody\n    };\n    const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);\n    const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();\n    const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();\n    const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{\n      pubkey,\n      sequence: signedSequence\n    }], signed.fee.amount, signedGasLimit, signMode);\n    return tx_3.TxRaw.fromPartial({\n      bodyBytes: signedTxBodyBytes,\n      authInfoBytes: signedAuthInfoBytes,\n      signatures: [(0, encoding_1.fromBase64)(signature.signature)]\n    });\n  }\n  async signDirect(signerAddress, messages, fee, memo, _ref2) {\n    let {\n      accountNumber,\n      sequence,\n      chainId\n    } = _ref2;\n    (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));\n    const accountFromSigner = (await this.signer.getAccounts()).find(account => account.address === signerAddress);\n    if (!accountFromSigner) {\n      throw new Error(\"Failed to retrieve account from signer\");\n    }\n    const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));\n    const txBodyEncodeObject = {\n      typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n      value: {\n        messages: messages,\n        memo: memo\n      }\n    };\n    const txBodyBytes = this.registry.encode(txBodyEncodeObject);\n    const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();\n    const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{\n      pubkey,\n      sequence\n    }], fee.amount, gasLimit);\n    const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);\n    const {\n      signature,\n      signed\n    } = await this.signer.signDirect(signerAddress, signDoc);\n    return tx_3.TxRaw.fromPartial({\n      bodyBytes: signed.bodyBytes,\n      authInfoBytes: signed.authInfoBytes,\n      signatures: [(0, encoding_1.fromBase64)(signature.signature)]\n    });\n  }\n}\nexports.SigningStargateClient = SigningStargateClient;","map":{"version":3,"sources":["../src/signingstargateclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SigningStargateClient = exports.defaultRegistryTypes = void 0;\nconst amino_1 = require(\"@cosmjs/amino\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nconst proto_signing_1 = require(\"@cosmjs/proto-signing\");\nconst tendermint_rpc_1 = require(\"@cosmjs/tendermint-rpc\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst coin_1 = require(\"cosmjs-types/cosmos/base/v1beta1/coin\");\nconst tx_1 = require(\"cosmjs-types/cosmos/distribution/v1beta1/tx\");\nconst tx_2 = require(\"cosmjs-types/cosmos/staking/v1beta1/tx\");\nconst signing_1 = require(\"cosmjs-types/cosmos/tx/signing/v1beta1/signing\");\nconst tx_3 = require(\"cosmjs-types/cosmos/tx/v1beta1/tx\");\nconst tx_4 = require(\"cosmjs-types/ibc/applications/transfer/v1/tx\");\nconst long_1 = __importDefault(require(\"long\"));\nconst aminotypes_1 = require(\"./aminotypes\");\nconst fee_1 = require(\"./fee\");\nconst modules_1 = require(\"./modules\");\nconst modules_2 = require(\"./modules\");\nconst stargateclient_1 = require(\"./stargateclient\");\nexports.defaultRegistryTypes = [\n    [\"/cosmos.base.v1beta1.Coin\", coin_1.Coin],\n    ...modules_1.authzTypes,\n    ...modules_1.bankTypes,\n    ...modules_1.distributionTypes,\n    ...modules_1.feegrantTypes,\n    ...modules_1.govTypes,\n    ...modules_1.stakingTypes,\n    ...modules_1.ibcTypes,\n    ...modules_1.vestingTypes,\n];\nfunction createDefaultRegistry() {\n    return new proto_signing_1.Registry(exports.defaultRegistryTypes);\n}\nfunction createDefaultTypes(prefix) {\n    return {\n        ...(0, modules_2.createAuthzAminoConverters)(),\n        ...(0, modules_2.createBankAminoConverters)(),\n        ...(0, modules_2.createDistributionAminoConverters)(),\n        ...(0, modules_2.createGovAminoConverters)(),\n        ...(0, modules_2.createStakingAminoConverters)(prefix),\n        ...(0, modules_2.createIbcAminoConverters)(),\n        ...(0, modules_2.createFreegrantAminoConverters)(),\n        ...(0, modules_2.createVestingAminoConverters)(),\n    };\n}\nclass SigningStargateClient extends stargateclient_1.StargateClient {\n    constructor(tmClient, signer, options) {\n        var _a;\n        super(tmClient, options);\n        // TODO: do we really want to set a default here? Ideally we could get it from the signer such that users only have to set it once.\n        const prefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : \"cosmos\";\n        const { registry = createDefaultRegistry(), aminoTypes = new aminotypes_1.AminoTypes(createDefaultTypes(prefix)) } = options;\n        this.registry = registry;\n        this.aminoTypes = aminoTypes;\n        this.signer = signer;\n        this.broadcastTimeoutMs = options.broadcastTimeoutMs;\n        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;\n        this.gasPrice = options.gasPrice;\n    }\n    static async connectWithSigner(endpoint, signer, options = {}) {\n        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);\n        return new SigningStargateClient(tmClient, signer, options);\n    }\n    /**\n     * Creates a client in offline mode.\n     *\n     * This should only be used in niche cases where you know exactly what you're doing,\n     * e.g. when building an offline signing application.\n     *\n     * When you try to use online functionality with such a signer, an\n     * exception will be raised.\n     */\n    static async offline(signer, options = {}) {\n        return new SigningStargateClient(undefined, signer, options);\n    }\n    async simulate(signerAddress, messages, memo) {\n        const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));\n        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);\n        if (!accountFromSigner) {\n            throw new Error(\"Failed to retrieve account from signer\");\n        }\n        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);\n        const { sequence } = await this.getSequence(signerAddress);\n        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);\n        (0, utils_1.assertDefined)(gasInfo);\n        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();\n    }\n    async sendTokens(senderAddress, recipientAddress, amount, fee, memo = \"\") {\n        const sendMsg = {\n            typeUrl: \"/cosmos.bank.v1beta1.MsgSend\",\n            value: {\n                fromAddress: senderAddress,\n                toAddress: recipientAddress,\n                amount: [...amount],\n            },\n        };\n        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);\n    }\n    async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = \"\") {\n        const delegateMsg = {\n            typeUrl: \"/cosmos.staking.v1beta1.MsgDelegate\",\n            value: tx_2.MsgDelegate.fromPartial({\n                delegatorAddress: delegatorAddress,\n                validatorAddress: validatorAddress,\n                amount: amount,\n            }),\n        };\n        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);\n    }\n    async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = \"\") {\n        const undelegateMsg = {\n            typeUrl: \"/cosmos.staking.v1beta1.MsgUndelegate\",\n            value: tx_2.MsgUndelegate.fromPartial({\n                delegatorAddress: delegatorAddress,\n                validatorAddress: validatorAddress,\n                amount: amount,\n            }),\n        };\n        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);\n    }\n    async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = \"\") {\n        const withdrawMsg = {\n            typeUrl: \"/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward\",\n            value: tx_1.MsgWithdrawDelegatorReward.fromPartial({\n                delegatorAddress: delegatorAddress,\n                validatorAddress: validatorAddress,\n            }),\n        };\n        return this.signAndBroadcast(delegatorAddress, [withdrawMsg], fee, memo);\n    }\n    async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, \n    /** timeout in seconds */\n    timeoutTimestamp, fee, memo = \"\") {\n        const timeoutTimestampNanoseconds = timeoutTimestamp\n            ? long_1.default.fromNumber(timeoutTimestamp).multiply(1000000000)\n            : undefined;\n        const transferMsg = {\n            typeUrl: \"/ibc.applications.transfer.v1.MsgTransfer\",\n            value: tx_4.MsgTransfer.fromPartial({\n                sourcePort: sourcePort,\n                sourceChannel: sourceChannel,\n                sender: senderAddress,\n                receiver: recipientAddress,\n                token: transferAmount,\n                timeoutHeight: timeoutHeight,\n                timeoutTimestamp: timeoutTimestampNanoseconds,\n            }),\n        };\n        return this.signAndBroadcast(senderAddress, [transferMsg], fee, memo);\n    }\n    async signAndBroadcast(signerAddress, messages, fee, memo = \"\") {\n        let usedFee;\n        if (fee == \"auto\" || typeof fee === \"number\") {\n            (0, utils_1.assertDefined)(this.gasPrice, \"Gas price must be set in the client options when auto gas is used.\");\n            const gasEstimation = await this.simulate(signerAddress, messages, memo);\n            const multiplier = typeof fee === \"number\" ? fee : 1.3;\n            usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);\n        }\n        else {\n            usedFee = fee;\n        }\n        const txRaw = await this.sign(signerAddress, messages, usedFee, memo);\n        const txBytes = tx_3.TxRaw.encode(txRaw).finish();\n        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);\n    }\n    /**\n     * Gets account number and sequence from the API, creates a sign doc,\n     * creates a single signature and assembles the signed transaction.\n     *\n     * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.\n     *\n     * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them\n     * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing\n     * (See the SigningStargateClient.offline constructor).\n     */\n    async sign(signerAddress, messages, fee, memo, explicitSignerData) {\n        let signerData;\n        if (explicitSignerData) {\n            signerData = explicitSignerData;\n        }\n        else {\n            const { accountNumber, sequence } = await this.getSequence(signerAddress);\n            const chainId = await this.getChainId();\n            signerData = {\n                accountNumber: accountNumber,\n                sequence: sequence,\n                chainId: chainId,\n            };\n        }\n        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer)\n            ? this.signDirect(signerAddress, messages, fee, memo, signerData)\n            : this.signAmino(signerAddress, messages, fee, memo, signerData);\n    }\n    async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {\n        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));\n        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);\n        if (!accountFromSigner) {\n            throw new Error(\"Failed to retrieve account from signer\");\n        }\n        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));\n        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;\n        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));\n        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence);\n        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);\n        const signedTxBody = {\n            messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),\n            memo: signed.memo,\n        };\n        const signedTxBodyEncodeObject = {\n            typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n            value: signedTxBody,\n        };\n        const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);\n        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();\n        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();\n        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signMode);\n        return tx_3.TxRaw.fromPartial({\n            bodyBytes: signedTxBodyBytes,\n            authInfoBytes: signedAuthInfoBytes,\n            signatures: [(0, encoding_1.fromBase64)(signature.signature)],\n        });\n    }\n    async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {\n        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));\n        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);\n        if (!accountFromSigner) {\n            throw new Error(\"Failed to retrieve account from signer\");\n        }\n        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));\n        const txBodyEncodeObject = {\n            typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n            value: {\n                messages: messages,\n                memo: memo,\n            },\n        };\n        const txBodyBytes = this.registry.encode(txBodyEncodeObject);\n        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();\n        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit);\n        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);\n        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);\n        return tx_3.TxRaw.fromPartial({\n            bodyBytes: signed.bodyBytes,\n            authInfoBytes: signed.authInfoBytes,\n            signatures: [(0, encoding_1.fromBase64)(signature.signature)],\n        });\n    }\n}\nexports.SigningStargateClient = SigningStargateClient;\n//# sourceMappingURL=signingstargateclient.js.map"]},"metadata":{},"sourceType":"script"}