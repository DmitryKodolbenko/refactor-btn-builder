{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _toConsumableArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtendedSecp256k1Signature = exports.Secp256k1Signature = void 0;\nfunction trimLeadingNullBytes(inData) {\n  var numberOfLeadingNullBytes = 0;\n  var _iterator = _createForOfIteratorHelper(inData),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var byte = _step.value;\n      if (byte === 0x00) {\n        numberOfLeadingNullBytes++;\n      } else {\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return inData.slice(numberOfLeadingNullBytes);\n}\nvar derTagInteger = 0x02;\nvar Secp256k1Signature = /*#__PURE__*/function () {\n  function Secp256k1Signature(r, s) {\n    _classCallCheck(this, Secp256k1Signature);\n    if (r.length > 32 || r.length === 0 || r[0] === 0x00) {\n      throw new Error(\"Unsigned integer r must be encoded as unpadded big endian.\");\n    }\n    if (s.length > 32 || s.length === 0 || s[0] === 0x00) {\n      throw new Error(\"Unsigned integer s must be encoded as unpadded big endian.\");\n    }\n    this.data = {\n      r: r,\n      s: s\n    };\n  }\n  /**\n   * Takes the pair of integers (r, s) as 2x32 byte of binary data.\n   *\n   * Note: This is the format Cosmos SDK uses natively.\n   *\n   * @param data a 64 byte value containing integers r and s.\n   */\n  _createClass(Secp256k1Signature, [{\n    key: \"r\",\n    value: function r(length) {\n      if (length === undefined) {\n        return this.data.r;\n      } else {\n        var paddingLength = length - this.data.r.length;\n        if (paddingLength < 0) {\n          throw new Error(\"Length too small to hold parameter r\");\n        }\n        var padding = new Uint8Array(paddingLength);\n        return new Uint8Array([].concat(_toConsumableArray(padding), _toConsumableArray(this.data.r)));\n      }\n    }\n  }, {\n    key: \"s\",\n    value: function s(length) {\n      if (length === undefined) {\n        return this.data.s;\n      } else {\n        var paddingLength = length - this.data.s.length;\n        if (paddingLength < 0) {\n          throw new Error(\"Length too small to hold parameter s\");\n        }\n        var padding = new Uint8Array(paddingLength);\n        return new Uint8Array([].concat(_toConsumableArray(padding), _toConsumableArray(this.data.s)));\n      }\n    }\n  }, {\n    key: \"toFixedLength\",\n    value: function toFixedLength() {\n      return new Uint8Array([].concat(_toConsumableArray(this.r(32)), _toConsumableArray(this.s(32))));\n    }\n  }, {\n    key: \"toDer\",\n    value: function toDer() {\n      // DER supports negative integers but our data is unsigned. Thus we need to prepend\n      // a leading 0 byte when the higest bit is set to differentiate nagative values\n      var rEncoded = this.data.r[0] >= 0x80 ? new Uint8Array([0].concat(_toConsumableArray(this.data.r))) : this.data.r;\n      var sEncoded = this.data.s[0] >= 0x80 ? new Uint8Array([0].concat(_toConsumableArray(this.data.s))) : this.data.s;\n      var rLength = rEncoded.length;\n      var sLength = sEncoded.length;\n      var data = new Uint8Array([derTagInteger, rLength].concat(_toConsumableArray(rEncoded), [derTagInteger, sLength], _toConsumableArray(sEncoded)));\n      return new Uint8Array([0x30, data.length].concat(_toConsumableArray(data)));\n    }\n  }], [{\n    key: \"fromFixedLength\",\n    value: function fromFixedLength(data) {\n      if (data.length !== 64) {\n        throw new Error(\"Got invalid data length: \".concat(data.length, \". Expected 2x 32 bytes for the pair (r, s)\"));\n      }\n      return new Secp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)));\n    }\n  }, {\n    key: \"fromDer\",\n    value: function fromDer(data) {\n      var pos = 0;\n      if (data[pos++] !== 0x30) {\n        throw new Error(\"Prefix 0x30 expected\");\n      }\n      var bodyLength = data[pos++];\n      if (data.length - pos !== bodyLength) {\n        throw new Error(\"Data length mismatch detected\");\n      }\n      // r\n      var rTag = data[pos++];\n      if (rTag !== derTagInteger) {\n        throw new Error(\"INTEGER tag expected\");\n      }\n      var rLength = data[pos++];\n      if (rLength >= 0x80) {\n        throw new Error(\"Decoding length values above 127 not supported\");\n      }\n      var rData = data.slice(pos, pos + rLength);\n      pos += rLength;\n      // s\n      var sTag = data[pos++];\n      if (sTag !== derTagInteger) {\n        throw new Error(\"INTEGER tag expected\");\n      }\n      var sLength = data[pos++];\n      if (sLength >= 0x80) {\n        throw new Error(\"Decoding length values above 127 not supported\");\n      }\n      var sData = data.slice(pos, pos + sLength);\n      pos += sLength;\n      return new Secp256k1Signature(\n      // r/s data can contain leading 0 bytes to express integers being non-negative in DER\n      trimLeadingNullBytes(rData), trimLeadingNullBytes(sData));\n    }\n  }]);\n  return Secp256k1Signature;\n}();\nexports.Secp256k1Signature = Secp256k1Signature;\n/**\n * A Secp256k1Signature plus the recovery parameter\n */\nvar ExtendedSecp256k1Signature = /*#__PURE__*/function (_Secp256k1Signature) {\n  _inherits(ExtendedSecp256k1Signature, _Secp256k1Signature);\n  var _super = _createSuper(ExtendedSecp256k1Signature);\n  function ExtendedSecp256k1Signature(r, s, recovery) {\n    var _this;\n    _classCallCheck(this, ExtendedSecp256k1Signature);\n    _this = _super.call(this, r, s);\n    if (!Number.isInteger(recovery)) {\n      throw new Error(\"The recovery parameter must be an integer.\");\n    }\n    if (recovery < 0 || recovery > 4) {\n      throw new Error(\"The recovery parameter must be one of 0, 1, 2, 3.\");\n    }\n    _this.recovery = recovery;\n    return _this;\n  }\n  /**\n   * Decode extended signature from the simple fixed length encoding\n   * described in toFixedLength().\n   */\n  _createClass(ExtendedSecp256k1Signature, [{\n    key: \"toFixedLength\",\n    value:\n    /**\n     * A simple custom encoding that encodes the extended signature as\n     * r (32 bytes) | s (32 bytes) | recovery param (1 byte)\n     * where | denotes concatenation of bonary data.\n     */\n    function toFixedLength() {\n      return new Uint8Array([].concat(_toConsumableArray(this.r(32)), _toConsumableArray(this.s(32)), [this.recovery]));\n    }\n  }], [{\n    key: \"fromFixedLength\",\n    value: function fromFixedLength(data) {\n      if (data.length !== 65) {\n        throw new Error(\"Got invalid data length \".concat(data.length, \". Expected 32 + 32 + 1\"));\n      }\n      return new ExtendedSecp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)), data[64]);\n    }\n  }]);\n  return ExtendedSecp256k1Signature;\n}(Secp256k1Signature);\nexports.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature;","map":{"version":3,"sources":["../src/secp256k1signature.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExtendedSecp256k1Signature = exports.Secp256k1Signature = void 0;\nfunction trimLeadingNullBytes(inData) {\n    let numberOfLeadingNullBytes = 0;\n    for (const byte of inData) {\n        if (byte === 0x00) {\n            numberOfLeadingNullBytes++;\n        }\n        else {\n            break;\n        }\n    }\n    return inData.slice(numberOfLeadingNullBytes);\n}\nconst derTagInteger = 0x02;\nclass Secp256k1Signature {\n    constructor(r, s) {\n        if (r.length > 32 || r.length === 0 || r[0] === 0x00) {\n            throw new Error(\"Unsigned integer r must be encoded as unpadded big endian.\");\n        }\n        if (s.length > 32 || s.length === 0 || s[0] === 0x00) {\n            throw new Error(\"Unsigned integer s must be encoded as unpadded big endian.\");\n        }\n        this.data = {\n            r: r,\n            s: s,\n        };\n    }\n    /**\n     * Takes the pair of integers (r, s) as 2x32 byte of binary data.\n     *\n     * Note: This is the format Cosmos SDK uses natively.\n     *\n     * @param data a 64 byte value containing integers r and s.\n     */\n    static fromFixedLength(data) {\n        if (data.length !== 64) {\n            throw new Error(`Got invalid data length: ${data.length}. Expected 2x 32 bytes for the pair (r, s)`);\n        }\n        return new Secp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)));\n    }\n    static fromDer(data) {\n        let pos = 0;\n        if (data[pos++] !== 0x30) {\n            throw new Error(\"Prefix 0x30 expected\");\n        }\n        const bodyLength = data[pos++];\n        if (data.length - pos !== bodyLength) {\n            throw new Error(\"Data length mismatch detected\");\n        }\n        // r\n        const rTag = data[pos++];\n        if (rTag !== derTagInteger) {\n            throw new Error(\"INTEGER tag expected\");\n        }\n        const rLength = data[pos++];\n        if (rLength >= 0x80) {\n            throw new Error(\"Decoding length values above 127 not supported\");\n        }\n        const rData = data.slice(pos, pos + rLength);\n        pos += rLength;\n        // s\n        const sTag = data[pos++];\n        if (sTag !== derTagInteger) {\n            throw new Error(\"INTEGER tag expected\");\n        }\n        const sLength = data[pos++];\n        if (sLength >= 0x80) {\n            throw new Error(\"Decoding length values above 127 not supported\");\n        }\n        const sData = data.slice(pos, pos + sLength);\n        pos += sLength;\n        return new Secp256k1Signature(\n        // r/s data can contain leading 0 bytes to express integers being non-negative in DER\n        trimLeadingNullBytes(rData), trimLeadingNullBytes(sData));\n    }\n    r(length) {\n        if (length === undefined) {\n            return this.data.r;\n        }\n        else {\n            const paddingLength = length - this.data.r.length;\n            if (paddingLength < 0) {\n                throw new Error(\"Length too small to hold parameter r\");\n            }\n            const padding = new Uint8Array(paddingLength);\n            return new Uint8Array([...padding, ...this.data.r]);\n        }\n    }\n    s(length) {\n        if (length === undefined) {\n            return this.data.s;\n        }\n        else {\n            const paddingLength = length - this.data.s.length;\n            if (paddingLength < 0) {\n                throw new Error(\"Length too small to hold parameter s\");\n            }\n            const padding = new Uint8Array(paddingLength);\n            return new Uint8Array([...padding, ...this.data.s]);\n        }\n    }\n    toFixedLength() {\n        return new Uint8Array([...this.r(32), ...this.s(32)]);\n    }\n    toDer() {\n        // DER supports negative integers but our data is unsigned. Thus we need to prepend\n        // a leading 0 byte when the higest bit is set to differentiate nagative values\n        const rEncoded = this.data.r[0] >= 0x80 ? new Uint8Array([0, ...this.data.r]) : this.data.r;\n        const sEncoded = this.data.s[0] >= 0x80 ? new Uint8Array([0, ...this.data.s]) : this.data.s;\n        const rLength = rEncoded.length;\n        const sLength = sEncoded.length;\n        const data = new Uint8Array([derTagInteger, rLength, ...rEncoded, derTagInteger, sLength, ...sEncoded]);\n        return new Uint8Array([0x30, data.length, ...data]);\n    }\n}\nexports.Secp256k1Signature = Secp256k1Signature;\n/**\n * A Secp256k1Signature plus the recovery parameter\n */\nclass ExtendedSecp256k1Signature extends Secp256k1Signature {\n    constructor(r, s, recovery) {\n        super(r, s);\n        if (!Number.isInteger(recovery)) {\n            throw new Error(\"The recovery parameter must be an integer.\");\n        }\n        if (recovery < 0 || recovery > 4) {\n            throw new Error(\"The recovery parameter must be one of 0, 1, 2, 3.\");\n        }\n        this.recovery = recovery;\n    }\n    /**\n     * Decode extended signature from the simple fixed length encoding\n     * described in toFixedLength().\n     */\n    static fromFixedLength(data) {\n        if (data.length !== 65) {\n            throw new Error(`Got invalid data length ${data.length}. Expected 32 + 32 + 1`);\n        }\n        return new ExtendedSecp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)), data[64]);\n    }\n    /**\n     * A simple custom encoding that encodes the extended signature as\n     * r (32 bytes) | s (32 bytes) | recovery param (1 byte)\n     * where | denotes concatenation of bonary data.\n     */\n    toFixedLength() {\n        return new Uint8Array([...this.r(32), ...this.s(32), this.recovery]);\n    }\n}\nexports.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature;\n//# sourceMappingURL=secp256k1signature.js.map"]},"metadata":{},"sourceType":"script"}