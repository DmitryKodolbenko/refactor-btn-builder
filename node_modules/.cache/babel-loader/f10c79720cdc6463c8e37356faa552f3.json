{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueAndUpdates = void 0;\nconst xstream_1 = require(\"xstream\");\n/**\n * A read only wrapper around DefaultValueProducer that allows\n * to synchronously get the current value using the .value property\n * and listen to to updates by suscribing to the .updates stream\n */\nclass ValueAndUpdates {\n  constructor(producer) {\n    this.producer = producer;\n    this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);\n  }\n  get value() {\n    return this.producer.value;\n  }\n  /**\n   * Resolves as soon as search value is found.\n   *\n   * @param search either a value or a function that must return true when found\n   * @returns the value of the update that caused the search match\n   */\n  async waitFor(search) {\n    const searchImplementation = typeof search === \"function\" ? search : value => value === search;\n    return new Promise((resolve, reject) => {\n      const subscription = this.updates.subscribe({\n        next: newValue => {\n          if (searchImplementation(newValue)) {\n            resolve(newValue);\n            // MemoryStream.subscribe() calls next with the last value.\n            // Make async to ensure the subscription exists\n            setTimeout(() => subscription.unsubscribe(), 0);\n          }\n        },\n        complete: () => {\n          subscription.unsubscribe();\n          reject(\"Update stream completed without expected value\");\n        },\n        error: error => {\n          reject(error);\n        }\n      });\n    });\n  }\n}\nexports.ValueAndUpdates = ValueAndUpdates;","map":{"version":3,"sources":["../src/valueandupdates.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAMA;;;;AAIG;AACH,MAAa,eAAe,CAAA;EAS1B,WAAA,CAAmB,QAAiC,EAAA;IAClD,IAAI,CAAC,QAAQ,GAAG,QAAQ;IACxB,IAAI,CAAC,OAAO,GAAG,SAAA,CAAA,YAAY,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC;EAC7D;EATA,IAAW,KAAK,GAAA;IACd,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK;EAC5B;EASA;;;;;AAKG;EACI,MAAM,OAAO,CAAC,MAA6B,EAAA;IAChD,MAAM,oBAAoB,GACxB,OAAO,MAAM,KAAK,UAAU,GAAI,MAA4B,GAAI,KAAQ,IAAc,KAAK,KAAK,MAAM;IAExG,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAI;MACrC,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC;QAC1C,IAAI,EAAG,QAAQ,IAAI;UACjB,IAAI,oBAAoB,CAAC,QAAQ,CAAC,EAAE;YAClC,OAAO,CAAC,QAAQ,CAAC;YAEjB;YACA;YACA,UAAU,CAAC,MAAM,YAAY,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;UAChD;QACH,CAAC;QACD,QAAQ,EAAE,MAAK;UACb,YAAY,CAAC,WAAW,EAAE;UAC1B,MAAM,CAAC,gDAAgD,CAAC;QAC1D,CAAC;QACD,KAAK,EAAG,KAAK,IAAI;UACf,MAAM,CAAC,KAAK,CAAC;QACf;OACD,CAAC;IACJ,CAAC,CAAC;EACJ;AACD;AA7CD,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueAndUpdates = void 0;\nconst xstream_1 = require(\"xstream\");\n/**\n * A read only wrapper around DefaultValueProducer that allows\n * to synchronously get the current value using the .value property\n * and listen to to updates by suscribing to the .updates stream\n */\nclass ValueAndUpdates {\n    constructor(producer) {\n        this.producer = producer;\n        this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);\n    }\n    get value() {\n        return this.producer.value;\n    }\n    /**\n     * Resolves as soon as search value is found.\n     *\n     * @param search either a value or a function that must return true when found\n     * @returns the value of the update that caused the search match\n     */\n    async waitFor(search) {\n        const searchImplementation = typeof search === \"function\" ? search : (value) => value === search;\n        return new Promise((resolve, reject) => {\n            const subscription = this.updates.subscribe({\n                next: (newValue) => {\n                    if (searchImplementation(newValue)) {\n                        resolve(newValue);\n                        // MemoryStream.subscribe() calls next with the last value.\n                        // Make async to ensure the subscription exists\n                        setTimeout(() => subscription.unsubscribe(), 0);\n                    }\n                },\n                complete: () => {\n                    subscription.unsubscribe();\n                    reject(\"Update stream completed without expected value\");\n                },\n                error: (error) => {\n                    reject(error);\n                },\n            });\n        });\n    }\n}\nexports.ValueAndUpdates = ValueAndUpdates;\n//# sourceMappingURL=valueandupdates.js.map"]},"metadata":{},"sourceType":"script"}