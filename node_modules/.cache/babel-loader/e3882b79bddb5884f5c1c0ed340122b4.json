{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addCoins = exports.parseCoins = exports.coins = exports.coin = void 0;\nvar math_1 = require(\"@cosmjs/math\");\n/**\n * Creates a coin.\n *\n * If your values do not exceed the safe integer range of JS numbers (53 bit),\n * you can use the number type here. This is the case for all typical Cosmos SDK\n * chains that use the default 6 decimals.\n *\n * In case you need to supportr larger values, use unsigned integer strings instead.\n */\nfunction coin(amount, denom) {\n  var outAmount;\n  if (typeof amount === \"number\") {\n    try {\n      outAmount = new math_1.Uint53(amount).toString();\n    } catch (_err) {\n      throw new Error(\"Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.\");\n    }\n  } else {\n    if (!amount.match(/^[0-9]+$/)) {\n      throw new Error(\"Invalid unsigned integer string format\");\n    }\n    outAmount = amount.replace(/^0*/, \"\") || \"0\";\n  }\n  return {\n    amount: outAmount,\n    denom: denom\n  };\n}\nexports.coin = coin;\n/**\n * Creates a list of coins with one element.\n */\nfunction coins(amount, denom) {\n  return [coin(amount, denom)];\n}\nexports.coins = coins;\n/**\n * Takes a coins list like \"819966000ucosm,700000000ustake\" and parses it.\n *\n * A Stargate-ready variant of this function is available via:\n *\n * ```\n * import { parseCoins } from \"@cosmjs/proto-signing\";\n * // or\n * import { parseCoins } from \"@cosmjs/stargate\";\n * ```\n */\nfunction parseCoins(input) {\n  return input.replace(/\\s/g, \"\").split(\",\").filter(Boolean).map(function (part) {\n    var match = part.match(/^([0-9]+)([a-zA-Z]+)/);\n    if (!match) throw new Error(\"Got an invalid coin string\");\n    return {\n      amount: math_1.Uint64.fromString(match[1]).toString(),\n      denom: match[2]\n    };\n  });\n}\nexports.parseCoins = parseCoins;\n/**\n * Function to sum up coins with type Coin\n */\nfunction addCoins(lhs, rhs) {\n  if (lhs.denom !== rhs.denom) throw new Error(\"Trying to add two coins with different denoms\");\n  return {\n    amount: math_1.Decimal.fromAtomics(lhs.amount, 0).plus(math_1.Decimal.fromAtomics(rhs.amount, 0)).atomics,\n    denom: lhs.denom\n  };\n}\nexports.addCoins = addCoins;","map":{"version":3,"sources":["../src/coins.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AAMA;;;;;;;;AAQG;AACH,SAAgB,IAAI,CAAC,MAAuB,EAAE,KAAa,EAAA;EACzD,IAAI,SAAiB;EACrB,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;IAC9B,IAAI;MACF,SAAS,GAAG,IAAI,MAAA,CAAA,MAAM,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE;KAC1C,CAAC,OAAO,IAAI,EAAE;MACb,MAAM,IAAI,KAAK,CACb,gHAAgH,CACjH;IACF;GACF,MAAM;IACL,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;MAC7B,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC;IAC1D;IACD,SAAS,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,GAAG;EAC7C;EACD,OAAO;IACL,MAAM,EAAE,SAAS;IACjB,KAAK,EAAE;GACR;AACH;AApBA,OAAA,CAAA,IAAA,GAAA,IAAA;AAsBA;;AAEG;AACH,SAAgB,KAAK,CAAC,MAAuB,EAAE,KAAa,EAAA;EAC1D,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;AAC9B;AAFA,OAAA,CAAA,KAAA,GAAA,KAAA;AAIA;;;;;;;;;;AAUG;AACH,SAAgB,UAAU,CAAC,KAAa,EAAA;EACtC,OAAO,KAAK,CACT,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAClB,KAAK,CAAC,GAAG,CAAC,CACV,MAAM,CAAC,OAAO,CAAC,CACf,GAAG,CAAC,UAAC,IAAI,EAAI;IACZ,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,sBAAsB,CAAC;IAChD,IAAI,CAAC,KAAK,EAAE,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC;IACzD,OAAO;MACL,MAAM,EAAE,MAAA,CAAA,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE;MAC9C,KAAK,EAAE,KAAK,CAAC,CAAC;KACf;EACH,CAAC,CAAC;AACN;AAbA,OAAA,CAAA,UAAA,GAAA,UAAA;AAeA;;AAEG;AACH,SAAgB,QAAQ,CAAC,GAAS,EAAE,GAAS,EAAA;EAC3C,IAAI,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,KAAK,EAAE,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC;EAC7F,OAAO;IACL,MAAM,EAAE,MAAA,CAAA,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAA,CAAA,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO;IAC3F,KAAK,EAAE,GAAG,CAAC;GACZ;AACH;AANA,OAAA,CAAA,QAAA,GAAA,QAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addCoins = exports.parseCoins = exports.coins = exports.coin = void 0;\nconst math_1 = require(\"@cosmjs/math\");\n/**\n * Creates a coin.\n *\n * If your values do not exceed the safe integer range of JS numbers (53 bit),\n * you can use the number type here. This is the case for all typical Cosmos SDK\n * chains that use the default 6 decimals.\n *\n * In case you need to supportr larger values, use unsigned integer strings instead.\n */\nfunction coin(amount, denom) {\n    let outAmount;\n    if (typeof amount === \"number\") {\n        try {\n            outAmount = new math_1.Uint53(amount).toString();\n        }\n        catch (_err) {\n            throw new Error(\"Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.\");\n        }\n    }\n    else {\n        if (!amount.match(/^[0-9]+$/)) {\n            throw new Error(\"Invalid unsigned integer string format\");\n        }\n        outAmount = amount.replace(/^0*/, \"\") || \"0\";\n    }\n    return {\n        amount: outAmount,\n        denom: denom,\n    };\n}\nexports.coin = coin;\n/**\n * Creates a list of coins with one element.\n */\nfunction coins(amount, denom) {\n    return [coin(amount, denom)];\n}\nexports.coins = coins;\n/**\n * Takes a coins list like \"819966000ucosm,700000000ustake\" and parses it.\n *\n * A Stargate-ready variant of this function is available via:\n *\n * ```\n * import { parseCoins } from \"@cosmjs/proto-signing\";\n * // or\n * import { parseCoins } from \"@cosmjs/stargate\";\n * ```\n */\nfunction parseCoins(input) {\n    return input\n        .replace(/\\s/g, \"\")\n        .split(\",\")\n        .filter(Boolean)\n        .map((part) => {\n        const match = part.match(/^([0-9]+)([a-zA-Z]+)/);\n        if (!match)\n            throw new Error(\"Got an invalid coin string\");\n        return {\n            amount: math_1.Uint64.fromString(match[1]).toString(),\n            denom: match[2],\n        };\n    });\n}\nexports.parseCoins = parseCoins;\n/**\n * Function to sum up coins with type Coin\n */\nfunction addCoins(lhs, rhs) {\n    if (lhs.denom !== rhs.denom)\n        throw new Error(\"Trying to add two coins with different denoms\");\n    return {\n        amount: math_1.Decimal.fromAtomics(lhs.amount, 0).plus(math_1.Decimal.fromAtomics(rhs.amount, 0)).atomics,\n        denom: lhs.denom,\n    };\n}\nexports.addCoins = addCoins;\n//# sourceMappingURL=coins.js.map"]},"metadata":{},"sourceType":"script"}