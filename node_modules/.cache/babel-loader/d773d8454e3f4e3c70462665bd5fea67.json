{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lastValue = exports.asArray = exports.countStream = exports.Reducer = void 0;\n// Reducer takes a stream of events T and a ReducerFunc, that\n// materializes a state of type U.\nvar Reducer = /*#__PURE__*/function () {\n  function Reducer(stream, reducer, initState) {\n    var _this = this;\n    _classCallCheck(this, Reducer);\n    this.stream = stream;\n    this.reducer = reducer;\n    this.state = initState;\n    this.completed = new Promise(function (resolve, reject) {\n      var subscription = _this.stream.subscribe({\n        next: function next(evt) {\n          _this.state = _this.reducer(_this.state, evt);\n        },\n        complete: function complete() {\n          resolve();\n          // this must happen after resolve, to ensure stream.subscribe() has finished\n          subscription.unsubscribe();\n        },\n        error: function error(err) {\n          reject(err);\n          // the stream already closed on error, but unsubscribe to be safe\n          subscription.unsubscribe();\n        }\n      });\n    });\n  }\n  // value returns current materialized state\n  _createClass(Reducer, [{\n    key: \"value\",\n    value: function value() {\n      return this.state;\n    }\n    // finished resolves on completed stream, rejects on stream error\n  }, {\n    key: \"finished\",\n    value: function () {\n      var _finished = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.completed);\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function finished() {\n        return _finished.apply(this, arguments);\n      }\n      return finished;\n    }()\n  }]);\n  return Reducer;\n}();\nexports.Reducer = Reducer;\nfunction increment(sum, _) {\n  return sum + 1;\n}\n// countStream returns a reducer that contains current count\n// of events on the stream\nfunction countStream(stream) {\n  return new Reducer(stream, increment, 0);\n}\nexports.countStream = countStream;\nfunction append(list, evt) {\n  return [].concat(_toConsumableArray(list), [evt]);\n}\n// asArray maintains an array containing all events that have\n// occurred on the stream\nfunction asArray(stream) {\n  return new Reducer(stream, append, []);\n}\nexports.asArray = asArray;\nfunction last(_, event) {\n  return event;\n}\n// lastValue returns the last value read from the stream, or undefined if no values sent\nfunction lastValue(stream) {\n  return new Reducer(stream, last, undefined);\n}\nexports.lastValue = lastValue;","map":{"version":3,"sources":["../src/reducer.ts"],"names":[],"mappings":";;;;;;;;;;;AAIA;AACA;AAAA,IACa,OAAO;EAQlB,iBAAmB,MAAiB,EAAE,OAA0B,EAAE,SAAY,EAAA;IAAA;IAAA;IAC5E,IAAI,CAAC,MAAM,GAAG,MAAM;IACpB,IAAI,CAAC,OAAO,GAAG,OAAO;IACtB,IAAI,CAAC,KAAK,GAAG,SAAS;IACtB,IAAI,CAAC,SAAS,GAAG,IAAI,OAAO,CAAO,UAAC,OAAO,EAAE,MAAM,EAAI;MACrD,IAAM,YAAY,GAAG,KAAI,CAAC,MAAM,CAAC,SAAS,CAAC;QACzC,IAAI,EAAE,cAAC,GAAM,EAAI;UACf,KAAI,CAAC,KAAK,GAAG,KAAI,CAAC,OAAO,CAAC,KAAI,CAAC,KAAK,EAAE,GAAG,CAAC;QAC5C,CAAC;QACD,QAAQ,EAAE,oBAAK;UACb,OAAO,EAAE;UACT;UACA,YAAY,CAAC,WAAW,EAAE;QAC5B,CAAC;QACD,KAAK,EAAE,eAAC,GAAQ,EAAI;UAClB,MAAM,CAAC,GAAG,CAAC;UACX;UACA,YAAY,CAAC,WAAW,EAAE;QAC5B;OACD,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA;EAAA;IAAA;IAAA,OACO,iBAAK;MACV,OAAO,IAAI,CAAC,KAAK;IACnB;IAEA;EAAA;IAAA;IAAA;MAAA,2EACO;QAAA;UAAA;YAAA;cAAA;gBAAA,iCACE,IAAI,CAAC,SAAS;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACtB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA;AAvCH,OAAA,CAAA,OAAA,GAAA,OAAA;AA0CA,SAAS,SAAS,CAAI,GAAW,EAAE,CAAI,EAAA;EACrC,OAAO,GAAG,GAAG,CAAC;AAChB;AAEA;AACA;AACA,SAAgB,WAAW,CAAI,MAAiB,EAAA;EAC9C,OAAO,IAAI,OAAO,CAAC,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC;AAC1C;AAFA,OAAA,CAAA,WAAA,GAAA,WAAA;AAIA,SAAS,MAAM,CAAI,IAAkB,EAAE,GAAM,EAAA;EAC3C,oCAAW,IAAI,IAAE,GAAG;AACtB;AAEA;AACA;AACA,SAAgB,OAAO,CAAI,MAAiB,EAAA;EAC1C,OAAO,IAAI,OAAO,CAAkB,MAAM,EAAE,MAAM,EAAE,EAAE,CAAC;AACzD;AAFA,OAAA,CAAA,OAAA,GAAA,OAAA;AAIA,SAAS,IAAI,CAAI,CAAM,EAAE,KAAQ,EAAA;EAC/B,OAAO,KAAK;AACd;AAEA;AACA,SAAgB,SAAS,CAAI,MAAiB,EAAA;EAC5C,OAAO,IAAI,OAAO,CAAmB,MAAM,EAAE,IAAI,EAAE,SAAS,CAAC;AAC/D;AAFA,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lastValue = exports.asArray = exports.countStream = exports.Reducer = void 0;\n// Reducer takes a stream of events T and a ReducerFunc, that\n// materializes a state of type U.\nclass Reducer {\n    constructor(stream, reducer, initState) {\n        this.stream = stream;\n        this.reducer = reducer;\n        this.state = initState;\n        this.completed = new Promise((resolve, reject) => {\n            const subscription = this.stream.subscribe({\n                next: (evt) => {\n                    this.state = this.reducer(this.state, evt);\n                },\n                complete: () => {\n                    resolve();\n                    // this must happen after resolve, to ensure stream.subscribe() has finished\n                    subscription.unsubscribe();\n                },\n                error: (err) => {\n                    reject(err);\n                    // the stream already closed on error, but unsubscribe to be safe\n                    subscription.unsubscribe();\n                },\n            });\n        });\n    }\n    // value returns current materialized state\n    value() {\n        return this.state;\n    }\n    // finished resolves on completed stream, rejects on stream error\n    async finished() {\n        return this.completed;\n    }\n}\nexports.Reducer = Reducer;\nfunction increment(sum, _) {\n    return sum + 1;\n}\n// countStream returns a reducer that contains current count\n// of events on the stream\nfunction countStream(stream) {\n    return new Reducer(stream, increment, 0);\n}\nexports.countStream = countStream;\nfunction append(list, evt) {\n    return [...list, evt];\n}\n// asArray maintains an array containing all events that have\n// occurred on the stream\nfunction asArray(stream) {\n    return new Reducer(stream, append, []);\n}\nexports.asArray = asArray;\nfunction last(_, event) {\n    return event;\n}\n// lastValue returns the last value read from the stream, or undefined if no values sent\nfunction lastValue(stream) {\n    return new Reducer(stream, last, undefined);\n}\nexports.lastValue = lastValue;\n//# sourceMappingURL=reducer.js.map"]},"metadata":{},"sourceType":"script"}