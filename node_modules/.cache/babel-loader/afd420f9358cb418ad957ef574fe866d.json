{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeMultisignedTx = exports.makeCompactBitArray = void 0;\nvar amino_1 = require(\"@cosmjs/amino\");\nvar encoding_1 = require(\"@cosmjs/encoding\");\nvar proto_signing_1 = require(\"@cosmjs/proto-signing\");\nvar multisig_1 = require(\"cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig\");\nvar signing_1 = require(\"cosmjs-types/cosmos/tx/signing/v1beta1/signing\");\nvar tx_1 = require(\"cosmjs-types/cosmos/tx/v1beta1/tx\");\nvar tx_2 = require(\"cosmjs-types/cosmos/tx/v1beta1/tx\");\nvar long_1 = __importDefault(require(\"long\"));\nfunction makeCompactBitArray(bits) {\n  var byteCount = Math.ceil(bits.length / 8);\n  var extraBits = bits.length - Math.floor(bits.length / 8) * 8;\n  var bytes = new Uint8Array(byteCount); // zero-filled\n  bits.forEach(function (value, index) {\n    var bytePos = Math.floor(index / 8);\n    var bitPos = index % 8;\n    // eslint-disable-next-line no-bitwise\n    if (value) bytes[bytePos] |= 1 << 8 - 1 - bitPos;\n  });\n  return multisig_1.CompactBitArray.fromPartial({\n    elems: bytes,\n    extraBitsStored: extraBits\n  });\n}\nexports.makeCompactBitArray = makeCompactBitArray;\nfunction makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {\n  var addresses = Array.from(signatures.keys());\n  var prefix = (0, encoding_1.fromBech32)(addresses[0]).prefix;\n  var signers = Array(multisigPubkey.value.pubkeys.length).fill(false);\n  var signaturesList = new Array();\n  for (var i = 0; i < multisigPubkey.value.pubkeys.length; i++) {\n    var signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i], prefix);\n    var signature = signatures.get(signerAddress);\n    if (signature) {\n      signers[i] = true;\n      signaturesList.push(signature);\n    }\n  }\n  var signerInfo = {\n    publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),\n    modeInfo: {\n      multi: {\n        bitarray: makeCompactBitArray(signers),\n        modeInfos: signaturesList.map(function (_) {\n          return {\n            single: {\n              mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON\n            }\n          };\n        })\n      }\n    },\n    sequence: long_1.default.fromNumber(sequence)\n  };\n  var authInfo = tx_1.AuthInfo.fromPartial({\n    signerInfos: [signerInfo],\n    fee: {\n      amount: _toConsumableArray(fee.amount),\n      gasLimit: long_1.default.fromString(fee.gas)\n    }\n  });\n  var authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();\n  var signedTx = tx_2.TxRaw.fromPartial({\n    bodyBytes: bodyBytes,\n    authInfoBytes: authInfoBytes,\n    signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({\n      signatures: signaturesList\n    })).finish()]\n  });\n  return signedTx;\n}\nexports.makeMultisignedTx = makeMultisignedTx;","map":{"version":3,"sources":["../src/multisignature.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeMultisignedTx = exports.makeCompactBitArray = void 0;\nconst amino_1 = require(\"@cosmjs/amino\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst proto_signing_1 = require(\"@cosmjs/proto-signing\");\nconst multisig_1 = require(\"cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig\");\nconst signing_1 = require(\"cosmjs-types/cosmos/tx/signing/v1beta1/signing\");\nconst tx_1 = require(\"cosmjs-types/cosmos/tx/v1beta1/tx\");\nconst tx_2 = require(\"cosmjs-types/cosmos/tx/v1beta1/tx\");\nconst long_1 = __importDefault(require(\"long\"));\nfunction makeCompactBitArray(bits) {\n    const byteCount = Math.ceil(bits.length / 8);\n    const extraBits = bits.length - Math.floor(bits.length / 8) * 8;\n    const bytes = new Uint8Array(byteCount); // zero-filled\n    bits.forEach((value, index) => {\n        const bytePos = Math.floor(index / 8);\n        const bitPos = index % 8;\n        // eslint-disable-next-line no-bitwise\n        if (value)\n            bytes[bytePos] |= 0b1 << (8 - 1 - bitPos);\n    });\n    return multisig_1.CompactBitArray.fromPartial({ elems: bytes, extraBitsStored: extraBits });\n}\nexports.makeCompactBitArray = makeCompactBitArray;\nfunction makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {\n    const addresses = Array.from(signatures.keys());\n    const prefix = (0, encoding_1.fromBech32)(addresses[0]).prefix;\n    const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);\n    const signaturesList = new Array();\n    for (let i = 0; i < multisigPubkey.value.pubkeys.length; i++) {\n        const signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i], prefix);\n        const signature = signatures.get(signerAddress);\n        if (signature) {\n            signers[i] = true;\n            signaturesList.push(signature);\n        }\n    }\n    const signerInfo = {\n        publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),\n        modeInfo: {\n            multi: {\n                bitarray: makeCompactBitArray(signers),\n                modeInfos: signaturesList.map((_) => ({ single: { mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } })),\n            },\n        },\n        sequence: long_1.default.fromNumber(sequence),\n    };\n    const authInfo = tx_1.AuthInfo.fromPartial({\n        signerInfos: [signerInfo],\n        fee: {\n            amount: [...fee.amount],\n            gasLimit: long_1.default.fromString(fee.gas),\n        },\n    });\n    const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();\n    const signedTx = tx_2.TxRaw.fromPartial({\n        bodyBytes: bodyBytes,\n        authInfoBytes: authInfoBytes,\n        signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({ signatures: signaturesList })).finish()],\n    });\n    return signedTx;\n}\nexports.makeMultisignedTx = makeMultisignedTx;\n//# sourceMappingURL=multisignature.js.map"]},"metadata":{},"sourceType":"script"}