{"ast":null,"code":"import { Cell } from \"ton\";\nconst OFF_CHAIN_CONTENT_PREFIX = 0x01;\nexport function flattenSnakeCell(cell) {\n  try {\n    let c = cell;\n    let res = Buffer.alloc(0);\n    while (c) {\n      let cs = c.beginParse();\n      // console.log(cs);\n      let data = cs.readRemainingBytes();\n      res = Buffer.concat([res, data]);\n      c = c.refs[0];\n    }\n    return res;\n  } catch (e) {\n    // console.log(e);\n    return null;\n  }\n}\nfunction bufferToChunks(buff, chunkSize) {\n  let chunks = [];\n  while (buff.byteLength > 0) {\n    chunks.push(buff.slice(0, chunkSize));\n    buff = buff.slice(chunkSize);\n  }\n  return chunks;\n}\nexport function makeSnakeCell(data) {\n  let chunks = bufferToChunks(data, 127);\n  let rootCell = new Cell();\n  let curCell = rootCell;\n  for (let i = 0; i < chunks.length; i++) {\n    let chunk = chunks[i];\n    curCell.bits.writeBuffer(chunk);\n    if (chunks[i + 1]) {\n      let nextCell = new Cell();\n      curCell.refs.push(nextCell);\n      curCell = nextCell;\n    }\n  }\n  return rootCell;\n}\nexport function encodeOffChainContent(content) {\n  let data = Buffer.from(content);\n  let offChainPrefix = Buffer.from([OFF_CHAIN_CONTENT_PREFIX]);\n  data = Buffer.concat([offChainPrefix, data]);\n  return makeSnakeCell(data);\n}\nexport function decodeOffChainContent(content) {\n  // console.log(content);\n  let data = flattenSnakeCell(content);\n  if (data) {\n    let prefix = data[0];\n    if (prefix !== OFF_CHAIN_CONTENT_PREFIX) {\n      console.log(`Unknown content prefix: ${prefix.toString(16)}`);\n      return \"\";\n    }\n    return data.slice(1).toString();\n  } else {\n    return \"\";\n  }\n}","map":{"version":3,"names":["Cell","OFF_CHAIN_CONTENT_PREFIX","flattenSnakeCell","cell","c","res","Buffer","alloc","cs","beginParse","data","readRemainingBytes","concat","refs","e","bufferToChunks","buff","chunkSize","chunks","byteLength","push","slice","makeSnakeCell","rootCell","curCell","i","length","chunk","bits","writeBuffer","nextCell","encodeOffChainContent","content","from","offChainPrefix","decodeOffChainContent","prefix","console","log","toString"],"sources":["/Users/sepezho/Work/tonana/fe/src/logic/transaction/BOCcontent.ts"],"sourcesContent":["import { Cell } from \"ton\";\n\nconst OFF_CHAIN_CONTENT_PREFIX = 0x01;\n\nexport function flattenSnakeCell(cell: Cell) {\n\ttry {\n\t\tlet c: Cell | null = cell;\n\n\t\tlet res = Buffer.alloc(0);\n\n\t\twhile (c) {\n\t\t\tlet cs = c.beginParse();\n\t\t\t// console.log(cs);\n\t\t\tlet data = cs.readRemainingBytes();\n\t\t\tres = Buffer.concat([res, data]);\n\t\t\tc = c.refs[0];\n\t\t}\n\n\t\treturn res;\n\t} catch (e) {\n\t\t// console.log(e);\n\t\treturn null;\n\t}\n}\n\nfunction bufferToChunks(buff: Buffer, chunkSize: number) {\n\tlet chunks: Buffer[] = [];\n\twhile (buff.byteLength > 0) {\n\t\tchunks.push(buff.slice(0, chunkSize));\n\t\tbuff = buff.slice(chunkSize);\n\t}\n\treturn chunks;\n}\n\nexport function makeSnakeCell(data: Buffer) {\n\tlet chunks = bufferToChunks(data, 127);\n\tlet rootCell = new Cell();\n\tlet curCell = rootCell;\n\n\tfor (let i = 0; i < chunks.length; i++) {\n\t\tlet chunk = chunks[i];\n\n\t\tcurCell.bits.writeBuffer(chunk);\n\n\t\tif (chunks[i + 1]) {\n\t\t\tlet nextCell = new Cell();\n\t\t\tcurCell.refs.push(nextCell);\n\t\t\tcurCell = nextCell;\n\t\t}\n\t}\n\n\treturn rootCell;\n}\n\nexport function encodeOffChainContent(content: string) {\n\tlet data = Buffer.from(content);\n\tlet offChainPrefix = Buffer.from([OFF_CHAIN_CONTENT_PREFIX]);\n\tdata = Buffer.concat([offChainPrefix, data]);\n\treturn makeSnakeCell(data);\n}\n\nexport function decodeOffChainContent(content: Cell) {\n\t// console.log(content);\n\tlet data = flattenSnakeCell(content);\n\n\tif (data) {\n\t\tlet prefix = data[0];\n\t\tif (prefix !== OFF_CHAIN_CONTENT_PREFIX) {\n\t\t\tconsole.log(`Unknown content prefix: ${prefix.toString(16)}`);\n\t\t\treturn \"\";\n\t\t}\n\t\treturn data.slice(1).toString();\n\t} else {\n\t\treturn \"\";\n\t}\n}\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,KAAK;AAE1B,MAAMC,wBAAwB,GAAG,IAAI;AAErC,OAAO,SAASC,gBAAgB,CAACC,IAAU,EAAE;EAC5C,IAAI;IACH,IAAIC,CAAc,GAAGD,IAAI;IAEzB,IAAIE,GAAG,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IAEzB,OAAOH,CAAC,EAAE;MACT,IAAII,EAAE,GAAGJ,CAAC,CAACK,UAAU,EAAE;MACvB;MACA,IAAIC,IAAI,GAAGF,EAAE,CAACG,kBAAkB,EAAE;MAClCN,GAAG,GAAGC,MAAM,CAACM,MAAM,CAAC,CAACP,GAAG,EAAEK,IAAI,CAAC,CAAC;MAChCN,CAAC,GAAGA,CAAC,CAACS,IAAI,CAAC,CAAC,CAAC;IACd;IAEA,OAAOR,GAAG;EACX,CAAC,CAAC,OAAOS,CAAC,EAAE;IACX;IACA,OAAO,IAAI;EACZ;AACD;AAEA,SAASC,cAAc,CAACC,IAAY,EAAEC,SAAiB,EAAE;EACxD,IAAIC,MAAgB,GAAG,EAAE;EACzB,OAAOF,IAAI,CAACG,UAAU,GAAG,CAAC,EAAE;IAC3BD,MAAM,CAACE,IAAI,CAACJ,IAAI,CAACK,KAAK,CAAC,CAAC,EAAEJ,SAAS,CAAC,CAAC;IACrCD,IAAI,GAAGA,IAAI,CAACK,KAAK,CAACJ,SAAS,CAAC;EAC7B;EACA,OAAOC,MAAM;AACd;AAEA,OAAO,SAASI,aAAa,CAACZ,IAAY,EAAE;EAC3C,IAAIQ,MAAM,GAAGH,cAAc,CAACL,IAAI,EAAE,GAAG,CAAC;EACtC,IAAIa,QAAQ,GAAG,IAAIvB,IAAI,EAAE;EACzB,IAAIwB,OAAO,GAAGD,QAAQ;EAEtB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,MAAM,CAACQ,MAAM,EAAED,CAAC,EAAE,EAAE;IACvC,IAAIE,KAAK,GAAGT,MAAM,CAACO,CAAC,CAAC;IAErBD,OAAO,CAACI,IAAI,CAACC,WAAW,CAACF,KAAK,CAAC;IAE/B,IAAIT,MAAM,CAACO,CAAC,GAAG,CAAC,CAAC,EAAE;MAClB,IAAIK,QAAQ,GAAG,IAAI9B,IAAI,EAAE;MACzBwB,OAAO,CAACX,IAAI,CAACO,IAAI,CAACU,QAAQ,CAAC;MAC3BN,OAAO,GAAGM,QAAQ;IACnB;EACD;EAEA,OAAOP,QAAQ;AAChB;AAEA,OAAO,SAASQ,qBAAqB,CAACC,OAAe,EAAE;EACtD,IAAItB,IAAI,GAAGJ,MAAM,CAAC2B,IAAI,CAACD,OAAO,CAAC;EAC/B,IAAIE,cAAc,GAAG5B,MAAM,CAAC2B,IAAI,CAAC,CAAChC,wBAAwB,CAAC,CAAC;EAC5DS,IAAI,GAAGJ,MAAM,CAACM,MAAM,CAAC,CAACsB,cAAc,EAAExB,IAAI,CAAC,CAAC;EAC5C,OAAOY,aAAa,CAACZ,IAAI,CAAC;AAC3B;AAEA,OAAO,SAASyB,qBAAqB,CAACH,OAAa,EAAE;EACpD;EACA,IAAItB,IAAI,GAAGR,gBAAgB,CAAC8B,OAAO,CAAC;EAEpC,IAAItB,IAAI,EAAE;IACT,IAAI0B,MAAM,GAAG1B,IAAI,CAAC,CAAC,CAAC;IACpB,IAAI0B,MAAM,KAAKnC,wBAAwB,EAAE;MACxCoC,OAAO,CAACC,GAAG,CAAE,2BAA0BF,MAAM,CAACG,QAAQ,CAAC,EAAE,CAAE,EAAC,CAAC;MAC7D,OAAO,EAAE;IACV;IACA,OAAO7B,IAAI,CAACW,KAAK,CAAC,CAAC,CAAC,CAACkB,QAAQ,EAAE;EAChC,CAAC,MAAM;IACN,OAAO,EAAE;EACV;AACD"},"metadata":{},"sourceType":"module"}