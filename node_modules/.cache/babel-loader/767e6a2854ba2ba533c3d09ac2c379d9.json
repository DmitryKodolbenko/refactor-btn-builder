{"ast":null,"code":"const {\n  Cell\n} = require(\"../boc\");\nconst {\n  Address,\n  bytesToBase64,\n  bytesToHex\n} = require(\"../utils\");\nclass Contract {\n  /**\n   * @param provider    {HttpProvider}\n   * @param options    {{code?: Cell, address?: Address | string, wc?: number}}\n   */\n  constructor(provider, options) {\n    this.provider = provider;\n    this.options = options;\n    this.address = options.address ? new Address(options.address) : null;\n    if (!options.wc) options.wc = this.address ? this.address.wc : 0;\n    this.methods = {};\n  }\n\n  /**\n   * @return {Promise<Address>}\n   */\n  async getAddress() {\n    if (!this.address) {\n      this.address = (await this.createStateInit()).address;\n    }\n    return this.address;\n  }\n\n  /**\n   * @private\n   * @return {Cell} cell contains contact code\n   */\n  createCodeCell() {\n    if (!this.options.code) throw new Error('Contract: options.code is not defined');\n    return this.options.code;\n  }\n\n  /**\n   * Method to override\n   * @protected\n   * @return {Cell} cell contains contract data\n   */\n  createDataCell() {\n    return new Cell();\n  }\n\n  /**\n   * @protected\n   * @return {Promise<{stateInit: Cell, address: Address, code: Cell, data: Cell}>}\n   */\n  async createStateInit() {\n    const codeCell = this.createCodeCell();\n    const dataCell = this.createDataCell();\n    const stateInit = Contract.createStateInit(codeCell, dataCell);\n    const stateInitHash = await stateInit.hash();\n    const address = new Address(this.options.wc + \":\" + bytesToHex(stateInitHash));\n    return {\n      stateInit: stateInit,\n      address: address,\n      code: codeCell,\n      data: dataCell\n    };\n  }\n\n  // _ split_depth:(Maybe (## 5)) special:(Maybe TickTock)\n  // code:(Maybe ^Cell) data:(Maybe ^Cell)\n  // library:(Maybe ^Cell) = StateInit;\n  /**\n   * @param code  {Cell}\n   * @param data  {Cell}\n   * @param library {null}\n   * @param splitDepth {null}\n   * @param ticktock  {null}\n   * @return {Cell}\n   */\n  static createStateInit(code, data) {\n    let library = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let splitDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let ticktock = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    if (library) throw \"Library in state init is not implemented\";\n    if (splitDepth) throw \"Split depth in state init is not implemented\";\n    if (ticktock) throw \"Ticktock in state init is not implemented\";\n    const stateInit = new Cell();\n    stateInit.bits.writeBitArray([Boolean(splitDepth), Boolean(ticktock), Boolean(code), Boolean(data), Boolean(library)]);\n    if (code) stateInit.refs.push(code);\n    if (data) stateInit.refs.push(data);\n    if (library) stateInit.refs.push(library);\n    return stateInit;\n  }\n\n  // extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32))\n  // = ExtraCurrencyCollection;\n  // currencies$_ grams:Grams other:ExtraCurrencyCollection\n  // = CurrencyCollection;\n\n  //int_msg_info$0 ihr_disabled:Bool bounce:Bool\n  //src:MsgAddressInt dest:MsgAddressInt\n  //value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams\n  //created_lt:uint64 created_at:uint32 = CommonMsgInfo;\n  /**\n   * @param dest  {Address | string}\n   * @param gramValue  {number | BN}\n   * @param ihrDisabled  {boolean}\n   * @param bounce  {null | boolean}\n   * @param bounced {boolean}\n   * @param src  {Address | string}\n   * @param currencyCollection  {null}\n   * @param ihrFees  {number | BN}\n   * @param fwdFees  {number | BN}\n   * @param createdLt  {number | BN}\n   * @param createdAt  {number | BN}\n   * @return {Cell}\n   */\n  static createInternalMessageHeader(dest) {\n    let gramValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let ihrDisabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let bounce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let bounced = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let src = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    let currencyCollection = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    let ihrFees = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    let fwdFees = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    let createdLt = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n    let createdAt = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;\n    const message = new Cell();\n    message.bits.writeBit(false);\n    message.bits.writeBit(ihrDisabled);\n    if (!(bounce === null)) {\n      message.bits.writeBit(bounce);\n    } else {\n      message.bits.writeBit(new Address(dest).isBounceable);\n    }\n    message.bits.writeBit(bounced);\n    message.bits.writeAddress(src ? new Address(src) : null);\n    message.bits.writeAddress(new Address(dest));\n    message.bits.writeGrams(gramValue);\n    if (currencyCollection) {\n      throw \"Currency collections are not implemented yet\";\n    }\n    message.bits.writeBit(Boolean(currencyCollection));\n    message.bits.writeGrams(ihrFees);\n    message.bits.writeGrams(fwdFees);\n    message.bits.writeUint(createdLt, 64);\n    message.bits.writeUint(createdAt, 32);\n    return message;\n  }\n\n  //ext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt\n  //import_fee:Grams = CommonMsgInfo;\n  /**\n   * @param dest  {Address | string}\n   * @param src  {Address | string}\n   * @param importFee  {number | BN}\n   * @return {Cell}\n   */\n  static createExternalMessageHeader(dest) {\n    let src = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let importFee = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const message = new Cell();\n    message.bits.writeUint(2, 2);\n    message.bits.writeAddress(src ? new Address(src) : null);\n    message.bits.writeAddress(new Address(dest));\n    message.bits.writeGrams(importFee);\n    return message;\n  }\n\n  //tblkch.pdf, page 57\n  /**\n   * Create CommonMsgInfo contains header, stateInit, body\n   * @param header {Cell}\n   * @param stateInit?  {Cell}\n   * @param body?  {Cell}\n   * @return {Cell}\n   */\n  static createCommonMsgInfo(header) {\n    let stateInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const commonMsgInfo = new Cell();\n    commonMsgInfo.writeCell(header);\n    if (stateInit) {\n      commonMsgInfo.bits.writeBit(true);\n      //-1:  need at least one bit for body\n      // TODO we also should check for free refs here\n      if (commonMsgInfo.bits.getFreeBits() - 1 >= stateInit.bits.getUsedBits()) {\n        commonMsgInfo.bits.writeBit(false);\n        commonMsgInfo.writeCell(stateInit);\n      } else {\n        commonMsgInfo.bits.writeBit(true);\n        commonMsgInfo.refs.push(stateInit);\n      }\n    } else {\n      commonMsgInfo.bits.writeBit(false);\n    }\n    // TODO we also should check for free refs here\n    if (body) {\n      if (commonMsgInfo.bits.getFreeBits() >= body.bits.getUsedBits()) {\n        commonMsgInfo.bits.writeBit(false);\n        commonMsgInfo.writeCell(body);\n      } else {\n        commonMsgInfo.bits.writeBit(true);\n        commonMsgInfo.refs.push(body);\n      }\n    } else {\n      commonMsgInfo.bits.writeBit(false);\n    }\n    return commonMsgInfo;\n  }\n  static createMethod(provider, queryPromise) {\n    return {\n      getQuery: async () => {\n        return (await queryPromise).message;\n      },\n      send: async () => {\n        const query = await queryPromise;\n        const boc = bytesToBase64(await query.message.toBoc(false));\n        return provider.sendBoc(boc);\n      },\n      estimateFee: async () => {\n        const query = await queryPromise;\n        const serialized = query.code ?\n        // deploy\n        {\n          address: query.address.toString(true, true, false),\n          body: bytesToBase64(await query.body.toBoc(false)),\n          init_code: bytesToBase64(await query.code.toBoc(false)),\n          init_data: bytesToBase64(await query.data.toBoc(false))\n        } : {\n          address: query.address.toString(true, true, true),\n          body: bytesToBase64(await query.body.toBoc(false))\n        };\n        return provider.getEstimateFee(serialized);\n      }\n    };\n  }\n}\nmodule.exports = {\n  Contract\n};","map":{"version":3,"names":["Cell","require","Address","bytesToBase64","bytesToHex","Contract","constructor","provider","options","address","wc","methods","getAddress","createStateInit","createCodeCell","code","Error","createDataCell","codeCell","dataCell","stateInit","stateInitHash","hash","data","library","splitDepth","ticktock","bits","writeBitArray","Boolean","refs","push","createInternalMessageHeader","dest","gramValue","ihrDisabled","bounce","bounced","src","currencyCollection","ihrFees","fwdFees","createdLt","createdAt","message","writeBit","isBounceable","writeAddress","writeGrams","writeUint","createExternalMessageHeader","importFee","createCommonMsgInfo","header","body","commonMsgInfo","writeCell","getFreeBits","getUsedBits","createMethod","queryPromise","getQuery","send","query","boc","toBoc","sendBoc","estimateFee","serialized","toString","init_code","init_data","getEstimateFee","module","exports"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/tonweb/src/contract/index.js"],"sourcesContent":["const {Cell} = require(\"../boc\");\nconst {Address, bytesToBase64, bytesToHex} = require(\"../utils\");\n\nclass Contract {\n    /**\n     * @param provider    {HttpProvider}\n     * @param options    {{code?: Cell, address?: Address | string, wc?: number}}\n     */\n    constructor(provider, options) {\n        this.provider = provider;\n        this.options = options;\n        this.address = options.address ? new Address(options.address) : null;\n        if (!options.wc) options.wc = this.address ? this.address.wc : 0;\n        this.methods = {};\n    }\n\n    /**\n     * @return {Promise<Address>}\n     */\n    async getAddress() {\n        if (!this.address) {\n            this.address = (await this.createStateInit()).address;\n        }\n        return this.address;\n    }\n\n    /**\n     * @private\n     * @return {Cell} cell contains contact code\n     */\n    createCodeCell() {\n        if (!this.options.code) throw new Error('Contract: options.code is not defined')\n        return this.options.code;\n    }\n\n    /**\n     * Method to override\n     * @protected\n     * @return {Cell} cell contains contract data\n     */\n    createDataCell() {\n        return new Cell();\n    }\n\n    /**\n     * @protected\n     * @return {Promise<{stateInit: Cell, address: Address, code: Cell, data: Cell}>}\n     */\n    async createStateInit() {\n        const codeCell = this.createCodeCell();\n        const dataCell = this.createDataCell();\n        const stateInit = Contract.createStateInit(codeCell, dataCell);\n        const stateInitHash = await stateInit.hash();\n        const address = new Address(this.options.wc + \":\" + bytesToHex(stateInitHash));\n        return {\n            stateInit: stateInit,\n            address: address,\n            code: codeCell,\n            data: dataCell,\n        }\n    }\n\n    // _ split_depth:(Maybe (## 5)) special:(Maybe TickTock)\n    // code:(Maybe ^Cell) data:(Maybe ^Cell)\n    // library:(Maybe ^Cell) = StateInit;\n    /**\n     * @param code  {Cell}\n     * @param data  {Cell}\n     * @param library {null}\n     * @param splitDepth {null}\n     * @param ticktock  {null}\n     * @return {Cell}\n     */\n    static createStateInit(code,\n                           data,\n                           library = null,\n                           splitDepth = null,\n                           ticktock = null) {\n        if (library)\n            throw \"Library in state init is not implemented\";\n        if (splitDepth)\n            throw \"Split depth in state init is not implemented\";\n        if (ticktock)\n            throw \"Ticktock in state init is not implemented\";\n\n        const stateInit = new Cell();\n\n        stateInit.bits.writeBitArray([Boolean(splitDepth), Boolean(ticktock), Boolean(code), Boolean(data), Boolean(library)]);\n        if (code)\n            stateInit.refs.push(code);\n        if (data)\n            stateInit.refs.push(data);\n        if (library)\n            stateInit.refs.push(library);\n        return stateInit;\n    }\n\n    // extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32))\n    // = ExtraCurrencyCollection;\n    // currencies$_ grams:Grams other:ExtraCurrencyCollection\n    // = CurrencyCollection;\n\n    //int_msg_info$0 ihr_disabled:Bool bounce:Bool\n    //src:MsgAddressInt dest:MsgAddressInt\n    //value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams\n    //created_lt:uint64 created_at:uint32 = CommonMsgInfo;\n    /**\n     * @param dest  {Address | string}\n     * @param gramValue  {number | BN}\n     * @param ihrDisabled  {boolean}\n     * @param bounce  {null | boolean}\n     * @param bounced {boolean}\n     * @param src  {Address | string}\n     * @param currencyCollection  {null}\n     * @param ihrFees  {number | BN}\n     * @param fwdFees  {number | BN}\n     * @param createdLt  {number | BN}\n     * @param createdAt  {number | BN}\n     * @return {Cell}\n     */\n    static createInternalMessageHeader(dest,\n                                       gramValue = 0,\n                                       ihrDisabled = true,\n                                       bounce = null,\n                                       bounced = false,\n                                       src = null,\n                                       currencyCollection = null,\n                                       ihrFees = 0,\n                                       fwdFees = 0,\n                                       createdLt = 0,\n                                       createdAt = 0) {\n        const message = new Cell();\n        message.bits.writeBit(false);\n        message.bits.writeBit(ihrDisabled);\n        if (!(bounce === null)) {\n            message.bits.writeBit(bounce);\n        } else {\n            message.bits.writeBit((new Address(dest)).isBounceable);\n        }\n        message.bits.writeBit(bounced);\n        message.bits.writeAddress(src ? new Address(src) : null);\n        message.bits.writeAddress(new Address(dest));\n        message.bits.writeGrams(gramValue);\n        if (currencyCollection) {\n            throw \"Currency collections are not implemented yet\";\n        }\n        message.bits.writeBit(Boolean(currencyCollection));\n        message.bits.writeGrams(ihrFees);\n        message.bits.writeGrams(fwdFees);\n        message.bits.writeUint(createdLt, 64);\n        message.bits.writeUint(createdAt, 32);\n        return message;\n    }\n\n    //ext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt\n    //import_fee:Grams = CommonMsgInfo;\n    /**\n     * @param dest  {Address | string}\n     * @param src  {Address | string}\n     * @param importFee  {number | BN}\n     * @return {Cell}\n     */\n    static createExternalMessageHeader(dest,\n                                       src = null,\n                                       importFee = 0) {\n        const message = new Cell();\n        message.bits.writeUint(2, 2);\n        message.bits.writeAddress(src ? new Address(src) : null);\n        message.bits.writeAddress(new Address(dest));\n        message.bits.writeGrams(importFee);\n        return message;\n    }\n\n    //tblkch.pdf, page 57\n    /**\n     * Create CommonMsgInfo contains header, stateInit, body\n     * @param header {Cell}\n     * @param stateInit?  {Cell}\n     * @param body?  {Cell}\n     * @return {Cell}\n     */\n    static createCommonMsgInfo(header, stateInit = null, body = null) {\n        const commonMsgInfo = new Cell();\n        commonMsgInfo.writeCell(header);\n\n        if (stateInit) {\n            commonMsgInfo.bits.writeBit(true);\n            //-1:  need at least one bit for body\n            // TODO we also should check for free refs here\n            if (commonMsgInfo.bits.getFreeBits() - 1 >= stateInit.bits.getUsedBits()) {\n                commonMsgInfo.bits.writeBit(false);\n                commonMsgInfo.writeCell(stateInit);\n            } else {\n                commonMsgInfo.bits.writeBit(true);\n                commonMsgInfo.refs.push(stateInit);\n            }\n        } else {\n            commonMsgInfo.bits.writeBit(false);\n        }\n        // TODO we also should check for free refs here\n        if (body) {\n            if (commonMsgInfo.bits.getFreeBits() >= body.bits.getUsedBits()) {\n                commonMsgInfo.bits.writeBit(false);\n                commonMsgInfo.writeCell(body);\n            } else {\n                commonMsgInfo.bits.writeBit(true);\n                commonMsgInfo.refs.push(body);\n            }\n        } else {\n            commonMsgInfo.bits.writeBit(false);\n        }\n        return commonMsgInfo;\n    }\n\n    static createMethod(provider, queryPromise) {\n        return {\n            getQuery: async () => {\n                return (await queryPromise).message;\n            },\n            send: async () => {\n                const query = await queryPromise;\n                const boc = bytesToBase64(await query.message.toBoc(false));\n                return provider.sendBoc(boc);\n            },\n            estimateFee: async () => {\n                const query = await queryPromise;\n                const serialized = query.code ? // deploy\n                    {\n                        address: query.address.toString(true, true, false),\n                        body: bytesToBase64(await query.body.toBoc(false)),\n                        init_code: bytesToBase64(await query.code.toBoc(false)),\n                        init_data: bytesToBase64(await query.data.toBoc(false)),\n                    } : {\n                        address: query.address.toString(true, true, true),\n                        body: bytesToBase64(await query.body.toBoc(false)),\n                    };\n\n                return provider.getEstimateFee(serialized);\n            }\n        }\n    }\n}\n\nmodule.exports = {Contract};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}