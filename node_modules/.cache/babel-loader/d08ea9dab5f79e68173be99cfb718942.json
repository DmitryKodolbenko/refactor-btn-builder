{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSupportedInterfaces = exports.getSupportedInterfacesRaw = exports.resolveKnownInterface = void 0;\nconst TupleSlice_1 = require(\"../boc/TupleSlice\");\nconst known = {\n  ['123515602279859691144772641439386770278']: 'org.ton.introspection.v0',\n  ['256184278959413194623484780286929323492']: 'com.tonwhales.nominators:v0',\n  ['242422353946785872806511191513850808027']: 'org.ton.jetton.master.v1',\n  ['311736387032003861293477945447179662681']: 'org.ton.jetton.wallet.v1'\n};\n/**\n * Resolves known interface\n * @param src source id\n * @returns known interface\n */\nfunction resolveKnownInterface(src) {\n  let kn = known[src];\n  if (kn) {\n    return kn;\n  } else {\n    return null;\n  }\n}\nexports.resolveKnownInterface = resolveKnownInterface;\n/**\n * Fetching supported interfaces\n * @param src address\n * @param client client\n * @returns array of supported interfaces\n */\nasync function getSupportedInterfacesRaw(src, client) {\n  // Query interfaces\n  let res = await client.callGetMethodWithError(src, 'supported_interfaces');\n  // If not successful: return empty\n  if (res.exit_code !== 0 && res.exit_code !== 1) {\n    return [];\n  }\n  try {\n    let slice = new TupleSlice_1.TupleSlice(res.stack);\n    // First interface have to be introspection\n    let firstNumber = slice.readBigNumber().toString();\n    if (firstNumber !== '123515602279859691144772641439386770278') {\n      return [];\n    }\n    // Read all remaining\n    let interfaces = [];\n    while (slice.remaining > 0) {\n      interfaces.push(slice.readBigNumber().toString());\n    }\n    return interfaces;\n  } catch (e) {\n    // In case of error: exit\n    console.warn(e);\n    return [];\n  }\n}\nexports.getSupportedInterfacesRaw = getSupportedInterfacesRaw;\n/**\n * Fetching supported interfaces\n * @param src address\n * @param client client\n * @returns array of supported interfaces\n */\nasync function getSupportedInterfaces(src, client) {\n  let supprotedRaw = await getSupportedInterfacesRaw(src, client);\n  return supprotedRaw.map(v => {\n    let k = resolveKnownInterface(v);\n    if (k) {\n      return {\n        type: 'known',\n        name: k\n      };\n    } else {\n      return {\n        type: 'unknown',\n        value: v\n      };\n    }\n  });\n}\nexports.getSupportedInterfaces = getSupportedInterfaces;","map":{"version":3,"names":["Object","defineProperty","exports","value","getSupportedInterfaces","getSupportedInterfacesRaw","resolveKnownInterface","TupleSlice_1","require","known","src","kn","client","res","callGetMethodWithError","exit_code","slice","TupleSlice","stack","firstNumber","readBigNumber","toString","interfaces","remaining","push","e","console","warn","supprotedRaw","map","v","k","type","name"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/introspection/getSupportedInterfaces.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSupportedInterfaces = exports.getSupportedInterfacesRaw = exports.resolveKnownInterface = void 0;\nconst TupleSlice_1 = require(\"../boc/TupleSlice\");\nconst known = {\n    ['123515602279859691144772641439386770278']: 'org.ton.introspection.v0',\n    ['256184278959413194623484780286929323492']: 'com.tonwhales.nominators:v0',\n    ['242422353946785872806511191513850808027']: 'org.ton.jetton.master.v1',\n    ['311736387032003861293477945447179662681']: 'org.ton.jetton.wallet.v1',\n};\n/**\n * Resolves known interface\n * @param src source id\n * @returns known interface\n */\nfunction resolveKnownInterface(src) {\n    let kn = known[src];\n    if (kn) {\n        return kn;\n    }\n    else {\n        return null;\n    }\n}\nexports.resolveKnownInterface = resolveKnownInterface;\n/**\n * Fetching supported interfaces\n * @param src address\n * @param client client\n * @returns array of supported interfaces\n */\nasync function getSupportedInterfacesRaw(src, client) {\n    // Query interfaces\n    let res = await client.callGetMethodWithError(src, 'supported_interfaces');\n    // If not successful: return empty\n    if (res.exit_code !== 0 && res.exit_code !== 1) {\n        return [];\n    }\n    try {\n        let slice = new TupleSlice_1.TupleSlice(res.stack);\n        // First interface have to be introspection\n        let firstNumber = slice.readBigNumber().toString();\n        if (firstNumber !== '123515602279859691144772641439386770278') {\n            return [];\n        }\n        // Read all remaining\n        let interfaces = [];\n        while (slice.remaining > 0) {\n            interfaces.push(slice.readBigNumber().toString());\n        }\n        return interfaces;\n    }\n    catch (e) {\n        // In case of error: exit\n        console.warn(e);\n        return [];\n    }\n}\nexports.getSupportedInterfacesRaw = getSupportedInterfacesRaw;\n/**\n * Fetching supported interfaces\n * @param src address\n * @param client client\n * @returns array of supported interfaces\n */\nasync function getSupportedInterfaces(src, client) {\n    let supprotedRaw = await getSupportedInterfacesRaw(src, client);\n    return supprotedRaw.map((v) => {\n        let k = resolveKnownInterface(v);\n        if (k) {\n            return { type: 'known', name: k };\n        }\n        else {\n            return { type: 'unknown', value: v };\n        }\n    });\n}\nexports.getSupportedInterfaces = getSupportedInterfaces;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,sBAAsB,GAAGF,OAAO,CAACG,yBAAyB,GAAGH,OAAO,CAACI,qBAAqB,GAAG,KAAK,CAAC;AAC3G,MAAMC,YAAY,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AACjD,MAAMC,KAAK,GAAG;EACV,CAAC,yCAAyC,GAAG,0BAA0B;EACvE,CAAC,yCAAyC,GAAG,6BAA6B;EAC1E,CAAC,yCAAyC,GAAG,0BAA0B;EACvE,CAAC,yCAAyC,GAAG;AACjD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAASH,qBAAqB,CAACI,GAAG,EAAE;EAChC,IAAIC,EAAE,GAAGF,KAAK,CAACC,GAAG,CAAC;EACnB,IAAIC,EAAE,EAAE;IACJ,OAAOA,EAAE;EACb,CAAC,MACI;IACD,OAAO,IAAI;EACf;AACJ;AACAT,OAAO,CAACI,qBAAqB,GAAGA,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,eAAeD,yBAAyB,CAACK,GAAG,EAAEE,MAAM,EAAE;EAClD;EACA,IAAIC,GAAG,GAAG,MAAMD,MAAM,CAACE,sBAAsB,CAACJ,GAAG,EAAE,sBAAsB,CAAC;EAC1E;EACA,IAAIG,GAAG,CAACE,SAAS,KAAK,CAAC,IAAIF,GAAG,CAACE,SAAS,KAAK,CAAC,EAAE;IAC5C,OAAO,EAAE;EACb;EACA,IAAI;IACA,IAAIC,KAAK,GAAG,IAAIT,YAAY,CAACU,UAAU,CAACJ,GAAG,CAACK,KAAK,CAAC;IAClD;IACA,IAAIC,WAAW,GAAGH,KAAK,CAACI,aAAa,EAAE,CAACC,QAAQ,EAAE;IAClD,IAAIF,WAAW,KAAK,yCAAyC,EAAE;MAC3D,OAAO,EAAE;IACb;IACA;IACA,IAAIG,UAAU,GAAG,EAAE;IACnB,OAAON,KAAK,CAACO,SAAS,GAAG,CAAC,EAAE;MACxBD,UAAU,CAACE,IAAI,CAACR,KAAK,CAACI,aAAa,EAAE,CAACC,QAAQ,EAAE,CAAC;IACrD;IACA,OAAOC,UAAU;EACrB,CAAC,CACD,OAAOG,CAAC,EAAE;IACN;IACAC,OAAO,CAACC,IAAI,CAACF,CAAC,CAAC;IACf,OAAO,EAAE;EACb;AACJ;AACAvB,OAAO,CAACG,yBAAyB,GAAGA,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,eAAeD,sBAAsB,CAACM,GAAG,EAAEE,MAAM,EAAE;EAC/C,IAAIgB,YAAY,GAAG,MAAMvB,yBAAyB,CAACK,GAAG,EAAEE,MAAM,CAAC;EAC/D,OAAOgB,YAAY,CAACC,GAAG,CAAEC,CAAC,IAAK;IAC3B,IAAIC,CAAC,GAAGzB,qBAAqB,CAACwB,CAAC,CAAC;IAChC,IAAIC,CAAC,EAAE;MACH,OAAO;QAAEC,IAAI,EAAE,OAAO;QAAEC,IAAI,EAAEF;MAAE,CAAC;IACrC,CAAC,MACI;MACD,OAAO;QAAEC,IAAI,EAAE,SAAS;QAAE7B,KAAK,EAAE2B;MAAE,CAAC;IACxC;EACJ,CAAC,CAAC;AACN;AACA5B,OAAO,CAACE,sBAAsB,GAAGA,sBAAsB"},"metadata":{},"sourceType":"script"}