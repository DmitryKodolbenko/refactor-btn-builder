{"ast":null,"code":"/**\n * Storage for storing block numbers that we have already processed.\n * Used by `BlockSubscription`.\n *\n * Dumb in-memory implementation.\n */\nclass InMemoryBlockStorage {\n  /**\n   * @param logFunction?   {(text: string) => void}\n   */\n  constructor(logFunction) {\n    this.masterchainBlocks = {}; // mcBlockNumber {number} -> isProcessed {boolean}\n    this.shardchainBlocks = {}; // workchain {number} + shardId {string} + shardBlockNumber {number} -> isProcessed {boolean}\n    this.logFunction = logFunction;\n  }\n\n  /**\n   * @private\n   * Insert new UNprocessed shardchain block numbers\n   * Block number (workchain + shardId + shardBlockNumber) should be IGNORED if it is already in the storage\n   * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n   */\n  async insertShardBlocks(shardBlockNumbers) {\n    for (const {\n      workchain,\n      shardId,\n      shardBlockNumber\n    } of shardBlockNumbers) {\n      if (this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] !== undefined) continue;\n      if (this.logFunction) {\n        this.logFunction('insert shard ' + workchain + ' ' + shardId + ' ' + shardBlockNumber);\n      }\n      // INSERT INTO shardchainBlocks VALUES (workchain, shardId, shardBlockNumber, FALSE);\n      this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] = false;\n    }\n  }\n\n  /**\n   * Insert new processed masterchain block number & new UNprocessed shardchains blocks numbers\n   * Must be in single DB transaction\n   * @param   mcBlockNumber {number}\n   * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n   */\n  async insertBlocks(mcBlockNumber, shardBlockNumbers) {\n    if (this.logFunction) {\n      this.logFunction('mc processed ' + mcBlockNumber);\n    }\n    // INSERT INTO masterchainBlocks VALUES (blockNumber, TRUE);\n    if (this.masterchainBlocks[mcBlockNumber] !== undefined) throw new Error('mc already exists ' + mcBlockNumber);\n    this.masterchainBlocks[mcBlockNumber] = true;\n    await this.insertShardBlocks(shardBlockNumbers);\n  }\n\n  /**\n   * Get last processed masterchain block number\n   * @return {Promise<number | undefined>}\n   */\n  async getLastMasterchainBlockNumber() {\n    // SELECT MAX(blockNumber) FROM masterchainBlocks\n    const blockNumbers = Object.keys(this.masterchainBlocks).map(x => Number(x)).sort((a, b) => b - a);\n    return blockNumbers[0];\n  }\n\n  /**\n   * Set that this shardchain block number processed & insert new UNprocessed shardchains blocks numbers\n   * Must be in single DB transaction\n   * @param   workchain {number}\n   * @param   shardId {string}\n   * @param   shardBlockNumber    {number}\n   * @param   prevShardBlocks    {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n   */\n  async setBlockProcessed(workchain, shardId, shardBlockNumber, prevShardBlocks) {\n    if (this.logFunction) {\n      this.logFunction('shard processed ' + workchain + ' ' + shardId + ' ' + shardBlockNumber);\n    }\n    // UPDATE shardchainBlocks SET processed = TRUE WHERE workchain = ? AND shardId = ? AND shardBlockNumber = ?\n    if (this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] === undefined) throw new Error('shard not exists ' + workchain + '_' + shardId + '_' + shardBlockNumber);\n    this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] = true;\n    await this.insertShardBlocks(prevShardBlocks);\n  }\n\n  /**\n   * Get any unprocesed shard block number (order is not important)\n   * @return {Promise<{workchain: number, shardId: string, shardBlockNumber: number}>}\n   */\n  async getUnprocessedShardBlock() {\n    // SELECT workchain, shardId, shardBlockNumber from sharchainBlocks WHERE processed = FALSE LIMIT 1\n    for (let key in this.shardchainBlocks) {\n      if (this.shardchainBlocks[key] === false) {\n        const arr = key.split('_');\n        return {\n          workchain: Number(arr[0]),\n          shardId: arr[1],\n          shardBlockNumber: Number(arr[2])\n        };\n      }\n    }\n    return undefined;\n  }\n}\nmodule.exports = {\n  InMemoryBlockStorage\n};","map":{"version":3,"names":["InMemoryBlockStorage","constructor","logFunction","masterchainBlocks","shardchainBlocks","insertShardBlocks","shardBlockNumbers","workchain","shardId","shardBlockNumber","undefined","insertBlocks","mcBlockNumber","Error","getLastMasterchainBlockNumber","blockNumbers","Object","keys","map","x","Number","sort","a","b","setBlockProcessed","prevShardBlocks","getUnprocessedShardBlock","key","arr","split","module","exports"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/tonweb/src/providers/blockSubscription/InMemoryBlockStorage.js"],"sourcesContent":["/**\n * Storage for storing block numbers that we have already processed.\n * Used by `BlockSubscription`.\n *\n * Dumb in-memory implementation.\n */\nclass InMemoryBlockStorage {\n\n    /**\n     * @param logFunction?   {(text: string) => void}\n     */\n    constructor(logFunction) {\n        this.masterchainBlocks = {}; // mcBlockNumber {number} -> isProcessed {boolean}\n        this.shardchainBlocks = {}; // workchain {number} + shardId {string} + shardBlockNumber {number} -> isProcessed {boolean}\n        this.logFunction = logFunction;\n    }\n\n    /**\n     * @private\n     * Insert new UNprocessed shardchain block numbers\n     * Block number (workchain + shardId + shardBlockNumber) should be IGNORED if it is already in the storage\n     * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n     */\n    async insertShardBlocks(shardBlockNumbers) {\n        for (const {workchain, shardId, shardBlockNumber} of shardBlockNumbers) {\n            if (this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] !== undefined) continue;\n            if (this.logFunction) {\n                this.logFunction('insert shard ' + workchain + ' ' + shardId + ' ' + shardBlockNumber);\n            }\n            // INSERT INTO shardchainBlocks VALUES (workchain, shardId, shardBlockNumber, FALSE);\n            this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] = false;\n        }\n    }\n\n    /**\n     * Insert new processed masterchain block number & new UNprocessed shardchains blocks numbers\n     * Must be in single DB transaction\n     * @param   mcBlockNumber {number}\n     * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n     */\n    async insertBlocks(mcBlockNumber, shardBlockNumbers) {\n        if (this.logFunction) {\n            this.logFunction('mc processed ' + mcBlockNumber);\n        }\n        // INSERT INTO masterchainBlocks VALUES (blockNumber, TRUE);\n        if (this.masterchainBlocks[mcBlockNumber] !== undefined) throw new Error('mc already exists ' + mcBlockNumber);\n        this.masterchainBlocks[mcBlockNumber] = true;\n\n        await this.insertShardBlocks(shardBlockNumbers);\n    }\n\n    /**\n     * Get last processed masterchain block number\n     * @return {Promise<number | undefined>}\n     */\n    async getLastMasterchainBlockNumber() {\n        // SELECT MAX(blockNumber) FROM masterchainBlocks\n        const blockNumbers = Object.keys(this.masterchainBlocks)\n            .map(x => Number(x))\n            .sort((a, b) => b - a);\n        return blockNumbers[0];\n    }\n\n    /**\n     * Set that this shardchain block number processed & insert new UNprocessed shardchains blocks numbers\n     * Must be in single DB transaction\n     * @param   workchain {number}\n     * @param   shardId {string}\n     * @param   shardBlockNumber    {number}\n     * @param   prevShardBlocks    {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n     */\n    async setBlockProcessed(workchain, shardId, shardBlockNumber, prevShardBlocks) {\n        if (this.logFunction) {\n            this.logFunction('shard processed ' + workchain + ' ' + shardId + ' ' + shardBlockNumber);\n        }\n        // UPDATE shardchainBlocks SET processed = TRUE WHERE workchain = ? AND shardId = ? AND shardBlockNumber = ?\n        if (this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] === undefined) throw new Error('shard not exists ' + workchain + '_' + shardId + '_' + shardBlockNumber);\n        this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] = true;\n\n        await this.insertShardBlocks(prevShardBlocks);\n    }\n\n    /**\n     * Get any unprocesed shard block number (order is not important)\n     * @return {Promise<{workchain: number, shardId: string, shardBlockNumber: number}>}\n     */\n    async getUnprocessedShardBlock() {\n        // SELECT workchain, shardId, shardBlockNumber from sharchainBlocks WHERE processed = FALSE LIMIT 1\n        for (let key in this.shardchainBlocks) {\n            if (this.shardchainBlocks[key] === false) {\n                const arr = key.split('_');\n                return {\n                    workchain: Number(arr[0]),\n                    shardId: arr[1],\n                    shardBlockNumber: Number(arr[2]),\n                }\n            }\n        }\n        return undefined;\n    }\n\n}\n\nmodule.exports = {InMemoryBlockStorage};"],"mappings":"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"},"metadata":{},"sourceType":"script"}