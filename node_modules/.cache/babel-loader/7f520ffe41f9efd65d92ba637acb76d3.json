{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;\n/* eslint-disable no-bitwise */\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\nvar uint64MaxValue = new bn_js_1.default(\"18446744073709551615\", 10, \"be\");\nvar Uint32 = /*#__PURE__*/function () {\n  function Uint32(input) {\n    _classCallCheck(this, Uint32);\n    if (Number.isNaN(input)) {\n      throw new Error(\"Input is not a number\");\n    }\n    if (!Number.isInteger(input)) {\n      throw new Error(\"Input is not an integer\");\n    }\n    if (input < 0 || input > 4294967295) {\n      throw new Error(\"Input not in uint32 range: \" + input.toString());\n    }\n    this.data = input;\n  }\n  /** @deprecated use Uint32.fromBytes */\n  _createClass(Uint32, [{\n    key: \"toBytesBigEndian\",\n    value: function toBytesBigEndian() {\n      // Use division instead of shifting since bitwise operators are defined\n      // on SIGNED int32 in JavaScript and we don't want to risk surprises\n      return new Uint8Array([Math.floor(this.data / Math.pow(2, 24)) & 0xff, Math.floor(this.data / Math.pow(2, 16)) & 0xff, Math.floor(this.data / Math.pow(2, 8)) & 0xff, Math.floor(this.data / Math.pow(2, 0)) & 0xff]);\n    }\n  }, {\n    key: \"toBytesLittleEndian\",\n    value: function toBytesLittleEndian() {\n      // Use division instead of shifting since bitwise operators are defined\n      // on SIGNED int32 in JavaScript and we don't want to risk surprises\n      return new Uint8Array([Math.floor(this.data / Math.pow(2, 0)) & 0xff, Math.floor(this.data / Math.pow(2, 8)) & 0xff, Math.floor(this.data / Math.pow(2, 16)) & 0xff, Math.floor(this.data / Math.pow(2, 24)) & 0xff]);\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString();\n    }\n  }], [{\n    key: \"fromBigEndianBytes\",\n    value: function fromBigEndianBytes(bytes) {\n      return Uint32.fromBytes(bytes);\n    }\n    /**\n     * Creates a Uint32 from a fixed length byte array.\n     *\n     * @param bytes a list of exactly 4 bytes\n     * @param endianess defaults to big endian\n     */\n  }, {\n    key: \"fromBytes\",\n    value: function fromBytes(bytes) {\n      var endianess = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"be\";\n      if (bytes.length !== 4) {\n        throw new Error(\"Invalid input length. Expected 4 bytes.\");\n      }\n      for (var i = 0; i < bytes.length; ++i) {\n        if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n          throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n        }\n      }\n      var beBytes = endianess === \"be\" ? bytes : Array.from(bytes).reverse();\n      // Use mulitiplication instead of shifting since bitwise operators are defined\n      // on SIGNED int32 in JavaScript and we don't want to risk surprises\n      return new Uint32(beBytes[0] * Math.pow(2, 24) + beBytes[1] * Math.pow(2, 16) + beBytes[2] * Math.pow(2, 8) + beBytes[3]);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(str) {\n      if (!str.match(/^[0-9]+$/)) {\n        throw new Error(\"Invalid string format\");\n      }\n      return new Uint32(Number.parseInt(str, 10));\n    }\n  }]);\n  return Uint32;\n}();\nexports.Uint32 = Uint32;\nvar Int53 = /*#__PURE__*/function () {\n  function Int53(input) {\n    _classCallCheck(this, Int53);\n    if (Number.isNaN(input)) {\n      throw new Error(\"Input is not a number\");\n    }\n    if (!Number.isInteger(input)) {\n      throw new Error(\"Input is not an integer\");\n    }\n    if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {\n      throw new Error(\"Input not in int53 range: \" + input.toString());\n    }\n    this.data = input;\n  }\n  _createClass(Int53, [{\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString();\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(str) {\n      if (!str.match(/^-?[0-9]+$/)) {\n        throw new Error(\"Invalid string format\");\n      }\n      return new Int53(Number.parseInt(str, 10));\n    }\n  }]);\n  return Int53;\n}();\nexports.Int53 = Int53;\nvar Uint53 = /*#__PURE__*/function () {\n  function Uint53(input) {\n    _classCallCheck(this, Uint53);\n    var signed = new Int53(input);\n    if (signed.toNumber() < 0) {\n      throw new Error(\"Input is negative\");\n    }\n    this.data = signed;\n  }\n  _createClass(Uint53, [{\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data.toNumber();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString();\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(str) {\n      var signed = Int53.fromString(str);\n      return new Uint53(signed.toNumber());\n    }\n  }]);\n  return Uint53;\n}();\nexports.Uint53 = Uint53;\nvar Uint64 = /*#__PURE__*/function () {\n  function Uint64(data) {\n    _classCallCheck(this, Uint64);\n    if (data.isNeg()) {\n      throw new Error(\"Input is negative\");\n    }\n    if (data.gt(uint64MaxValue)) {\n      throw new Error(\"Input exceeds uint64 range\");\n    }\n    this.data = data;\n  }\n  /** @deprecated use Uint64.fromBytes */\n  _createClass(Uint64, [{\n    key: \"toBytesBigEndian\",\n    value: function toBytesBigEndian() {\n      return Uint8Array.from(this.data.toArray(\"be\", 8));\n    }\n  }, {\n    key: \"toBytesLittleEndian\",\n    value: function toBytesLittleEndian() {\n      return Uint8Array.from(this.data.toArray(\"le\", 8));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString(10);\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data.toNumber();\n    }\n  }], [{\n    key: \"fromBytesBigEndian\",\n    value: function fromBytesBigEndian(bytes) {\n      return Uint64.fromBytes(bytes);\n    }\n    /**\n     * Creates a Uint64 from a fixed length byte array.\n     *\n     * @param bytes a list of exactly 8 bytes\n     * @param endianess defaults to big endian\n     */\n  }, {\n    key: \"fromBytes\",\n    value: function fromBytes(bytes) {\n      var endianess = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"be\";\n      if (bytes.length !== 8) {\n        throw new Error(\"Invalid input length. Expected 8 bytes.\");\n      }\n      for (var i = 0; i < bytes.length; ++i) {\n        if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n          throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n        }\n      }\n      var beBytes = endianess === \"be\" ? Array.from(bytes) : Array.from(bytes).reverse();\n      return new Uint64(new bn_js_1.default(beBytes));\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(str) {\n      if (!str.match(/^[0-9]+$/)) {\n        throw new Error(\"Invalid string format\");\n      }\n      return new Uint64(new bn_js_1.default(str, 10, \"be\"));\n    }\n  }, {\n    key: \"fromNumber\",\n    value: function fromNumber(input) {\n      if (Number.isNaN(input)) {\n        throw new Error(\"Input is not a number\");\n      }\n      if (!Number.isInteger(input)) {\n        throw new Error(\"Input is not an integer\");\n      }\n      var bigint;\n      try {\n        bigint = new bn_js_1.default(input);\n      } catch (_a) {\n        throw new Error(\"Input is not a safe integer\");\n      }\n      return new Uint64(bigint);\n    }\n  }]);\n  return Uint64;\n}();\nexports.Uint64 = Uint64;\n// Assign classes to unused variables in order to verify static interface conformance at compile time.\n// Workaround for https://github.com/microsoft/TypeScript/issues/33892\nvar _int53Class = Int53;\nvar _uint53Class = Uint53;\nvar _uint32Class = Uint32;\nvar _uint64Class = Uint64;","map":{"version":3,"sources":["../src/integers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;\n/* eslint-disable no-bitwise */\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst uint64MaxValue = new bn_js_1.default(\"18446744073709551615\", 10, \"be\");\nclass Uint32 {\n    constructor(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        if (input < 0 || input > 4294967295) {\n            throw new Error(\"Input not in uint32 range: \" + input.toString());\n        }\n        this.data = input;\n    }\n    /** @deprecated use Uint32.fromBytes */\n    static fromBigEndianBytes(bytes) {\n        return Uint32.fromBytes(bytes);\n    }\n    /**\n     * Creates a Uint32 from a fixed length byte array.\n     *\n     * @param bytes a list of exactly 4 bytes\n     * @param endianess defaults to big endian\n     */\n    static fromBytes(bytes, endianess = \"be\") {\n        if (bytes.length !== 4) {\n            throw new Error(\"Invalid input length. Expected 4 bytes.\");\n        }\n        for (let i = 0; i < bytes.length; ++i) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n                throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n            }\n        }\n        const beBytes = endianess === \"be\" ? bytes : Array.from(bytes).reverse();\n        // Use mulitiplication instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 2 ** 8 + beBytes[3]);\n    }\n    static fromString(str) {\n        if (!str.match(/^[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Uint32(Number.parseInt(str, 10));\n    }\n    toBytesBigEndian() {\n        // Use division instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint8Array([\n            Math.floor(this.data / 2 ** 24) & 0xff,\n            Math.floor(this.data / 2 ** 16) & 0xff,\n            Math.floor(this.data / 2 ** 8) & 0xff,\n            Math.floor(this.data / 2 ** 0) & 0xff,\n        ]);\n    }\n    toBytesLittleEndian() {\n        // Use division instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint8Array([\n            Math.floor(this.data / 2 ** 0) & 0xff,\n            Math.floor(this.data / 2 ** 8) & 0xff,\n            Math.floor(this.data / 2 ** 16) & 0xff,\n            Math.floor(this.data / 2 ** 24) & 0xff,\n        ]);\n    }\n    toNumber() {\n        return this.data;\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Uint32 = Uint32;\nclass Int53 {\n    constructor(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\"Input not in int53 range: \" + input.toString());\n        }\n        this.data = input;\n    }\n    static fromString(str) {\n        if (!str.match(/^-?[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Int53(Number.parseInt(str, 10));\n    }\n    toNumber() {\n        return this.data;\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Int53 = Int53;\nclass Uint53 {\n    constructor(input) {\n        const signed = new Int53(input);\n        if (signed.toNumber() < 0) {\n            throw new Error(\"Input is negative\");\n        }\n        this.data = signed;\n    }\n    static fromString(str) {\n        const signed = Int53.fromString(str);\n        return new Uint53(signed.toNumber());\n    }\n    toNumber() {\n        return this.data.toNumber();\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Uint53 = Uint53;\nclass Uint64 {\n    constructor(data) {\n        if (data.isNeg()) {\n            throw new Error(\"Input is negative\");\n        }\n        if (data.gt(uint64MaxValue)) {\n            throw new Error(\"Input exceeds uint64 range\");\n        }\n        this.data = data;\n    }\n    /** @deprecated use Uint64.fromBytes */\n    static fromBytesBigEndian(bytes) {\n        return Uint64.fromBytes(bytes);\n    }\n    /**\n     * Creates a Uint64 from a fixed length byte array.\n     *\n     * @param bytes a list of exactly 8 bytes\n     * @param endianess defaults to big endian\n     */\n    static fromBytes(bytes, endianess = \"be\") {\n        if (bytes.length !== 8) {\n            throw new Error(\"Invalid input length. Expected 8 bytes.\");\n        }\n        for (let i = 0; i < bytes.length; ++i) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n                throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n            }\n        }\n        const beBytes = endianess === \"be\" ? Array.from(bytes) : Array.from(bytes).reverse();\n        return new Uint64(new bn_js_1.default(beBytes));\n    }\n    static fromString(str) {\n        if (!str.match(/^[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Uint64(new bn_js_1.default(str, 10, \"be\"));\n    }\n    static fromNumber(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        let bigint;\n        try {\n            bigint = new bn_js_1.default(input);\n        }\n        catch (_a) {\n            throw new Error(\"Input is not a safe integer\");\n        }\n        return new Uint64(bigint);\n    }\n    toBytesBigEndian() {\n        return Uint8Array.from(this.data.toArray(\"be\", 8));\n    }\n    toBytesLittleEndian() {\n        return Uint8Array.from(this.data.toArray(\"le\", 8));\n    }\n    toString() {\n        return this.data.toString(10);\n    }\n    toNumber() {\n        return this.data.toNumber();\n    }\n}\nexports.Uint64 = Uint64;\n// Assign classes to unused variables in order to verify static interface conformance at compile time.\n// Workaround for https://github.com/microsoft/TypeScript/issues/33892\nconst _int53Class = Int53;\nconst _uint53Class = Uint53;\nconst _uint32Class = Uint32;\nconst _uint64Class = Uint64;\n//# sourceMappingURL=integers.js.map"]},"metadata":{},"sourceType":"script"}