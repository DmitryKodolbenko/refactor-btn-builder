{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport * as A from './Array';\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport * as RR from './ReadonlyRecord';\nimport * as Se from './Semigroup';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n/**\n * Calculate the number of key/value pairs in a `Record`.\n *\n * @example\n * import { size } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.0.0\n */\nexport var size = RR.size;\n/**\n * Test whether a `Record` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n *\n * @since 2.0.0\n */\nexport var isEmpty = RR.isEmpty;\nvar keys_ = function keys_(O) {\n  return function (r) {\n    return Object.keys(r).sort(O.compare);\n  };\n};\n/**\n * The keys of a `Record`, sorted alphabetically.\n *\n * @example\n * import { keys } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(keys({ c: 1, a: 2, b: 3 }), [\"a\", \"b\", \"c\"]);\n *\n * @since 2.0.0\n */\nexport var keys = /*#__PURE__*/keys_(S.Ord);\nexport function collect(O) {\n  if (typeof O === 'function') {\n    return collect(S.Ord)(O);\n  }\n  var keysO = keys_(O);\n  return function (f) {\n    return function (r) {\n      var out = [];\n      for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n        var key = _a[_i];\n        out.push(f(key, r[key]));\n      }\n      return out;\n    };\n  };\n}\n/**\n * Get a sorted `Array` of the key/value pairs contained in a `Record`.\n * Sorted alphabetically by key.\n *\n * @example\n * import { toArray } from 'fp-ts/Record'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toArray = /*#__PURE__*/collect(S.Ord)(function (k, a) {\n  return [k, a];\n});\nexport function toUnfoldable(U) {\n  return function (r) {\n    var sas = toArray(r);\n    var len = sas.length;\n    return U.unfold(0, function (b) {\n      return b < len ? _.some([sas[b], b + 1]) : _.none;\n    });\n  };\n}\n/**\n * Insert or replace a key/value pair in a `Record`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = RR.upsertAt;\n/**\n * Test whether or not a key exists in a `Record`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = RR.has;\nexport function deleteAt(k) {\n  return function (r) {\n    if (!_.has.call(r, k)) {\n      return r;\n    }\n    var out = Object.assign({}, r);\n    delete out[k];\n    return out;\n  };\n}\n/**\n * Replace a key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var updateAt = function updateAt(k, a) {\n  return modifyAt(k, function () {\n    return a;\n  });\n};\n/**\n * Applies a mapping function to one spcific key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var modifyAt = function modifyAt(k, f) {\n  return function (r) {\n    if (!has(k, r)) {\n      return _.none;\n    }\n    var out = Object.assign({}, r);\n    out[k] = f(r[k]);\n    return _.some(out);\n  };\n};\nexport function pop(k) {\n  var deleteAtk = deleteAt(k);\n  return function (r) {\n    var oa = lookup(k, r);\n    return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n  };\n}\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether one `Record` contains all of the keys and values\n * contained in another `Record`.\n *\n * @example\n * import { isSubrecord } from 'fp-ts/Record'\n * import { string } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"not-bar\", c: \"baz\" }),\n *   false\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   false\n * );\n *\n * @since 2.0.0\n */\nexport var isSubrecord = RR.isSubrecord;\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing the value,\n * otherwise it returns `None`\n *\n * @example\n * import { lookup } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(lookup(\"b\")({ a: \"foo\", b: \"bar\" }), option.some(\"bar\"));\n * assert.deepStrictEqual(lookup(\"c\")({ a: \"foo\", b: \"bar\" }), option.none);\n *\n * @since 2.0.0\n */\nexport var lookup = RR.lookup;\n/**\n * Map a `Record` passing the key/value pairs to the iterating function.\n *\n * @example\n * import { mapWithIndex } from \"fp-ts/Record\";\n *\n * const f = (k: string, n: number) => `${k.toUpperCase()}-${n}`;\n * assert.deepStrictEqual(mapWithIndex(f)({ a: 3, b: 5 }), { a: \"A-3\", b: \"B-5\" });\n *\n * @since 2.0.0\n */\nexport var mapWithIndex = RR.mapWithIndex;\n/**\n * Map a `Record` passing the values to the iterating function.\n *\n * @example\n * import { map } from \"fp-ts/Record\";\n *\n * const f = (n: number) => `-${n}-`;\n * assert.deepStrictEqual(map(f)({ a: 3, b: 5 }), { a: \"-3-\", b: \"-5-\" });\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = RR.map;\nexport function reduceWithIndex() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  return args.length === 1 ? RR.reduceWithIndex(args[0]) : RR.reduceWithIndex(S.Ord).apply(void 0, args);\n}\nexport function foldMapWithIndex(O) {\n  return 'compare' in O ? RR.foldMapWithIndex(O) : RR.foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  return args.length === 1 ? RR.reduceRightWithIndex(args[0]) : RR.reduceRightWithIndex(S.Ord).apply(void 0, args);\n}\n/**\n * Create a `Record` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @since 2.0.0\n */\nexport var singleton = RR.singleton;\nexport function traverseWithIndex(F) {\n  return RR.traverseWithIndex(F);\n}\nexport function traverse(F) {\n  return RR.traverse(F);\n}\nexport function sequence(F) {\n  return RR.sequence(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function wither(F) {\n  var traverseF = traverse(F);\n  return function (f) {\n    return function (fa) {\n      return F.map(pipe(fa, traverseF(f)), compact);\n    };\n  };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function wilt(F) {\n  var traverseF = traverse(F);\n  return function (f) {\n    return function (fa) {\n      return F.map(pipe(fa, traverseF(f)), separate);\n    };\n  };\n};\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMapWithIndex } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (key: string, a: number) =>\n *   a >= 0 ? either.right(`${key} is >= 0 (${a})`) : either.left(`${key} is < 0 (${a})`);\n * assert.deepStrictEqual(partitionMapWithIndex(f)({ a: -1, b: 2, c: 123 }), {\n *   left: {\n *     a: \"a is < 0 (-1)\",\n *   },\n *   right: {\n *     b: \"b is >= 0 (2)\",\n *     c: \"c is >= 0 (123)\",\n *   },\n * });\n *\n * @since 2.0.0\n */\nexport var partitionMapWithIndex = RR.partitionMapWithIndex;\nexport function partitionWithIndex(predicateWithIndex) {\n  return RR.partitionWithIndex(predicateWithIndex);\n}\n/**\n * Maps a `Record` with an iterating function that takes key and value and\n * returns an `Option`, keeping only the `Some` values and discarding `None`s.\n *\n * @example\n * import { filterMapWithIndex } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (key: string, a: number) => (a >= 0 ? option.some(`${key}${a}`) : option.none);\n * assert.deepStrictEqual(filterMapWithIndex(f)({ a: -1, b: 2, c: 3 }), {\n *   b: \"b2\",\n *   c: \"c3\",\n * });\n *\n * @since 2.0.0\n */\nexport var filterMapWithIndex = RR.filterMapWithIndex;\nexport function filterWithIndex(predicateWithIndex) {\n  return RR.filterWithIndex(predicateWithIndex);\n}\nexport function fromFoldable(M, F) {\n  return RR.fromFoldable(M, F);\n}\n/**\n * Alias of [`toArray`](#toArray).\n *\n * @example\n * import { toEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var toEntries = toArray;\n/**\n * Converts an `Array` of `[key, value]` tuples into a `Record`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function fromEntries(fa) {\n  return fromFoldable(Se.last(), A.Foldable)(fa);\n};\nexport function fromFoldableMap(M, F) {\n  return RR.fromFoldableMap(M, F);\n}\n/**\n * Test if every value in a `Record` satisfies the predicate.\n *\n * @example\n * import { every } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);\n *\n * @since 2.0.0\n */\nexport var every = RR.every;\n/**\n * Test if at least one value in a `Record` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.0.0\n */\nexport var some = RR.some;\n// TODO: remove non-curried overloading in v3\n/**\n * Given an `Eq` checks if a `Record` contains an entry with\n * value equal to a provided value.\n *\n * @example\n * import { elem } from \"fp-ts/Record\"\n * import { number } from \"fp-ts\"\n *\n * assert.deepStrictEqual(elem(number.Eq)(123, { foo: 123, bar: 234 }), true);\n * assert.deepStrictEqual(elem(number.Eq)(-7, { foo: 123, bar: 234 }), false);\n *\n * @since 2.0.0\n */\nexport var elem = RR.elem;\n/**\n * Union of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function union(M) {\n  var unionM = RR.union(M);\n  return function (second) {\n    return function (first) {\n      if (isEmpty(first)) {\n        return __assign({}, second);\n      }\n      if (isEmpty(second)) {\n        return __assign({}, first);\n      }\n      return unionM(second)(first);\n    };\n  };\n};\n/**\n * Intersection of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function intersection(M) {\n  return function (second) {\n    return function (first) {\n      if (isEmpty(first) || isEmpty(second)) {\n        return {};\n      }\n      return RR.intersection(M)(second)(first);\n    };\n  };\n};\n/**\n * Difference between two `Record`s.\n * Takes two `Record`s and produces a `Record` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function difference(second) {\n  return function (first) {\n    if (isEmpty(first)) {\n      return __assign({}, second);\n    }\n    if (isEmpty(second)) {\n      return __assign({}, first);\n    }\n    return RR.difference(second)(first);\n  };\n};\nvar _map = RR._map;\nvar _mapWithIndex = RR._mapWithIndex;\nvar _reduce = RR._reduce;\nvar _foldMap = RR._foldMap;\nvar _reduceRight = RR._reduceRight;\nvar _filter = RR._filter;\nvar _filterMap = RR._filterMap;\nvar _partition = RR._partition;\nvar _partitionMap = RR._partitionMap;\nvar _reduceWithIndex = RR._reduceWithIndex;\nvar _foldMapWithIndex = RR._foldMapWithIndex;\nvar _reduceRightWithIndex = RR._reduceRightWithIndex;\nvar _partitionMapWithIndex = RR._partitionMapWithIndex;\nvar _partitionWithIndex = RR._partitionWithIndex;\nvar _filterMapWithIndex = RR._filterMapWithIndex;\nvar _filterWithIndex = RR._filterWithIndex;\nvar _traverse = RR._traverse;\nvar _sequence = RR._sequence;\nvar _traverseWithIndex = function _traverseWithIndex(O) {\n  return function (F) {\n    var keysO = keys_(O);\n    return function (ta, f) {\n      var ks = keysO(ta);\n      if (ks.length === 0) {\n        return F.of({});\n      }\n      var fr = F.of({});\n      var _loop_1 = function _loop_1(key) {\n        fr = F.ap(F.map(fr, function (r) {\n          return function (b) {\n            r[key] = b;\n            return r;\n          };\n        }), f(key, ta[key]));\n      };\n      for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n        var key = ks_1[_i];\n        _loop_1(key);\n      }\n      return fr;\n    };\n  };\n};\n/**\n * Given a `Predicate`, it produces a new `Record` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = RR.filter;\n/**\n * Maps a `Record` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = RR.filterMap;\n/**\n * Partition a `Record` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = RR.partition;\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = RR.partitionMap;\nexport function reduce() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  return args.length === 1 ? RR.reduce(args[0]) : RR.reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n  return 'compare' in O ? RR.foldMap(O) : RR.foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  return args.length === 1 ? RR.reduceRight(args[0]) : RR.reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `Record` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = RR.compact;\n/**\n * Separate a `Record` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/Record'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = RR.separate;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Record';\nexport function getShow(O) {\n  return 'compare' in O ? RR.getShow(O) : RR.getShow(S.Ord)(O);\n}\n/**\n * Given an `Eq` for the base type, it produces an `Eq`\n * for a `Record` of that base type.\n *\n * @example\n * import { getEq } from \"fp-ts/Record\";\n * import { string } from \"fp-ts\";\n * import { Eq } from \"fp-ts/Eq\";\n *\n * const eq: Eq<Record<string, string>> = getEq(string.Eq);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { b: \"bar\" }), false);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { a: \"foo\" }), true);\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RR.getEq;\n/**\n * Returns a `Monoid` instance for `Record`s, given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s comining the\n * overlapping entries with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getMonoid } from 'fp-ts/Record'\n *\n * const M = getMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = RR.getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n  URI: URI,\n  map: _map\n};\n/**\n * Takes a value and a `Record` of functions and returns a\n * `Record` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/Record\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n  URI: URI,\n  map: _map,\n  mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function getFoldable(O) {\n  return {\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n  };\n};\n/**\n * Produces a `FoldableWithIndex1` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function getFoldableWithIndex(O) {\n  return {\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n  };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n  URI: URI,\n  compact: compact,\n  separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n  URI: URI,\n  map: _map,\n  compact: compact,\n  separate: separate,\n  filter: _filter,\n  filterMap: _filterMap,\n  partition: _partition,\n  partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n  URI: URI,\n  map: _map,\n  mapWithIndex: _mapWithIndex,\n  compact: compact,\n  separate: separate,\n  filter: _filter,\n  filterMap: _filterMap,\n  partition: _partition,\n  partitionMap: _partitionMap,\n  filterMapWithIndex: _filterMapWithIndex,\n  filterWithIndex: _filterWithIndex,\n  partitionMapWithIndex: _partitionMapWithIndex,\n  partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function getTraversable(O) {\n  return {\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n  };\n};\n/**\n * Produces a `TraversableWithIndex` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function getTraversableWithIndex(O) {\n  return {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n  };\n};\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function getWitherable(O) {\n  var T = getTraversable(O);\n  return {\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: T.traverse,\n    sequence: T.sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: witherDefault(T, Compactable),\n    wilt: wiltDefault(T, Compactable)\n  };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function getUnionSemigroup(S) {\n  var unionS = union(S);\n  return {\n    concat: function concat(first, second) {\n      return unionS(second)(first);\n    }\n  };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `Record`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/Record'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function getUnionMonoid(S) {\n  return {\n    concat: getUnionSemigroup(S).concat,\n    empty: {}\n  };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function getIntersectionSemigroup(S) {\n  var intersectionS = intersection(S);\n  return {\n    concat: function concat(first, second) {\n      return intersectionS(second)(first);\n    }\n  };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `Record`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference } from \"fp-ts/Record\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<Record<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function getDifferenceMagma() {\n  return {\n    concat: function concat(first, second) {\n      return difference(second)(first);\n    }\n  };\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n  URI: URI,\n  reduce: /*#__PURE__*/_reduce(S.Ord),\n  foldMap: /*#__PURE__*/_foldMap(S.Ord),\n  reduceRight: /*#__PURE__*/_reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n  URI: URI,\n  reduce: /*#__PURE__*/_reduce(S.Ord),\n  foldMap: /*#__PURE__*/_foldMap(S.Ord),\n  reduceRight: /*#__PURE__*/_reduceRight(S.Ord),\n  reduceWithIndex: /*#__PURE__*/_reduceWithIndex(S.Ord),\n  foldMapWithIndex: /*#__PURE__*/_foldMapWithIndex(S.Ord),\n  reduceRightWithIndex: /*#__PURE__*/_reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n  URI: URI,\n  map: _map,\n  reduce: /*#__PURE__*/_reduce(S.Ord),\n  foldMap: /*#__PURE__*/_foldMap(S.Ord),\n  reduceRight: /*#__PURE__*/_reduceRight(S.Ord),\n  traverse: /*#__PURE__*/_traverse(S.Ord),\n  sequence: sequence\n};\n/**\n * Use the `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n  URI: URI,\n  map: _map,\n  mapWithIndex: _mapWithIndex,\n  reduce: /*#__PURE__*/_reduce(S.Ord),\n  foldMap: /*#__PURE__*/_foldMap(S.Ord),\n  reduceRight: /*#__PURE__*/_reduceRight(S.Ord),\n  reduceWithIndex: /*#__PURE__*/_reduceWithIndex(S.Ord),\n  foldMapWithIndex: /*#__PURE__*/_foldMapWithIndex(S.Ord),\n  reduceRightWithIndex: /*#__PURE__*/_reduceRightWithIndex(S.Ord),\n  traverse: /*#__PURE__*/_traverse(S.Ord),\n  sequence: sequence,\n  traverseWithIndex: /*#__PURE__*/_traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n  URI: URI,\n  map: _map,\n  reduce: /*#__PURE__*/_reduce(S.Ord),\n  foldMap: /*#__PURE__*/_foldMap(S.Ord),\n  reduceRight: /*#__PURE__*/_reduceRight(S.Ord),\n  traverse: /*#__PURE__*/_traverse(S.Ord),\n  sequence: sequence,\n  compact: compact,\n  separate: separate,\n  filter: _filter,\n  filterMap: _filterMap,\n  partition: _partition,\n  partitionMap: _partitionMap,\n  wither: _wither,\n  wilt: _wilt\n};\n/**\n * Use a new `{}` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = {};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\n/**\n * Use [`has`](#has) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var hasOwnProperty = RR.hasOwnProperty;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `R.Functor` instead of `R.record`\n * (where `R` is from `import R from 'fp-ts/Record'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var record = {\n  URI: URI,\n  map: _map,\n  reduce: /*#__PURE__*/_reduce(S.Ord),\n  foldMap: /*#__PURE__*/_foldMap(S.Ord),\n  reduceRight: /*#__PURE__*/_reduceRight(S.Ord),\n  traverse: /*#__PURE__*/_traverse(S.Ord),\n  sequence: sequence,\n  compact: compact,\n  separate: separate,\n  filter: _filter,\n  filterMap: _filterMap,\n  partition: _partition,\n  partitionMap: _partitionMap,\n  mapWithIndex: _mapWithIndex,\n  reduceWithIndex: /*#__PURE__*/_reduceWithIndex(S.Ord),\n  foldMapWithIndex: /*#__PURE__*/_foldMapWithIndex(S.Ord),\n  reduceRightWithIndex: /*#__PURE__*/_reduceRightWithIndex(S.Ord),\n  filterMapWithIndex: _filterMapWithIndex,\n  filterWithIndex: _filterWithIndex,\n  partitionMapWithIndex: _partitionMapWithIndex,\n  partitionWithIndex: _partitionWithIndex,\n  traverseWithIndex: /*#__PURE__*/_traverseWithIndex(S.Ord),\n  wither: _wither,\n  wilt: _wilt\n};","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","A","pipe","flap","flap_","_","RR","Se","S","wiltDefault","witherDefault","size","isEmpty","keys_","O","r","keys","sort","compare","Ord","collect","keysO","f","out","_i","_a","key","push","toArray","k","a","toUnfoldable","U","sas","len","unfold","b","some","none","upsertAt","has","deleteAt","updateAt","modifyAt","pop","deleteAtk","oa","lookup","isNone","value","isSubrecord","mapWithIndex","map","reduceWithIndex","args","foldMapWithIndex","reduceRightWithIndex","singleton","traverseWithIndex","F","traverse","sequence","wither","traverseF","fa","compact","wilt","separate","partitionMapWithIndex","partitionWithIndex","predicateWithIndex","filterMapWithIndex","filterWithIndex","fromFoldable","M","toEntries","fromEntries","last","Foldable","fromFoldableMap","every","elem","union","unionM","second","first","intersection","difference","_map","_mapWithIndex","_reduce","_foldMap","_reduceRight","_filter","_filterMap","_partition","_partitionMap","_reduceWithIndex","_foldMapWithIndex","_reduceRightWithIndex","_partitionMapWithIndex","_partitionWithIndex","_filterMapWithIndex","_filterWithIndex","_traverse","_sequence","_traverseWithIndex","ta","ks","of","fr","_loop_1","ap","ks_1","filter","filterMap","partition","partitionMap","reduce","foldMap","reduceRight","URI","getShow","getEq","getMonoid","Functor","FunctorWithIndex","getFoldable","getFoldableWithIndex","Compactable","Filterable","FilterableWithIndex","getTraversable","getTraversableWithIndex","getWitherable","T","getUnionSemigroup","unionS","concat","getUnionMonoid","empty","getIntersectionSemigroup","intersectionS","getDifferenceMagma","FoldableWithIndex","Traversable","TraversableWithIndex","_wither","_wilt","Witherable","insertAt","record"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/fp-ts/es6/Record.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport * as A from './Array';\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport * as RR from './ReadonlyRecord';\nimport * as Se from './Semigroup';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n/**\n * Calculate the number of key/value pairs in a `Record`.\n *\n * @example\n * import { size } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.0.0\n */\nexport var size = RR.size;\n/**\n * Test whether a `Record` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n *\n * @since 2.0.0\n */\nexport var isEmpty = RR.isEmpty;\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * The keys of a `Record`, sorted alphabetically.\n *\n * @example\n * import { keys } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(keys({ c: 1, a: 2, b: 3 }), [\"a\", \"b\", \"c\"]);\n *\n * @since 2.0.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `Array` of the key/value pairs contained in a `Record`.\n * Sorted alphabetically by key.\n *\n * @example\n * import { toArray } from 'fp-ts/Record'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toArray = /*#__PURE__*/ collect(S.Ord)(function (k, a) { return [\n    k,\n    a\n]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `Record`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = RR.upsertAt;\n/**\n * Test whether or not a key exists in a `Record`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = RR.has;\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var updateAt = function (k, a) {\n    return modifyAt(k, function () { return a; });\n};\n/**\n * Applies a mapping function to one spcific key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var out = Object.assign({}, r);\n        out[k] = f(r[k]);\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether one `Record` contains all of the keys and values\n * contained in another `Record`.\n *\n * @example\n * import { isSubrecord } from 'fp-ts/Record'\n * import { string } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"not-bar\", c: \"baz\" }),\n *   false\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   false\n * );\n *\n * @since 2.0.0\n */\nexport var isSubrecord = RR.isSubrecord;\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing the value,\n * otherwise it returns `None`\n *\n * @example\n * import { lookup } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(lookup(\"b\")({ a: \"foo\", b: \"bar\" }), option.some(\"bar\"));\n * assert.deepStrictEqual(lookup(\"c\")({ a: \"foo\", b: \"bar\" }), option.none);\n *\n * @since 2.0.0\n */\nexport var lookup = RR.lookup;\n/**\n * Map a `Record` passing the key/value pairs to the iterating function.\n *\n * @example\n * import { mapWithIndex } from \"fp-ts/Record\";\n *\n * const f = (k: string, n: number) => `${k.toUpperCase()}-${n}`;\n * assert.deepStrictEqual(mapWithIndex(f)({ a: 3, b: 5 }), { a: \"A-3\", b: \"B-5\" });\n *\n * @since 2.0.0\n */\nexport var mapWithIndex = RR.mapWithIndex;\n/**\n * Map a `Record` passing the values to the iterating function.\n *\n * @example\n * import { map } from \"fp-ts/Record\";\n *\n * const f = (n: number) => `-${n}-`;\n * assert.deepStrictEqual(map(f)({ a: 3, b: 5 }), { a: \"-3-\", b: \"-5-\" });\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = RR.map;\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceWithIndex(args[0]) : RR.reduceWithIndex(S.Ord).apply(void 0, args);\n}\nexport function foldMapWithIndex(O) {\n    return 'compare' in O ? RR.foldMapWithIndex(O) : RR.foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRightWithIndex(args[0]) : RR.reduceRightWithIndex(S.Ord).apply(void 0, args);\n}\n/**\n * Create a `Record` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @since 2.0.0\n */\nexport var singleton = RR.singleton;\nexport function traverseWithIndex(F) {\n    return RR.traverseWithIndex(F);\n}\nexport function traverse(F) {\n    return RR.traverse(F);\n}\nexport function sequence(F) {\n    return RR.sequence(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMapWithIndex } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (key: string, a: number) =>\n *   a >= 0 ? either.right(`${key} is >= 0 (${a})`) : either.left(`${key} is < 0 (${a})`);\n * assert.deepStrictEqual(partitionMapWithIndex(f)({ a: -1, b: 2, c: 123 }), {\n *   left: {\n *     a: \"a is < 0 (-1)\",\n *   },\n *   right: {\n *     b: \"b is >= 0 (2)\",\n *     c: \"c is >= 0 (123)\",\n *   },\n * });\n *\n * @since 2.0.0\n */\nexport var partitionMapWithIndex = RR.partitionMapWithIndex;\nexport function partitionWithIndex(predicateWithIndex) {\n    return RR.partitionWithIndex(predicateWithIndex);\n}\n/**\n * Maps a `Record` with an iterating function that takes key and value and\n * returns an `Option`, keeping only the `Some` values and discarding `None`s.\n *\n * @example\n * import { filterMapWithIndex } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (key: string, a: number) => (a >= 0 ? option.some(`${key}${a}`) : option.none);\n * assert.deepStrictEqual(filterMapWithIndex(f)({ a: -1, b: 2, c: 3 }), {\n *   b: \"b2\",\n *   c: \"c3\",\n * });\n *\n * @since 2.0.0\n */\nexport var filterMapWithIndex = RR.filterMapWithIndex;\nexport function filterWithIndex(predicateWithIndex) {\n    return RR.filterWithIndex(predicateWithIndex);\n}\nexport function fromFoldable(M, F) {\n    return RR.fromFoldable(M, F);\n}\n/**\n * Alias of [`toArray`](#toArray).\n *\n * @example\n * import { toEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var toEntries = toArray;\n/**\n * Converts an `Array` of `[key, value]` tuples into a `Record`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) { return fromFoldable(Se.last(), A.Foldable)(fa); };\nexport function fromFoldableMap(M, F) {\n    return RR.fromFoldableMap(M, F);\n}\n/**\n * Test if every value in a `Record` satisfies the predicate.\n *\n * @example\n * import { every } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);\n *\n * @since 2.0.0\n */\nexport var every = RR.every;\n/**\n * Test if at least one value in a `Record` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.0.0\n */\nexport var some = RR.some;\n// TODO: remove non-curried overloading in v3\n/**\n * Given an `Eq` checks if a `Record` contains an entry with\n * value equal to a provided value.\n *\n * @example\n * import { elem } from \"fp-ts/Record\"\n * import { number } from \"fp-ts\"\n *\n * assert.deepStrictEqual(elem(number.Eq)(123, { foo: 123, bar: 234 }), true);\n * assert.deepStrictEqual(elem(number.Eq)(-7, { foo: 123, bar: 234 }), false);\n *\n * @since 2.0.0\n */\nexport var elem = RR.elem;\n/**\n * Union of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    var unionM = RR.union(M);\n    return function (second) { return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return unionM(second)(first);\n    }; };\n};\n/**\n * Intersection of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return {};\n            }\n            return RR.intersection(M)(second)(first);\n        };\n    };\n};\n/**\n * Difference between two `Record`s.\n * Takes two `Record`s and produces a `Record` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return RR.difference(second)(first);\n    };\n};\nvar _map = RR._map;\nvar _mapWithIndex = RR._mapWithIndex;\nvar _reduce = RR._reduce;\nvar _foldMap = RR._foldMap;\nvar _reduceRight = RR._reduceRight;\nvar _filter = RR._filter;\nvar _filterMap = RR._filterMap;\nvar _partition = RR._partition;\nvar _partitionMap = RR._partitionMap;\nvar _reduceWithIndex = RR._reduceWithIndex;\nvar _foldMapWithIndex = RR._foldMapWithIndex;\nvar _reduceRightWithIndex = RR._reduceRightWithIndex;\nvar _partitionMapWithIndex = RR._partitionMapWithIndex;\nvar _partitionWithIndex = RR._partitionWithIndex;\nvar _filterMapWithIndex = RR._filterMapWithIndex;\nvar _filterWithIndex = RR._filterWithIndex;\nvar _traverse = RR._traverse;\nvar _sequence = RR._sequence;\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of({});\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    r[key] = b;\n                    return r;\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `Record` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = RR.filter;\n/**\n * Maps a `Record` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = RR.filterMap;\n/**\n * Partition a `Record` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = RR.partition;\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = RR.partitionMap;\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduce(args[0]) : RR.reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    return 'compare' in O ? RR.foldMap(O) : RR.foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRight(args[0]) : RR.reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `Record` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = RR.compact;\n/**\n * Separate a `Record` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/Record'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = RR.separate;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Record';\nexport function getShow(O) {\n    return 'compare' in O ? RR.getShow(O) : RR.getShow(S.Ord)(O);\n}\n/**\n * Given an `Eq` for the base type, it produces an `Eq`\n * for a `Record` of that base type.\n *\n * @example\n * import { getEq } from \"fp-ts/Record\";\n * import { string } from \"fp-ts\";\n * import { Eq } from \"fp-ts/Eq\";\n *\n * const eq: Eq<Record<string, string>> = getEq(string.Eq);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { b: \"bar\" }), false);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { a: \"foo\" }), true);\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RR.getEq;\n/**\n * Returns a `Monoid` instance for `Record`s, given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s comining the\n * overlapping entries with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getMonoid } from 'fp-ts/Record'\n *\n * const M = getMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = RR.getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `Record` of functions and returns a\n * `Record` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/Record\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `Record`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/Record'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: {}\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `Record`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference } from \"fp-ts/Record\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<Record<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use the `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use a new `{}` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = {};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\n/**\n * Use [`has`](#has) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var hasOwnProperty = RR.hasOwnProperty;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `R.Functor` instead of `R.record`\n * (where `R` is from `import R from 'fp-ts/Record'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var record = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}