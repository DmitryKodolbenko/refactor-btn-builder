{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Slice = void 0;\nconst __1 = require(\"..\");\nclass Slice {\n  constructor(sourceBits, sourceRefs) {\n    this.refs = [];\n    this.skip = bits => {\n      this.bits.skip(bits);\n    };\n    this.readUint = bits => {\n      return this.bits.readUint(bits);\n    };\n    this.readUintNumber = bits => {\n      return this.bits.readUintNumber(bits);\n    };\n    this.readInt = bits => {\n      return this.bits.readInt(bits);\n    };\n    this.readIntNumber = bits => {\n      return this.bits.readIntNumber(bits);\n    };\n    this.readBuffer = size => {\n      return this.bits.readBuffer(size);\n    };\n    this.readBit = () => {\n      return this.bits.readBit();\n    };\n    this.readCoins = () => {\n      return this.bits.readCoins();\n    };\n    this.readVarUInt = headerBits => {\n      return this.bits.readVarUInt(headerBits);\n    };\n    this.readVarUIntNumber = headerBits => {\n      return this.bits.readVarUIntNumber(headerBits);\n    };\n    this.readRemaining = () => {\n      return this.bits.readRemaining();\n    };\n    this.readRemainingBytes = () => {\n      if (this.bits.remaining % 8 !== 0) {\n        throw Error('Number remaining of bits is not multiply of 8');\n      }\n      return this.bits.readBuffer(this.bits.remaining / 8);\n    };\n    this.readAddress = () => {\n      return this.bits.readAddress();\n    };\n    this.readUnaryLength = () => {\n      return this.bits.readUnaryLength();\n    };\n    this.readBitString = n => {\n      return this.bits.readBitString(n);\n    };\n    this.readOptDict = (keySize, extractor) => {\n      if (this.readBit()) {\n        return this.readDict(keySize, extractor);\n      } else {\n        return null;\n      }\n    };\n    this.readDict = (keySize, extractor) => {\n      let first = this.refs.shift();\n      if (first) {\n        return (0, __1.parseDict)(first.beginParse(), keySize, extractor);\n      } else {\n        throw Error('No ref');\n      }\n    };\n    this.readRef = () => {\n      let first = this.refs.shift();\n      if (first) {\n        return Slice.fromCell(first);\n      } else {\n        throw Error('No ref');\n      }\n    };\n    this.readCell = () => {\n      let first = this.refs.shift();\n      if (first) {\n        return first;\n      } else {\n        throw Error('No ref');\n      }\n    };\n    this.preloadCell = () => {\n      let first = this.refs[0];\n      if (first) {\n        return first;\n      } else {\n        throw Error('No ref');\n      }\n    };\n    this.clone = () => {\n      // Copy remaining\n      const cloned = this.sourceBits.clone();\n      const reader = new __1.BitStringReader(cloned);\n      reader.skip(this.bits.currentOffset);\n      const remaining = reader.readRemaining();\n      const remainingRefs = [...this.refs];\n      // Build slice\n      return new Slice(remaining, remainingRefs);\n    };\n    this.toCell = () => {\n      // Copy remaining\n      const cloned = this.sourceBits.clone();\n      const reader = new __1.BitStringReader(cloned);\n      reader.skip(this.bits.currentOffset);\n      const remaining = reader.readRemaining();\n      let cell = new __1.Cell('ordinary', remaining);\n      for (let r of this.refs) {\n        cell.refs.push(r);\n      }\n      return cell;\n    };\n    this.sourceBits = sourceBits.clone();\n    this.refs = [...sourceRefs];\n    this.bits = new __1.BitStringReader(this.sourceBits);\n  }\n  static fromCell(cell) {\n    if (cell.isExotic) {\n      throw Error('Unable to create slice from exotic');\n    }\n    return new Slice(cell.bits, cell.refs);\n  }\n  get remaining() {\n    return this.bits.remaining;\n  }\n  get remainingRefs() {\n    return this.refs.length;\n  }\n}\nexports.Slice = Slice;","map":{"version":3,"names":["Object","defineProperty","exports","value","Slice","__1","require","constructor","sourceBits","sourceRefs","refs","skip","bits","readUint","readUintNumber","readInt","readIntNumber","readBuffer","size","readBit","readCoins","readVarUInt","headerBits","readVarUIntNumber","readRemaining","readRemainingBytes","remaining","Error","readAddress","readUnaryLength","readBitString","n","readOptDict","keySize","extractor","readDict","first","shift","parseDict","beginParse","readRef","fromCell","readCell","preloadCell","clone","cloned","reader","BitStringReader","currentOffset","remainingRefs","toCell","cell","Cell","r","push","isExotic","length"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/boc/Slice.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Slice = void 0;\nconst __1 = require(\"..\");\nclass Slice {\n    constructor(sourceBits, sourceRefs) {\n        this.refs = [];\n        this.skip = (bits) => {\n            this.bits.skip(bits);\n        };\n        this.readUint = (bits) => {\n            return this.bits.readUint(bits);\n        };\n        this.readUintNumber = (bits) => {\n            return this.bits.readUintNumber(bits);\n        };\n        this.readInt = (bits) => {\n            return this.bits.readInt(bits);\n        };\n        this.readIntNumber = (bits) => {\n            return this.bits.readIntNumber(bits);\n        };\n        this.readBuffer = (size) => {\n            return this.bits.readBuffer(size);\n        };\n        this.readBit = () => {\n            return this.bits.readBit();\n        };\n        this.readCoins = () => {\n            return this.bits.readCoins();\n        };\n        this.readVarUInt = (headerBits) => {\n            return this.bits.readVarUInt(headerBits);\n        };\n        this.readVarUIntNumber = (headerBits) => {\n            return this.bits.readVarUIntNumber(headerBits);\n        };\n        this.readRemaining = () => {\n            return this.bits.readRemaining();\n        };\n        this.readRemainingBytes = () => {\n            if (this.bits.remaining % 8 !== 0) {\n                throw Error('Number remaining of bits is not multiply of 8');\n            }\n            return this.bits.readBuffer(this.bits.remaining / 8);\n        };\n        this.readAddress = () => {\n            return this.bits.readAddress();\n        };\n        this.readUnaryLength = () => {\n            return this.bits.readUnaryLength();\n        };\n        this.readBitString = (n) => {\n            return this.bits.readBitString(n);\n        };\n        this.readOptDict = (keySize, extractor) => {\n            if (this.readBit()) {\n                return this.readDict(keySize, extractor);\n            }\n            else {\n                return null;\n            }\n        };\n        this.readDict = (keySize, extractor) => {\n            let first = this.refs.shift();\n            if (first) {\n                return (0, __1.parseDict)(first.beginParse(), keySize, extractor);\n            }\n            else {\n                throw Error('No ref');\n            }\n        };\n        this.readRef = () => {\n            let first = this.refs.shift();\n            if (first) {\n                return Slice.fromCell(first);\n            }\n            else {\n                throw Error('No ref');\n            }\n        };\n        this.readCell = () => {\n            let first = this.refs.shift();\n            if (first) {\n                return first;\n            }\n            else {\n                throw Error('No ref');\n            }\n        };\n        this.preloadCell = () => {\n            let first = this.refs[0];\n            if (first) {\n                return first;\n            }\n            else {\n                throw Error('No ref');\n            }\n        };\n        this.clone = () => {\n            // Copy remaining\n            const cloned = this.sourceBits.clone();\n            const reader = new __1.BitStringReader(cloned);\n            reader.skip(this.bits.currentOffset);\n            const remaining = reader.readRemaining();\n            const remainingRefs = [...this.refs];\n            // Build slice\n            return new Slice(remaining, remainingRefs);\n        };\n        this.toCell = () => {\n            // Copy remaining\n            const cloned = this.sourceBits.clone();\n            const reader = new __1.BitStringReader(cloned);\n            reader.skip(this.bits.currentOffset);\n            const remaining = reader.readRemaining();\n            let cell = new __1.Cell('ordinary', remaining);\n            for (let r of this.refs) {\n                cell.refs.push(r);\n            }\n            return cell;\n        };\n        this.sourceBits = sourceBits.clone();\n        this.refs = [...sourceRefs];\n        this.bits = new __1.BitStringReader(this.sourceBits);\n    }\n    static fromCell(cell) {\n        if (cell.isExotic) {\n            throw Error('Unable to create slice from exotic');\n        }\n        return new Slice(cell.bits, cell.refs);\n    }\n    get remaining() {\n        return this.bits.remaining;\n    }\n    get remainingRefs() {\n        return this.refs.length;\n    }\n}\nexports.Slice = Slice;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}