{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lastValue = exports.asArray = exports.countStream = exports.Reducer = void 0;\n// Reducer takes a stream of events T and a ReducerFunc, that\n// materializes a state of type U.\nclass Reducer {\n  constructor(stream, reducer, initState) {\n    this.stream = stream;\n    this.reducer = reducer;\n    this.state = initState;\n    this.completed = new Promise((resolve, reject) => {\n      const subscription = this.stream.subscribe({\n        next: evt => {\n          this.state = this.reducer(this.state, evt);\n        },\n        complete: () => {\n          resolve();\n          // this must happen after resolve, to ensure stream.subscribe() has finished\n          subscription.unsubscribe();\n        },\n        error: err => {\n          reject(err);\n          // the stream already closed on error, but unsubscribe to be safe\n          subscription.unsubscribe();\n        }\n      });\n    });\n  }\n  // value returns current materialized state\n  value() {\n    return this.state;\n  }\n  // finished resolves on completed stream, rejects on stream error\n  async finished() {\n    return this.completed;\n  }\n}\nexports.Reducer = Reducer;\nfunction increment(sum, _) {\n  return sum + 1;\n}\n// countStream returns a reducer that contains current count\n// of events on the stream\nfunction countStream(stream) {\n  return new Reducer(stream, increment, 0);\n}\nexports.countStream = countStream;\nfunction append(list, evt) {\n  return [...list, evt];\n}\n// asArray maintains an array containing all events that have\n// occurred on the stream\nfunction asArray(stream) {\n  return new Reducer(stream, append, []);\n}\nexports.asArray = asArray;\nfunction last(_, event) {\n  return event;\n}\n// lastValue returns the last value read from the stream, or undefined if no values sent\nfunction lastValue(stream) {\n  return new Reducer(stream, last, undefined);\n}\nexports.lastValue = lastValue;","map":{"version":3,"sources":["../src/reducer.ts"],"names":[],"mappings":";;;;;;AAIA;AACA;AACA,MAAa,OAAO,CAAA;EAQlB,WAAA,CAAmB,MAAiB,EAAE,OAA0B,EAAE,SAAY,EAAA;IAC5E,IAAI,CAAC,MAAM,GAAG,MAAM;IACpB,IAAI,CAAC,OAAO,GAAG,OAAO;IACtB,IAAI,CAAC,KAAK,GAAG,SAAS;IACtB,IAAI,CAAC,SAAS,GAAG,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,KAAI;MACrD,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC;QACzC,IAAI,EAAG,GAAM,IAAI;UACf,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC;QAC5C,CAAC;QACD,QAAQ,EAAE,MAAK;UACb,OAAO,EAAE;UACT;UACA,YAAY,CAAC,WAAW,EAAE;QAC5B,CAAC;QACD,KAAK,EAAG,GAAQ,IAAI;UAClB,MAAM,CAAC,GAAG,CAAC;UACX;UACA,YAAY,CAAC,WAAW,EAAE;QAC5B;OACD,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA;EACO,KAAK,GAAA;IACV,OAAO,IAAI,CAAC,KAAK;EACnB;EAEA;EACO,MAAM,QAAQ,GAAA;IACnB,OAAO,IAAI,CAAC,SAAS;EACvB;AACD;AAxCD,OAAA,CAAA,OAAA,GAAA,OAAA;AA0CA,SAAS,SAAS,CAAI,GAAW,EAAE,CAAI,EAAA;EACrC,OAAO,GAAG,GAAG,CAAC;AAChB;AAEA;AACA;AACA,SAAgB,WAAW,CAAI,MAAiB,EAAA;EAC9C,OAAO,IAAI,OAAO,CAAC,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC;AAC1C;AAFA,OAAA,CAAA,WAAA,GAAA,WAAA;AAIA,SAAS,MAAM,CAAI,IAAkB,EAAE,GAAM,EAAA;EAC3C,OAAO,CAAC,GAAG,IAAI,EAAE,GAAG,CAAC;AACvB;AAEA;AACA;AACA,SAAgB,OAAO,CAAI,MAAiB,EAAA;EAC1C,OAAO,IAAI,OAAO,CAAkB,MAAM,EAAE,MAAM,EAAE,EAAE,CAAC;AACzD;AAFA,OAAA,CAAA,OAAA,GAAA,OAAA;AAIA,SAAS,IAAI,CAAI,CAAM,EAAE,KAAQ,EAAA;EAC/B,OAAO,KAAK;AACd;AAEA;AACA,SAAgB,SAAS,CAAI,MAAiB,EAAA;EAC5C,OAAO,IAAI,OAAO,CAAmB,MAAM,EAAE,IAAI,EAAE,SAAS,CAAC;AAC/D;AAFA,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lastValue = exports.asArray = exports.countStream = exports.Reducer = void 0;\n// Reducer takes a stream of events T and a ReducerFunc, that\n// materializes a state of type U.\nclass Reducer {\n    constructor(stream, reducer, initState) {\n        this.stream = stream;\n        this.reducer = reducer;\n        this.state = initState;\n        this.completed = new Promise((resolve, reject) => {\n            const subscription = this.stream.subscribe({\n                next: (evt) => {\n                    this.state = this.reducer(this.state, evt);\n                },\n                complete: () => {\n                    resolve();\n                    // this must happen after resolve, to ensure stream.subscribe() has finished\n                    subscription.unsubscribe();\n                },\n                error: (err) => {\n                    reject(err);\n                    // the stream already closed on error, but unsubscribe to be safe\n                    subscription.unsubscribe();\n                },\n            });\n        });\n    }\n    // value returns current materialized state\n    value() {\n        return this.state;\n    }\n    // finished resolves on completed stream, rejects on stream error\n    async finished() {\n        return this.completed;\n    }\n}\nexports.Reducer = Reducer;\nfunction increment(sum, _) {\n    return sum + 1;\n}\n// countStream returns a reducer that contains current count\n// of events on the stream\nfunction countStream(stream) {\n    return new Reducer(stream, increment, 0);\n}\nexports.countStream = countStream;\nfunction append(list, evt) {\n    return [...list, evt];\n}\n// asArray maintains an array containing all events that have\n// occurred on the stream\nfunction asArray(stream) {\n    return new Reducer(stream, append, []);\n}\nexports.asArray = asArray;\nfunction last(_, event) {\n    return event;\n}\n// lastValue returns the last value read from the stream, or undefined if no values sent\nfunction lastValue(stream) {\n    return new Reducer(stream, last, undefined);\n}\nexports.lastValue = lastValue;\n//# sourceMappingURL=reducer.js.map"]},"metadata":{},"sourceType":"script"}