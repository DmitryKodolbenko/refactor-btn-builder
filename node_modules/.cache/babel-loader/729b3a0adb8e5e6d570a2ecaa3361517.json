{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryClient = void 0;\n/* eslint-disable no-dupe-class-members, @typescript-eslint/ban-types, @typescript-eslint/naming-convention */\nconst ics23_1 = require(\"@confio/ics23\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst stream_1 = require(\"@cosmjs/stream\");\nconst utils_1 = require(\"@cosmjs/utils\");\nfunction checkAndParseOp(op, kind, key) {\n  if (op.type !== kind) {\n    throw new Error(`Op expected to be ${kind}, got \"${op.type}`);\n  }\n  if (!(0, utils_1.arrayContentEquals)(key, op.key)) {\n    throw new Error(`Proven key different than queried key.\\nQuery: ${(0, encoding_1.toHex)(key)}\\nProven: ${(0, encoding_1.toHex)(op.key)}`);\n  }\n  return ics23_1.ics23.CommitmentProof.decode(op.data);\n}\nclass QueryClient {\n  constructor(tmClient) {\n    this.tmClient = tmClient;\n  }\n  static withExtensions(tmClient) {\n    const client = new QueryClient(tmClient);\n    for (var _len = arguments.length, extensionSetups = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      extensionSetups[_key - 1] = arguments[_key];\n    }\n    const extensions = extensionSetups.map(setupExtension => setupExtension(client));\n    for (const extension of extensions) {\n      (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);\n      for (const [moduleKey, moduleValue] of Object.entries(extension)) {\n        (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module \"${moduleKey}\".`);\n        const current = client[moduleKey] || {};\n        client[moduleKey] = {\n          ...current,\n          ...moduleValue\n        };\n      }\n    }\n    return client;\n  }\n  async queryVerified(store, key, desiredHeight) {\n    const {\n      height,\n      proof,\n      value\n    } = await this.queryRawProof(store, key, desiredHeight);\n    const subProof = checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n    const storeProof = checkAndParseOp(proof.ops[1], \"ics23:simple\", (0, encoding_1.toAscii)(store));\n    // this must always be existence, if the store is not a typo\n    (0, utils_1.assert)(storeProof.exist);\n    (0, utils_1.assert)(storeProof.exist.value);\n    // this may be exist or non-exist, depends on response\n    if (!value || value.length === 0) {\n      // non-existence check\n      (0, utils_1.assert)(subProof.nonexist);\n      // the subproof must map the desired key to the \"value\" of the storeProof\n      (0, ics23_1.verifyNonExistence)(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, key);\n    } else {\n      // existence check\n      (0, utils_1.assert)(subProof.exist);\n      (0, utils_1.assert)(subProof.exist.value);\n      // the subproof must map the desired key to the \"value\" of the storeProof\n      (0, ics23_1.verifyExistence)(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, key, value);\n    }\n    // the store proof must map its declared value (root of subProof) to the appHash of the next block\n    const header = await this.getNextHeader(height);\n    (0, ics23_1.verifyExistence)(storeProof.exist, ics23_1.tendermintSpec, header.appHash, (0, encoding_1.toAscii)(store), storeProof.exist.value);\n    return value;\n  }\n  async queryRawProof(store, queryKey, desiredHeight) {\n    var _a;\n    const {\n      key,\n      value,\n      height,\n      proof,\n      code,\n      log\n    } = await this.tmClient.abciQuery({\n      // we need the StoreKey for the module, not the module name\n      // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12\n      path: `/store/${store}/key`,\n      data: queryKey,\n      prove: true,\n      height: desiredHeight\n    });\n    if (code) {\n      throw new Error(`Query failed with (${code}): ${log}`);\n    }\n    if (!(0, utils_1.arrayContentEquals)(queryKey, key)) {\n      throw new Error(`Response key ${(0, encoding_1.toHex)(key)} doesn't match query key ${(0, encoding_1.toHex)(queryKey)}`);\n    }\n    if (!height) {\n      throw new Error(\"No query height returned\");\n    }\n    if (!proof || proof.ops.length !== 2) {\n      throw new Error(`Expected 2 proof ops, got ${(_a = proof === null || proof === void 0 ? void 0 : proof.ops.length) !== null && _a !== void 0 ? _a : 0}. Are you using stargate?`);\n    }\n    // we don't need the results, but we can ensure the data is the proper format\n    checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n    checkAndParseOp(proof.ops[1], \"ics23:simple\", (0, encoding_1.toAscii)(store));\n    return {\n      key: key,\n      value: value,\n      height: height,\n      // need to clone this: readonly input / writeable output\n      proof: {\n        ops: [...proof.ops]\n      }\n    };\n  }\n  async queryUnverified(path, request) {\n    const response = await this.tmClient.abciQuery({\n      path: path,\n      data: request,\n      prove: false\n    });\n    if (response.code) {\n      throw new Error(`Query failed with (${response.code}): ${response.log}`);\n    }\n    return response.value;\n  }\n  // this must return the header for height+1\n  // throws an error if height is 0 or undefined\n  async getNextHeader(height) {\n    (0, utils_1.assertDefined)(height);\n    if (height === 0) {\n      throw new Error(\"Query returned height 0, cannot prove it\");\n    }\n    const searchHeight = height + 1;\n    let nextHeader;\n    let headersSubscription;\n    try {\n      headersSubscription = this.tmClient.subscribeNewBlockHeader();\n    } catch (_a) {\n      // Ignore exception caused by non-WebSocket Tendermint clients\n    }\n    if (headersSubscription) {\n      const firstHeader = await (0, stream_1.firstEvent)(headersSubscription);\n      // The first header we get might not be n+1 but n+2 or even higher. In such cases we fall back on a query.\n      if (firstHeader.height === searchHeight) {\n        nextHeader = firstHeader;\n      }\n    }\n    while (!nextHeader) {\n      // start from current height to avoid backend error for minHeight in the future\n      const correctHeader = (await this.tmClient.blockchain(height, searchHeight)).blockMetas.map(meta => meta.header).find(h => h.height === searchHeight);\n      if (correctHeader) {\n        nextHeader = correctHeader;\n      } else {\n        await (0, utils_1.sleep)(1000);\n      }\n    }\n    (0, utils_1.assert)(nextHeader.height === searchHeight, \"Got wrong header. This is a bug in the logic above.\");\n    return nextHeader;\n  }\n}\nexports.QueryClient = QueryClient;","map":{"version":3,"sources":["../../src/queryclient/queryclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueryClient = void 0;\n/* eslint-disable no-dupe-class-members, @typescript-eslint/ban-types, @typescript-eslint/naming-convention */\nconst ics23_1 = require(\"@confio/ics23\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst stream_1 = require(\"@cosmjs/stream\");\nconst utils_1 = require(\"@cosmjs/utils\");\nfunction checkAndParseOp(op, kind, key) {\n    if (op.type !== kind) {\n        throw new Error(`Op expected to be ${kind}, got \"${op.type}`);\n    }\n    if (!(0, utils_1.arrayContentEquals)(key, op.key)) {\n        throw new Error(`Proven key different than queried key.\\nQuery: ${(0, encoding_1.toHex)(key)}\\nProven: ${(0, encoding_1.toHex)(op.key)}`);\n    }\n    return ics23_1.ics23.CommitmentProof.decode(op.data);\n}\nclass QueryClient {\n    constructor(tmClient) {\n        this.tmClient = tmClient;\n    }\n    static withExtensions(tmClient, ...extensionSetups) {\n        const client = new QueryClient(tmClient);\n        const extensions = extensionSetups.map((setupExtension) => setupExtension(client));\n        for (const extension of extensions) {\n            (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);\n            for (const [moduleKey, moduleValue] of Object.entries(extension)) {\n                (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module \"${moduleKey}\".`);\n                const current = client[moduleKey] || {};\n                client[moduleKey] = {\n                    ...current,\n                    ...moduleValue,\n                };\n            }\n        }\n        return client;\n    }\n    async queryVerified(store, key, desiredHeight) {\n        const { height, proof, value } = await this.queryRawProof(store, key, desiredHeight);\n        const subProof = checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n        const storeProof = checkAndParseOp(proof.ops[1], \"ics23:simple\", (0, encoding_1.toAscii)(store));\n        // this must always be existence, if the store is not a typo\n        (0, utils_1.assert)(storeProof.exist);\n        (0, utils_1.assert)(storeProof.exist.value);\n        // this may be exist or non-exist, depends on response\n        if (!value || value.length === 0) {\n            // non-existence check\n            (0, utils_1.assert)(subProof.nonexist);\n            // the subproof must map the desired key to the \"value\" of the storeProof\n            (0, ics23_1.verifyNonExistence)(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, key);\n        }\n        else {\n            // existence check\n            (0, utils_1.assert)(subProof.exist);\n            (0, utils_1.assert)(subProof.exist.value);\n            // the subproof must map the desired key to the \"value\" of the storeProof\n            (0, ics23_1.verifyExistence)(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, key, value);\n        }\n        // the store proof must map its declared value (root of subProof) to the appHash of the next block\n        const header = await this.getNextHeader(height);\n        (0, ics23_1.verifyExistence)(storeProof.exist, ics23_1.tendermintSpec, header.appHash, (0, encoding_1.toAscii)(store), storeProof.exist.value);\n        return value;\n    }\n    async queryRawProof(store, queryKey, desiredHeight) {\n        var _a;\n        const { key, value, height, proof, code, log } = await this.tmClient.abciQuery({\n            // we need the StoreKey for the module, not the module name\n            // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12\n            path: `/store/${store}/key`,\n            data: queryKey,\n            prove: true,\n            height: desiredHeight,\n        });\n        if (code) {\n            throw new Error(`Query failed with (${code}): ${log}`);\n        }\n        if (!(0, utils_1.arrayContentEquals)(queryKey, key)) {\n            throw new Error(`Response key ${(0, encoding_1.toHex)(key)} doesn't match query key ${(0, encoding_1.toHex)(queryKey)}`);\n        }\n        if (!height) {\n            throw new Error(\"No query height returned\");\n        }\n        if (!proof || proof.ops.length !== 2) {\n            throw new Error(`Expected 2 proof ops, got ${(_a = proof === null || proof === void 0 ? void 0 : proof.ops.length) !== null && _a !== void 0 ? _a : 0}. Are you using stargate?`);\n        }\n        // we don't need the results, but we can ensure the data is the proper format\n        checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n        checkAndParseOp(proof.ops[1], \"ics23:simple\", (0, encoding_1.toAscii)(store));\n        return {\n            key: key,\n            value: value,\n            height: height,\n            // need to clone this: readonly input / writeable output\n            proof: {\n                ops: [...proof.ops],\n            },\n        };\n    }\n    async queryUnverified(path, request) {\n        const response = await this.tmClient.abciQuery({\n            path: path,\n            data: request,\n            prove: false,\n        });\n        if (response.code) {\n            throw new Error(`Query failed with (${response.code}): ${response.log}`);\n        }\n        return response.value;\n    }\n    // this must return the header for height+1\n    // throws an error if height is 0 or undefined\n    async getNextHeader(height) {\n        (0, utils_1.assertDefined)(height);\n        if (height === 0) {\n            throw new Error(\"Query returned height 0, cannot prove it\");\n        }\n        const searchHeight = height + 1;\n        let nextHeader;\n        let headersSubscription;\n        try {\n            headersSubscription = this.tmClient.subscribeNewBlockHeader();\n        }\n        catch (_a) {\n            // Ignore exception caused by non-WebSocket Tendermint clients\n        }\n        if (headersSubscription) {\n            const firstHeader = await (0, stream_1.firstEvent)(headersSubscription);\n            // The first header we get might not be n+1 but n+2 or even higher. In such cases we fall back on a query.\n            if (firstHeader.height === searchHeight) {\n                nextHeader = firstHeader;\n            }\n        }\n        while (!nextHeader) {\n            // start from current height to avoid backend error for minHeight in the future\n            const correctHeader = (await this.tmClient.blockchain(height, searchHeight)).blockMetas\n                .map((meta) => meta.header)\n                .find((h) => h.height === searchHeight);\n            if (correctHeader) {\n                nextHeader = correctHeader;\n            }\n            else {\n                await (0, utils_1.sleep)(1000);\n            }\n        }\n        (0, utils_1.assert)(nextHeader.height === searchHeight, \"Got wrong header. This is a bug in the logic above.\");\n        return nextHeader;\n    }\n}\nexports.QueryClient = QueryClient;\n//# sourceMappingURL=queryclient.js.map"]},"metadata":{},"sourceType":"script"}