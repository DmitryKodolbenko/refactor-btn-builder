{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamingSocket = void 0;\nvar xstream_1 = require(\"xstream\");\nvar socketwrapper_1 = require(\"./socketwrapper\");\n/**\n * A WebSocket wrapper that exposes all events as a stream.\n *\n * This underlying socket will not be closed when the stream has no listeners\n */\nvar StreamingSocket = /*#__PURE__*/function () {\n  function StreamingSocket(url) {\n    var _this = this;\n    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    _classCallCheck(this, StreamingSocket);\n    this.socket = new socketwrapper_1.SocketWrapper(url, function (event) {\n      if (_this.eventProducerListener) {\n        _this.eventProducerListener.next(event);\n      }\n    }, function (errorEvent) {\n      if (_this.eventProducerListener) {\n        _this.eventProducerListener.error(errorEvent);\n      }\n    }, function () {\n      // socket opened\n    }, function (closeEvent) {\n      if (_this.eventProducerListener) {\n        if (closeEvent.wasClean) {\n          _this.eventProducerListener.complete();\n        } else {\n          _this.eventProducerListener.error(\"Socket was closed unclean\");\n        }\n      }\n    }, timeout);\n    this.connected = this.socket.connected;\n    var eventProducer = {\n      start: function start(listener) {\n        return _this.eventProducerListener = listener;\n      },\n      stop: function stop() {\n        return _this.eventProducerListener = undefined;\n      }\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n  }\n  _createClass(StreamingSocket, [{\n    key: \"connect\",\n    value: function connect() {\n      this.socket.connect();\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.socket.disconnect();\n    }\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.socket.send(data));\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function send(_x) {\n        return _send.apply(this, arguments);\n      }\n      return send;\n    }()\n  }]);\n  return StreamingSocket;\n}();\nexports.StreamingSocket = StreamingSocket;","map":{"version":3,"sources":["../src/streamingsocket.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA,IAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;AAEA;;;;AAIG;AAJH,IAKa,eAAe;EAM1B,yBAAmB,GAAW,EAAkB;IAAA;IAAA,IAAhB,OAAO,uEAAG,KAAM;IAAA;IAC9C,IAAI,CAAC,MAAM,GAAG,IAAI,eAAA,CAAA,aAAa,CAC7B,GAAG,EACH,UAAC,KAAK,EAAI;MACR,IAAI,KAAI,CAAC,qBAAqB,EAAE;QAC9B,KAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,KAAK,CAAC;MACvC;IACH,CAAC,EACD,UAAC,UAAU,EAAI;MACb,IAAI,KAAI,CAAC,qBAAqB,EAAE;QAC9B,KAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,UAAU,CAAC;MAC7C;IACH,CAAC,EACD,YAAK;MACH;IAAA,CACD,EACD,UAAC,UAAU,EAAI;MACb,IAAI,KAAI,CAAC,qBAAqB,EAAE;QAC9B,IAAI,UAAU,CAAC,QAAQ,EAAE;UACvB,KAAI,CAAC,qBAAqB,CAAC,QAAQ,EAAE;SACtC,MAAM;UACL,KAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,2BAA2B,CAAC;QAC9D;MACF;IACH,CAAC,EACD,OAAO,CACR;IACD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS;IAEtC,IAAM,aAAa,GAAkB;MACnC,KAAK,EAAE,eAAC,QAAQ;QAAA,OAAM,KAAI,CAAC,qBAAqB,GAAG,QAAQ;MAAA,CAAC;MAC5D,IAAI,EAAE;QAAA,OAAO,KAAI,CAAC,qBAAqB,GAAG,SAAS;MAAA;KACpD;IACD,IAAI,CAAC,MAAM,GAAG,SAAA,CAAA,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC;EAC5C;EAAC;IAAA;IAAA,OAEM,mBAAO;MACZ,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;IACvB;EAAC;IAAA;IAAA,OAEM,sBAAU;MACf,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE;IAC1B;EAAC;IAAA;IAAA;MAAA,uEAEM,iBAAW,IAAY;QAAA;UAAA;YAAA;cAAA;gBAAA,iCACrB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAC9B;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA;AApDH,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StreamingSocket = void 0;\nconst xstream_1 = require(\"xstream\");\nconst socketwrapper_1 = require(\"./socketwrapper\");\n/**\n * A WebSocket wrapper that exposes all events as a stream.\n *\n * This underlying socket will not be closed when the stream has no listeners\n */\nclass StreamingSocket {\n    constructor(url, timeout = 10000) {\n        this.socket = new socketwrapper_1.SocketWrapper(url, (event) => {\n            if (this.eventProducerListener) {\n                this.eventProducerListener.next(event);\n            }\n        }, (errorEvent) => {\n            if (this.eventProducerListener) {\n                this.eventProducerListener.error(errorEvent);\n            }\n        }, () => {\n            // socket opened\n        }, (closeEvent) => {\n            if (this.eventProducerListener) {\n                if (closeEvent.wasClean) {\n                    this.eventProducerListener.complete();\n                }\n                else {\n                    this.eventProducerListener.error(\"Socket was closed unclean\");\n                }\n            }\n        }, timeout);\n        this.connected = this.socket.connected;\n        const eventProducer = {\n            start: (listener) => (this.eventProducerListener = listener),\n            stop: () => (this.eventProducerListener = undefined),\n        };\n        this.events = xstream_1.Stream.create(eventProducer);\n    }\n    connect() {\n        this.socket.connect();\n    }\n    disconnect() {\n        this.socket.disconnect();\n    }\n    async send(data) {\n        return this.socket.send(data);\n    }\n}\nexports.StreamingSocket = StreamingSocket;\n//# sourceMappingURL=streamingsocket.js.map"]},"metadata":{},"sourceType":"script"}