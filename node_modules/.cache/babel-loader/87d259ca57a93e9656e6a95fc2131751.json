{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompress = exports.compress = void 0;\nvar codecimpl_1 = require(\"./generated/codecimpl\");\nfunction compress(proof) {\n  if (!proof.batch) {\n    return proof;\n  }\n  return {\n    compressed: compressBatch(proof.batch)\n  };\n}\nexports.compress = compress;\nfunction decompress(proof) {\n  if (!proof.compressed) {\n    return proof;\n  }\n  return {\n    batch: decompressBatch(proof.compressed)\n  };\n}\nexports.decompress = decompress;\nfunction compressBatch(proof) {\n  var centries = [];\n  var lookup = [];\n  var registry = new Map();\n  var _iterator = _createForOfIteratorHelper(proof.entries),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var entry = _step.value;\n      if (entry.exist) {\n        var centry = {\n          exist: compressExist(entry.exist, lookup, registry)\n        };\n        centries.push(centry);\n      } else if (entry.nonexist) {\n        var non = entry.nonexist;\n        var _centry = {\n          nonexist: {\n            key: non.key,\n            left: compressExist(non.left, lookup, registry),\n            right: compressExist(non.right, lookup, registry)\n          }\n        };\n        centries.push(_centry);\n      } else {\n        throw new Error(\"Unexpected batch entry during compress\");\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    entries: centries,\n    lookupInners: lookup\n  };\n}\nfunction compressExist(exist, lookup, registry) {\n  if (!exist) {\n    return undefined;\n  }\n  var path = exist.path.map(function (inner) {\n    var sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();\n    var idx = registry.get(sig);\n    if (idx === undefined) {\n      idx = lookup.length;\n      lookup.push(inner);\n      registry.set(sig, idx);\n    }\n    return idx;\n  });\n  return {\n    key: exist.key,\n    value: exist.value,\n    leaf: exist.leaf,\n    path: path\n  };\n}\nfunction decompressBatch(proof) {\n  var lookup = proof.lookupInners;\n  var entries = proof.entries.map(function (comp) {\n    if (comp.exist) {\n      return {\n        exist: decompressExist(comp.exist, lookup)\n      };\n    } else if (comp.nonexist) {\n      var non = comp.nonexist;\n      return {\n        nonexist: {\n          key: non.key,\n          left: decompressExist(non.left, lookup),\n          right: decompressExist(non.right, lookup)\n        }\n      };\n    } else {\n      throw new Error(\"Unexpected batch entry during compress\");\n    }\n  });\n  return {\n    entries: entries\n  };\n}\nfunction decompressExist(exist, lookup) {\n  if (!exist) {\n    return undefined;\n  }\n  var key = exist.key,\n    value = exist.value,\n    leaf = exist.leaf,\n    path = exist.path;\n  var newPath = (path || []).map(function (idx) {\n    return lookup[idx];\n  });\n  return {\n    key: key,\n    value: value,\n    leaf: leaf,\n    path: newPath\n  };\n}","map":{"version":3,"sources":["../src/compress.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decompress = exports.compress = void 0;\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nfunction compress(proof) {\n    if (!proof.batch) {\n        return proof;\n    }\n    return { compressed: compressBatch(proof.batch) };\n}\nexports.compress = compress;\nfunction decompress(proof) {\n    if (!proof.compressed) {\n        return proof;\n    }\n    return { batch: decompressBatch(proof.compressed) };\n}\nexports.decompress = decompress;\nfunction compressBatch(proof) {\n    const centries = [];\n    const lookup = [];\n    const registry = new Map();\n    for (const entry of proof.entries) {\n        if (entry.exist) {\n            const centry = { exist: compressExist(entry.exist, lookup, registry) };\n            centries.push(centry);\n        }\n        else if (entry.nonexist) {\n            const non = entry.nonexist;\n            const centry = {\n                nonexist: {\n                    key: non.key,\n                    left: compressExist(non.left, lookup, registry),\n                    right: compressExist(non.right, lookup, registry),\n                },\n            };\n            centries.push(centry);\n        }\n        else {\n            throw new Error(\"Unexpected batch entry during compress\");\n        }\n    }\n    return {\n        entries: centries,\n        lookupInners: lookup,\n    };\n}\nfunction compressExist(exist, lookup, registry) {\n    if (!exist) {\n        return undefined;\n    }\n    const path = exist.path.map((inner) => {\n        const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();\n        let idx = registry.get(sig);\n        if (idx === undefined) {\n            idx = lookup.length;\n            lookup.push(inner);\n            registry.set(sig, idx);\n        }\n        return idx;\n    });\n    return {\n        key: exist.key,\n        value: exist.value,\n        leaf: exist.leaf,\n        path,\n    };\n}\nfunction decompressBatch(proof) {\n    const lookup = proof.lookupInners;\n    const entries = proof.entries.map((comp) => {\n        if (comp.exist) {\n            return { exist: decompressExist(comp.exist, lookup) };\n        }\n        else if (comp.nonexist) {\n            const non = comp.nonexist;\n            return {\n                nonexist: {\n                    key: non.key,\n                    left: decompressExist(non.left, lookup),\n                    right: decompressExist(non.right, lookup),\n                },\n            };\n        }\n        else {\n            throw new Error(\"Unexpected batch entry during compress\");\n        }\n    });\n    return {\n        entries,\n    };\n}\nfunction decompressExist(exist, lookup) {\n    if (!exist) {\n        return undefined;\n    }\n    const { key, value, leaf, path } = exist;\n    const newPath = (path || []).map((idx) => lookup[idx]);\n    return { key, value, leaf, path: newPath };\n}\n//# sourceMappingURL=compress.js.map"]},"metadata":{},"sourceType":"script"}