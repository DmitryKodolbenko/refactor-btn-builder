{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.derivePath = exports.isValidPath = exports.getPublicKey = exports.getMasterKeyFromSeed = void 0;\nvar createHmac = require(\"create-hmac\");\nvar nacl = require(\"tweetnacl\");\nvar utils_1 = require(\"./utils\");\nvar ED25519_CURVE = 'ed25519 seed';\nvar HARDENED_OFFSET = 0x80000000;\nexports.getMasterKeyFromSeed = function (seed) {\n  var hmac = createHmac('sha512', ED25519_CURVE);\n  var I = hmac.update(Buffer.from(seed, 'hex')).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR\n  };\n};\nvar CKDPriv = function CKDPriv(_ref, index) {\n  var key = _ref.key,\n    chainCode = _ref.chainCode;\n  var indexBuffer = Buffer.allocUnsafe(4);\n  indexBuffer.writeUInt32BE(index, 0);\n  var data = Buffer.concat([Buffer.alloc(1, 0), key, indexBuffer]);\n  var I = createHmac('sha512', chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR\n  };\n};\nexports.getPublicKey = function (privateKey) {\n  var withZeroByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var keyPair = nacl.sign.keyPair.fromSeed(privateKey);\n  var signPk = keyPair.secretKey.subarray(32);\n  var zero = Buffer.alloc(1, 0);\n  return withZeroByte ? Buffer.concat([zero, Buffer.from(signPk)]) : Buffer.from(signPk);\n};\nexports.isValidPath = function (path) {\n  if (!utils_1.pathRegex.test(path)) {\n    return false;\n  }\n  return !path.split('/').slice(1).map(utils_1.replaceDerive).some(isNaN);\n};\nexports.derivePath = function (path, seed) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : HARDENED_OFFSET;\n  if (!exports.isValidPath(path)) {\n    throw new Error('Invalid derivation path');\n  }\n  var _exports$getMasterKey = exports.getMasterKeyFromSeed(seed),\n    key = _exports$getMasterKey.key,\n    chainCode = _exports$getMasterKey.chainCode;\n  var segments = path.split('/').slice(1).map(utils_1.replaceDerive).map(function (el) {\n    return parseInt(el, 10);\n  });\n  return segments.reduce(function (parentKeys, segment) {\n    return CKDPriv(parentKeys, segment + offset);\n  }, {\n    key: key,\n    chainCode: chainCode\n  });\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","derivePath","isValidPath","getPublicKey","getMasterKeyFromSeed","createHmac","require","nacl","utils_1","ED25519_CURVE","HARDENED_OFFSET","seed","hmac","I","update","Buffer","from","digest","IL","slice","IR","key","chainCode","CKDPriv","index","indexBuffer","allocUnsafe","writeUInt32BE","data","concat","alloc","privateKey","withZeroByte","keyPair","sign","fromSeed","signPk","secretKey","subarray","zero","path","pathRegex","test","split","map","replaceDerive","some","isNaN","offset","Error","segments","el","parseInt","reduce","parentKeys","segment"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/near-hd-key/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.derivePath = exports.isValidPath = exports.getPublicKey = exports.getMasterKeyFromSeed = void 0;\nconst createHmac = require(\"create-hmac\");\nconst nacl = require(\"tweetnacl\");\nconst utils_1 = require(\"./utils\");\nconst ED25519_CURVE = 'ed25519 seed';\nconst HARDENED_OFFSET = 0x80000000;\nexports.getMasterKeyFromSeed = (seed) => {\n    const hmac = createHmac('sha512', ED25519_CURVE);\n    const I = hmac.update(Buffer.from(seed, 'hex')).digest();\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return {\n        key: IL,\n        chainCode: IR,\n    };\n};\nconst CKDPriv = ({ key, chainCode }, index) => {\n    const indexBuffer = Buffer.allocUnsafe(4);\n    indexBuffer.writeUInt32BE(index, 0);\n    const data = Buffer.concat([Buffer.alloc(1, 0), key, indexBuffer]);\n    const I = createHmac('sha512', chainCode)\n        .update(data)\n        .digest();\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return {\n        key: IL,\n        chainCode: IR,\n    };\n};\nexports.getPublicKey = (privateKey, withZeroByte = true) => {\n    const keyPair = nacl.sign.keyPair.fromSeed(privateKey);\n    const signPk = keyPair.secretKey.subarray(32);\n    const zero = Buffer.alloc(1, 0);\n    return withZeroByte ?\n        Buffer.concat([zero, Buffer.from(signPk)]) :\n        Buffer.from(signPk);\n};\nexports.isValidPath = (path) => {\n    if (!utils_1.pathRegex.test(path)) {\n        return false;\n    }\n    return !path\n        .split('/')\n        .slice(1)\n        .map(utils_1.replaceDerive)\n        .some(isNaN);\n};\nexports.derivePath = (path, seed, offset = HARDENED_OFFSET) => {\n    if (!exports.isValidPath(path)) {\n        throw new Error('Invalid derivation path');\n    }\n    const { key, chainCode } = exports.getMasterKeyFromSeed(seed);\n    const segments = path\n        .split('/')\n        .slice(1)\n        .map(utils_1.replaceDerive)\n        .map(el => parseInt(el, 10));\n    return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), { key, chainCode });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}