{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeDict = exports.detectLabelType = exports.writeLabelSame = exports.writeLabelLong = exports.writeLabelShort = exports.buildTree = void 0;\nvar bn_js_1 = require(\"bn.js\");\nvar Cell_1 = require(\"../Cell\");\nvar findCommonPrefix_1 = require(\"./utils/findCommonPrefix\");\n//\n// Tree Build\n//\nfunction pad(src, size) {\n  while (src.length < size) {\n    src = '0' + src;\n  }\n  return src;\n}\nfunction removePrefixMap(src, length) {\n  if (length === 0) {\n    return src;\n  } else {\n    var res = new Map();\n    var _iterator = _createForOfIteratorHelper(src.keys()),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var k = _step.value;\n        var d = src.get(k);\n        res.set(k.slice(length), d);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return res;\n  }\n}\nfunction forkMap(src) {\n  if (src.size === 0) {\n    throw Error('Internal inconsistency');\n  }\n  var left = new Map();\n  var right = new Map();\n  var _iterator2 = _createForOfIteratorHelper(src.keys()),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var k = _step2.value;\n      var d = src.get(k);\n      if (k.startsWith('0')) {\n        left.set(k.substr(1), d);\n      } else {\n        right.set(k.substr(1), d);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  if (left.size === 0) {\n    throw Error('Internal inconsistency. Left emtpy.');\n  }\n  if (right.size === 0) {\n    throw Error('Internal inconsistency. Right emtpy.');\n  }\n  return {\n    left: left,\n    right: right\n  };\n}\nfunction buildNode(src) {\n  if (src.size === 0) {\n    throw Error('Internal inconsistency');\n  }\n  if (src.size === 1) {\n    return {\n      type: 'leaf',\n      value: Array.from(src.values())[0]\n    };\n  }\n  var _forkMap = forkMap(src),\n    left = _forkMap.left,\n    right = _forkMap.right;\n  return {\n    type: 'fork',\n    left: buildEdge(left),\n    right: buildEdge(right)\n  };\n}\nfunction buildEdge(src) {\n  if (src.size === 0) {\n    throw Error('Internal inconsistency');\n  }\n  var label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()));\n  return {\n    label: label,\n    node: buildNode(removePrefixMap(src, label.length))\n  };\n}\nfunction buildTree(src, keyLength) {\n  // Convert map keys\n  var converted = new Map();\n  for (var _i = 0, _Array$from = Array.from(src.keys()); _i < _Array$from.length; _i++) {\n    var k = _Array$from[_i];\n    var padded = pad(new bn_js_1.BN(k).toString(2), keyLength);\n    converted.set(padded, src.get(k));\n  }\n  // Calculate root label\n  return buildEdge(converted);\n}\nexports.buildTree = buildTree;\n//\n// Serialization\n//\nfunction writeLabelShort(src, to) {\n  // Header\n  to.writeBit(0);\n  // Unary length\n  for (var i = 0; i < src.length; i++) {\n    to.writeBit(1);\n  }\n  to.writeBit(0);\n  // Value\n  for (var _i2 = 0; _i2 < src.length; _i2++) {\n    to.writeBit(src[_i2] === '1');\n  }\n  return to;\n}\nexports.writeLabelShort = writeLabelShort;\nfunction labelShortLength(src) {\n  return 1 + src.length + 1 + src.length;\n}\nfunction writeLabelLong(src, keyLength, to) {\n  // Header\n  to.writeBit(1);\n  to.writeBit(0);\n  // Length\n  var length = Math.ceil(Math.log2(keyLength + 1));\n  to.writeUint(src.length, length);\n  // Value\n  for (var i = 0; i < src.length; i++) {\n    to.writeBit(src[i] === '1');\n  }\n  return to;\n}\nexports.writeLabelLong = writeLabelLong;\nfunction labelLongLength(src, keyLength) {\n  return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;\n}\nfunction writeLabelSame(value, length, keyLength, to) {\n  // Header\n  to.writeBit(1);\n  to.writeBit(1);\n  // Value\n  to.writeBit(value);\n  // Length\n  var lenLen = Math.ceil(Math.log2(keyLength + 1));\n  to.writeUint(length, lenLen);\n}\nexports.writeLabelSame = writeLabelSame;\nfunction labelSameLength(keyLength) {\n  return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));\n}\nfunction isSame(src) {\n  if (src.length === 0 || src.length === 1) {\n    return true;\n  }\n  for (var i = 1; i < src.length; i++) {\n    if (src[i] !== src[0]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction detectLabelType(src, keyLength) {\n  var kind = 'short';\n  var kindLength = labelShortLength(src);\n  var longLength = labelLongLength(src, keyLength);\n  if (longLength < kindLength) {\n    kindLength = longLength;\n    kind = 'long';\n  }\n  if (isSame(src)) {\n    var sameLength = labelSameLength(keyLength);\n    if (sameLength < kindLength) {\n      kindLength = sameLength;\n      kind = 'same';\n    }\n  }\n  return kind;\n}\nexports.detectLabelType = detectLabelType;\nfunction writeLabel(src, keyLength, to) {\n  var type = detectLabelType(src, keyLength);\n  if (type === 'short') {\n    writeLabelShort(src, to);\n  }\n  if (type === 'long') {\n    writeLabelLong(src, keyLength, to);\n  }\n  if (type === 'same') {\n    writeLabelSame(src[0] === '1', src.length, keyLength, to);\n  }\n}\nfunction writeNode(src, keyLength, serializer, to) {\n  if (src.type === 'leaf') {\n    serializer(src.value, to);\n  }\n  if (src.type === 'fork') {\n    var leftCell = new Cell_1.Cell();\n    var rightCell = new Cell_1.Cell();\n    writeEdge(src.left, keyLength - 1, serializer, leftCell);\n    writeEdge(src.right, keyLength - 1, serializer, rightCell);\n    to.refs.push(leftCell);\n    to.refs.push(rightCell);\n  }\n}\nfunction writeEdge(src, keyLength, serializer, to) {\n  writeLabel(src.label, keyLength, to.bits);\n  writeNode(src.node, keyLength - src.label.length, serializer, to);\n}\nfunction serializeDict(src, keyLength, serializer) {\n  var tree = buildTree(src, keyLength);\n  var dest = new Cell_1.Cell();\n  writeEdge(tree, keyLength, serializer, dest);\n  return dest;\n}\nexports.serializeDict = serializeDict;","map":{"version":3,"names":["Object","defineProperty","exports","value","serializeDict","detectLabelType","writeLabelSame","writeLabelLong","writeLabelShort","buildTree","bn_js_1","require","Cell_1","findCommonPrefix_1","pad","src","size","length","removePrefixMap","res","Map","keys","k","d","get","set","slice","forkMap","Error","left","right","startsWith","substr","buildNode","type","Array","from","values","buildEdge","label","findCommonPrefix","node","keyLength","converted","padded","BN","toString","to","writeBit","i","labelShortLength","Math","ceil","log2","writeUint","labelLongLength","lenLen","labelSameLength","isSame","kind","kindLength","longLength","sameLength","writeLabel","writeNode","serializer","leftCell","Cell","rightCell","writeEdge","refs","push","bits","tree","dest"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/boc/dict/serializeDict.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeDict = exports.detectLabelType = exports.writeLabelSame = exports.writeLabelLong = exports.writeLabelShort = exports.buildTree = void 0;\nconst bn_js_1 = require(\"bn.js\");\nconst Cell_1 = require(\"../Cell\");\nconst findCommonPrefix_1 = require(\"./utils/findCommonPrefix\");\n//\n// Tree Build\n//\nfunction pad(src, size) {\n    while (src.length < size) {\n        src = '0' + src;\n    }\n    return src;\n}\nfunction removePrefixMap(src, length) {\n    if (length === 0) {\n        return src;\n    }\n    else {\n        let res = new Map();\n        for (let k of src.keys()) {\n            let d = src.get(k);\n            res.set(k.slice(length), d);\n        }\n        return res;\n    }\n}\nfunction forkMap(src) {\n    if (src.size === 0) {\n        throw Error('Internal inconsistency');\n    }\n    let left = new Map();\n    let right = new Map();\n    for (let k of src.keys()) {\n        let d = src.get(k);\n        if (k.startsWith('0')) {\n            left.set(k.substr(1), d);\n        }\n        else {\n            right.set(k.substr(1), d);\n        }\n    }\n    if (left.size === 0) {\n        throw Error('Internal inconsistency. Left emtpy.');\n    }\n    if (right.size === 0) {\n        throw Error('Internal inconsistency. Right emtpy.');\n    }\n    return { left, right };\n}\nfunction buildNode(src) {\n    if (src.size === 0) {\n        throw Error('Internal inconsistency');\n    }\n    if (src.size === 1) {\n        return { type: 'leaf', value: Array.from(src.values())[0] };\n    }\n    let { left, right } = forkMap(src);\n    return {\n        type: 'fork',\n        left: buildEdge(left),\n        right: buildEdge(right)\n    };\n}\nfunction buildEdge(src) {\n    if (src.size === 0) {\n        throw Error('Internal inconsistency');\n    }\n    const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()));\n    return { label, node: buildNode(removePrefixMap(src, label.length)) };\n}\nfunction buildTree(src, keyLength) {\n    // Convert map keys\n    let converted = new Map();\n    for (let k of Array.from(src.keys())) {\n        const padded = pad(new bn_js_1.BN(k).toString(2), keyLength);\n        converted.set(padded, src.get(k));\n    }\n    // Calculate root label\n    return buildEdge(converted);\n}\nexports.buildTree = buildTree;\n//\n// Serialization\n//\nfunction writeLabelShort(src, to) {\n    // Header\n    to.writeBit(0);\n    // Unary length\n    for (let i = 0; i < src.length; i++) {\n        to.writeBit(1);\n    }\n    to.writeBit(0);\n    // Value\n    for (let i = 0; i < src.length; i++) {\n        to.writeBit(src[i] === '1');\n    }\n    return to;\n}\nexports.writeLabelShort = writeLabelShort;\nfunction labelShortLength(src) {\n    return 1 + src.length + 1 + src.length;\n}\nfunction writeLabelLong(src, keyLength, to) {\n    // Header\n    to.writeBit(1);\n    to.writeBit(0);\n    // Length\n    let length = Math.ceil(Math.log2(keyLength + 1));\n    to.writeUint(src.length, length);\n    // Value\n    for (let i = 0; i < src.length; i++) {\n        to.writeBit(src[i] === '1');\n    }\n    return to;\n}\nexports.writeLabelLong = writeLabelLong;\nfunction labelLongLength(src, keyLength) {\n    return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;\n}\nfunction writeLabelSame(value, length, keyLength, to) {\n    // Header\n    to.writeBit(1);\n    to.writeBit(1);\n    // Value\n    to.writeBit(value);\n    // Length\n    let lenLen = Math.ceil(Math.log2(keyLength + 1));\n    to.writeUint(length, lenLen);\n}\nexports.writeLabelSame = writeLabelSame;\nfunction labelSameLength(keyLength) {\n    return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));\n}\nfunction isSame(src) {\n    if (src.length === 0 || src.length === 1) {\n        return true;\n    }\n    for (let i = 1; i < src.length; i++) {\n        if (src[i] !== src[0]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction detectLabelType(src, keyLength) {\n    let kind = 'short';\n    let kindLength = labelShortLength(src);\n    let longLength = labelLongLength(src, keyLength);\n    if (longLength < kindLength) {\n        kindLength = longLength;\n        kind = 'long';\n    }\n    if (isSame(src)) {\n        let sameLength = labelSameLength(keyLength);\n        if (sameLength < kindLength) {\n            kindLength = sameLength;\n            kind = 'same';\n        }\n    }\n    return kind;\n}\nexports.detectLabelType = detectLabelType;\nfunction writeLabel(src, keyLength, to) {\n    let type = detectLabelType(src, keyLength);\n    if (type === 'short') {\n        writeLabelShort(src, to);\n    }\n    if (type === 'long') {\n        writeLabelLong(src, keyLength, to);\n    }\n    if (type === 'same') {\n        writeLabelSame(src[0] === '1', src.length, keyLength, to);\n    }\n}\nfunction writeNode(src, keyLength, serializer, to) {\n    if (src.type === 'leaf') {\n        serializer(src.value, to);\n    }\n    if (src.type === 'fork') {\n        const leftCell = new Cell_1.Cell();\n        const rightCell = new Cell_1.Cell();\n        writeEdge(src.left, keyLength - 1, serializer, leftCell);\n        writeEdge(src.right, keyLength - 1, serializer, rightCell);\n        to.refs.push(leftCell);\n        to.refs.push(rightCell);\n    }\n}\nfunction writeEdge(src, keyLength, serializer, to) {\n    writeLabel(src.label, keyLength, to.bits);\n    writeNode(src.node, keyLength - src.label.length, serializer, to);\n}\nfunction serializeDict(src, keyLength, serializer) {\n    const tree = buildTree(src, keyLength);\n    const dest = new Cell_1.Cell();\n    writeEdge(tree, keyLength, serializer, dest);\n    return dest;\n}\nexports.serializeDict = serializeDict;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}