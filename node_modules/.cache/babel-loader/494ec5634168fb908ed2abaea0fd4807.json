{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _slicedToArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _get = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _objectSpread = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _objectWithoutProperties = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _excluded = [\"keyPair\"],\n  _excluded2 = [\"walletUrl\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConnectedMeteorWalletAccount = exports.MeteorWallet = void 0;\nvar near_api_js_1 = require(\"near-api-js\");\n// import { Action, createTransaction, Transaction } from \"near-api-js/lib/transaction\";\nvar ExternalActionTypes_1 = require(\"../../meteor-common/src/models/external_actions/ExternalActionTypes\");\nvar borsh_1 = require(\"borsh\");\nvar StringUtils_1 = require(\"../../meteor-common/src/utils/StringUtils\");\n// import { PublicKey } from \"near-api-js/lib/utils\";\nvar EnvironmentStorageUtils_1 = require(\"../../meteor-common/src/utils/EnvironmentStorageUtils\");\nvar TransactionSchema_1 = require(\"./near-schema/TransactionSchema\");\nvar MeteorSdkUtils_1 = require(\"./utils/MeteorSdkUtils\");\nvar MeteorPostMessenger_1 = require(\"./postMessage/MeteorPostMessenger\");\nvar LOGIN_WALLET_URL_SUFFIX = \"/login/\";\nvar SIGN_WALLET_URL_SUFFIX = \"/sign/\";\nvar MULTISIG_HAS_METHOD = \"add_request_and_confirm\";\nvar LOCAL_STORAGE_KEY_SUFFIX = \"_meteor_wallet_auth_key\";\nvar PENDING_ACCESS_KEY_PREFIX = \"pending_key\"; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\nvar localStorageAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({\n  getString: function getString(key) {\n    return window.localStorage.getItem(key);\n  },\n  setString: function setString(key, value) {\n    return window.localStorage.setItem(key, value);\n  },\n  clear: function clear(key) {\n    return window.localStorage.removeItem(key);\n  }\n});\nvar sessionAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({\n  getString: function getString(key) {\n    return window.sessionStorage.getItem(key);\n  },\n  setString: function setString(key, value) {\n    return window.sessionStorage.setItem(key, value);\n  },\n  clear: function clear(key) {\n    return window.sessionStorage.removeItem(key);\n  }\n});\n/**\r\n * This class is used in conjunction with `near-api-js` and `BrowserLocalStorageKeyStore`.\r\n * It directs users to the Meteor Extension or (if not available) a popup of the Meteor Wallet website for key management.\r\n *\r\n * @example\r\n * ```js\r\n * import { MeteorWallet } from \"@meteorwallet/sdk\";\r\n *\r\n * // create new MeteorWallet instance (passing in your initialized Near connection)\r\n * const meteorWallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });\r\n *\r\n * // -- or -- (for a quick and default Near connection config)\r\n * const meteorWallet = MeteorWallet.init({ networkId: \"testnet\" });\r\n *\r\n * // If not signed in, start the sign-in flow with Meteor Wallet.\r\n * // Keys will be stored in the BrowserLocalStorageKeyStore\r\n * if(!meteorWallet.isSignedIn()) {\r\n *   const { accountId } = await meteorWallet.requestSignIn();\r\n * }\r\n * ```\r\n */\nvar MeteorWallet = /*#__PURE__*/function () {\n  /**\r\n   * Construct MeteorWallet. If you'd a quick and default way, you can also use {@link MeteorWallet.init}\r\n   *\r\n   * @example\r\n   * ```js\r\n   * // create new MeteorWallet instance (passing in your initialized Near connection)\r\n   * const meteorWallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });\r\n   *\r\n   * if(!meteorWallet.isSignedIn()) {\r\n   *   const { accountId } = await meteorWallet.requestSignIn();\r\n   * }\r\n   * ```\r\n   */\n  function MeteorWallet(_a) {\n    _classCallCheck(this, MeteorWallet);\n    var _b, _c;\n    var near = _a.near,\n      _a$appKeyPrefix = _a.appKeyPrefix,\n      appKeyPrefix = _a$appKeyPrefix === void 0 ? (_b = near.config.contractName) !== null && _b !== void 0 ? _b : \"default\" : _a$appKeyPrefix;\n    /** @hidden */\n    this._initializationPromises = [];\n    this._near = near;\n    var authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n    this._authDataKey = authDataKey;\n    this._authData = (_c = localStorageAdapter.getJson(authDataKey)) !== null && _c !== void 0 ? _c : {\n      allKeys: []\n    };\n    this._networkId = near.config.networkId;\n    this._walletBaseUrl = near.config.walletUrl;\n    this._keyStore = near.connection.signer.keyStore;\n    /*\r\n    console.log(\"Initialized wallet- checking if signed in\");\r\n          if (!this.isSignedIn()) {\r\n      console.log(\"Completing sign-in process, if its available\");\r\n      this._initializationPromises.push(this._completeSignInWithAccessKey());\r\n    }*/\n  }\n  /**\r\n   * The easiest way to set up the SDK. Returns an instance of MeteorWallet, automatically connected to the Near API.\r\n   *\r\n   * If you need more control over the Near Network configuration- rather use {@link MeteorWallet:constructor}\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const wallet = await MeteorWallet.init({ networkId: \"testnet\" });\r\n   * ```\r\n   */\n  _createClass(MeteorWallet, [{\n    key: \"isExtensionInstalled\",\n    value:\n    /* async initialize() {\r\n       await Promise.all(this._initializationPromises);\r\n     }*/\n    function isExtensionInstalled() {\n      return window.meteorWallet != null;\n    }\n    /**\r\n     * Returns true, if this app is authorized with an account in the wallet.\r\n     * @example\r\n     * ```js\r\n     * const wallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });\r\n     * wallet.isSignedIn();\r\n     * ```\r\n     */\n  }, {\n    key: \"isSignedIn\",\n    value: function isSignedIn() {\n      return !!this._authData.accountId;\n    }\n    /**\r\n     * Returns authorized Account ID.\r\n     * @example\r\n     * ```js\r\n     * const wallet = new MeteorWallet(near, 'my-app');\r\n     * const accountId = wallet.getAccountId();\r\n     * ```\r\n     */\n  }, {\n    key: \"getAccountId\",\n    value: function getAccountId() {\n      return this._authData.accountId;\n    }\n    /**\r\n     * Verifies that the user is the owner of a specific Near account, available in the wallet.\r\n     * Removes the need to do blockchain operations for simple Dapp actions.\r\n     * Signs a payload with the wallet's private key. Will return a promise with a payload like so:\r\n     *\r\n     * ```ts\r\n     * interface VerifiedOwner {\r\n     *   accountId: string;\r\n     *   message: string;                 // The same passed message, unencrypted\r\n     *   blockId: string;\r\n     *   publicKey: string;               // The public key which should be verified as belonging to this account\r\n     *   signature: string;               // The signed payload (this exact same object JSON stringified, excluding this \"signature\" property)\r\n     *   keyType: utils.key_pair.KeyType; // Type from inside the near-api-js package\r\n     * }\r\n     * ```\r\n     *\r\n     * or throw a {@link MeteorActionError} error if the verification failed for whatever reason.\r\n     * */\n  }, {\n    key: \"verifyOwner\",\n    value: function () {\n      var _verifyOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n        var _a, accountId, response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                accountId = (_a = options.accountId) !== null && _a !== void 0 ? _a : this.getAccountId();\n                _context.next = 3;\n                return (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\n                  actionType: ExternalActionTypes_1.EWalletExternalActionType.verify_owner,\n                  inputs: {\n                    accountId: accountId,\n                    message: options.message\n                  },\n                  network: this._networkId\n                });\n              case 3:\n                response = _context.sent;\n                if (!response.success) {\n                  _context.next = 8;\n                  break;\n                }\n                return _context.abrupt(\"return\", response);\n              case 8:\n                throw new ExternalActionTypes_1.MeteorActionError({\n                  endTags: response.endTags,\n                  message: response.message\n                });\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function verifyOwner(_x) {\n        return _verifyOwner.apply(this, arguments);\n      }\n      return verifyOwner;\n    }()\n    /**\r\n     * Requests a sign-in using Meteor Wallet. Will return a promise with the `accountId` of the\r\n     * signed-in account, or throw a {@link MeteorActionError} error if the sign-in failed for whatever reason.\r\n     * */\n  }, {\n    key: \"requestSignIn\",\n    value: function () {\n      var _requestSignIn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {\n        var keyPair, restOptions, accessKey, usingPublicKey, response, _response$payload, allKeys, accountId;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                keyPair = options.keyPair, restOptions = _objectWithoutProperties(options, _excluded);\n                accessKey = keyPair !== null && keyPair !== void 0 ? keyPair : near_api_js_1.KeyPair.fromRandom(\"ed25519\");\n                usingPublicKey = accessKey.getPublicKey().toString();\n                _context2.next = 5;\n                return (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\n                  actionType: ExternalActionTypes_1.EWalletExternalActionType.login,\n                  inputs: _objectSpread({\n                    public_key: usingPublicKey\n                  }, restOptions),\n                  network: this._networkId\n                });\n              case 5:\n                response = _context2.sent;\n                if (!response.success) {\n                  _context2.next = 15;\n                  break;\n                }\n                _response$payload = response.payload, allKeys = _response$payload.allKeys, accountId = _response$payload.accountId;\n                this._authData = {\n                  accountId: accountId,\n                  allKeys: allKeys,\n                  signedInContract: {\n                    contract_id: restOptions.contract_id,\n                    public_key: usingPublicKey\n                  }\n                };\n                localStorageAdapter.setJson(this._authDataKey, this._authData);\n                _context2.next = 12;\n                return this._keyStore.setKey(this._networkId, accountId, accessKey);\n              case 12:\n                return _context2.abrupt(\"return\", {\n                  success: true,\n                  endTags: [],\n                  payload: {\n                    accessKey: accessKey,\n                    accountId: accountId\n                  }\n                });\n              case 15:\n                throw new ExternalActionTypes_1.MeteorActionError({\n                  endTags: response.endTags,\n                  message: response.message\n                });\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function requestSignIn(_x2) {\n        return _requestSignIn.apply(this, arguments);\n      }\n      return requestSignIn;\n    }()\n    /**\r\n     * Sign out from the current account\r\n     */\n  }, {\n    key: \"signOut\",\n    value: function () {\n      var _signOut = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var accountId, inputs, response;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                accountId = this.getAccountId();\n                if (!(this._authData.signedInContract != null && accountId != null)) {\n                  _context3.next = 6;\n                  break;\n                }\n                inputs = {\n                  accountId: accountId,\n                  contractInfo: this._authData.signedInContract\n                };\n                _context3.next = 5;\n                return (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\n                  actionType: ExternalActionTypes_1.EWalletExternalActionType.logout,\n                  inputs: inputs,\n                  network: this._networkId\n                });\n              case 5:\n                response = _context3.sent;\n              case 6:\n                this._authData = {\n                  allKeys: []\n                };\n                localStorageAdapter.clear(this._authDataKey);\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function signOut() {\n        return _signOut.apply(this, arguments);\n      }\n      return signOut;\n    }()\n    /**\r\n     * Sign transactions using Meteor Wallet. Will return a promise with an array of `FinalExecutionOutcome`\r\n     * of the given transactions.\r\n     * */\n  }, {\n    key: \"requestSignTransactions\",\n    value: function () {\n      var _requestSignTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(inputs) {\n        var transactions, response;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                transactions = inputs.transactions;\n                _context4.next = 3;\n                return (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\n                  actionType: ExternalActionTypes_1.EWalletExternalActionType.sign,\n                  inputs: {\n                    transactions: transactions.map(function (transaction) {\n                      return (0, borsh_1.serialize)(TransactionSchema_1.SCHEMA, transaction);\n                    }).map(function (serialized) {\n                      return Buffer.from(serialized).toString(\"base64\");\n                    }).join(\",\")\n                  },\n                  // inputs: { public_key: usingPublicKey, ...options },\n                  network: this._networkId\n                });\n              case 3:\n                response = _context4.sent;\n                if (!response.success) {\n                  _context4.next = 8;\n                  break;\n                }\n                return _context4.abrupt(\"return\", response.payload.executionOutcomes);\n              case 8:\n                throw new ExternalActionTypes_1.MeteorActionError({\n                  endTags: response.endTags,\n                  message: response.message\n                });\n              case 9:\n                return _context4.abrupt(\"return\", []);\n              case 10:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function requestSignTransactions(_x3) {\n        return _requestSignTransactions.apply(this, arguments);\n      }\n      return requestSignTransactions;\n    }()\n    /**\r\n     * Returns the current connected wallet account\r\n     */\n  }, {\n    key: \"account\",\n    value: function account() {\n      var currentAccountId = this.getAccountId();\n      if (!this._connectedAccount && (0, StringUtils_1.notNullEmpty)(currentAccountId)) {\n        this._connectedAccount = new ConnectedMeteorWalletAccount(this, this._near.connection, currentAccountId);\n      }\n      return this._connectedAccount;\n    }\n  }], [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref) {\n        var walletUrl, config, keyStore, near, wallet;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                walletUrl = _ref.walletUrl, config = _objectWithoutProperties(_ref, _excluded2);\n                keyStore = new near_api_js_1.keyStores.BrowserLocalStorageKeyStore();\n                _context5.next = 4;\n                return (0, near_api_js_1.connect)(_objectSpread(_objectSpread({\n                  keyStore: keyStore,\n                  headers: {},\n                  walletUrl: (0, MeteorSdkUtils_1.resolveWalletUrl)(config.networkId, walletUrl)\n                }, (0, MeteorSdkUtils_1.getNetworkPreset)(config.networkId)), config));\n              case 4:\n                near = _context5.sent;\n                wallet = new MeteorWallet({\n                  near: near,\n                  appKeyPrefix: \"near_app\"\n                }); // Cleanup up any pending keys (cancelled logins).\n                if (wallet.isSignedIn()) {\n                  _context5.next = 9;\n                  break;\n                }\n                _context5.next = 9;\n                return keyStore.clear();\n              case 9:\n                return _context5.abrupt(\"return\", wallet);\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n      function init(_x4) {\n        return _init.apply(this, arguments);\n      }\n      return init;\n    }()\n  }]);\n  return MeteorWallet;\n}();\nexports.MeteorWallet = MeteorWallet;\n/**\r\n * Near Account implementation which makes use of {@link MeteorWallet} when no local key is available.\r\n *\r\n * Generally won't be created directly- can be obtained by using {@link MeteorWallet.account}\r\n *\r\n * @example\r\n * ```js\r\n * const account = meteorWallet.account();\r\n *\r\n * // uses Meteor Wallet to sign the transaction using this account\r\n * const response = await account.requestSignTransaction({\r\n *   actions: transactionActions,\r\n *   receiverId: \"my-contract\"\r\n * });\r\n * ```\r\n */\nvar ConnectedMeteorWalletAccount = /*#__PURE__*/function (_near_api_js_1$Accoun) {\n  _inherits(ConnectedMeteorWalletAccount, _near_api_js_1$Accoun);\n  var _super = _createSuper(ConnectedMeteorWalletAccount);\n  /** @hidden */\n  function ConnectedMeteorWalletAccount(walletConnection, connection, accountId) {\n    var _this;\n    _classCallCheck(this, ConnectedMeteorWalletAccount);\n    _this = _super.call(this, connection, accountId);\n    _this.meteorWallet = walletConnection;\n    return _this;\n  }\n  /**\r\n   * Sign a transaction using Meteor Wallet. Overrides the Near Account API method of the same name, makes use of {@link ConnectedMeteorWalletAccount.signAndSendTransaction_direct}\r\n   */\n  _createClass(ConnectedMeteorWalletAccount, [{\n    key: \"signAndSendTransaction\",\n    value: function () {\n      var _signAndSendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(typeof (_args6.length <= 0 ? undefined : _args6[0]) === \"string\")) {\n                  _context6.next = 2;\n                  break;\n                }\n                return _context6.abrupt(\"return\", this.signAndSendTransaction_direct({\n                  receiverId: _args6.length <= 0 ? undefined : _args6[0],\n                  actions: _args6.length <= 1 ? undefined : _args6[1]\n                }));\n              case 2:\n                return _context6.abrupt(\"return\", this.signAndSendTransaction_direct(_args6.length <= 0 ? undefined : _args6[0]));\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function signAndSendTransaction() {\n        return _signAndSendTransaction.apply(this, arguments);\n      }\n      return signAndSendTransaction;\n    }() /** @hidden */\n  }, {\n    key: \"trySendOrCreateTransaction\",\n    value: function () {\n      var _trySendOrCreateTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref2) {\n        var receiverId, actions, localKey, accessKey, block, blockHash, publicKey, nonce, transaction;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                receiverId = _ref2.receiverId, actions = _ref2.actions;\n                _context7.next = 3;\n                return this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n              case 3:\n                localKey = _context7.sent;\n                _context7.next = 6;\n                return this.accessKeyForTransaction(receiverId, actions, localKey);\n              case 6:\n                accessKey = _context7.sent;\n                if (accessKey) {\n                  _context7.next = 9;\n                  break;\n                }\n                throw new Error(\"Cannot find matching key for transaction sent to \".concat(receiverId));\n              case 9:\n                if (!(localKey && localKey.toString() === accessKey.public_key)) {\n                  _context7.next = 26;\n                  break;\n                }\n                _context7.prev = 10;\n                _context7.next = 13;\n                return _get(_getPrototypeOf(ConnectedMeteorWalletAccount.prototype), \"signAndSendTransaction\", this).call(this, {\n                  receiverId: receiverId,\n                  actions: actions\n                });\n              case 13:\n                _context7.t0 = _context7.sent;\n                return _context7.abrupt(\"return\", {\n                  executionOutcome: _context7.t0,\n                  sent: true\n                });\n              case 17:\n                _context7.prev = 17;\n                _context7.t1 = _context7[\"catch\"](10);\n                if (!(_context7.t1.type === \"NotEnoughAllowance\")) {\n                  _context7.next = 25;\n                  break;\n                }\n                _context7.next = 22;\n                return this.accessKeyForTransaction(receiverId, actions);\n              case 22:\n                accessKey = _context7.sent;\n                _context7.next = 26;\n                break;\n              case 25:\n                throw _context7.t1;\n              case 26:\n                _context7.next = 28;\n                return this.connection.provider.block({\n                  finality: \"final\"\n                });\n              case 28:\n                block = _context7.sent;\n                blockHash = (0, borsh_1.baseDecode)(block.header.hash);\n                publicKey = near_api_js_1.utils.PublicKey.from(accessKey.public_key); // TODO: Cache & listen for nonce updates for given access key\n                nonce = accessKey.access_key.nonce + 1;\n                transaction = near_api_js_1.transactions.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n                return _context7.abrupt(\"return\", {\n                  sent: false,\n                  transaction: transaction\n                });\n              case 34:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[10, 17]]);\n      }));\n      function trySendOrCreateTransaction(_x5) {\n        return _trySendOrCreateTransaction.apply(this, arguments);\n      }\n      return trySendOrCreateTransaction;\n    }()\n    /**\r\n     * Sign a transaction using Meteor Wallet\r\n     * @see {@link MeteorWallet.requestSignTransactions}\r\n     */\n  }, {\n    key: \"signAndSendTransaction_direct\",\n    value: function () {\n      var _signAndSendTransaction_direct = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref3) {\n        var receiverId, actions, _yield$this$trySendOr, transaction, sent, executionOutcome;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                receiverId = _ref3.receiverId, actions = _ref3.actions;\n                _context8.next = 3;\n                return this.trySendOrCreateTransaction({\n                  receiverId: receiverId,\n                  actions: actions\n                });\n              case 3:\n                _yield$this$trySendOr = _context8.sent;\n                transaction = _yield$this$trySendOr.transaction;\n                sent = _yield$this$trySendOr.sent;\n                executionOutcome = _yield$this$trySendOr.executionOutcome;\n                if (!sent) {\n                  _context8.next = 9;\n                  break;\n                }\n                return _context8.abrupt(\"return\", executionOutcome);\n              case 9:\n                _context8.next = 11;\n                return this.meteorWallet.requestSignTransactions({\n                  transactions: [transaction]\n                });\n              case 11:\n                return _context8.abrupt(\"return\", _context8.sent[0]);\n              case 12:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n      function signAndSendTransaction_direct(_x6) {\n        return _signAndSendTransaction_direct.apply(this, arguments);\n      }\n      return signAndSendTransaction_direct;\n    }()\n    /** @hidden */\n    /*async signAndSendTransaction_redirect({\r\n      receiverId,\r\n      actions,\r\n      walletMeta,\r\n      walletCallbackUrl = window.location.href,\r\n    }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome> {\r\n      const { transaction, sent, executionOutcome } = await this.trySendOrCreateTransaction({ receiverId, actions });\r\n          if (sent) {\r\n        return executionOutcome!;\r\n      }\r\n          await this.meteorWallet.requestSignTransactions_redirect({\r\n        transactions: [transaction!],\r\n        meta: walletMeta,\r\n        callback_url: walletCallbackUrl,\r\n      });\r\n          return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n          reject(new Error(\"Failed to redirect to sign transaction\"));\r\n        }, 1000);\r\n      });\r\n    }*/\n    /**\r\n     * Check if given access key allows the function call or method attempted in transaction\r\n     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\r\n     * @param receiverId The NEAR account attempting to have access\r\n     * @param actions The action(s) needed to be checked for access\r\n     */\n  }, {\n    key: \"accessKeyMatchesTransaction\",\n    value: function () {\n      var _accessKeyMatchesTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(accessKey, receiverId, actions) {\n        var permission, _permission$FunctionC, allowedReceiverId, allowedMethods, _actions, functionCall;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                permission = accessKey.access_key.permission;\n                if (!(permission === \"FullAccess\")) {\n                  _context9.next = 3;\n                  break;\n                }\n                return _context9.abrupt(\"return\", true);\n              case 3:\n                if (!permission.FunctionCall) {\n                  _context9.next = 12;\n                  break;\n                }\n                _permission$FunctionC = permission.FunctionCall, allowedReceiverId = _permission$FunctionC.receiver_id, allowedMethods = _permission$FunctionC.method_names;\n                /********************************\r\n                 Accept multisig access keys and let wallets attempt to signAndSendTransaction\r\n                 If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\r\n                 ********************************/\n                if (!(allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD))) {\n                  _context9.next = 7;\n                  break;\n                }\n                return _context9.abrupt(\"return\", true);\n              case 7:\n                if (!(allowedReceiverId === receiverId)) {\n                  _context9.next = 12;\n                  break;\n                }\n                if (!(actions.length !== 1)) {\n                  _context9.next = 10;\n                  break;\n                }\n                return _context9.abrupt(\"return\", false);\n              case 10:\n                _actions = _slicedToArray(actions, 1), functionCall = _actions[0].functionCall;\n                return _context9.abrupt(\"return\", functionCall && (!functionCall.deposit || functionCall.deposit.toString() === \"0\") && (\n                // TODO: Should support charging amount smaller than allowance?\n                allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName)));\n              case 12:\n                return _context9.abrupt(\"return\", false);\n              case 13:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n      function accessKeyMatchesTransaction(_x7, _x8, _x9) {\n        return _accessKeyMatchesTransaction.apply(this, arguments);\n      }\n      return accessKeyMatchesTransaction;\n    }()\n    /**\r\n     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\r\n     * @param receiverId The NEAR account seeking the access key for a transaction\r\n     * @param actions The action(s) sought to gain access to\r\n     * @param localKey A local public key provided to check for access\r\n     * @returns Promise<any>\r\n     */\n  }, {\n    key: \"accessKeyForTransaction\",\n    value: function () {\n      var _accessKeyForTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(receiverId, actions, localKey) {\n        var accessKeys, accessKey, walletKeys, _iterator, _step, _accessKey;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.getAccessKeys();\n              case 2:\n                accessKeys = _context10.sent;\n                if (!localKey) {\n                  _context10.next = 12;\n                  break;\n                }\n                accessKey = accessKeys.find(function (key) {\n                  return key.public_key.toString() === localKey.toString();\n                });\n                _context10.t0 = accessKey;\n                if (!_context10.t0) {\n                  _context10.next = 10;\n                  break;\n                }\n                _context10.next = 9;\n                return this.accessKeyMatchesTransaction(accessKey, receiverId, actions);\n              case 9:\n                _context10.t0 = _context10.sent;\n              case 10:\n                if (!_context10.t0) {\n                  _context10.next = 12;\n                  break;\n                }\n                return _context10.abrupt(\"return\", accessKey);\n              case 12:\n                walletKeys = this.meteorWallet._authData.allKeys;\n                _iterator = _createForOfIteratorHelper(accessKeys);\n                _context10.prev = 14;\n                _iterator.s();\n              case 16:\n                if ((_step = _iterator.n()).done) {\n                  _context10.next = 27;\n                  break;\n                }\n                _accessKey = _step.value;\n                _context10.t1 = walletKeys.indexOf(_accessKey.public_key) !== -1;\n                if (!_context10.t1) {\n                  _context10.next = 23;\n                  break;\n                }\n                _context10.next = 22;\n                return this.accessKeyMatchesTransaction(_accessKey, receiverId, actions);\n              case 22:\n                _context10.t1 = _context10.sent;\n              case 23:\n                if (!_context10.t1) {\n                  _context10.next = 25;\n                  break;\n                }\n                return _context10.abrupt(\"return\", _accessKey);\n              case 25:\n                _context10.next = 16;\n                break;\n              case 27:\n                _context10.next = 32;\n                break;\n              case 29:\n                _context10.prev = 29;\n                _context10.t2 = _context10[\"catch\"](14);\n                _iterator.e(_context10.t2);\n              case 32:\n                _context10.prev = 32;\n                _iterator.f();\n                return _context10.finish(32);\n              case 35:\n                return _context10.abrupt(\"return\", null);\n              case 36:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[14, 29, 32, 35]]);\n      }));\n      function accessKeyForTransaction(_x10, _x11, _x12) {\n        return _accessKeyForTransaction.apply(this, arguments);\n      }\n      return accessKeyForTransaction;\n    }()\n  }]);\n  return ConnectedMeteorWalletAccount;\n}(near_api_js_1.Account);\nexports.ConnectedMeteorWalletAccount = ConnectedMeteorWalletAccount;","map":{"version":3,"sources":["meteor-sdk/src/MeteorWallet.ts"],"names":[],"mappings":"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","sourceRoot":"./src/","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ConnectedMeteorWalletAccount = exports.MeteorWallet = void 0;\r\nconst near_api_js_1 = require(\"near-api-js\");\r\n// import { Action, createTransaction, Transaction } from \"near-api-js/lib/transaction\";\r\nconst ExternalActionTypes_1 = require(\"../../meteor-common/src/models/external_actions/ExternalActionTypes\");\r\nconst borsh_1 = require(\"borsh\");\r\nconst StringUtils_1 = require(\"../../meteor-common/src/utils/StringUtils\");\r\n// import { PublicKey } from \"near-api-js/lib/utils\";\r\nconst EnvironmentStorageUtils_1 = require(\"../../meteor-common/src/utils/EnvironmentStorageUtils\");\r\nconst TransactionSchema_1 = require(\"./near-schema/TransactionSchema\");\r\nconst MeteorSdkUtils_1 = require(\"./utils/MeteorSdkUtils\");\r\nconst MeteorPostMessenger_1 = require(\"./postMessage/MeteorPostMessenger\");\r\nconst LOGIN_WALLET_URL_SUFFIX = \"/login/\";\r\nconst SIGN_WALLET_URL_SUFFIX = \"/sign/\";\r\nconst MULTISIG_HAS_METHOD = \"add_request_and_confirm\";\r\nconst LOCAL_STORAGE_KEY_SUFFIX = \"_meteor_wallet_auth_key\";\r\nconst PENDING_ACCESS_KEY_PREFIX = \"pending_key\"; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\r\nconst localStorageAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({\r\n    getString: (key) => window.localStorage.getItem(key),\r\n    setString: (key, value) => window.localStorage.setItem(key, value),\r\n    clear: (key) => window.localStorage.removeItem(key),\r\n});\r\nconst sessionAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({\r\n    getString: (key) => window.sessionStorage.getItem(key),\r\n    setString: (key, value) => window.sessionStorage.setItem(key, value),\r\n    clear: (key) => window.sessionStorage.removeItem(key),\r\n});\r\n/**\r\n * This class is used in conjunction with `near-api-js` and `BrowserLocalStorageKeyStore`.\r\n * It directs users to the Meteor Extension or (if not available) a popup of the Meteor Wallet website for key management.\r\n *\r\n * @example\r\n * ```js\r\n * import { MeteorWallet } from \"@meteorwallet/sdk\";\r\n *\r\n * // create new MeteorWallet instance (passing in your initialized Near connection)\r\n * const meteorWallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });\r\n *\r\n * // -- or -- (for a quick and default Near connection config)\r\n * const meteorWallet = MeteorWallet.init({ networkId: \"testnet\" });\r\n *\r\n * // If not signed in, start the sign-in flow with Meteor Wallet.\r\n * // Keys will be stored in the BrowserLocalStorageKeyStore\r\n * if(!meteorWallet.isSignedIn()) {\r\n *   const { accountId } = await meteorWallet.requestSignIn();\r\n * }\r\n * ```\r\n */\r\nclass MeteorWallet {\r\n    /**\r\n     * Construct MeteorWallet. If you'd a quick and default way, you can also use {@link MeteorWallet.init}\r\n     *\r\n     * @example\r\n     * ```js\r\n     * // create new MeteorWallet instance (passing in your initialized Near connection)\r\n     * const meteorWallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });\r\n     *\r\n     * if(!meteorWallet.isSignedIn()) {\r\n     *   const { accountId } = await meteorWallet.requestSignIn();\r\n     * }\r\n     * ```\r\n     */\r\n    constructor(_a) {\r\n        var _b, _c;\r\n        var { near, appKeyPrefix = (_b = near.config.contractName) !== null && _b !== void 0 ? _b : \"default\" } = _a;\r\n        /** @hidden */\r\n        this._initializationPromises = [];\r\n        this._near = near;\r\n        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\r\n        this._authDataKey = authDataKey;\r\n        this._authData = (_c = localStorageAdapter.getJson(authDataKey)) !== null && _c !== void 0 ? _c : { allKeys: [] };\r\n        this._networkId = near.config.networkId;\r\n        this._walletBaseUrl = near.config.walletUrl;\r\n        this._keyStore = near.connection.signer.keyStore;\r\n        /*\r\n        console.log(\"Initialized wallet- checking if signed in\");\r\n    \r\n        if (!this.isSignedIn()) {\r\n          console.log(\"Completing sign-in process, if its available\");\r\n          this._initializationPromises.push(this._completeSignInWithAccessKey());\r\n        }*/\r\n    }\r\n    /**\r\n     * The easiest way to set up the SDK. Returns an instance of MeteorWallet, automatically connected to the Near API.\r\n     *\r\n     * If you need more control over the Near Network configuration- rather use {@link MeteorWallet:constructor}\r\n     *\r\n     * @example\r\n     * ```js\r\n     * const wallet = await MeteorWallet.init({ networkId: \"testnet\" });\r\n     * ```\r\n     */\r\n    static async init({ walletUrl, ...config }) {\r\n        const keyStore = new near_api_js_1.keyStores.BrowserLocalStorageKeyStore();\r\n        const near = await (0, near_api_js_1.connect)({\r\n            keyStore,\r\n            headers: {},\r\n            walletUrl: (0, MeteorSdkUtils_1.resolveWalletUrl)(config.networkId, walletUrl),\r\n            ...(0, MeteorSdkUtils_1.getNetworkPreset)(config.networkId),\r\n            ...config,\r\n        });\r\n        const wallet = new MeteorWallet({ near, appKeyPrefix: \"near_app\" });\r\n        // Cleanup up any pending keys (cancelled logins).\r\n        if (!wallet.isSignedIn()) {\r\n            await keyStore.clear();\r\n        }\r\n        return wallet;\r\n    }\r\n    /* async initialize() {\r\n       await Promise.all(this._initializationPromises);\r\n     }*/\r\n    isExtensionInstalled() {\r\n        return window.meteorWallet != null;\r\n    }\r\n    /**\r\n     * Returns true, if this app is authorized with an account in the wallet.\r\n     * @example\r\n     * ```js\r\n     * const wallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });\r\n     * wallet.isSignedIn();\r\n     * ```\r\n     */\r\n    isSignedIn() {\r\n        return !!this._authData.accountId;\r\n    }\r\n    /**\r\n     * Returns authorized Account ID.\r\n     * @example\r\n     * ```js\r\n     * const wallet = new MeteorWallet(near, 'my-app');\r\n     * const accountId = wallet.getAccountId();\r\n     * ```\r\n     */\r\n    getAccountId() {\r\n        return this._authData.accountId;\r\n    }\r\n    /**\r\n     * Verifies that the user is the owner of a specific Near account, available in the wallet.\r\n     * Removes the need to do blockchain operations for simple Dapp actions.\r\n     * Signs a payload with the wallet's private key. Will return a promise with a payload like so:\r\n     *\r\n     * ```ts\r\n     * interface VerifiedOwner {\r\n     *   accountId: string;\r\n     *   message: string;                 // The same passed message, unencrypted\r\n     *   blockId: string;\r\n     *   publicKey: string;               // The public key which should be verified as belonging to this account\r\n     *   signature: string;               // The signed payload (this exact same object JSON stringified, excluding this \"signature\" property)\r\n     *   keyType: utils.key_pair.KeyType; // Type from inside the near-api-js package\r\n     * }\r\n     * ```\r\n     *\r\n     * or throw a {@link MeteorActionError} error if the verification failed for whatever reason.\r\n     * */\r\n    async verifyOwner(options) {\r\n        var _a;\r\n        const accountId = (_a = options.accountId) !== null && _a !== void 0 ? _a : this.getAccountId();\r\n        const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\r\n            actionType: ExternalActionTypes_1.EWalletExternalActionType.verify_owner,\r\n            inputs: {\r\n                accountId,\r\n                message: options.message,\r\n            },\r\n            network: this._networkId,\r\n        });\r\n        if (response.success) {\r\n            return response;\r\n        }\r\n        else {\r\n            throw new ExternalActionTypes_1.MeteorActionError({\r\n                endTags: response.endTags,\r\n                message: response.message,\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Requests a sign-in using Meteor Wallet. Will return a promise with the `accountId` of the\r\n     * signed-in account, or throw a {@link MeteorActionError} error if the sign-in failed for whatever reason.\r\n     * */\r\n    async requestSignIn(options) {\r\n        const { keyPair, ...restOptions } = options;\r\n        const accessKey = keyPair !== null && keyPair !== void 0 ? keyPair : near_api_js_1.KeyPair.fromRandom(\"ed25519\");\r\n        let usingPublicKey = accessKey.getPublicKey().toString();\r\n        const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\r\n            actionType: ExternalActionTypes_1.EWalletExternalActionType.login,\r\n            inputs: { public_key: usingPublicKey, ...restOptions },\r\n            network: this._networkId,\r\n        });\r\n        if (response.success) {\r\n            const { allKeys, accountId } = response.payload;\r\n            this._authData = {\r\n                accountId,\r\n                allKeys,\r\n                signedInContract: {\r\n                    contract_id: restOptions.contract_id,\r\n                    public_key: usingPublicKey,\r\n                },\r\n            };\r\n            localStorageAdapter.setJson(this._authDataKey, this._authData);\r\n            await this._keyStore.setKey(this._networkId, accountId, accessKey);\r\n            return {\r\n                success: true,\r\n                endTags: [],\r\n                payload: {\r\n                    accessKey,\r\n                    accountId,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            throw new ExternalActionTypes_1.MeteorActionError({\r\n                endTags: response.endTags,\r\n                message: response.message,\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Sign out from the current account\r\n     */\r\n    async signOut() {\r\n        const accountId = this.getAccountId();\r\n        if (this._authData.signedInContract != null && accountId != null) {\r\n            const inputs = {\r\n                accountId,\r\n                contractInfo: this._authData.signedInContract,\r\n            };\r\n            const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\r\n                actionType: ExternalActionTypes_1.EWalletExternalActionType.logout,\r\n                inputs,\r\n                network: this._networkId,\r\n            });\r\n        }\r\n        this._authData = { allKeys: [] };\r\n        localStorageAdapter.clear(this._authDataKey);\r\n    }\r\n    /**\r\n     * Sign transactions using Meteor Wallet. Will return a promise with an array of `FinalExecutionOutcome`\r\n     * of the given transactions.\r\n     * */\r\n    async requestSignTransactions(inputs) {\r\n        const { transactions } = inputs;\r\n        const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\r\n            actionType: ExternalActionTypes_1.EWalletExternalActionType.sign,\r\n            inputs: {\r\n                transactions: transactions\r\n                    .map((transaction) => (0, borsh_1.serialize)(TransactionSchema_1.SCHEMA, transaction))\r\n                    .map((serialized) => Buffer.from(serialized).toString(\"base64\"))\r\n                    .join(\",\"),\r\n            },\r\n            // inputs: { public_key: usingPublicKey, ...options },\r\n            network: this._networkId,\r\n        });\r\n        // console.log(\"Finished sign-in request\", response);\r\n        if (response.success) {\r\n            return response.payload.executionOutcomes;\r\n        }\r\n        else {\r\n            throw new ExternalActionTypes_1.MeteorActionError({\r\n                endTags: response.endTags,\r\n                message: response.message,\r\n            });\r\n        }\r\n        return [];\r\n    }\r\n    /**\r\n     * Returns the current connected wallet account\r\n     */\r\n    account() {\r\n        const currentAccountId = this.getAccountId();\r\n        if (!this._connectedAccount && (0, StringUtils_1.notNullEmpty)(currentAccountId)) {\r\n            this._connectedAccount = new ConnectedMeteorWalletAccount(this, this._near.connection, currentAccountId);\r\n        }\r\n        return this._connectedAccount;\r\n    }\r\n}\r\nexports.MeteorWallet = MeteorWallet;\r\n/**\r\n * Near Account implementation which makes use of {@link MeteorWallet} when no local key is available.\r\n *\r\n * Generally won't be created directly- can be obtained by using {@link MeteorWallet.account}\r\n *\r\n * @example\r\n * ```js\r\n * const account = meteorWallet.account();\r\n *\r\n * // uses Meteor Wallet to sign the transaction using this account\r\n * const response = await account.requestSignTransaction({\r\n *   actions: transactionActions,\r\n *   receiverId: \"my-contract\"\r\n * });\r\n * ```\r\n */\r\nclass ConnectedMeteorWalletAccount extends near_api_js_1.Account {\r\n    /** @hidden */\r\n    constructor(walletConnection, connection, accountId) {\r\n        super(connection, accountId);\r\n        this.meteorWallet = walletConnection;\r\n    }\r\n    /**\r\n     * Sign a transaction using Meteor Wallet. Overrides the Near Account API method of the same name, makes use of {@link ConnectedMeteorWalletAccount.signAndSendTransaction_direct}\r\n     */\r\n    async signAndSendTransaction(...args) {\r\n        if (typeof args[0] === \"string\") {\r\n            return this.signAndSendTransaction_direct({ receiverId: args[0], actions: args[1] });\r\n        }\r\n        return this.signAndSendTransaction_direct(args[0]);\r\n    }\r\n    /** @hidden */\r\n    async trySendOrCreateTransaction({ receiverId, actions, }) {\r\n        const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\r\n        let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);\r\n        if (!accessKey) {\r\n            throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\r\n        }\r\n        if (localKey && localKey.toString() === accessKey.public_key) {\r\n            try {\r\n                return { executionOutcome: await super.signAndSendTransaction({ receiverId, actions }), sent: true };\r\n            }\r\n            catch (e) {\r\n                if (e.type === \"NotEnoughAllowance\") {\r\n                    accessKey = await this.accessKeyForTransaction(receiverId, actions);\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        const block = await this.connection.provider.block({ finality: \"final\" });\r\n        const blockHash = (0, borsh_1.baseDecode)(block.header.hash);\r\n        const publicKey = near_api_js_1.utils.PublicKey.from(accessKey.public_key);\r\n        // TODO: Cache & listen for nonce updates for given access key\r\n        const nonce = accessKey.access_key.nonce + 1;\r\n        const transaction = near_api_js_1.transactions.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\r\n        return {\r\n            sent: false,\r\n            transaction,\r\n        };\r\n    }\r\n    /**\r\n     * Sign a transaction using Meteor Wallet\r\n     * @see {@link MeteorWallet.requestSignTransactions}\r\n     */\r\n    async signAndSendTransaction_direct({ receiverId, actions, }) {\r\n        const { transaction, sent, executionOutcome } = await this.trySendOrCreateTransaction({ receiverId, actions });\r\n        if (sent) {\r\n            return executionOutcome;\r\n        }\r\n        return (await this.meteorWallet.requestSignTransactions({ transactions: [transaction] }))[0];\r\n    }\r\n    /** @hidden */\r\n    /*async signAndSendTransaction_redirect({\r\n      receiverId,\r\n      actions,\r\n      walletMeta,\r\n      walletCallbackUrl = window.location.href,\r\n    }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome> {\r\n      const { transaction, sent, executionOutcome } = await this.trySendOrCreateTransaction({ receiverId, actions });\r\n  \r\n      if (sent) {\r\n        return executionOutcome!;\r\n      }\r\n  \r\n      await this.meteorWallet.requestSignTransactions_redirect({\r\n        transactions: [transaction!],\r\n        meta: walletMeta,\r\n        callback_url: walletCallbackUrl,\r\n      });\r\n  \r\n      return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n          reject(new Error(\"Failed to redirect to sign transaction\"));\r\n        }, 1000);\r\n      });\r\n    }*/\r\n    /**\r\n     * Check if given access key allows the function call or method attempted in transaction\r\n     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\r\n     * @param receiverId The NEAR account attempting to have access\r\n     * @param actions The action(s) needed to be checked for access\r\n     */\r\n    async accessKeyMatchesTransaction(accessKey, receiverId, actions) {\r\n        const { access_key: { permission }, } = accessKey;\r\n        if (permission === \"FullAccess\") {\r\n            return true;\r\n        }\r\n        if (permission.FunctionCall) {\r\n            const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;\r\n            /********************************\r\n             Accept multisig access keys and let wallets attempt to signAndSendTransaction\r\n             If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\r\n             ********************************/\r\n            if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\r\n                return true;\r\n            }\r\n            if (allowedReceiverId === receiverId) {\r\n                if (actions.length !== 1) {\r\n                    return false;\r\n                }\r\n                const [{ functionCall }] = actions;\r\n                return (functionCall &&\r\n                    (!functionCall.deposit || functionCall.deposit.toString() === \"0\") && // TODO: Should support charging amount smaller than allowance?\r\n                    (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName)));\r\n                // TODO: Handle cases when allowance doesn't have enough to pay for gas\r\n            }\r\n        }\r\n        // TODO: Support other permissions than FunctionCall\r\n        return false;\r\n    }\r\n    /**\r\n     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\r\n     * @param receiverId The NEAR account seeking the access key for a transaction\r\n     * @param actions The action(s) sought to gain access to\r\n     * @param localKey A local public key provided to check for access\r\n     * @returns Promise<any>\r\n     */\r\n    async accessKeyForTransaction(receiverId, actions, localKey) {\r\n        const accessKeys = await this.getAccessKeys();\r\n        if (localKey) {\r\n            const accessKey = accessKeys.find((key) => key.public_key.toString() === localKey.toString());\r\n            if (accessKey && (await this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\r\n                return accessKey;\r\n            }\r\n        }\r\n        const walletKeys = this.meteorWallet._authData.allKeys;\r\n        for (const accessKey of accessKeys) {\r\n            if (walletKeys.indexOf(accessKey.public_key) !== -1 &&\r\n                (await this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\r\n                return accessKey;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\nexports.ConnectedMeteorWalletAccount = ConnectedMeteorWalletAccount;\r\n//# sourceMappingURL=MeteorWallet.js.map"]},"metadata":{},"sourceType":"script"}