{"ast":null,"code":"const {\n  BitString\n} = require(\"./BitString\");\nconst {\n  bytesToBase64,\n  compareBytes,\n  concatBytes,\n  crc32c,\n  hexToBytes,\n  readNBytesUIntFromArray,\n  sha256,\n  bytesToHex\n} = require(\"../utils\");\nconst reachBocMagicPrefix = hexToBytes('B5EE9C72');\nconst leanBocMagicPrefix = hexToBytes('68ff65f3');\nconst leanBocMagicPrefixCRC = hexToBytes('acc3a728');\nclass Cell {\n  constructor() {\n    this.bits = new BitString(1023);\n    this.refs = [];\n    this.isExotic = false;\n  }\n\n  /**\n   * @param serializedBoc  {string | Uint8Array} hex or bytearray\n   * @return {Cell[]} root cells\n   */\n  static fromBoc(serializedBoc) {\n    return deserializeBoc(serializedBoc);\n  }\n\n  /**\n   * @param serializedBoc  {string | Uint8Array} hex or bytearray\n   * @return {Cell} root cell\n   */\n  static oneFromBoc(serializedBoc) {\n    const cells = deserializeBoc(serializedBoc);\n    if (cells.length !== 1) throw new Error('expected 1 root cell but have ' + cells.length);\n    return cells[0];\n  }\n\n  /**\n   * Write another cell to this cell\n   * @param anotherCell  {Cell}\n   */\n  writeCell(anotherCell) {\n    // XXX we do not check that there are anough place in cell\n    this.bits.writeBitString(anotherCell.bits);\n    this.refs = this.refs.concat(anotherCell.refs);\n  }\n\n  /**\n   * @return {number}\n   */\n  getMaxLevel() {\n    //TODO level calculation differ for exotic cells\n    let maxLevel = 0;\n    for (let k in this.refs) {\n      const i = this.refs[k];\n      if (i.getMaxLevel() > maxLevel) {\n        maxLevel = i.getMaxLevel();\n      }\n    }\n    return maxLevel;\n  }\n\n  /**\n   * @return {number}\n   */\n  isExplicitlyStoredHashes() {\n    return 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  getMaxDepth() {\n    let maxDepth = 0;\n    if (this.refs.length > 0) {\n      for (let k in this.refs) {\n        const i = this.refs[k];\n        if (i.getMaxDepth() > maxDepth) {\n          maxDepth = i.getMaxDepth();\n        }\n      }\n      maxDepth = maxDepth + 1;\n    }\n    return maxDepth;\n  }\n\n  /**\n   * @private\n   * @return {Uint8Array}\n   */\n  getMaxDepthAsArray() {\n    const maxDepth = this.getMaxDepth();\n    const d = Uint8Array.from({\n      length: 2\n    }, () => 0);\n    d[1] = maxDepth % 256;\n    d[0] = Math.floor(maxDepth / 256);\n    return d;\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  getRefsDescriptor() {\n    const d1 = Uint8Array.from({\n      length: 1\n    }, () => 0);\n    d1[0] = this.refs.length + this.isExotic * 8 + this.getMaxLevel() * 32;\n    return d1;\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  getBitsDescriptor() {\n    const d2 = Uint8Array.from({\n      length: 1\n    }, () => 0);\n    d2[0] = Math.ceil(this.bits.cursor / 8) + Math.floor(this.bits.cursor / 8);\n    return d2;\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  getDataWithDescriptors() {\n    const d1 = this.getRefsDescriptor();\n    const d2 = this.getBitsDescriptor();\n    const tuBits = this.bits.getTopUppedArray();\n    return concatBytes(concatBytes(d1, d2), tuBits);\n  }\n\n  /**\n   * @return {Promise<Uint8Array>}\n   */\n  async getRepr() {\n    const reprArray = [];\n    reprArray.push(this.getDataWithDescriptors());\n    for (let k in this.refs) {\n      const i = this.refs[k];\n      reprArray.push(i.getMaxDepthAsArray());\n    }\n    for (let k in this.refs) {\n      const i = this.refs[k];\n      reprArray.push(await i.hash());\n    }\n    let x = new Uint8Array();\n    for (let k in reprArray) {\n      const i = reprArray[k];\n      x = concatBytes(x, i);\n    }\n    return x;\n  }\n\n  /**\n   * @return {Promise<Uint8Array>}\n   */\n  async hash() {\n    return new Uint8Array(await sha256(await this.getRepr()));\n  }\n\n  /**\n   * Recursively prints cell's content like Fift\n   * @return  {string}\n   */\n  print(indent) {\n    indent = indent || '';\n    let s = indent + 'x{' + this.bits.toHex() + '}\\n';\n    for (let k in this.refs) {\n      const i = this.refs[k];\n      s += i.print(indent + ' ');\n    }\n    return s;\n  }\n\n  //serialized_boc#b5ee9c72 has_idx:(## 1) has_crc32c:(## 1)\n  //  has_cache_bits:(## 1) flags:(## 2) { flags = 0 }\n  //  size:(## 3) { size <= 4 }\n  //  off_bytes:(## 8) { off_bytes <= 8 }\n  //  cells:(##(size * 8))\n  //  roots:(##(size * 8)) { roots >= 1 }\n  //  absent:(##(size * 8)) { roots + absent <= cells }\n  //  tot_cells_size:(##(off_bytes * 8))\n  //  root_list:(roots * ##(size * 8))\n  //  index:has_idx?(cells * ##(off_bytes * 8))\n  //  cell_data:(tot_cells_size * [ uint8 ])\n  //  crc32c:has_crc32c?uint32\n  // = BagOfCells;\n  /**\n   * create boc bytearray\n   * @param has_idx? {boolean}\n   * @param hash_crc32?  {boolean}\n   * @param has_cache_bits?  {boolean}\n   * @param flags? {number}\n   * @return {Promise<Uint8Array>}\n   */\n  async toBoc() {\n    let has_idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let hash_crc32 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let has_cache_bits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const root_cell = this;\n    const allcells = await root_cell.treeWalk();\n    const topologicalOrder = allcells[0];\n    const cellsIndex = allcells[1];\n    const cells_num = topologicalOrder.length;\n    const s = cells_num.toString(2).length; // Minimal number of bits to represent reference (unused?)\n    const s_bytes = Math.min(Math.ceil(s / 8), 1);\n    let full_size = 0;\n    let sizeIndex = [];\n    for (let cell_info of topologicalOrder) {\n      //TODO it should be async map or async for\n      sizeIndex.push(full_size);\n      full_size = full_size + (await cell_info[1].bocSerializationSize(cellsIndex, s_bytes));\n    }\n    const offset_bits = full_size.toString(2).length; // Minimal number of bits to offset/len (unused?)\n    const offset_bytes = Math.max(Math.ceil(offset_bits / 8), 1);\n    const serialization = new BitString((1023 + 32 * 4 + 32 * 3) * topologicalOrder.length);\n    serialization.writeBytes(reachBocMagicPrefix);\n    serialization.writeBitArray([has_idx, hash_crc32, has_cache_bits]);\n    serialization.writeUint(flags, 2);\n    serialization.writeUint(s_bytes, 3);\n    serialization.writeUint8(offset_bytes);\n    serialization.writeUint(cells_num, s_bytes * 8);\n    serialization.writeUint(1, s_bytes * 8); // One root for now\n    serialization.writeUint(0, s_bytes * 8); // Complete BOCs only\n    serialization.writeUint(full_size, offset_bytes * 8);\n    serialization.writeUint(0, s_bytes * 8); // Root shoulh have index 0\n    if (has_idx) {\n      topologicalOrder.forEach((cell_data, index) => serialization.writeUint(sizeIndex[index], offset_bytes * 8));\n    }\n    for (let cell_info of topologicalOrder) {\n      //TODO it should be async map or async for\n      const refcell_ser = await cell_info[1].serializeForBoc(cellsIndex, s_bytes);\n      serialization.writeBytes(refcell_ser);\n    }\n    let ser_arr = serialization.getTopUppedArray();\n    if (hash_crc32) {\n      ser_arr = concatBytes(ser_arr, crc32c(ser_arr));\n    }\n    return ser_arr;\n  }\n\n  /**\n   * @private\n   * @param cellsIndex\n   * @param refSize\n   * @return {Promise<Uint8Array>}\n   */\n  async serializeForBoc(cellsIndex, refSize) {\n    const reprArray = [];\n    reprArray.push(this.getDataWithDescriptors());\n    if (this.isExplicitlyStoredHashes()) {\n      throw new Error(\"Cell hashes explicit storing is not implemented\");\n    }\n    for (let k in this.refs) {\n      const i = this.refs[k];\n      const refHash = await i.hash();\n      const refIndexInt = cellsIndex[refHash];\n      let refIndexHex = refIndexInt.toString(16);\n      if (refIndexHex.length % 2) {\n        refIndexHex = \"0\" + refIndexHex;\n      }\n      const reference = hexToBytes(refIndexHex);\n      reprArray.push(reference);\n    }\n    let x = new Uint8Array();\n    for (let k in reprArray) {\n      const i = reprArray[k];\n      x = concatBytes(x, i);\n    }\n    return x;\n  }\n\n  /**\n   * @private\n   * @param cellsIndex\n   * @param refSize\n   * @return {Promise<number>}\n   */\n  async bocSerializationSize(cellsIndex, refSize) {\n    return (await this.serializeForBoc(cellsIndex, refSize)).length;\n  }\n\n  /**\n   * @private\n   * @return {[[], {}]} topologicalOrderArray and indexHashmap\n   */\n  async treeWalk() {\n    return treeWalk(this, [], {});\n  }\n}\nasync function moveToTheEnd(indexHashmap, topologicalOrderArray, target) {\n  const targetIndex = indexHashmap[target];\n  for (let h in indexHashmap) {\n    if (indexHashmap[h] > targetIndex) {\n      indexHashmap[h] = indexHashmap[h] - 1;\n    }\n  }\n  indexHashmap[target] = topologicalOrderArray.length - 1;\n  const data = topologicalOrderArray.splice(targetIndex, 1)[0];\n  topologicalOrderArray.push(data);\n  for (let subCell of data[1].refs) {\n    await moveToTheEnd(indexHashmap, topologicalOrderArray, await subCell.hash());\n  }\n}\n\n/**\n * @param cell  {Cell}\n * @param topologicalOrderArray array of pairs: cellHash: Uint8Array, cell: Cell, ...\n * @param indexHashmap cellHash: Uint8Array -> cellIndex: number\n * @return {[[], {}]} topologicalOrderArray and indexHashmap\n */\nasync function treeWalk(cell, topologicalOrderArray, indexHashmap) {\n  let parentHash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  const cellHash = await cell.hash();\n  if (cellHash in indexHashmap) {\n    // Duplication cell\n    //it is possible that already seen cell is a children of more deep cell\n    if (parentHash) {\n      if (indexHashmap[parentHash] > indexHashmap[cellHash]) {\n        await moveToTheEnd(indexHashmap, topologicalOrderArray, cellHash);\n      }\n    }\n    return [topologicalOrderArray, indexHashmap];\n  }\n  indexHashmap[cellHash] = topologicalOrderArray.length;\n  topologicalOrderArray.push([cellHash, cell]);\n  for (let subCell of cell.refs) {\n    const res = await treeWalk(subCell, topologicalOrderArray, indexHashmap, cellHash);\n    topologicalOrderArray = res[0];\n    indexHashmap = res[1];\n  }\n  return [topologicalOrderArray, indexHashmap];\n}\nfunction parseBocHeader(serializedBoc) {\n  // snake_case is used to match TON docs\n  if (serializedBoc.length < 4 + 1) throw \"Not enough bytes for magic prefix\";\n  const inputData = serializedBoc; // Save copy for crc32\n  const prefix = serializedBoc.slice(0, 4);\n  serializedBoc = serializedBoc.slice(4);\n  let has_idx, hash_crc32, has_cache_bits, flags, size_bytes;\n  if (compareBytes(prefix, reachBocMagicPrefix)) {\n    const flags_byte = serializedBoc[0];\n    has_idx = flags_byte & 128;\n    hash_crc32 = flags_byte & 64;\n    has_cache_bits = flags_byte & 32;\n    flags = (flags_byte & 16) * 2 + (flags_byte & 8);\n    size_bytes = flags_byte % 8;\n  }\n  if (compareBytes(prefix, leanBocMagicPrefix)) {\n    has_idx = 1;\n    hash_crc32 = 0;\n    has_cache_bits = 0;\n    flags = 0;\n    size_bytes = serializedBoc[0];\n  }\n  if (compareBytes(prefix, leanBocMagicPrefixCRC)) {\n    has_idx = 1;\n    hash_crc32 = 1;\n    has_cache_bits = 0;\n    flags = 0;\n    size_bytes = serializedBoc[0];\n  }\n  serializedBoc = serializedBoc.slice(1);\n  if (serializedBoc.length < 1 + 5 * size_bytes) throw \"Not enough bytes for encoding cells counters\";\n  const offset_bytes = serializedBoc[0];\n  serializedBoc = serializedBoc.slice(1);\n  const cells_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(size_bytes);\n  const roots_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(size_bytes);\n  const absent_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(size_bytes);\n  const tot_cells_size = readNBytesUIntFromArray(offset_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(offset_bytes);\n  if (serializedBoc.length < roots_num * size_bytes) throw \"Not enough bytes for encoding root cells hashes\";\n  let root_list = [];\n  for (let c = 0; c < roots_num; c++) {\n    root_list.push(readNBytesUIntFromArray(size_bytes, serializedBoc));\n    serializedBoc = serializedBoc.slice(size_bytes);\n  }\n  let index = false;\n  if (has_idx) {\n    index = [];\n    if (serializedBoc.length < offset_bytes * cells_num) throw \"Not enough bytes for index encoding\";\n    for (let c = 0; c < cells_num; c++) {\n      index.push(readNBytesUIntFromArray(offset_bytes, serializedBoc));\n      serializedBoc = serializedBoc.slice(offset_bytes);\n    }\n  }\n  if (serializedBoc.length < tot_cells_size) throw \"Not enough bytes for cells data\";\n  const cells_data = serializedBoc.slice(0, tot_cells_size);\n  serializedBoc = serializedBoc.slice(tot_cells_size);\n  if (hash_crc32) {\n    if (serializedBoc.length < 4) throw \"Not enough bytes for crc32c hashsum\";\n    const length = inputData.length;\n    if (!compareBytes(crc32c(inputData.slice(0, length - 4)), serializedBoc.slice(0, 4))) throw \"Crc32c hashsum mismatch\";\n    serializedBoc = serializedBoc.slice(4);\n  }\n  if (serializedBoc.length) throw \"Too much bytes in BoC serialization\";\n  return {\n    has_idx: has_idx,\n    hash_crc32: hash_crc32,\n    has_cache_bits: has_cache_bits,\n    flags: flags,\n    size_bytes: size_bytes,\n    off_bytes: offset_bytes,\n    cells_num: cells_num,\n    roots_num: roots_num,\n    absent_num: absent_num,\n    tot_cells_size: tot_cells_size,\n    root_list: root_list,\n    index: index,\n    cells_data: cells_data\n  };\n}\nfunction deserializeCellData(cellData, referenceIndexSize) {\n  if (cellData.length < 2) throw \"Not enough bytes to encode cell descriptors\";\n  const d1 = cellData[0],\n    d2 = cellData[1];\n  cellData = cellData.slice(2);\n  const level = Math.floor(d1 / 32);\n  const isExotic = d1 & 8;\n  const refNum = d1 % 8;\n  const dataBytesize = Math.ceil(d2 / 2);\n  const fullfilledBytes = !(d2 % 2);\n  let cell = new Cell();\n  cell.isExotic = isExotic;\n  if (cellData.length < dataBytesize + referenceIndexSize * refNum) throw \"Not enough bytes to encode cell data\";\n  cell.bits.setTopUppedArray(cellData.slice(0, dataBytesize), fullfilledBytes);\n  cellData = cellData.slice(dataBytesize);\n  for (let r = 0; r < refNum; r++) {\n    cell.refs.push(readNBytesUIntFromArray(referenceIndexSize, cellData));\n    cellData = cellData.slice(referenceIndexSize);\n  }\n  return {\n    cell: cell,\n    residue: cellData\n  };\n}\n\n/**\n * @param serializedBoc  {string | Uint8Array} hex or bytearray\n * @return {Cell[]} root cells\n */\nfunction deserializeBoc(serializedBoc) {\n  if (typeof serializedBoc == 'string') {\n    serializedBoc = hexToBytes(serializedBoc);\n  }\n  const header = parseBocHeader(serializedBoc);\n  let cells_data = header.cells_data;\n  let cells_array = [];\n  for (let ci = 0; ci < header.cells_num; ci++) {\n    let dd = deserializeCellData(cells_data, header.size_bytes);\n    cells_data = dd.residue;\n    cells_array.push(dd.cell);\n  }\n  for (let ci = header.cells_num - 1; ci >= 0; ci--) {\n    let c = cells_array[ci];\n    for (let ri = 0; ri < c.refs.length; ri++) {\n      const r = c.refs[ri];\n      if (r < ci) {\n        throw \"Topological order is broken\";\n      }\n      c.refs[ri] = cells_array[r];\n    }\n  }\n  let root_cells = [];\n  for (let ri of header.root_list) {\n    root_cells.push(cells_array[ri]);\n  }\n  return root_cells;\n}\nmodule.exports = {\n  Cell\n};","map":{"version":3,"names":["BitString","require","bytesToBase64","compareBytes","concatBytes","crc32c","hexToBytes","readNBytesUIntFromArray","sha256","bytesToHex","reachBocMagicPrefix","leanBocMagicPrefix","leanBocMagicPrefixCRC","Cell","constructor","bits","refs","isExotic","fromBoc","serializedBoc","deserializeBoc","oneFromBoc","cells","length","Error","writeCell","anotherCell","writeBitString","concat","getMaxLevel","maxLevel","k","i","isExplicitlyStoredHashes","getMaxDepth","maxDepth","getMaxDepthAsArray","d","Uint8Array","from","Math","floor","getRefsDescriptor","d1","getBitsDescriptor","d2","ceil","cursor","getDataWithDescriptors","tuBits","getTopUppedArray","getRepr","reprArray","push","hash","x","print","indent","s","toHex","toBoc","has_idx","hash_crc32","has_cache_bits","flags","root_cell","allcells","treeWalk","topologicalOrder","cellsIndex","cells_num","toString","s_bytes","min","full_size","sizeIndex","cell_info","bocSerializationSize","offset_bits","offset_bytes","max","serialization","writeBytes","writeBitArray","writeUint","writeUint8","forEach","cell_data","index","refcell_ser","serializeForBoc","ser_arr","refSize","refHash","refIndexInt","refIndexHex","reference","moveToTheEnd","indexHashmap","topologicalOrderArray","target","targetIndex","h","data","splice","subCell","cell","parentHash","cellHash","res","parseBocHeader","inputData","prefix","slice","size_bytes","flags_byte","roots_num","absent_num","tot_cells_size","root_list","c","cells_data","off_bytes","deserializeCellData","cellData","referenceIndexSize","level","refNum","dataBytesize","fullfilledBytes","setTopUppedArray","r","residue","header","cells_array","ci","dd","ri","root_cells","module","exports"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/tonweb/src/boc/Cell.js"],"sourcesContent":["const {BitString} = require(\"./BitString\");\nconst {\n    bytesToBase64,\n    compareBytes,\n    concatBytes,\n    crc32c,\n    hexToBytes,\n    readNBytesUIntFromArray,\n    sha256,\n    bytesToHex\n} = require(\"../utils\");\n\nconst reachBocMagicPrefix = hexToBytes('B5EE9C72');\nconst leanBocMagicPrefix = hexToBytes('68ff65f3');\nconst leanBocMagicPrefixCRC = hexToBytes('acc3a728');\n\nclass Cell {\n    constructor() {\n        this.bits = new BitString(1023);\n        this.refs = [];\n        this.isExotic = false;\n    }\n\n    /**\n     * @param serializedBoc  {string | Uint8Array} hex or bytearray\n     * @return {Cell[]} root cells\n     */\n    static fromBoc(serializedBoc) {\n        return deserializeBoc(serializedBoc);\n    }\n\n    /**\n     * @param serializedBoc  {string | Uint8Array} hex or bytearray\n     * @return {Cell} root cell\n     */\n    static oneFromBoc(serializedBoc) {\n        const cells = deserializeBoc(serializedBoc);\n        if (cells.length !== 1) throw new Error('expected 1 root cell but have ' + cells.length);\n        return cells[0];\n    }\n\n    /**\n     * Write another cell to this cell\n     * @param anotherCell  {Cell}\n     */\n    writeCell(anotherCell) {\n        // XXX we do not check that there are anough place in cell\n        this.bits.writeBitString(anotherCell.bits);\n        this.refs = this.refs.concat(anotherCell.refs);\n    }\n\n    /**\n     * @return {number}\n     */\n    getMaxLevel() {\n        //TODO level calculation differ for exotic cells\n        let maxLevel = 0;\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            if (i.getMaxLevel() > maxLevel) {\n                maxLevel = i.getMaxLevel();\n            }\n        }\n        return maxLevel;\n    }\n\n    /**\n     * @return {number}\n     */\n    isExplicitlyStoredHashes() {\n        return 0;\n    }\n\n    /**\n     * @return {number}\n     */\n    getMaxDepth() {\n        let maxDepth = 0;\n        if (this.refs.length > 0) {\n            for (let k in this.refs) {\n                const i = this.refs[k];\n                if (i.getMaxDepth() > maxDepth) {\n                    maxDepth = i.getMaxDepth();\n                }\n            }\n            maxDepth = maxDepth + 1;\n        }\n        return maxDepth;\n    }\n\n    /**\n     * @private\n     * @return {Uint8Array}\n     */\n    getMaxDepthAsArray() {\n        const maxDepth = this.getMaxDepth();\n        const d = Uint8Array.from({length: 2}, () => 0);\n        d[1] = maxDepth % 256;\n        d[0] = Math.floor(maxDepth / 256);\n        return d;\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n    getRefsDescriptor() {\n        const d1 = Uint8Array.from({length: 1}, () => 0);\n        d1[0] = this.refs.length + this.isExotic * 8 + this.getMaxLevel() * 32;\n        return d1;\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n    getBitsDescriptor() {\n        const d2 = Uint8Array.from({length: 1}, () => 0);\n        d2[0] = Math.ceil(this.bits.cursor / 8) + Math.floor(this.bits.cursor / 8);\n        return d2;\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n    getDataWithDescriptors() {\n        const d1 = this.getRefsDescriptor();\n        const d2 = this.getBitsDescriptor();\n        const tuBits = this.bits.getTopUppedArray();\n        return concatBytes(concatBytes(d1, d2), tuBits);\n    }\n\n    /**\n     * @return {Promise<Uint8Array>}\n     */\n    async getRepr() {\n        const reprArray = [];\n\n        reprArray.push(this.getDataWithDescriptors());\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            reprArray.push(i.getMaxDepthAsArray());\n        }\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            reprArray.push(await i.hash());\n        }\n        let x = new Uint8Array();\n        for (let k in reprArray) {\n            const i = reprArray[k];\n            x = concatBytes(x, i);\n        }\n        return x;\n    }\n\n    /**\n     * @return {Promise<Uint8Array>}\n     */\n    async hash() {\n        return new Uint8Array(\n            await sha256(await this.getRepr())\n        );\n    }\n\n    /**\n     * Recursively prints cell's content like Fift\n     * @return  {string}\n     */\n    print(indent) {\n        indent = indent || '';\n        let s = indent + 'x{' + this.bits.toHex() + '}\\n';\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            s += i.print(indent + ' ');\n        }\n        return s;\n    }\n\n    //serialized_boc#b5ee9c72 has_idx:(## 1) has_crc32c:(## 1)\n    //  has_cache_bits:(## 1) flags:(## 2) { flags = 0 }\n    //  size:(## 3) { size <= 4 }\n    //  off_bytes:(## 8) { off_bytes <= 8 }\n    //  cells:(##(size * 8))\n    //  roots:(##(size * 8)) { roots >= 1 }\n    //  absent:(##(size * 8)) { roots + absent <= cells }\n    //  tot_cells_size:(##(off_bytes * 8))\n    //  root_list:(roots * ##(size * 8))\n    //  index:has_idx?(cells * ##(off_bytes * 8))\n    //  cell_data:(tot_cells_size * [ uint8 ])\n    //  crc32c:has_crc32c?uint32\n    // = BagOfCells;\n    /**\n     * create boc bytearray\n     * @param has_idx? {boolean}\n     * @param hash_crc32?  {boolean}\n     * @param has_cache_bits?  {boolean}\n     * @param flags? {number}\n     * @return {Promise<Uint8Array>}\n     */\n    async toBoc(has_idx = true, hash_crc32 = true, has_cache_bits = false, flags = 0) {\n        const root_cell = this;\n\n        const allcells = await root_cell.treeWalk();\n        const topologicalOrder = allcells[0];\n        const cellsIndex = allcells[1];\n\n        const cells_num = topologicalOrder.length;\n        const s = cells_num.toString(2).length; // Minimal number of bits to represent reference (unused?)\n        const s_bytes = Math.min(Math.ceil(s / 8), 1);\n        let full_size = 0;\n        let sizeIndex = [];\n        for (let cell_info of topologicalOrder) {\n            //TODO it should be async map or async for\n            sizeIndex.push(full_size);\n            full_size = full_size + await cell_info[1].bocSerializationSize(cellsIndex, s_bytes);\n        }\n        const offset_bits = full_size.toString(2).length; // Minimal number of bits to offset/len (unused?)\n        const offset_bytes = Math.max(Math.ceil(offset_bits / 8), 1);\n\n        const serialization = new BitString((1023 + 32 * 4 + 32 * 3) * topologicalOrder.length);\n        serialization.writeBytes(reachBocMagicPrefix);\n        serialization.writeBitArray([has_idx, hash_crc32, has_cache_bits]);\n        serialization.writeUint(flags, 2);\n        serialization.writeUint(s_bytes, 3);\n        serialization.writeUint8(offset_bytes);\n        serialization.writeUint(cells_num, s_bytes * 8);\n        serialization.writeUint(1, s_bytes * 8); // One root for now\n        serialization.writeUint(0, s_bytes * 8); // Complete BOCs only\n        serialization.writeUint(full_size, offset_bytes * 8);\n        serialization.writeUint(0, s_bytes * 8); // Root shoulh have index 0\n        if (has_idx) {\n            topologicalOrder.forEach(\n                (cell_data, index) =>\n                    serialization.writeUint(sizeIndex[index], offset_bytes * 8));\n        }\n        for (let cell_info of topologicalOrder) {\n            //TODO it should be async map or async for\n            const refcell_ser = await cell_info[1].serializeForBoc(cellsIndex, s_bytes);\n            serialization.writeBytes(refcell_ser);\n        }\n        let ser_arr = serialization.getTopUppedArray();\n        if (hash_crc32) {\n            ser_arr = concatBytes(ser_arr, crc32c(ser_arr));\n        }\n\n        return ser_arr;\n    }\n\n    /**\n     * @private\n     * @param cellsIndex\n     * @param refSize\n     * @return {Promise<Uint8Array>}\n     */\n    async serializeForBoc(cellsIndex, refSize) {\n        const reprArray = [];\n\n        reprArray.push(this.getDataWithDescriptors());\n        if (this.isExplicitlyStoredHashes()) {\n            throw new Error(\"Cell hashes explicit storing is not implemented\");\n        }\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            const refHash = await i.hash();\n            const refIndexInt = cellsIndex[refHash];\n            let refIndexHex = refIndexInt.toString(16);\n            if (refIndexHex.length % 2) {\n                refIndexHex = \"0\" + refIndexHex;\n            }\n            const reference = hexToBytes(refIndexHex);\n            reprArray.push(reference);\n        }\n        let x = new Uint8Array();\n        for (let k in reprArray) {\n            const i = reprArray[k];\n            x = concatBytes(x, i);\n        }\n        return x;\n    }\n\n    /**\n     * @private\n     * @param cellsIndex\n     * @param refSize\n     * @return {Promise<number>}\n     */\n    async bocSerializationSize(cellsIndex, refSize) {\n        return (await this.serializeForBoc(cellsIndex, refSize)).length;\n    }\n\n    /**\n     * @private\n     * @return {[[], {}]} topologicalOrderArray and indexHashmap\n     */\n    async treeWalk() {\n        return treeWalk(this, [], {});\n    }\n}\n\nasync function moveToTheEnd(indexHashmap, topologicalOrderArray, target) {\n    const targetIndex = indexHashmap[target];\n    for (let h in indexHashmap) {\n        if (indexHashmap[h] > targetIndex) {\n            indexHashmap[h] = indexHashmap[h] - 1;\n        }\n    }\n    indexHashmap[target] = topologicalOrderArray.length - 1;\n    const data = topologicalOrderArray.splice(targetIndex, 1)[0];\n    topologicalOrderArray.push(data);\n    for (let subCell of data[1].refs) {\n        await moveToTheEnd(indexHashmap, topologicalOrderArray, await subCell.hash());\n    }\n}\n\n/**\n * @param cell  {Cell}\n * @param topologicalOrderArray array of pairs: cellHash: Uint8Array, cell: Cell, ...\n * @param indexHashmap cellHash: Uint8Array -> cellIndex: number\n * @return {[[], {}]} topologicalOrderArray and indexHashmap\n */\nasync function treeWalk(cell, topologicalOrderArray, indexHashmap, parentHash = null) {\n    const cellHash = await cell.hash();\n    if (cellHash in indexHashmap) { // Duplication cell\n        //it is possible that already seen cell is a children of more deep cell\n        if (parentHash) {\n            if (indexHashmap[parentHash] > indexHashmap[cellHash]) {\n                await moveToTheEnd(indexHashmap, topologicalOrderArray, cellHash);\n            }\n        }\n        return [topologicalOrderArray, indexHashmap];\n    }\n    indexHashmap[cellHash] = topologicalOrderArray.length;\n    topologicalOrderArray.push([cellHash, cell]);\n    for (let subCell of cell.refs) {\n        const res = await treeWalk(subCell, topologicalOrderArray, indexHashmap, cellHash);\n        topologicalOrderArray = res[0];\n        indexHashmap = res[1];\n    }\n\n    return [topologicalOrderArray, indexHashmap];\n}\n\n\nfunction parseBocHeader(serializedBoc) {\n    // snake_case is used to match TON docs\n    if (serializedBoc.length < 4 + 1)\n        throw \"Not enough bytes for magic prefix\";\n    const inputData = serializedBoc; // Save copy for crc32\n    const prefix = serializedBoc.slice(0, 4);\n    serializedBoc = serializedBoc.slice(4);\n    let has_idx, hash_crc32, has_cache_bits, flags, size_bytes;\n    if (compareBytes(prefix, reachBocMagicPrefix)) {\n        const flags_byte = serializedBoc[0];\n        has_idx = flags_byte & 128;\n        hash_crc32 = flags_byte & 64;\n        has_cache_bits = flags_byte & 32;\n        flags = (flags_byte & 16) * 2 + (flags_byte & 8);\n        size_bytes = flags_byte % 8;\n    }\n    if (compareBytes(prefix, leanBocMagicPrefix)) {\n        has_idx = 1;\n        hash_crc32 = 0;\n        has_cache_bits = 0;\n        flags = 0;\n        size_bytes = serializedBoc[0];\n    }\n    if (compareBytes(prefix, leanBocMagicPrefixCRC)) {\n        has_idx = 1;\n        hash_crc32 = 1;\n        has_cache_bits = 0;\n        flags = 0;\n        size_bytes = serializedBoc[0];\n    }\n    serializedBoc = serializedBoc.slice(1);\n    if (serializedBoc.length < 1 + 5 * size_bytes)\n        throw \"Not enough bytes for encoding cells counters\";\n    const offset_bytes = serializedBoc[0];\n    serializedBoc = serializedBoc.slice(1);\n    const cells_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(size_bytes);\n    const roots_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(size_bytes);\n    const absent_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(size_bytes);\n    const tot_cells_size = readNBytesUIntFromArray(offset_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(offset_bytes);\n    if (serializedBoc.length < roots_num * size_bytes)\n        throw \"Not enough bytes for encoding root cells hashes\";\n    let root_list = [];\n    for (let c = 0; c < roots_num; c++) {\n        root_list.push(readNBytesUIntFromArray(size_bytes, serializedBoc));\n        serializedBoc = serializedBoc.slice(size_bytes);\n    }\n    let index = false;\n    if (has_idx) {\n        index = [];\n        if (serializedBoc.length < offset_bytes * cells_num)\n            throw \"Not enough bytes for index encoding\";\n        for (let c = 0; c < cells_num; c++) {\n            index.push(readNBytesUIntFromArray(offset_bytes, serializedBoc));\n            serializedBoc = serializedBoc.slice(offset_bytes);\n        }\n    }\n\n    if (serializedBoc.length < tot_cells_size)\n        throw \"Not enough bytes for cells data\";\n    const cells_data = serializedBoc.slice(0, tot_cells_size);\n    serializedBoc = serializedBoc.slice(tot_cells_size);\n    if (hash_crc32) {\n        if (serializedBoc.length < 4)\n            throw \"Not enough bytes for crc32c hashsum\";\n        const length = inputData.length;\n        if (!compareBytes(crc32c(inputData.slice(0, length - 4)), serializedBoc.slice(0, 4)))\n            throw \"Crc32c hashsum mismatch\";\n        serializedBoc = serializedBoc.slice(4);\n    }\n    if (serializedBoc.length)\n        throw \"Too much bytes in BoC serialization\";\n    return {\n        has_idx: has_idx, hash_crc32: hash_crc32, has_cache_bits: has_cache_bits, flags: flags, size_bytes: size_bytes,\n        off_bytes: offset_bytes, cells_num: cells_num, roots_num: roots_num, absent_num: absent_num,\n        tot_cells_size: tot_cells_size, root_list: root_list, index: index,\n        cells_data: cells_data\n    };\n}\n\nfunction deserializeCellData(cellData, referenceIndexSize) {\n    if (cellData.length < 2)\n        throw \"Not enough bytes to encode cell descriptors\";\n    const d1 = cellData[0], d2 = cellData[1];\n    cellData = cellData.slice(2);\n    const level = Math.floor(d1 / 32);\n    const isExotic = d1 & 8;\n    const refNum = d1 % 8;\n    const dataBytesize = Math.ceil(d2 / 2);\n    const fullfilledBytes = !(d2 % 2);\n    let cell = new Cell();\n    cell.isExotic = isExotic;\n    if (cellData.length < dataBytesize + referenceIndexSize * refNum)\n        throw \"Not enough bytes to encode cell data\";\n    cell.bits.setTopUppedArray(cellData.slice(0, dataBytesize), fullfilledBytes);\n    cellData = cellData.slice(dataBytesize);\n    for (let r = 0; r < refNum; r++) {\n        cell.refs.push(readNBytesUIntFromArray(referenceIndexSize, cellData));\n        cellData = cellData.slice(referenceIndexSize);\n    }\n    return {cell: cell, residue: cellData};\n}\n\n\n/**\n * @param serializedBoc  {string | Uint8Array} hex or bytearray\n * @return {Cell[]} root cells\n */\nfunction deserializeBoc(serializedBoc) {\n    if (typeof (serializedBoc) == 'string') {\n        serializedBoc = hexToBytes(serializedBoc);\n    }\n    const header = parseBocHeader(serializedBoc);\n    let cells_data = header.cells_data;\n    let cells_array = [];\n    for (let ci = 0; ci < header.cells_num; ci++) {\n        let dd = deserializeCellData(cells_data, header.size_bytes);\n        cells_data = dd.residue;\n        cells_array.push(dd.cell);\n    }\n    for (let ci = header.cells_num - 1; ci >= 0; ci--) {\n        let c = cells_array[ci];\n        for (let ri = 0; ri < c.refs.length; ri++) {\n            const r = c.refs[ri];\n            if (r < ci) {\n                throw \"Topological order is broken\";\n            }\n            c.refs[ri] = cells_array[r];\n        }\n    }\n    let root_cells = [];\n    for (let ri of header.root_list) {\n        root_cells.push(cells_array[ri]);\n    }\n    return root_cells;\n}\n\nmodule.exports = {Cell};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}