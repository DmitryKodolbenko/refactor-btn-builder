{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Secp256k1 = void 0;\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst elliptic_1 = __importDefault(require(\"elliptic\"));\nconst secp256k1signature_1 = require(\"./secp256k1signature\");\nconst secp256k1 = new elliptic_1.default.ec(\"secp256k1\");\nconst secp256k1N = new bn_js_1.default(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", \"hex\");\nclass Secp256k1 {\n  /**\n   * Takes a 32 byte private key and returns a privkey/pubkey pair.\n   *\n   * The resulting pubkey is uncompressed. For the use in Cosmos it should\n   * be compressed first using `Secp256k1.compressPubkey`.\n   */\n  static async makeKeypair(privkey) {\n    if (privkey.length !== 32) {\n      // is this check missing in secp256k1.validatePrivateKey?\n      // https://github.com/bitjson/bitcoin-ts/issues/4\n      throw new Error(\"input data is not a valid secp256k1 private key\");\n    }\n    const keypair = secp256k1.keyFromPrivate(privkey);\n    if (keypair.validate().result !== true) {\n      throw new Error(\"input data is not a valid secp256k1 private key\");\n    }\n    // range test that is not part of the elliptic implementation\n    const privkeyAsBigInteger = new bn_js_1.default(privkey);\n    if (privkeyAsBigInteger.gte(secp256k1N)) {\n      // not strictly smaller than N\n      throw new Error(\"input data is not a valid secp256k1 private key\");\n    }\n    const out = {\n      privkey: (0, encoding_1.fromHex)(keypair.getPrivate(\"hex\")),\n      // encodes uncompressed as\n      // - 1-byte prefix \"04\"\n      // - 32-byte x coordinate\n      // - 32-byte y coordinate\n      pubkey: Uint8Array.from(keypair.getPublic(\"array\"))\n    };\n    return out;\n  }\n  /**\n   * Creates a signature that is\n   * - deterministic (RFC 6979)\n   * - lowS signature\n   * - DER encoded\n   */\n  static async createSignature(messageHash, privkey) {\n    if (messageHash.length === 0) {\n      throw new Error(\"Message hash must not be empty\");\n    }\n    if (messageHash.length > 32) {\n      throw new Error(\"Message hash length must not exceed 32 bytes\");\n    }\n    const keypair = secp256k1.keyFromPrivate(privkey);\n    // the `canonical` option ensures creation of lowS signature representations\n    const {\n      r,\n      s,\n      recoveryParam\n    } = keypair.sign(messageHash, {\n      canonical: true\n    });\n    if (typeof recoveryParam !== \"number\") throw new Error(\"Recovery param missing\");\n    return new secp256k1signature_1.ExtendedSecp256k1Signature(Uint8Array.from(r.toArray()), Uint8Array.from(s.toArray()), recoveryParam);\n  }\n  static async verifySignature(signature, messageHash, pubkey) {\n    if (messageHash.length === 0) {\n      throw new Error(\"Message hash must not be empty\");\n    }\n    if (messageHash.length > 32) {\n      throw new Error(\"Message hash length must not exceed 32 bytes\");\n    }\n    const keypair = secp256k1.keyFromPublic(pubkey);\n    // From https://github.com/indutny/elliptic:\n    //\n    //     Sign the message's hash (input must be an array, or a hex-string)\n    //\n    //     Signature MUST be either:\n    //     1) DER-encoded signature as hex-string; or\n    //     2) DER-encoded signature as buffer; or\n    //     3) object with two hex-string properties (r and s); or\n    //     4) object with two buffer properties (r and s)\n    //\n    // Uint8Array is not a Buffer, but elliptic seems to be happy with the interface\n    // common to both types. Uint8Array is not an array of ints but the interface is\n    // similar\n    try {\n      return keypair.verify(messageHash, signature.toDer());\n    } catch (error) {\n      return false;\n    }\n  }\n  static recoverPubkey(signature, messageHash) {\n    const signatureForElliptic = {\n      r: (0, encoding_1.toHex)(signature.r()),\n      s: (0, encoding_1.toHex)(signature.s())\n    };\n    const point = secp256k1.recoverPubKey(messageHash, signatureForElliptic, signature.recovery);\n    const keypair = secp256k1.keyFromPublic(point);\n    return (0, encoding_1.fromHex)(keypair.getPublic(false, \"hex\"));\n  }\n  /**\n   * Takes a compressed or uncompressed pubkey and return a compressed one.\n   *\n   * This function is idempotent.\n   */\n  static compressPubkey(pubkey) {\n    switch (pubkey.length) {\n      case 33:\n        return pubkey;\n      case 65:\n        return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(true, \"array\"));\n      default:\n        throw new Error(\"Invalid pubkey length\");\n    }\n  }\n  /**\n   * Takes a compressed or uncompressed pubkey and returns an uncompressed one.\n   *\n   * This function is idempotent.\n   */\n  static uncompressPubkey(pubkey) {\n    switch (pubkey.length) {\n      case 33:\n        return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(false, \"array\"));\n      case 65:\n        return pubkey;\n      default:\n        throw new Error(\"Invalid pubkey length\");\n    }\n  }\n  static trimRecoveryByte(signature) {\n    switch (signature.length) {\n      case 64:\n        return signature;\n      case 65:\n        return signature.slice(0, 64);\n      default:\n        throw new Error(\"Invalid signature length\");\n    }\n  }\n}\nexports.Secp256k1 = Secp256k1;","map":{"version":3,"sources":["../src/secp256k1.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Secp256k1 = void 0;\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst elliptic_1 = __importDefault(require(\"elliptic\"));\nconst secp256k1signature_1 = require(\"./secp256k1signature\");\nconst secp256k1 = new elliptic_1.default.ec(\"secp256k1\");\nconst secp256k1N = new bn_js_1.default(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", \"hex\");\nclass Secp256k1 {\n    /**\n     * Takes a 32 byte private key and returns a privkey/pubkey pair.\n     *\n     * The resulting pubkey is uncompressed. For the use in Cosmos it should\n     * be compressed first using `Secp256k1.compressPubkey`.\n     */\n    static async makeKeypair(privkey) {\n        if (privkey.length !== 32) {\n            // is this check missing in secp256k1.validatePrivateKey?\n            // https://github.com/bitjson/bitcoin-ts/issues/4\n            throw new Error(\"input data is not a valid secp256k1 private key\");\n        }\n        const keypair = secp256k1.keyFromPrivate(privkey);\n        if (keypair.validate().result !== true) {\n            throw new Error(\"input data is not a valid secp256k1 private key\");\n        }\n        // range test that is not part of the elliptic implementation\n        const privkeyAsBigInteger = new bn_js_1.default(privkey);\n        if (privkeyAsBigInteger.gte(secp256k1N)) {\n            // not strictly smaller than N\n            throw new Error(\"input data is not a valid secp256k1 private key\");\n        }\n        const out = {\n            privkey: (0, encoding_1.fromHex)(keypair.getPrivate(\"hex\")),\n            // encodes uncompressed as\n            // - 1-byte prefix \"04\"\n            // - 32-byte x coordinate\n            // - 32-byte y coordinate\n            pubkey: Uint8Array.from(keypair.getPublic(\"array\")),\n        };\n        return out;\n    }\n    /**\n     * Creates a signature that is\n     * - deterministic (RFC 6979)\n     * - lowS signature\n     * - DER encoded\n     */\n    static async createSignature(messageHash, privkey) {\n        if (messageHash.length === 0) {\n            throw new Error(\"Message hash must not be empty\");\n        }\n        if (messageHash.length > 32) {\n            throw new Error(\"Message hash length must not exceed 32 bytes\");\n        }\n        const keypair = secp256k1.keyFromPrivate(privkey);\n        // the `canonical` option ensures creation of lowS signature representations\n        const { r, s, recoveryParam } = keypair.sign(messageHash, { canonical: true });\n        if (typeof recoveryParam !== \"number\")\n            throw new Error(\"Recovery param missing\");\n        return new secp256k1signature_1.ExtendedSecp256k1Signature(Uint8Array.from(r.toArray()), Uint8Array.from(s.toArray()), recoveryParam);\n    }\n    static async verifySignature(signature, messageHash, pubkey) {\n        if (messageHash.length === 0) {\n            throw new Error(\"Message hash must not be empty\");\n        }\n        if (messageHash.length > 32) {\n            throw new Error(\"Message hash length must not exceed 32 bytes\");\n        }\n        const keypair = secp256k1.keyFromPublic(pubkey);\n        // From https://github.com/indutny/elliptic:\n        //\n        //     Sign the message's hash (input must be an array, or a hex-string)\n        //\n        //     Signature MUST be either:\n        //     1) DER-encoded signature as hex-string; or\n        //     2) DER-encoded signature as buffer; or\n        //     3) object with two hex-string properties (r and s); or\n        //     4) object with two buffer properties (r and s)\n        //\n        // Uint8Array is not a Buffer, but elliptic seems to be happy with the interface\n        // common to both types. Uint8Array is not an array of ints but the interface is\n        // similar\n        try {\n            return keypair.verify(messageHash, signature.toDer());\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    static recoverPubkey(signature, messageHash) {\n        const signatureForElliptic = { r: (0, encoding_1.toHex)(signature.r()), s: (0, encoding_1.toHex)(signature.s()) };\n        const point = secp256k1.recoverPubKey(messageHash, signatureForElliptic, signature.recovery);\n        const keypair = secp256k1.keyFromPublic(point);\n        return (0, encoding_1.fromHex)(keypair.getPublic(false, \"hex\"));\n    }\n    /**\n     * Takes a compressed or uncompressed pubkey and return a compressed one.\n     *\n     * This function is idempotent.\n     */\n    static compressPubkey(pubkey) {\n        switch (pubkey.length) {\n            case 33:\n                return pubkey;\n            case 65:\n                return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(true, \"array\"));\n            default:\n                throw new Error(\"Invalid pubkey length\");\n        }\n    }\n    /**\n     * Takes a compressed or uncompressed pubkey and returns an uncompressed one.\n     *\n     * This function is idempotent.\n     */\n    static uncompressPubkey(pubkey) {\n        switch (pubkey.length) {\n            case 33:\n                return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(false, \"array\"));\n            case 65:\n                return pubkey;\n            default:\n                throw new Error(\"Invalid pubkey length\");\n        }\n    }\n    static trimRecoveryByte(signature) {\n        switch (signature.length) {\n            case 64:\n                return signature;\n            case 65:\n                return signature.slice(0, 64);\n            default:\n                throw new Error(\"Invalid signature length\");\n        }\n    }\n}\nexports.Secp256k1 = Secp256k1;\n//# sourceMappingURL=secp256k1.js.map"]},"metadata":{},"sourceType":"script"}