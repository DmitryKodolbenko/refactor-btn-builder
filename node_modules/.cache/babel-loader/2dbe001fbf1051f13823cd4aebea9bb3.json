{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findAttribute = exports.parseRawLog = exports.parseLogs = exports.parseLog = exports.parseEvent = exports.parseAttribute = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nvar utils_1 = require(\"@cosmjs/utils\");\nfunction parseAttribute(input) {\n  if (!(0, utils_1.isNonNullObject)(input)) throw new Error(\"Attribute must be a non-null object\");\n  var key = input.key,\n    value = input.value;\n  if (typeof key !== \"string\" || !key) throw new Error(\"Attribute's key must be a non-empty string\");\n  if (typeof value !== \"string\" && typeof value !== \"undefined\") {\n    throw new Error(\"Attribute's value must be a string or unset\");\n  }\n  return {\n    key: key,\n    value: value || \"\"\n  };\n}\nexports.parseAttribute = parseAttribute;\nfunction parseEvent(input) {\n  if (!(0, utils_1.isNonNullObject)(input)) throw new Error(\"Event must be a non-null object\");\n  var type = input.type,\n    attributes = input.attributes;\n  if (typeof type !== \"string\" || type === \"\") {\n    throw new Error(\"Event type must be a non-empty string\");\n  }\n  if (!Array.isArray(attributes)) throw new Error(\"Event's attributes must be an array\");\n  return {\n    type: type,\n    attributes: attributes.map(parseAttribute)\n  };\n}\nexports.parseEvent = parseEvent;\nfunction parseLog(input) {\n  if (!(0, utils_1.isNonNullObject)(input)) throw new Error(\"Log must be a non-null object\");\n  var msg_index = input.msg_index,\n    log = input.log,\n    events = input.events;\n  if (typeof msg_index !== \"number\") throw new Error(\"Log's msg_index must be a number\");\n  if (typeof log !== \"string\") throw new Error(\"Log's log must be a string\");\n  if (!Array.isArray(events)) throw new Error(\"Log's events must be an array\");\n  return {\n    msg_index: msg_index,\n    log: log,\n    events: events.map(parseEvent)\n  };\n}\nexports.parseLog = parseLog;\nfunction parseLogs(input) {\n  if (!Array.isArray(input)) throw new Error(\"Logs must be an array\");\n  return input.map(parseLog);\n}\nexports.parseLogs = parseLogs;\nfunction parseRawLog() {\n  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"[]\";\n  var logsToParse = JSON.parse(input).map(function (_ref, i) {\n    var events = _ref.events;\n    return {\n      msg_index: i,\n      events: events,\n      log: \"\"\n    };\n  });\n  return parseLogs(logsToParse);\n}\nexports.parseRawLog = parseRawLog;\n/**\n * Searches in logs for the first event of the given event type and in that event\n * for the first first attribute with the given attribute key.\n *\n * Throws if the attribute was not found.\n */\nfunction findAttribute(logs, eventType, attrKey) {\n  var _a;\n  var firstLogs = logs.find(function () {\n    return true;\n  });\n  var out = (_a = firstLogs === null || firstLogs === void 0 ? void 0 : firstLogs.events.find(function (event) {\n    return event.type === eventType;\n  })) === null || _a === void 0 ? void 0 : _a.attributes.find(function (attr) {\n    return attr.key === attrKey;\n  });\n  if (!out) {\n    throw new Error(\"Could not find attribute '\".concat(attrKey, \"' in first event of type '\").concat(eventType, \"' in first log.\"));\n  }\n  return out;\n}\nexports.findAttribute = findAttribute;","map":{"version":3,"sources":["../src/logs.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findAttribute = exports.parseRawLog = exports.parseLogs = exports.parseLog = exports.parseEvent = exports.parseAttribute = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst utils_1 = require(\"@cosmjs/utils\");\nfunction parseAttribute(input) {\n    if (!(0, utils_1.isNonNullObject)(input))\n        throw new Error(\"Attribute must be a non-null object\");\n    const { key, value } = input;\n    if (typeof key !== \"string\" || !key)\n        throw new Error(\"Attribute's key must be a non-empty string\");\n    if (typeof value !== \"string\" && typeof value !== \"undefined\") {\n        throw new Error(\"Attribute's value must be a string or unset\");\n    }\n    return {\n        key: key,\n        value: value || \"\",\n    };\n}\nexports.parseAttribute = parseAttribute;\nfunction parseEvent(input) {\n    if (!(0, utils_1.isNonNullObject)(input))\n        throw new Error(\"Event must be a non-null object\");\n    const { type, attributes } = input;\n    if (typeof type !== \"string\" || type === \"\") {\n        throw new Error(`Event type must be a non-empty string`);\n    }\n    if (!Array.isArray(attributes))\n        throw new Error(\"Event's attributes must be an array\");\n    return {\n        type: type,\n        attributes: attributes.map(parseAttribute),\n    };\n}\nexports.parseEvent = parseEvent;\nfunction parseLog(input) {\n    if (!(0, utils_1.isNonNullObject)(input))\n        throw new Error(\"Log must be a non-null object\");\n    const { msg_index, log, events } = input;\n    if (typeof msg_index !== \"number\")\n        throw new Error(\"Log's msg_index must be a number\");\n    if (typeof log !== \"string\")\n        throw new Error(\"Log's log must be a string\");\n    if (!Array.isArray(events))\n        throw new Error(\"Log's events must be an array\");\n    return {\n        msg_index: msg_index,\n        log: log,\n        events: events.map(parseEvent),\n    };\n}\nexports.parseLog = parseLog;\nfunction parseLogs(input) {\n    if (!Array.isArray(input))\n        throw new Error(\"Logs must be an array\");\n    return input.map(parseLog);\n}\nexports.parseLogs = parseLogs;\nfunction parseRawLog(input = \"[]\") {\n    const logsToParse = JSON.parse(input).map(({ events }, i) => ({\n        msg_index: i,\n        events,\n        log: \"\",\n    }));\n    return parseLogs(logsToParse);\n}\nexports.parseRawLog = parseRawLog;\n/**\n * Searches in logs for the first event of the given event type and in that event\n * for the first first attribute with the given attribute key.\n *\n * Throws if the attribute was not found.\n */\nfunction findAttribute(logs, eventType, attrKey) {\n    var _a;\n    const firstLogs = logs.find(() => true);\n    const out = (_a = firstLogs === null || firstLogs === void 0 ? void 0 : firstLogs.events.find((event) => event.type === eventType)) === null || _a === void 0 ? void 0 : _a.attributes.find((attr) => attr.key === attrKey);\n    if (!out) {\n        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);\n    }\n    return out;\n}\nexports.findAttribute = findAttribute;\n//# sourceMappingURL=logs.js.map"]},"metadata":{},"sourceType":"script"}