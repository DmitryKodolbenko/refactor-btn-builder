{"ast":null,"code":"\"use strict\";\n\n/**\n * ```ts\n * interface Separated<E, A> {\n *    readonly left: E\n *    readonly right: A\n * }\n * ```\n *\n * Represents a result of separating a whole into two parts.\n *\n * @since 2.10.0\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.10.0\n */\nvar separated = function separated(left, right) {\n  return {\n    left: left,\n    right: right\n  };\n};\nexports.separated = separated;\nvar _map = function _map(fa, f) {\n  return (0, function_1.pipe)(fa, (0, exports.map)(f));\n};\nvar _mapLeft = function _mapLeft(fa, f) {\n  return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));\n};\nvar _bimap = function _bimap(fa, g, f) {\n  return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f));\n};\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.10.0\n */\nvar map = function map(f) {\n  return function (fa) {\n    return (0, exports.separated)((0, exports.left)(fa), f((0, exports.right)(fa)));\n  };\n};\nexports.map = map;\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.10.0\n */\nvar mapLeft = function mapLeft(f) {\n  return function (fa) {\n    return (0, exports.separated)(f((0, exports.left)(fa)), (0, exports.right)(fa));\n  };\n};\nexports.mapLeft = mapLeft;\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.10.0\n */\nvar bimap = function bimap(f, g) {\n  return function (fa) {\n    return (0, exports.separated)(f((0, exports.left)(fa)), g((0, exports.right)(fa)));\n  };\n};\nexports.bimap = bimap;\n/**\n * @category type lambdas\n * @since 2.10.0\n */\nexports.URI = 'Separated';\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Bifunctor = {\n  URI: exports.URI,\n  mapLeft: _mapLeft,\n  bimap: _bimap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Functor = {\n  URI: exports.URI,\n  map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexports.flap = (0, Functor_1.flap)(exports.Functor);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nvar left = function left(s) {\n  return s.left;\n};\nexports.left = left;\n/**\n * @since 2.10.0\n */\nvar right = function right(s) {\n  return s.right;\n};\nexports.right = right;","map":{"version":3,"names":["Object","defineProperty","exports","value","right","left","flap","Functor","Bifunctor","URI","bimap","mapLeft","map","separated","function_1","require","Functor_1","_map","fa","f","pipe","_mapLeft","_bimap","g","s"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/fp-ts/lib/Separated.js"],"sourcesContent":["\"use strict\";\n/**\n * ```ts\n * interface Separated<E, A> {\n *    readonly left: E\n *    readonly right: A\n * }\n * ```\n *\n * Represents a result of separating a whole into two parts.\n *\n * @since 2.10.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.10.0\n */\nvar separated = function (left, right) { return ({ left: left, right: right }); };\nexports.separated = separated;\nvar _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };\nvar _mapLeft = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f)); };\nvar _bimap = function (fa, g, f) { return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f)); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.10.0\n */\nvar map = function (f) {\n    return function (fa) {\n        return (0, exports.separated)((0, exports.left)(fa), f((0, exports.right)(fa)));\n    };\n};\nexports.map = map;\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.10.0\n */\nvar mapLeft = function (f) {\n    return function (fa) {\n        return (0, exports.separated)(f((0, exports.left)(fa)), (0, exports.right)(fa));\n    };\n};\nexports.mapLeft = mapLeft;\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.10.0\n */\nvar bimap = function (f, g) {\n    return function (fa) {\n        return (0, exports.separated)(f((0, exports.left)(fa)), g((0, exports.right)(fa)));\n    };\n};\nexports.bimap = bimap;\n/**\n * @category type lambdas\n * @since 2.10.0\n */\nexports.URI = 'Separated';\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Bifunctor = {\n    URI: exports.URI,\n    mapLeft: _mapLeft,\n    bimap: _bimap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Functor = {\n    URI: exports.URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexports.flap = (0, Functor_1.flap)(exports.Functor);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nvar left = function (s) { return s.left; };\nexports.left = left;\n/**\n * @since 2.10.0\n */\nvar right = function (s) { return s.right; };\nexports.right = right;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}