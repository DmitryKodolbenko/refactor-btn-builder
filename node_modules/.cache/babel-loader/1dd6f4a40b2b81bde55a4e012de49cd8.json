{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseJsonRpcResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcErrorResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = void 0;\nvar compatibility_1 = require(\"./compatibility\");\n/**\n * Extracts ID field from request or response object.\n *\n * Returns `null` when no valid ID was found.\n */\nfunction parseJsonRpcId(data) {\n  if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {\n    throw new Error(\"Data must be JSON compatible dictionary\");\n  }\n  var id = data.id;\n  if (typeof id !== \"number\" && typeof id !== \"string\") {\n    return null;\n  }\n  return id;\n}\nexports.parseJsonRpcId = parseJsonRpcId;\nfunction parseJsonRpcRequest(data) {\n  if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {\n    throw new Error(\"Data must be JSON compatible dictionary\");\n  }\n  if (data.jsonrpc !== \"2.0\") {\n    throw new Error(\"Got unexpected jsonrpc version: \".concat(data.jsonrpc));\n  }\n  var id = parseJsonRpcId(data);\n  if (id === null) {\n    throw new Error(\"Invalid id field\");\n  }\n  var method = data.method;\n  if (typeof method !== \"string\") {\n    throw new Error(\"Invalid method field\");\n  }\n  if (!(0, compatibility_1.isJsonCompatibleArray)(data.params) && !(0, compatibility_1.isJsonCompatibleDictionary)(data.params)) {\n    throw new Error(\"Invalid params field\");\n  }\n  return {\n    jsonrpc: \"2.0\",\n    id: id,\n    method: method,\n    params: data.params\n  };\n}\nexports.parseJsonRpcRequest = parseJsonRpcRequest;\nfunction parseError(error) {\n  if (typeof error.code !== \"number\") {\n    throw new Error(\"Error property 'code' is not a number\");\n  }\n  if (typeof error.message !== \"string\") {\n    throw new Error(\"Error property 'message' is not a string\");\n  }\n  var maybeUndefinedData;\n  if (error.data === undefined) {\n    maybeUndefinedData = undefined;\n  } else if ((0, compatibility_1.isJsonCompatibleValue)(error.data)) {\n    maybeUndefinedData = error.data;\n  } else {\n    throw new Error(\"Error property 'data' is defined but not a JSON compatible value.\");\n  }\n  return _objectSpread({\n    code: error.code,\n    message: error.message\n  }, maybeUndefinedData !== undefined ? {\n    data: maybeUndefinedData\n  } : {});\n}\n/** Throws if data is not a JsonRpcErrorResponse */\nfunction parseJsonRpcErrorResponse(data) {\n  if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {\n    throw new Error(\"Data must be JSON compatible dictionary\");\n  }\n  if (data.jsonrpc !== \"2.0\") {\n    throw new Error(\"Got unexpected jsonrpc version: \".concat(JSON.stringify(data)));\n  }\n  var id = data.id;\n  if (typeof id !== \"number\" && typeof id !== \"string\" && id !== null) {\n    throw new Error(\"Invalid id field\");\n  }\n  if (typeof data.error === \"undefined\" || !(0, compatibility_1.isJsonCompatibleDictionary)(data.error)) {\n    throw new Error(\"Invalid error field\");\n  }\n  return {\n    jsonrpc: \"2.0\",\n    id: id,\n    error: parseError(data.error)\n  };\n}\nexports.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;\n/** Throws if data is not a JsonRpcSuccessResponse */\nfunction parseJsonRpcSuccessResponse(data) {\n  if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {\n    throw new Error(\"Data must be JSON compatible dictionary\");\n  }\n  if (data.jsonrpc !== \"2.0\") {\n    throw new Error(\"Got unexpected jsonrpc version: \".concat(JSON.stringify(data)));\n  }\n  var id = data.id;\n  if (typeof id !== \"number\" && typeof id !== \"string\") {\n    throw new Error(\"Invalid id field\");\n  }\n  if (typeof data.result === \"undefined\") {\n    throw new Error(\"Invalid result field\");\n  }\n  var result = data.result;\n  return {\n    jsonrpc: \"2.0\",\n    id: id,\n    result: result\n  };\n}\nexports.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;\n/**\n * Returns a JsonRpcErrorResponse if input can be parsed as a JSON-RPC error. Otherwise parses\n * input as JsonRpcSuccessResponse. Throws if input is neither a valid error nor success response.\n */\nfunction parseJsonRpcResponse(data) {\n  var response;\n  try {\n    response = parseJsonRpcErrorResponse(data);\n  } catch (_) {\n    response = parseJsonRpcSuccessResponse(data);\n  }\n  return response;\n}\nexports.parseJsonRpcResponse = parseJsonRpcResponse;","map":{"version":3,"sources":["../src/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseJsonRpcResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcErrorResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = void 0;\nconst compatibility_1 = require(\"./compatibility\");\n/**\n * Extracts ID field from request or response object.\n *\n * Returns `null` when no valid ID was found.\n */\nfunction parseJsonRpcId(data) {\n    if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {\n        throw new Error(\"Data must be JSON compatible dictionary\");\n    }\n    const id = data.id;\n    if (typeof id !== \"number\" && typeof id !== \"string\") {\n        return null;\n    }\n    return id;\n}\nexports.parseJsonRpcId = parseJsonRpcId;\nfunction parseJsonRpcRequest(data) {\n    if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {\n        throw new Error(\"Data must be JSON compatible dictionary\");\n    }\n    if (data.jsonrpc !== \"2.0\") {\n        throw new Error(`Got unexpected jsonrpc version: ${data.jsonrpc}`);\n    }\n    const id = parseJsonRpcId(data);\n    if (id === null) {\n        throw new Error(\"Invalid id field\");\n    }\n    const method = data.method;\n    if (typeof method !== \"string\") {\n        throw new Error(\"Invalid method field\");\n    }\n    if (!(0, compatibility_1.isJsonCompatibleArray)(data.params) && !(0, compatibility_1.isJsonCompatibleDictionary)(data.params)) {\n        throw new Error(\"Invalid params field\");\n    }\n    return {\n        jsonrpc: \"2.0\",\n        id: id,\n        method: method,\n        params: data.params,\n    };\n}\nexports.parseJsonRpcRequest = parseJsonRpcRequest;\nfunction parseError(error) {\n    if (typeof error.code !== \"number\") {\n        throw new Error(\"Error property 'code' is not a number\");\n    }\n    if (typeof error.message !== \"string\") {\n        throw new Error(\"Error property 'message' is not a string\");\n    }\n    let maybeUndefinedData;\n    if (error.data === undefined) {\n        maybeUndefinedData = undefined;\n    }\n    else if ((0, compatibility_1.isJsonCompatibleValue)(error.data)) {\n        maybeUndefinedData = error.data;\n    }\n    else {\n        throw new Error(\"Error property 'data' is defined but not a JSON compatible value.\");\n    }\n    return {\n        code: error.code,\n        message: error.message,\n        ...(maybeUndefinedData !== undefined ? { data: maybeUndefinedData } : {}),\n    };\n}\n/** Throws if data is not a JsonRpcErrorResponse */\nfunction parseJsonRpcErrorResponse(data) {\n    if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {\n        throw new Error(\"Data must be JSON compatible dictionary\");\n    }\n    if (data.jsonrpc !== \"2.0\") {\n        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);\n    }\n    const id = data.id;\n    if (typeof id !== \"number\" && typeof id !== \"string\" && id !== null) {\n        throw new Error(\"Invalid id field\");\n    }\n    if (typeof data.error === \"undefined\" || !(0, compatibility_1.isJsonCompatibleDictionary)(data.error)) {\n        throw new Error(\"Invalid error field\");\n    }\n    return {\n        jsonrpc: \"2.0\",\n        id: id,\n        error: parseError(data.error),\n    };\n}\nexports.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;\n/** Throws if data is not a JsonRpcSuccessResponse */\nfunction parseJsonRpcSuccessResponse(data) {\n    if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {\n        throw new Error(\"Data must be JSON compatible dictionary\");\n    }\n    if (data.jsonrpc !== \"2.0\") {\n        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);\n    }\n    const id = data.id;\n    if (typeof id !== \"number\" && typeof id !== \"string\") {\n        throw new Error(\"Invalid id field\");\n    }\n    if (typeof data.result === \"undefined\") {\n        throw new Error(\"Invalid result field\");\n    }\n    const result = data.result;\n    return {\n        jsonrpc: \"2.0\",\n        id: id,\n        result: result,\n    };\n}\nexports.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;\n/**\n * Returns a JsonRpcErrorResponse if input can be parsed as a JSON-RPC error. Otherwise parses\n * input as JsonRpcSuccessResponse. Throws if input is neither a valid error nor success response.\n */\nfunction parseJsonRpcResponse(data) {\n    let response;\n    try {\n        response = parseJsonRpcErrorResponse(data);\n    }\n    catch (_) {\n        response = parseJsonRpcSuccessResponse(data);\n    }\n    return response;\n}\nexports.parseJsonRpcResponse = parseJsonRpcResponse;\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"script"}