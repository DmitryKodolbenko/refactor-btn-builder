{"ast":null,"code":"var _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require(\"../utils\"),\n  BN = _require.BN,\n  bytesToHex = _require.bytesToHex;\nvar BitString = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * @param length {number}    length of BitString in bits\n   */\n  function BitString(length) {\n    _classCallCheck(this, BitString);\n    this.array = Uint8Array.from({\n      length: Math.ceil(length / 8)\n    }, function () {\n      return 0;\n    });\n    this.cursor = 0;\n    this.length = length;\n  }\n\n  /**\n   * @return {number}\n   */\n  _createClass(BitString, [{\n    key: \"getFreeBits\",\n    value: function getFreeBits() {\n      return this.length - this.cursor;\n    }\n\n    /**\n     * @return {number}\n     */\n  }, {\n    key: \"getUsedBits\",\n    value: function getUsedBits() {\n      return this.cursor;\n    }\n\n    /**\n     * @return {number}\n     */\n  }, {\n    key: \"getUsedBytes\",\n    value: function getUsedBytes() {\n      return Math.ceil(this.cursor / 8);\n    }\n\n    /**\n     * @param n {number}\n     * @return {boolean}    bit value at position `n`\n     */\n  }, {\n    key: \"get\",\n    value: function get(n) {\n      return (this.array[n / 8 | 0] & 1 << 7 - n % 8) > 0;\n    }\n\n    /**\n     * @private\n     * @param n {number}\n     */\n  }, {\n    key: \"checkRange\",\n    value: function checkRange(n) {\n      if (n > this.length) {\n        throw Error(\"BitString overflow\");\n      }\n    }\n\n    /**\n     * Set bit value to 1 at position `n`\n     * @param n {number}\n     */\n  }, {\n    key: \"on\",\n    value: function on(n) {\n      this.checkRange(n);\n      this.array[n / 8 | 0] |= 1 << 7 - n % 8;\n    }\n\n    /**\n     * Set bit value to 0 at position `n`\n     * @param n {number}\n     */\n  }, {\n    key: \"off\",\n    value: function off(n) {\n      this.checkRange(n);\n      this.array[n / 8 | 0] &= ~(1 << 7 - n % 8);\n    }\n\n    /**\n     * Toggle bit value at position `n`\n     * @param n {number}\n     */\n  }, {\n    key: \"toggle\",\n    value: function toggle(n) {\n      this.checkRange(n);\n      this.array[n / 8 | 0] ^= 1 << 7 - n % 8;\n    }\n\n    /**\n     * forEach every bit\n     * @param callback  {function(boolean): void}\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback) {\n      var max = this.cursor;\n      for (var x = 0; x < max; x++) {\n        callback(this.get(x));\n      }\n    }\n\n    /**\n     * Write bit and increase cursor\n     * @param b  {boolean | number}\n     */\n  }, {\n    key: \"writeBit\",\n    value: function writeBit(b) {\n      if (b && b > 0) {\n        this.on(this.cursor);\n      } else {\n        this.off(this.cursor);\n      }\n      this.cursor = this.cursor + 1;\n    }\n\n    /**\n     * @param ba  {Array<boolean | number>}\n     */\n  }, {\n    key: \"writeBitArray\",\n    value: function writeBitArray(ba) {\n      for (var i = 0; i < ba.length; i++) {\n        this.writeBit(ba[i]);\n      }\n    }\n\n    /**\n     * Write unsigned int\n     * @param number  {number | BN}\n     * @param bitLength  {number}  size of uint in bits\n     */\n  }, {\n    key: \"writeUint\",\n    value: function writeUint(number, bitLength) {\n      number = new BN(number);\n      if (bitLength == 0 || number.toString(2).length > bitLength) {\n        if (number == 0) return;\n        throw Error(\"bitLength is too small for number, got number=\" + number + \",bitLength=\" + bitLength);\n      }\n      var s = number.toString(2, bitLength);\n      for (var i = 0; i < bitLength; i++) {\n        this.writeBit(s[i] == 1);\n      }\n    }\n\n    /**\n     * Write signed int\n     * @param number  {number | BN}\n     * @param bitLength  {number}  size of int in bits\n     */\n  }, {\n    key: \"writeInt\",\n    value: function writeInt(number, bitLength) {\n      number = new BN(number);\n      if (bitLength == 1) {\n        if (number == -1) {\n          this.writeBit(true);\n          return;\n        }\n        if (number == 0) {\n          this.writeBit(false);\n          return;\n        }\n        throw Error(\"Bitlength is too small for number\");\n      } else {\n        if (number.isNeg()) {\n          this.writeBit(true);\n          var b = new BN(2);\n          var nb = b.pow(new BN(bitLength - 1));\n          this.writeUint(nb.add(number), bitLength - 1);\n        } else {\n          this.writeBit(false);\n          this.writeUint(number, bitLength - 1);\n        }\n      }\n    }\n\n    /**\n     * Write unsigned 8-bit int\n     * @param ui8 {number}\n     */\n  }, {\n    key: \"writeUint8\",\n    value: function writeUint8(ui8) {\n      this.writeUint(ui8, 8);\n    }\n\n    /**\n     * Write array of unsigned 8-bit ints\n     * @param ui8 {Uint8Array}\n     */\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(ui8) {\n      for (var i = 0; i < ui8.length; i++) {\n        this.writeUint8(ui8[i]);\n      }\n    }\n\n    /**\n     * @param s {string}\n     */\n  }, {\n    key: \"writeString\",\n    value: function writeString(s) {\n      for (var i = 0; i < s.length; i++) {\n        this.writeUint8(s.charCodeAt(i));\n      }\n    }\n\n    /**\n     * @param amount  {number | BN} in nanograms\n     */\n  }, {\n    key: \"writeGrams\",\n    value: function writeGrams(amount) {\n      if (amount == 0) {\n        this.writeUint(0, 4);\n      } else {\n        amount = new BN(amount);\n        var l = Math.ceil(amount.toString(16).length / 2);\n        this.writeUint(l, 4);\n        this.writeUint(amount, l * 8);\n      }\n    }\n\n    /**\n     * @param amount  {number | BN} in nanotons\n     */\n  }, {\n    key: \"writeCoins\",\n    value: function writeCoins(amount) {\n      this.writeGrams(amount);\n    }\n\n    //addr_none$00 = MsgAddressExt;\n    //addr_std$10 anycast:(Maybe Anycast)\n    // workchain_id:int8 address:uint256 = MsgAddressInt;\n    /**\n     * @param address {Address | null}\n     */\n  }, {\n    key: \"writeAddress\",\n    value: function writeAddress(address) {\n      if (address == null) {\n        this.writeUint(0, 2);\n      } else {\n        this.writeUint(2, 2);\n        this.writeUint(0, 1); // TODO split addresses (anycast)\n        this.writeInt(address.wc, 8);\n        this.writeBytes(address.hashPart);\n      }\n    }\n\n    /**\n     * write another BitString to this BitString\n     * @param anotherBitString  {BitString}\n     */\n  }, {\n    key: \"writeBitString\",\n    value: function writeBitString(anotherBitString) {\n      var _this = this;\n      anotherBitString.forEach(function (x) {\n        _this.writeBit(x);\n      });\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var result = new BitString(0);\n      result.array = this.array.slice(0);\n      result.length = this.length;\n      result.cursor = this.cursor;\n      return result;\n    }\n\n    /**\n     * @return {string} hex\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toHex();\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n  }, {\n    key: \"getTopUppedArray\",\n    value: function getTopUppedArray() {\n      var ret = this.clone();\n      var tu = Math.ceil(ret.cursor / 8) * 8 - ret.cursor;\n      if (tu > 0) {\n        tu = tu - 1;\n        ret.writeBit(true);\n        while (tu > 0) {\n          tu = tu - 1;\n          ret.writeBit(false);\n        }\n      }\n      ret.array = ret.array.slice(0, Math.ceil(ret.cursor / 8));\n      return ret.array;\n    }\n\n    /**\n     * like Fift\n     * @return {string}\n     */\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      if (this.cursor % 4 === 0) {\n        var s = bytesToHex(this.array.slice(0, Math.ceil(this.cursor / 8))).toUpperCase();\n        if (this.cursor % 8 === 0) {\n          return s;\n        } else {\n          return s.substr(0, s.length - 1);\n        }\n      } else {\n        var temp = this.clone();\n        temp.writeBit(1);\n        while (temp.cursor % 4 !== 0) {\n          temp.writeBit(0);\n        }\n        var hex = temp.toHex().toUpperCase();\n        return hex + '_';\n      }\n    }\n\n    /**\n     * set this cell data to match provided topUppedArray\n     * @param array  {Uint8Array}\n     * @param fullfilledBytes  {boolean}\n     */\n  }, {\n    key: \"setTopUppedArray\",\n    value: function setTopUppedArray(array) {\n      var fullfilledBytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.length = array.length * 8;\n      this.array = array;\n      this.cursor = this.length;\n      if (fullfilledBytes || !this.length) {\n        return;\n      } else {\n        var foundEndBit = false;\n        for (var c = 0; c < 7; c++) {\n          this.cursor -= 1;\n          if (this.get(this.cursor)) {\n            foundEndBit = true;\n            this.off(this.cursor);\n            break;\n          }\n        }\n        if (!foundEndBit) {\n          console.log(array, fullfilledBytes);\n          throw new Error(\"Incorrect TopUppedArray\");\n        }\n      }\n    }\n  }]);\n  return BitString;\n}();\nmodule.exports = {\n  BitString: BitString\n};","map":{"version":3,"names":["require","BN","bytesToHex","BitString","length","array","Uint8Array","from","Math","ceil","cursor","n","Error","checkRange","callback","max","x","get","b","on","off","ba","i","writeBit","number","bitLength","toString","s","isNeg","nb","pow","writeUint","add","ui8","writeUint8","charCodeAt","amount","l","writeGrams","address","writeInt","wc","writeBytes","hashPart","anotherBitString","forEach","result","slice","toHex","ret","clone","tu","toUpperCase","substr","temp","hex","fullfilledBytes","foundEndBit","c","console","log","module","exports"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/tonweb/src/boc/BitString.js"],"sourcesContent":["const {BN, bytesToHex} = require(\"../utils\");\n\nclass BitString {\n    /**\n     * @param length {number}    length of BitString in bits\n     */\n    constructor(length) {\n        this.array = Uint8Array.from({length: Math.ceil(length / 8)}, () => 0);\n        this.cursor = 0;\n        this.length = length;\n    }\n\n    /**\n     * @return {number}\n     */\n    getFreeBits() {\n        return this.length - this.cursor;\n    }\n\n    /**\n     * @return {number}\n     */\n    getUsedBits() {\n        return this.cursor;\n    }\n\n    /**\n     * @return {number}\n     */\n    getUsedBytes() {\n        return Math.ceil(this.cursor / 8);\n    }\n\n    /**\n     * @param n {number}\n     * @return {boolean}    bit value at position `n`\n     */\n    get(n) {\n        return (this.array[(n / 8) | 0] & (1 << (7 - (n % 8)))) > 0;\n    }\n\n    /**\n     * @private\n     * @param n {number}\n     */\n    checkRange(n) {\n        if (n > this.length) {\n            throw Error(\"BitString overflow\");\n        }\n    }\n\n    /**\n     * Set bit value to 1 at position `n`\n     * @param n {number}\n     */\n    on(n) {\n        this.checkRange(n);\n        this.array[(n / 8) | 0] |= 1 << (7 - (n % 8));\n    }\n\n    /**\n     * Set bit value to 0 at position `n`\n     * @param n {number}\n     */\n    off(n) {\n        this.checkRange(n);\n        this.array[(n / 8) | 0] &= ~(1 << (7 - (n % 8)));\n    }\n\n    /**\n     * Toggle bit value at position `n`\n     * @param n {number}\n     */\n    toggle(n) {\n        this.checkRange(n);\n        this.array[(n / 8) | 0] ^= 1 << (7 - (n % 8));\n    }\n\n    /**\n     * forEach every bit\n     * @param callback  {function(boolean): void}\n     */\n    forEach(callback) {\n        const max = this.cursor;\n        for (let x = 0; x < max; x++) {\n            callback(this.get(x));\n        }\n    }\n\n    /**\n     * Write bit and increase cursor\n     * @param b  {boolean | number}\n     */\n    writeBit(b) {\n        if (b && b > 0) {\n            this.on(this.cursor);\n        } else {\n            this.off(this.cursor);\n        }\n        this.cursor = this.cursor + 1;\n    }\n\n    /**\n     * @param ba  {Array<boolean | number>}\n     */\n    writeBitArray(ba) {\n        for (let i = 0; i < ba.length; i++) {\n            this.writeBit(ba[i]);\n        }\n    }\n\n    /**\n     * Write unsigned int\n     * @param number  {number | BN}\n     * @param bitLength  {number}  size of uint in bits\n     */\n    writeUint(number, bitLength) {\n        number = new BN(number);\n        if (\n            bitLength == 0 ||\n            (number.toString(2).length > bitLength)\n        ) {\n            if (number == 0) return;\n            throw Error(\"bitLength is too small for number, got number=\" + number + \",bitLength=\" + bitLength);\n        }\n        const s = number.toString(2, bitLength);\n        for (let i = 0; i < bitLength; i++) {\n            this.writeBit(s[i] == 1);\n        }\n    }\n\n    /**\n     * Write signed int\n     * @param number  {number | BN}\n     * @param bitLength  {number}  size of int in bits\n     */\n    writeInt(number, bitLength) {\n        number = new BN(number);\n        if (bitLength == 1) {\n            if (number == -1) {\n                this.writeBit(true);\n                return;\n            }\n            if (number == 0) {\n                this.writeBit(false);\n                return;\n            }\n            throw Error(\"Bitlength is too small for number\");\n        } else {\n            if (number.isNeg()) {\n                this.writeBit(true);\n                const b = new BN(2);\n                const nb = b.pow(new BN(bitLength - 1));\n                this.writeUint(nb.add(number), bitLength - 1);\n            } else {\n                this.writeBit(false);\n                this.writeUint(number, bitLength - 1);\n            }\n        }\n    }\n\n    /**\n     * Write unsigned 8-bit int\n     * @param ui8 {number}\n     */\n    writeUint8(ui8) {\n        this.writeUint(ui8, 8);\n    }\n\n    /**\n     * Write array of unsigned 8-bit ints\n     * @param ui8 {Uint8Array}\n     */\n    writeBytes(ui8) {\n        for (let i = 0; i < ui8.length; i++) {\n            this.writeUint8(ui8[i]);\n        }\n    }\n\n    /**\n     * @param s {string}\n     */\n    writeString(s) {\n        for (let i = 0; i < s.length; i++) {\n            this.writeUint8(s.charCodeAt(i));\n        }\n    }\n\n    /**\n     * @param amount  {number | BN} in nanograms\n     */\n    writeGrams(amount) {\n        if (amount == 0) {\n            this.writeUint(0, 4);\n        } else {\n            amount = new BN(amount);\n            const l = Math.ceil((amount.toString(16).length) / 2);\n            this.writeUint(l, 4);\n            this.writeUint(amount, l * 8);\n        }\n    }\n\n\n    /**\n     * @param amount  {number | BN} in nanotons\n     */\n    writeCoins(amount) {\n        this.writeGrams(amount);\n    }\n\n    //addr_none$00 = MsgAddressExt;\n    //addr_std$10 anycast:(Maybe Anycast)\n    // workchain_id:int8 address:uint256 = MsgAddressInt;\n    /**\n     * @param address {Address | null}\n     */\n    writeAddress(address) {\n        if (address == null) {\n            this.writeUint(0, 2);\n        } else {\n            this.writeUint(2, 2);\n            this.writeUint(0, 1); // TODO split addresses (anycast)\n            this.writeInt(address.wc, 8);\n            this.writeBytes(address.hashPart);\n        }\n    }\n\n    /**\n     * write another BitString to this BitString\n     * @param anotherBitString  {BitString}\n     */\n    writeBitString(anotherBitString) {\n        anotherBitString.forEach(x => {\n            this.writeBit(x);\n        });\n    }\n\n    clone() {\n        const result = new BitString(0);\n        result.array = this.array.slice(0);\n        result.length = this.length\n        result.cursor = this.cursor;\n        return result;\n    }\n\n    /**\n     * @return {string} hex\n     */\n    toString() {\n        return this.toHex();\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n    getTopUppedArray() {\n        const ret = this.clone();\n\n        let tu = Math.ceil(ret.cursor / 8) * 8 - ret.cursor;\n        if (tu > 0) {\n            tu = tu - 1;\n            ret.writeBit(true);\n            while (tu > 0) {\n                tu = tu - 1;\n                ret.writeBit(false);\n            }\n        }\n        ret.array = ret.array.slice(0, Math.ceil(ret.cursor / 8));\n        return ret.array;\n    }\n\n    /**\n     * like Fift\n     * @return {string}\n     */\n    toHex() {\n        if (this.cursor % 4 === 0) {\n            const s = bytesToHex(this.array.slice(0, Math.ceil(this.cursor / 8))).toUpperCase();\n            if (this.cursor % 8 === 0) {\n                return s;\n            } else {\n                return s.substr(0, s.length - 1);\n            }\n        } else {\n            const temp = this.clone();\n            temp.writeBit(1);\n            while (temp.cursor % 4 !== 0) {\n                temp.writeBit(0);\n            }\n            const hex = temp.toHex().toUpperCase();\n            return hex + '_';\n        }\n    }\n\n    /**\n     * set this cell data to match provided topUppedArray\n     * @param array  {Uint8Array}\n     * @param fullfilledBytes  {boolean}\n     */\n    setTopUppedArray(array, fullfilledBytes = true) {\n        this.length = array.length * 8;\n        this.array = array;\n        this.cursor = this.length;\n        if (fullfilledBytes || !this.length) {\n            return;\n        } else {\n            let foundEndBit = false;\n            for (let c = 0; c < 7; c++) {\n                this.cursor -= 1;\n                if (this.get(this.cursor)) {\n                    foundEndBit = true;\n                    this.off(this.cursor);\n                    break;\n                }\n            }\n            if (!foundEndBit) {\n                console.log(array, fullfilledBytes);\n                throw new Error(\"Incorrect TopUppedArray\");\n            }\n        }\n    }\n}\n\nmodule.exports = {BitString};"],"mappings":"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"},"metadata":{},"sourceType":"script"}