{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bytesBefore = exports.ensureBytesBefore = exports.bytesEqual = exports.ensureBytesEqual = exports.ensureInner = exports.ensureLeaf = void 0;\nfunction ensureLeaf(leaf, spec) {\n  if (leaf.hash !== spec.hash) {\n    throw new Error(`Unexpected hashOp: ${leaf.hash}`);\n  }\n  if (leaf.prehashKey !== spec.prehashKey) {\n    throw new Error(`Unexpected prehashKey: ${leaf.prehashKey}`);\n  }\n  if (leaf.prehashValue !== spec.prehashValue) {\n    throw new Error(`Unexpected prehashValue: ${leaf.prehashValue}`);\n  }\n  if (leaf.length !== spec.length) {\n    throw new Error(`Unexpected length op: ${leaf.length}`);\n  }\n  ensurePrefix(leaf.prefix, spec.prefix);\n}\nexports.ensureLeaf = ensureLeaf;\nfunction ensureInner(inner, prefix, spec) {\n  if (inner.hash !== spec.hash) {\n    throw new Error(`Unexpected hashOp: ${inner.hash}`);\n  }\n  if (!inner.prefix) {\n    throw new Error(\"No prefix set for inner node\");\n  }\n  if (hasPrefix(inner.prefix, prefix)) {\n    throw new Error(`Inner node has leaf prefix`);\n  }\n  if (inner.prefix.length < (spec.minPrefixLength || 0)) {\n    throw new Error(`Prefix too short: ${inner.prefix.length} bytes`);\n  }\n  const maxLeftChildBytes = (spec.childOrder.length - 1) * spec.childSize;\n  if (inner.prefix.length > (spec.maxPrefixLength || 0) + maxLeftChildBytes) {\n    throw new Error(`Prefix too long: ${inner.prefix.length} bytes`);\n  }\n}\nexports.ensureInner = ensureInner;\nfunction ensurePrefix(check, prefix) {\n  // no prefix supplied, means everything passes\n  if (!prefix || prefix.length === 0) {\n    return;\n  }\n  if (!check) {\n    throw new Error(`Target bytes missing`);\n  }\n  ensureBytesEqual(prefix, check.slice(0, prefix.length));\n}\n// ensureBytesEqual throws an error if the arrays are different\nfunction ensureBytesEqual(a, b) {\n  if (a.length !== b.length) {\n    throw new Error(`Different lengths ${a.length} vs ${b.length}`);\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      throw new Error(`Arrays differ at index ${i}: ${a[i]} vs ${b[i]}`);\n    }\n  }\n}\nexports.ensureBytesEqual = ensureBytesEqual;\nfunction bytesEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.bytesEqual = bytesEqual;\nfunction hasPrefix(check, prefix) {\n  // no prefix supplied, means everything passes\n  if (!prefix || prefix.length === 0) {\n    return false;\n  }\n  if (!check) {\n    return false;\n  }\n  if (check.length <= prefix.length) {\n    return false;\n  }\n  for (let i = 0; i < prefix.length; i++) {\n    if (check[i] !== prefix[i]) {\n      return false;\n    }\n  }\n  throw true;\n}\n// ensureBytesBefore throws an error if first >= last\n// we compare byte by byte\nfunction ensureBytesBefore(first, last) {\n  if (!bytesBefore(first, last)) {\n    throw new Error(\"first is after last\");\n  }\n}\nexports.ensureBytesBefore = ensureBytesBefore;\nfunction bytesBefore(first, last) {\n  const min = first.length < last.length ? first.length : last.length;\n  for (let i = 0; i < min; i++) {\n    if (first[i] < last[i]) {\n      return true;\n    }\n    if (first[i] > last[i]) {\n      return false;\n    }\n    // if they are equal, continue to next step\n  }\n  // if they match, ensure that last is longer than first..\n  return first.length < last.length;\n}\nexports.bytesBefore = bytesBefore;","map":{"version":3,"sources":["../src/specs.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bytesBefore = exports.ensureBytesBefore = exports.bytesEqual = exports.ensureBytesEqual = exports.ensureInner = exports.ensureLeaf = void 0;\nfunction ensureLeaf(leaf, spec) {\n    if (leaf.hash !== spec.hash) {\n        throw new Error(`Unexpected hashOp: ${leaf.hash}`);\n    }\n    if (leaf.prehashKey !== spec.prehashKey) {\n        throw new Error(`Unexpected prehashKey: ${leaf.prehashKey}`);\n    }\n    if (leaf.prehashValue !== spec.prehashValue) {\n        throw new Error(`Unexpected prehashValue: ${leaf.prehashValue}`);\n    }\n    if (leaf.length !== spec.length) {\n        throw new Error(`Unexpected length op: ${leaf.length}`);\n    }\n    ensurePrefix(leaf.prefix, spec.prefix);\n}\nexports.ensureLeaf = ensureLeaf;\nfunction ensureInner(inner, prefix, spec) {\n    if (inner.hash !== spec.hash) {\n        throw new Error(`Unexpected hashOp: ${inner.hash}`);\n    }\n    if (!inner.prefix) {\n        throw new Error(\"No prefix set for inner node\");\n    }\n    if (hasPrefix(inner.prefix, prefix)) {\n        throw new Error(`Inner node has leaf prefix`);\n    }\n    if (inner.prefix.length < (spec.minPrefixLength || 0)) {\n        throw new Error(`Prefix too short: ${inner.prefix.length} bytes`);\n    }\n    const maxLeftChildBytes = (spec.childOrder.length - 1) * spec.childSize;\n    if (inner.prefix.length > (spec.maxPrefixLength || 0) + maxLeftChildBytes) {\n        throw new Error(`Prefix too long: ${inner.prefix.length} bytes`);\n    }\n}\nexports.ensureInner = ensureInner;\nfunction ensurePrefix(check, prefix) {\n    // no prefix supplied, means everything passes\n    if (!prefix || prefix.length === 0) {\n        return;\n    }\n    if (!check) {\n        throw new Error(`Target bytes missing`);\n    }\n    ensureBytesEqual(prefix, check.slice(0, prefix.length));\n}\n// ensureBytesEqual throws an error if the arrays are different\nfunction ensureBytesEqual(a, b) {\n    if (a.length !== b.length) {\n        throw new Error(`Different lengths ${a.length} vs ${b.length}`);\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            throw new Error(`Arrays differ at index ${i}: ${a[i]} vs ${b[i]}`);\n        }\n    }\n}\nexports.ensureBytesEqual = ensureBytesEqual;\nfunction bytesEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.bytesEqual = bytesEqual;\nfunction hasPrefix(check, prefix) {\n    // no prefix supplied, means everything passes\n    if (!prefix || prefix.length === 0) {\n        return false;\n    }\n    if (!check) {\n        return false;\n    }\n    if (check.length <= prefix.length) {\n        return false;\n    }\n    for (let i = 0; i < prefix.length; i++) {\n        if (check[i] !== prefix[i]) {\n            return false;\n        }\n    }\n    throw true;\n}\n// ensureBytesBefore throws an error if first >= last\n// we compare byte by byte\nfunction ensureBytesBefore(first, last) {\n    if (!bytesBefore(first, last)) {\n        throw new Error(\"first is after last\");\n    }\n}\nexports.ensureBytesBefore = ensureBytesBefore;\nfunction bytesBefore(first, last) {\n    const min = first.length < last.length ? first.length : last.length;\n    for (let i = 0; i < min; i++) {\n        if (first[i] < last[i]) {\n            return true;\n        }\n        if (first[i] > last[i]) {\n            return false;\n        }\n        // if they are equal, continue to next step\n    }\n    // if they match, ensure that last is longer than first..\n    return first.length < last.length;\n}\nexports.bytesBefore = bytesBefore;\n//# sourceMappingURL=specs.js.map"]},"metadata":{},"sourceType":"script"}