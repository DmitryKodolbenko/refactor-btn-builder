{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getApplicativeComposition = exports.getApplicativeMonoid = void 0;\n/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\nvar Apply_1 = require(\"./Apply\");\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\nfunction getApplicativeMonoid(F) {\n  var f = (0, Apply_1.getApplySemigroup)(F);\n  return function (M) {\n    return {\n      concat: f(M).concat,\n      empty: F.of(M.empty)\n    };\n  };\n}\nexports.getApplicativeMonoid = getApplicativeMonoid;\n/** @deprecated */\nfunction getApplicativeComposition(F, G) {\n  var map = (0, Functor_1.getFunctorComposition)(F, G).map;\n  var _ap = (0, Apply_1.ap)(F, G);\n  return {\n    map: map,\n    of: function of(a) {\n      return F.of(G.of(a));\n    },\n    ap: function ap(fgab, fga) {\n      return (0, function_1.pipe)(fgab, _ap(fga));\n    }\n  };\n}\nexports.getApplicativeComposition = getApplicativeComposition;","map":{"version":3,"names":["Object","defineProperty","exports","value","getApplicativeComposition","getApplicativeMonoid","Apply_1","require","function_1","Functor_1","F","f","getApplySemigroup","M","concat","empty","of","G","map","getFunctorComposition","_ap","ap","a","fgab","fga","pipe"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/fp-ts/lib/Applicative.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getApplicativeComposition = exports.getApplicativeMonoid = void 0;\n/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\nvar Apply_1 = require(\"./Apply\");\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\nfunction getApplicativeMonoid(F) {\n    var f = (0, Apply_1.getApplySemigroup)(F);\n    return function (M) { return ({\n        concat: f(M).concat,\n        empty: F.of(M.empty)\n    }); };\n}\nexports.getApplicativeMonoid = getApplicativeMonoid;\n/** @deprecated */\nfunction getApplicativeComposition(F, G) {\n    var map = (0, Functor_1.getFunctorComposition)(F, G).map;\n    var _ap = (0, Apply_1.ap)(F, G);\n    return {\n        map: map,\n        of: function (a) { return F.of(G.of(a)); },\n        ap: function (fgab, fga) { return (0, function_1.pipe)(fgab, _ap(fga)); }\n    };\n}\nexports.getApplicativeComposition = getApplicativeComposition;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,yBAAyB,GAAGF,OAAO,CAACG,oBAAoB,GAAG,KAAK,CAAC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,OAAO,GAAGC,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIC,UAAU,GAAGD,OAAO,CAAC,YAAY,CAAC;AACtC,IAAIE,SAAS,GAAGF,OAAO,CAAC,WAAW,CAAC;AACpC,SAASF,oBAAoB,CAACK,CAAC,EAAE;EAC7B,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEL,OAAO,CAACM,iBAAiB,EAAEF,CAAC,CAAC;EACzC,OAAO,UAAUG,CAAC,EAAE;IAAE,OAAQ;MAC1BC,MAAM,EAAEH,CAAC,CAACE,CAAC,CAAC,CAACC,MAAM;MACnBC,KAAK,EAAEL,CAAC,CAACM,EAAE,CAACH,CAAC,CAACE,KAAK;IACvB,CAAC;EAAG,CAAC;AACT;AACAb,OAAO,CAACG,oBAAoB,GAAGA,oBAAoB;AACnD;AACA,SAASD,yBAAyB,CAACM,CAAC,EAAEO,CAAC,EAAE;EACrC,IAAIC,GAAG,GAAG,CAAC,CAAC,EAAET,SAAS,CAACU,qBAAqB,EAAET,CAAC,EAAEO,CAAC,CAAC,CAACC,GAAG;EACxD,IAAIE,GAAG,GAAG,CAAC,CAAC,EAAEd,OAAO,CAACe,EAAE,EAAEX,CAAC,EAAEO,CAAC,CAAC;EAC/B,OAAO;IACHC,GAAG,EAAEA,GAAG;IACRF,EAAE,EAAE,YAAUM,CAAC,EAAE;MAAE,OAAOZ,CAAC,CAACM,EAAE,CAACC,CAAC,CAACD,EAAE,CAACM,CAAC,CAAC,CAAC;IAAE,CAAC;IAC1CD,EAAE,EAAE,YAAUE,IAAI,EAAEC,GAAG,EAAE;MAAE,OAAO,CAAC,CAAC,EAAEhB,UAAU,CAACiB,IAAI,EAAEF,IAAI,EAAEH,GAAG,CAACI,GAAG,CAAC,CAAC;IAAE;EAC5E,CAAC;AACL;AACAtB,OAAO,CAACE,yBAAyB,GAAGA,yBAAyB"},"metadata":{},"sourceType":"script"}