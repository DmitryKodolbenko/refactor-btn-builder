{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.batchVerifyNonMembership = exports.batchVerifyMembership = exports.verifyNonMembership = exports.verifyMembership = void 0;\nvar compress_1 = require(\"./compress\");\nvar proofs_1 = require(\"./proofs\");\nvar specs_1 = require(\"./specs\");\n/*\nThis implements the client side functions as specified in\nhttps://github.com/cosmos/ics/tree/master/spec/ics-023-vector-commitments\n\nIn particular:\n\n  // Assumes ExistenceProof\n  type verifyMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key, value: Value) => boolean\n\n  // Assumes NonExistenceProof\n  type verifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key) => boolean\n\n  // Assumes BatchProof - required ExistenceProofs may be a subset of all items proven\n  type batchVerifyMembership = (root: CommitmentRoot, proof: CommitmentProof, items: Map<Key, Value>) => boolean\n\n  // Assumes BatchProof - required NonExistenceProofs may be a subset of all items proven\n  type batchVerifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, keys: Set<Key>) => boolean\n\nWe make an adjustment to accept a Spec to ensure the provided proof is in the format of the expected merkle store.\nThis can avoid an range of attacks on fake preimages, as we need to be careful on how to map key, value -> leaf\nand determine neighbors\n*/\n/**\n * verifyMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction verifyMembership(proof, spec, root, key, value) {\n  var norm = (0, compress_1.decompress)(proof);\n  var exist = getExistForKey(norm, key);\n  if (!exist) {\n    return false;\n  }\n  try {\n    (0, proofs_1.verifyExistence)(exist, spec, root, key, value);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\nexports.verifyMembership = verifyMembership;\n/**\n * verifyNonMembership ensures proof is (contains) a valid non-existence proof for the given key\n */\nfunction verifyNonMembership(proof, spec, root, key) {\n  var norm = (0, compress_1.decompress)(proof);\n  var nonexist = getNonExistForKey(norm, key);\n  if (!nonexist) {\n    return false;\n  }\n  try {\n    (0, proofs_1.verifyNonExistence)(nonexist, spec, root, key);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\nexports.verifyNonMembership = verifyNonMembership;\n/**\n * batchVerifyMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction batchVerifyMembership(proof, spec, root, items) {\n  var norm = (0, compress_1.decompress)(proof);\n  var _iterator = _createForOfIteratorHelper(items.entries()),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        key = _step$value[0],\n        value = _step$value[1];\n      if (!verifyMembership(norm, spec, root, key, value)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return true;\n}\nexports.batchVerifyMembership = batchVerifyMembership;\n/**\n * batchVerifyNonMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction batchVerifyNonMembership(proof, spec, root, keys) {\n  var norm = (0, compress_1.decompress)(proof);\n  var _iterator2 = _createForOfIteratorHelper(keys),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var key = _step2.value;\n      if (!verifyNonMembership(norm, spec, root, key)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return true;\n}\nexports.batchVerifyNonMembership = batchVerifyNonMembership;\nfunction getExistForKey(proof, key) {\n  var match = function match(p) {\n    return !!p && (0, specs_1.bytesEqual)(key, p.key);\n  };\n  if (match(proof.exist)) {\n    return proof.exist;\n  } else if (proof.batch) {\n    return proof.batch.entries.map(function (x) {\n      return x.exist || null;\n    }).find(match);\n  }\n  return undefined;\n}\nfunction getNonExistForKey(proof, key) {\n  var match = function match(p) {\n    return !!p && (!p.left || (0, specs_1.bytesBefore)(p.left.key, key)) && (!p.right || (0, specs_1.bytesBefore)(key, p.right.key));\n  };\n  if (match(proof.nonexist)) {\n    return proof.nonexist;\n  } else if (proof.batch) {\n    return proof.batch.entries.map(function (x) {\n      return x.nonexist || null;\n    }).find(match);\n  }\n  return undefined;\n}","map":{"version":3,"sources":["../src/ics23.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.batchVerifyNonMembership = exports.batchVerifyMembership = exports.verifyNonMembership = exports.verifyMembership = void 0;\nconst compress_1 = require(\"./compress\");\nconst proofs_1 = require(\"./proofs\");\nconst specs_1 = require(\"./specs\");\n/*\nThis implements the client side functions as specified in\nhttps://github.com/cosmos/ics/tree/master/spec/ics-023-vector-commitments\n\nIn particular:\n\n  // Assumes ExistenceProof\n  type verifyMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key, value: Value) => boolean\n\n  // Assumes NonExistenceProof\n  type verifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key) => boolean\n\n  // Assumes BatchProof - required ExistenceProofs may be a subset of all items proven\n  type batchVerifyMembership = (root: CommitmentRoot, proof: CommitmentProof, items: Map<Key, Value>) => boolean\n\n  // Assumes BatchProof - required NonExistenceProofs may be a subset of all items proven\n  type batchVerifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, keys: Set<Key>) => boolean\n\nWe make an adjustment to accept a Spec to ensure the provided proof is in the format of the expected merkle store.\nThis can avoid an range of attacks on fake preimages, as we need to be careful on how to map key, value -> leaf\nand determine neighbors\n*/\n/**\n * verifyMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction verifyMembership(proof, spec, root, key, value) {\n    const norm = (0, compress_1.decompress)(proof);\n    const exist = getExistForKey(norm, key);\n    if (!exist) {\n        return false;\n    }\n    try {\n        (0, proofs_1.verifyExistence)(exist, spec, root, key, value);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexports.verifyMembership = verifyMembership;\n/**\n * verifyNonMembership ensures proof is (contains) a valid non-existence proof for the given key\n */\nfunction verifyNonMembership(proof, spec, root, key) {\n    const norm = (0, compress_1.decompress)(proof);\n    const nonexist = getNonExistForKey(norm, key);\n    if (!nonexist) {\n        return false;\n    }\n    try {\n        (0, proofs_1.verifyNonExistence)(nonexist, spec, root, key);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexports.verifyNonMembership = verifyNonMembership;\n/**\n * batchVerifyMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction batchVerifyMembership(proof, spec, root, items) {\n    const norm = (0, compress_1.decompress)(proof);\n    for (const [key, value] of items.entries()) {\n        if (!verifyMembership(norm, spec, root, key, value)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.batchVerifyMembership = batchVerifyMembership;\n/**\n * batchVerifyNonMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction batchVerifyNonMembership(proof, spec, root, keys) {\n    const norm = (0, compress_1.decompress)(proof);\n    for (const key of keys) {\n        if (!verifyNonMembership(norm, spec, root, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.batchVerifyNonMembership = batchVerifyNonMembership;\nfunction getExistForKey(proof, key) {\n    const match = (p) => !!p && (0, specs_1.bytesEqual)(key, p.key);\n    if (match(proof.exist)) {\n        return proof.exist;\n    }\n    else if (proof.batch) {\n        return proof.batch.entries.map((x) => x.exist || null).find(match);\n    }\n    return undefined;\n}\nfunction getNonExistForKey(proof, key) {\n    const match = (p) => {\n        return (!!p &&\n            (!p.left || (0, specs_1.bytesBefore)(p.left.key, key)) &&\n            (!p.right || (0, specs_1.bytesBefore)(key, p.right.key)));\n    };\n    if (match(proof.nonexist)) {\n        return proof.nonexist;\n    }\n    else if (proof.batch) {\n        return proof.batch.entries.map((x) => x.nonexist || null).find(match);\n    }\n    return undefined;\n}\n//# sourceMappingURL=ics23.js.map"]},"metadata":{},"sourceType":"script"}