{"ast":null,"code":"/* eslint-disable prefer-template */\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { DisconnectedDevice, TransportOpenUserCancelled } from \"@ledgerhq/errors\";\nimport { getBluetoothServiceUuids, getInfosForServiceUuid } from \"@ledgerhq/devices\";\nimport { sendAPDU } from \"@ledgerhq/devices/lib/ble/sendAPDU\";\nimport { receiveAPDU } from \"@ledgerhq/devices/lib/ble/receiveAPDU\";\nimport { log } from \"@ledgerhq/logs\";\nimport { Observable, defer, merge, from } from \"rxjs\";\nimport { share, ignoreElements, first, map, tap } from \"rxjs/operators\";\nimport { monitorCharacteristic } from \"./monitorCharacteristic\";\nconst requiresBluetooth = () => {\n  // $FlowFixMe\n  const {\n    bluetooth\n  } = navigator;\n  if (typeof bluetooth === \"undefined\") {\n    throw new Error(\"web bluetooth not supported\");\n  }\n  return bluetooth;\n};\nconst availability = () => Observable.create(observer => {\n  const bluetooth = requiresBluetooth();\n  const onAvailabilityChanged = e => {\n    observer.next(e.value);\n  };\n  bluetooth.addEventListener(\"availabilitychanged\", onAvailabilityChanged);\n  let unsubscribed = false;\n  bluetooth.getAvailability().then(available => {\n    if (!unsubscribed) {\n      observer.next(available);\n    }\n  });\n  return () => {\n    unsubscribed = true;\n    bluetooth.removeEventListener(\"availabilitychanged\", onAvailabilityChanged);\n  };\n});\nconst transportsCache = {};\nconst requestDeviceParam = () => ({\n  filters: getBluetoothServiceUuids().map(uuid => ({\n    services: [uuid]\n  }))\n});\nconst retrieveService = async device => {\n  if (!device.gatt) throw new Error(\"bluetooth gatt not found\");\n  const [service] = await device.gatt.getPrimaryServices();\n  if (!service) throw new Error(\"bluetooth service not found\");\n  const infos = getInfosForServiceUuid(service.uuid);\n  if (!infos) throw new Error(\"bluetooth service infos not found\");\n  return [service, infos];\n};\nasync function open(deviceOrId, needsReconnect) {\n  let device;\n  if (typeof deviceOrId === \"string\") {\n    if (transportsCache[deviceOrId]) {\n      log(\"ble-verbose\", \"Transport in cache, using that.\");\n      return transportsCache[deviceOrId];\n    }\n    const bluetooth = requiresBluetooth(); // TODO instead we should \"query\" the device by its ID\n\n    device = await bluetooth.requestDevice(requestDeviceParam());\n  } else {\n    device = deviceOrId;\n  }\n  if (!device.gatt.connected) {\n    log(\"ble-verbose\", \"not connected. connecting...\");\n    await device.gatt.connect();\n  }\n  const [service, infos] = await retrieveService(device);\n  const {\n    deviceModel,\n    writeUuid,\n    notifyUuid\n  } = infos;\n  const [writeC, notifyC] = await Promise.all([service.getCharacteristic(writeUuid), service.getCharacteristic(notifyUuid)]);\n  const notifyObservable = monitorCharacteristic(notifyC).pipe(tap(value => {\n    log(\"ble-frame\", \"<= \" + value.toString(\"hex\"));\n  }), share());\n  const notif = notifyObservable.subscribe();\n  const transport = new BluetoothTransport(device, writeC, notifyObservable, deviceModel);\n  if (!device.gatt.connected) {\n    throw new DisconnectedDevice();\n  } // eslint-disable-next-line require-atomic-updates\n\n  transportsCache[transport.id] = transport;\n  const onDisconnect = e => {\n    console.log(\"onDisconnect!\", e);\n    delete transportsCache[transport.id];\n    transport.notYetDisconnected = false;\n    notif.unsubscribe();\n    device.removeEventListener(\"gattserverdisconnected\", onDisconnect);\n    log(\"ble-verbose\", `BleTransport(${transport.id}) disconnected`);\n    transport.emit(\"disconnect\", e);\n  };\n  device.addEventListener(\"gattserverdisconnected\", onDisconnect);\n  let beforeMTUTime = Date.now();\n  try {\n    await transport.inferMTU();\n  } finally {\n    let afterMTUTime = Date.now(); // workaround for #279: we need to open() again if we come the first time here,\n    // to make sure we do a disconnect() after the first pairing time\n    // because of a firmware bug\n\n    if (afterMTUTime - beforeMTUTime < 1000) {\n      needsReconnect = false; // (optim) there is likely no new pairing done because mtu answer was fast.\n    }\n\n    if (needsReconnect) {\n      await device.gatt.disconnect(); // necessary time for the bonding workaround\n\n      await new Promise(s => setTimeout(s, 4000));\n    }\n  }\n  if (needsReconnect) {\n    return open(device, false);\n  }\n  return transport;\n}\n/**\n * react-native bluetooth BLE implementation\n * @example\n * import BluetoothTransport from \"@ledgerhq/hw-transport-web-ble\";\n */\n\nexport default class BluetoothTransport extends Transport {\n  /**\n   * observe event with { available: bool, type: string }\n   * (available is generic, type is specific)\n   * an event is emit once and then each time it changes\n   */\n\n  /**\n   * Scan for Ledger Bluetooth devices.\n   * On this web implementation, it only emits ONE device, the one that was selected in the UI (if any).\n   */\n  static listen(observer) {\n    log(\"ble-verbose\", \"listen...\");\n    let unsubscribed;\n    const bluetooth = requiresBluetooth();\n    bluetooth.requestDevice(requestDeviceParam()).then(async device => {\n      if (!unsubscribed) {\n        observer.next({\n          type: \"add\",\n          descriptor: device\n        });\n        observer.complete();\n      }\n    }, error => {\n      observer.error(new TransportOpenUserCancelled(error.message));\n    });\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return {\n      unsubscribe\n    };\n  }\n  /**\n   * open a bluetooth device.\n   */\n\n  static async open(deviceOrId) {\n    return open(deviceOrId, true);\n  }\n  /**\n   * globally disconnect a bluetooth device by its id.\n   */\n\n  constructor(device, writeCharacteristic, notifyObservable, deviceModel) {\n    super();\n    this.id = void 0;\n    this.device = void 0;\n    this.mtuSize = 20;\n    this.writeCharacteristic = void 0;\n    this.notifyObservable = void 0;\n    this.notYetDisconnected = true;\n    this.deviceModel = void 0;\n    this.exchange = apdu => this.exchangeAtomicImpl(async () => {\n      try {\n        const msgIn = apdu.toString(\"hex\");\n        log(\"apdu\", `=> ${msgIn}`);\n        const data = await merge(this.notifyObservable.pipe(receiveAPDU), sendAPDU(this.write, apdu, this.mtuSize)).toPromise();\n        const msgOut = data.toString(\"hex\");\n        log(\"apdu\", `<= ${msgOut}`);\n        return data;\n      } catch (e) {\n        log(\"ble-error\", \"exchange got \" + String(e));\n        if (this.notYetDisconnected) {\n          // in such case we will always disconnect because something is bad.\n          this.device.gatt.disconnect();\n        }\n        throw e;\n      }\n    });\n    this.write = async buffer => {\n      log(\"ble-frame\", \"=> \" + buffer.toString(\"hex\"));\n      await this.writeCharacteristic.writeValue(buffer);\n    };\n    this.id = device.id;\n    this.device = device;\n    this.writeCharacteristic = writeCharacteristic;\n    this.notifyObservable = notifyObservable;\n    this.deviceModel = deviceModel;\n    log(\"ble-verbose\", `BleTransport(${String(this.id)}) new instance`);\n  }\n  async inferMTU() {\n    let mtu = 23;\n    await this.exchangeAtomicImpl(async () => {\n      try {\n        mtu = (await merge(this.notifyObservable.pipe(first(buffer => buffer.readUInt8(0) === 0x08), map(buffer => buffer.readUInt8(5))), defer(() => from(this.write(Buffer.from([0x08, 0, 0, 0, 0])))).pipe(ignoreElements())).toPromise()) + 3;\n      } catch (e) {\n        log(\"ble-error\", \"inferMTU got \" + String(e));\n        this.device.gatt.disconnect();\n        throw e;\n      }\n    });\n    if (mtu > 23) {\n      const mtuSize = mtu - 3;\n      log(\"ble-verbose\", `BleTransport(${String(this.id)}) mtu set to ${String(mtuSize)}`);\n      this.mtuSize = mtuSize;\n    }\n    return this.mtuSize;\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n  setScrambleKey() {}\n  async close() {\n    if (this.exchangeBusyPromise) {\n      await this.exchangeBusyPromise;\n    }\n  }\n}\nBluetoothTransport.isSupported = () => Promise.resolve().then(requiresBluetooth).then(() => true, () => false);\nBluetoothTransport.observeAvailability = observer => availability.subscribe(observer);\nBluetoothTransport.list = () => Promise.resolve([]);\nBluetoothTransport.disconnect = async id => {\n  log(\"ble-verbose\", `user disconnect(${id})`);\n  const transport = transportsCache[id];\n  if (transport) {\n    transport.device.gatt.disconnect();\n  }\n};","map":{"version":3,"sources":["../src/TransportWebBLE.js"],"names":["Transport","DisconnectedDevice","TransportOpenUserCancelled","getBluetoothServiceUuids","getInfosForServiceUuid","sendAPDU","receiveAPDU","log","Observable","defer","merge","from","share","ignoreElements","first","map","tap","monitorCharacteristic","requiresBluetooth","bluetooth","navigator","Error","availability","create","observer","onAvailabilityChanged","e","next","value","addEventListener","unsubscribed","getAvailability","then","available","removeEventListener","transportsCache","requestDeviceParam","filters","uuid","services","retrieveService","device","gatt","service","getPrimaryServices","infos","open","deviceOrId","needsReconnect","requestDevice","connected","connect","deviceModel","writeUuid","notifyUuid","writeC","notifyC","Promise","all","getCharacteristic","notifyObservable","pipe","toString","notif","subscribe","transport","BluetoothTransport","id","onDisconnect","console","notYetDisconnected","unsubscribe","emit","beforeMTUTime","Date","now","inferMTU","afterMTUTime","disconnect","s","setTimeout","isSupported","resolve","observeAvailability","list","listen","type","descriptor","complete","error","message","mtuSize","writeCharacteristic","constructor","String","mtu","exchangeAtomicImpl","buffer","readUInt8","write","Buffer","toPromise","exchange","apdu","msgIn","data","msgOut","setScrambleKey","writeValue","close","exchangeBusyPromise"],"mappings":"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","sourcesContent":["// @flow\n/* eslint-disable prefer-template */\n\nimport Transport from \"@ledgerhq/hw-transport\";\nimport {\n  DisconnectedDevice,\n  TransportOpenUserCancelled,\n} from \"@ledgerhq/errors\";\nimport {\n  getBluetoothServiceUuids,\n  getInfosForServiceUuid,\n} from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { sendAPDU } from \"@ledgerhq/devices/lib/ble/sendAPDU\";\nimport { receiveAPDU } from \"@ledgerhq/devices/lib/ble/receiveAPDU\";\nimport { log } from \"@ledgerhq/logs\";\nimport { Observable, defer, merge, from } from \"rxjs\";\nimport { share, ignoreElements, first, map, tap } from \"rxjs/operators\";\nimport type { Device, Characteristic } from \"./types\";\nimport { monitorCharacteristic } from \"./monitorCharacteristic\";\n\nconst requiresBluetooth = () => {\n  // $FlowFixMe\n  const { bluetooth } = navigator;\n  if (typeof bluetooth === \"undefined\") {\n    throw new Error(\"web bluetooth not supported\");\n  }\n  return bluetooth;\n};\n\nconst availability = (): Observable<boolean> =>\n  Observable.create((observer) => {\n    const bluetooth = requiresBluetooth();\n    const onAvailabilityChanged = (e) => {\n      observer.next(e.value);\n    };\n    bluetooth.addEventListener(\"availabilitychanged\", onAvailabilityChanged);\n    let unsubscribed = false;\n    bluetooth.getAvailability().then((available) => {\n      if (!unsubscribed) {\n        observer.next(available);\n      }\n    });\n    return () => {\n      unsubscribed = true;\n      bluetooth.removeEventListener(\n        \"availabilitychanged\",\n        onAvailabilityChanged\n      );\n    };\n  });\n\nconst transportsCache = {};\n\nconst requestDeviceParam = () => ({\n  filters: getBluetoothServiceUuids().map((uuid) => ({\n    services: [uuid],\n  })),\n});\n\nconst retrieveService = async (device) => {\n  if (!device.gatt) throw new Error(\"bluetooth gatt not found\");\n  const [service] = await device.gatt.getPrimaryServices();\n  if (!service) throw new Error(\"bluetooth service not found\");\n  const infos = getInfosForServiceUuid(service.uuid);\n  if (!infos) throw new Error(\"bluetooth service infos not found\");\n  return [service, infos];\n};\n\nasync function open(deviceOrId: Device | string, needsReconnect: boolean) {\n  let device;\n  if (typeof deviceOrId === \"string\") {\n    if (transportsCache[deviceOrId]) {\n      log(\"ble-verbose\", \"Transport in cache, using that.\");\n      return transportsCache[deviceOrId];\n    }\n\n    const bluetooth = requiresBluetooth();\n\n    // TODO instead we should \"query\" the device by its ID\n    device = await bluetooth.requestDevice(requestDeviceParam());\n  } else {\n    device = deviceOrId;\n  }\n\n  if (!device.gatt.connected) {\n    log(\"ble-verbose\", \"not connected. connecting...\");\n    await device.gatt.connect();\n  }\n\n  const [service, infos] = await retrieveService(device);\n  const { deviceModel, writeUuid, notifyUuid } = infos;\n  const [writeC, notifyC] = await Promise.all([\n    service.getCharacteristic(writeUuid),\n    service.getCharacteristic(notifyUuid),\n  ]);\n\n  const notifyObservable = monitorCharacteristic(notifyC).pipe(\n    tap((value) => {\n      log(\"ble-frame\", \"<= \" + value.toString(\"hex\"));\n    }),\n    share()\n  );\n\n  const notif = notifyObservable.subscribe();\n\n  const transport = new BluetoothTransport(\n    device,\n    writeC,\n    notifyObservable,\n    deviceModel\n  );\n\n  if (!device.gatt.connected) {\n    throw new DisconnectedDevice();\n  }\n\n  // eslint-disable-next-line require-atomic-updates\n  transportsCache[transport.id] = transport;\n  const onDisconnect = (e) => {\n    console.log(\"onDisconnect!\", e);\n    delete transportsCache[transport.id];\n    transport.notYetDisconnected = false;\n    notif.unsubscribe();\n    device.removeEventListener(\"gattserverdisconnected\", onDisconnect);\n    log(\"ble-verbose\", `BleTransport(${transport.id}) disconnected`);\n    transport.emit(\"disconnect\", e);\n  };\n  device.addEventListener(\"gattserverdisconnected\", onDisconnect);\n\n  let beforeMTUTime = Date.now();\n  try {\n    await transport.inferMTU();\n  } finally {\n    let afterMTUTime = Date.now();\n\n    // workaround for #279: we need to open() again if we come the first time here,\n    // to make sure we do a disconnect() after the first pairing time\n    // because of a firmware bug\n\n    if (afterMTUTime - beforeMTUTime < 1000) {\n      needsReconnect = false; // (optim) there is likely no new pairing done because mtu answer was fast.\n    }\n\n    if (needsReconnect) {\n      await device.gatt.disconnect();\n      // necessary time for the bonding workaround\n      await new Promise((s) => setTimeout(s, 4000));\n    }\n  }\n\n  if (needsReconnect) {\n    return open(device, false);\n  }\n\n  return transport;\n}\n\n/**\n * react-native bluetooth BLE implementation\n * @example\n * import BluetoothTransport from \"@ledgerhq/hw-transport-web-ble\";\n */\nexport default class BluetoothTransport extends Transport<Device | string> {\n  static isSupported = (): Promise<boolean> =>\n    Promise.resolve()\n      .then(requiresBluetooth)\n      .then(\n        () => true,\n        () => false\n      );\n\n  /**\n   * observe event with { available: bool, type: string }\n   * (available is generic, type is specific)\n   * an event is emit once and then each time it changes\n   */\n  static observeAvailability = (observer: *) =>\n    availability.subscribe(observer);\n\n  static list = (): * => Promise.resolve([]);\n\n  /**\n   * Scan for Ledger Bluetooth devices.\n   * On this web implementation, it only emits ONE device, the one that was selected in the UI (if any).\n   */\n  static listen(observer: *) {\n    log(\"ble-verbose\", \"listen...\");\n    let unsubscribed;\n\n    const bluetooth = requiresBluetooth();\n\n    bluetooth.requestDevice(requestDeviceParam()).then(\n      async (device) => {\n        if (!unsubscribed) {\n          observer.next({\n            type: \"add\",\n            descriptor: device,\n          });\n          observer.complete();\n        }\n      },\n      (error) => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  }\n\n  /**\n   * open a bluetooth device.\n   */\n  static async open(deviceOrId: Device | string) {\n    return open(deviceOrId, true);\n  }\n\n  /**\n   * globally disconnect a bluetooth device by its id.\n   */\n  static disconnect = async (id: *) => {\n    log(\"ble-verbose\", `user disconnect(${id})`);\n    const transport = transportsCache[id];\n    if (transport) {\n      transport.device.gatt.disconnect();\n    }\n  };\n\n  id: string;\n\n  device: Device;\n\n  mtuSize: number = 20;\n\n  writeCharacteristic: Characteristic;\n\n  notifyObservable: Observable<Buffer>;\n\n  notYetDisconnected = true;\n\n  deviceModel: DeviceModel;\n\n  constructor(\n    device: Device,\n    writeCharacteristic: Characteristic,\n    notifyObservable: Observable<*>,\n    deviceModel: DeviceModel\n  ) {\n    super();\n    this.id = device.id;\n    this.device = device;\n    this.writeCharacteristic = writeCharacteristic;\n    this.notifyObservable = notifyObservable;\n    this.deviceModel = deviceModel;\n\n    log(\"ble-verbose\", `BleTransport(${String(this.id)}) new instance`);\n  }\n\n  async inferMTU() {\n    let mtu = 23;\n\n    await this.exchangeAtomicImpl(async () => {\n      try {\n        mtu =\n          (await merge(\n            this.notifyObservable.pipe(\n              first((buffer) => buffer.readUInt8(0) === 0x08),\n              map((buffer) => buffer.readUInt8(5))\n            ),\n            defer(() => from(this.write(Buffer.from([0x08, 0, 0, 0, 0])))).pipe(\n              ignoreElements()\n            )\n          ).toPromise()) + 3;\n      } catch (e) {\n        log(\"ble-error\", \"inferMTU got \" + String(e));\n        this.device.gatt.disconnect();\n        throw e;\n      }\n    });\n\n    if (mtu > 23) {\n      const mtuSize = mtu - 3;\n      log(\n        \"ble-verbose\",\n        `BleTransport(${String(this.id)}) mtu set to ${String(mtuSize)}`\n      );\n      this.mtuSize = mtuSize;\n    }\n\n    return this.mtuSize;\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      try {\n        const msgIn = apdu.toString(\"hex\");\n        log(\"apdu\", `=> ${msgIn}`);\n\n        const data = await merge(\n          this.notifyObservable.pipe(receiveAPDU),\n          sendAPDU(this.write, apdu, this.mtuSize)\n        ).toPromise();\n\n        const msgOut = data.toString(\"hex\");\n        log(\"apdu\", `<= ${msgOut}`);\n\n        return data;\n      } catch (e) {\n        log(\"ble-error\", \"exchange got \" + String(e));\n        if (this.notYetDisconnected) {\n          // in such case we will always disconnect because something is bad.\n          this.device.gatt.disconnect();\n        }\n        throw e;\n      }\n    });\n\n  setScrambleKey() {}\n\n  write = async (buffer: Buffer) => {\n    log(\"ble-frame\", \"=> \" + buffer.toString(\"hex\"));\n    await this.writeCharacteristic.writeValue(buffer);\n  };\n\n  async close() {\n    if (this.exchangeBusyPromise) {\n      await this.exchangeBusyPromise;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}