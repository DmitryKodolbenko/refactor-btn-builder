{"ast":null,"code":"import _slicedToArray from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _asyncToGenerator from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, DisconnectedDeviceDuringOperation, DisconnectedDevice, TransportError } from \"@ledgerhq/errors\";\nvar ledgerDevices = [{\n  vendorId: ledgerUSBVendorId\n}];\nvar isSupported = function isSupported() {\n  return Promise.resolve(!!(global.navigator && global.navigator.hid));\n};\nvar getHID = function getHID() {\n  // $FlowFixMe\n  var _navigator = navigator,\n    hid = _navigator.hid;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\nfunction requestLedgerDevices() {\n  return _requestLedgerDevices.apply(this, arguments);\n}\nfunction _requestLedgerDevices() {\n  _requestLedgerDevices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n    var device;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return getHID().requestDevice({\n              filters: ledgerDevices\n            });\n          case 2:\n            device = _context6.sent;\n            if (!Array.isArray(device)) {\n              _context6.next = 5;\n              break;\n            }\n            return _context6.abrupt(\"return\", device);\n          case 5:\n            return _context6.abrupt(\"return\", [device]);\n          case 6:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _requestLedgerDevices.apply(this, arguments);\n}\nfunction getLedgerDevices() {\n  return _getLedgerDevices.apply(this, arguments);\n}\nfunction _getLedgerDevices() {\n  _getLedgerDevices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n    var devices;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return getHID().getDevices();\n          case 2:\n            devices = _context7.sent;\n            return _context7.abrupt(\"return\", devices.filter(function (d) {\n              return d.vendorId === ledgerUSBVendorId;\n            }));\n          case 4:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _getLedgerDevices.apply(this, arguments);\n}\nfunction getFirstLedgerDevice() {\n  return _getFirstLedgerDevice.apply(this, arguments);\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\nfunction _getFirstLedgerDevice() {\n  _getFirstLedgerDevice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n    var existingDevices, devices;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return getLedgerDevices();\n          case 2:\n            existingDevices = _context8.sent;\n            if (!(existingDevices.length > 0)) {\n              _context8.next = 5;\n              break;\n            }\n            return _context8.abrupt(\"return\", existingDevices[0]);\n          case 5:\n            _context8.next = 7;\n            return requestLedgerDevices();\n          case 7:\n            devices = _context8.sent;\n            return _context8.abrupt(\"return\", devices[0]);\n          case 9:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _getFirstLedgerDevice.apply(this, arguments);\n}\nvar TransportWebHID = /*#__PURE__*/function (_Transport) {\n  _inherits(TransportWebHID, _Transport);\n  var _super = _createSuper(TransportWebHID);\n  function TransportWebHID(device) {\n    var _this;\n    _classCallCheck(this, TransportWebHID);\n    _this = _super.call(this);\n    _this.device = void 0;\n    _this.deviceModel = void 0;\n    _this.channel = Math.floor(Math.random() * 0xffff);\n    _this.packetSize = 64;\n    _this.inputs = [];\n    _this.inputCallback = void 0;\n    _this.read = function () {\n      if (_this.inputs.length) {\n        return Promise.resolve(_this.inputs.shift());\n      }\n      return new Promise(function (success) {\n        _this.inputCallback = success;\n      });\n    };\n    _this.onInputReport = function (e) {\n      var buffer = Buffer.from(e.data.buffer);\n      if (_this.inputCallback) {\n        _this.inputCallback(buffer);\n        _this.inputCallback = null;\n      } else {\n        _this.inputs.push(buffer);\n      }\n    };\n    _this._disconnectEmitted = false;\n    _this._emitDisconnect = function (e) {\n      if (_this._disconnectEmitted) return;\n      _this._disconnectEmitted = true;\n      _this.emit(\"disconnect\", e);\n    };\n    _this.exchange = function (apdu) {\n      return _this.exchangeAtomicImpl( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _assertThisInitialize, channel, packetSize, framing, blocks, i, result, acc, buffer;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _assertThisInitialize = _assertThisInitialized(_this), channel = _assertThisInitialize.channel, packetSize = _assertThisInitialize.packetSize;\n                log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n                framing = hidFraming(channel, packetSize); // Write...\n                blocks = framing.makeBlocks(apdu);\n                i = 0;\n              case 5:\n                if (!(i < blocks.length)) {\n                  _context.next = 11;\n                  break;\n                }\n                _context.next = 8;\n                return _this.device.sendReport(0, blocks[i]);\n              case 8:\n                i++;\n                _context.next = 5;\n                break;\n              case 11:\n                if (result = framing.getReducedResult(acc)) {\n                  _context.next = 18;\n                  break;\n                }\n                _context.next = 14;\n                return _this.read();\n              case 14:\n                buffer = _context.sent;\n                acc = framing.reduceResponse(acc, buffer);\n                _context.next = 11;\n                break;\n              case 18:\n                log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n                return _context.abrupt(\"return\", result);\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))).catch(function (e) {\n        if (e && e.message && e.message.includes(\"write\")) {\n          _this._emitDisconnect(e);\n          throw new DisconnectedDeviceDuringOperation(e.message);\n        }\n        throw e;\n      });\n    };\n    _this.device = device;\n    _this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", _this.onInputReport);\n    return _this;\n  }\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  _createClass(TransportWebHID, [{\n    key: \"close\",\n    value:\n    /**\n     * Release the transport device\n     */\n    function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.exchangeBusyPromise;\n              case 2:\n                this.device.removeEventListener(\"inputreport\", this.onInputReport);\n                _context2.next = 5;\n                return this.device.close();\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function close() {\n        return _close.apply(this, arguments);\n      }\n      return close;\n    }()\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey() {}\n  }], [{\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _yield$requestLedgerD, _yield$requestLedgerD2, device;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return requestLedgerDevices();\n              case 2:\n                _yield$requestLedgerD = _context3.sent;\n                _yield$requestLedgerD2 = _slicedToArray(_yield$requestLedgerD, 1);\n                device = _yield$requestLedgerD2[0];\n                return _context3.abrupt(\"return\", TransportWebHID.open(device));\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      function request() {\n        return _request.apply(this, arguments);\n      }\n      return request;\n    }()\n    /**\n     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n     */\n  }, {\n    key: \"openConnected\",\n    value: function () {\n      var _openConnected = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var devices;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return getLedgerDevices();\n              case 2:\n                devices = _context4.sent;\n                if (!(devices.length === 0)) {\n                  _context4.next = 5;\n                  break;\n                }\n                return _context4.abrupt(\"return\", null);\n              case 5:\n                return _context4.abrupt(\"return\", TransportWebHID.open(devices[0]));\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n      function openConnected() {\n        return _openConnected.apply(this, arguments);\n      }\n      return openConnected;\n    }()\n    /**\n     * Create a Ledger transport with a HIDDevice\n     */\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(device) {\n        var transport, onDisconnect;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return device.open();\n              case 2:\n                transport = new TransportWebHID(device);\n                onDisconnect = function onDisconnect(e) {\n                  if (device === e.device) {\n                    getHID().removeEventListener(\"disconnect\", onDisconnect);\n                    transport._emitDisconnect(new DisconnectedDevice());\n                  }\n                };\n                getHID().addEventListener(\"disconnect\", onDisconnect);\n                return _context5.abrupt(\"return\", transport);\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n      function open(_x) {\n        return _open.apply(this, arguments);\n      }\n      return open;\n    }()\n  }]);\n  return TransportWebHID;\n}(Transport);\nexport { TransportWebHID as default };\nTransportWebHID.isSupported = isSupported;\nTransportWebHID.list = getLedgerDevices;\nTransportWebHID.listen = function (observer) {\n  var unsubscribed = false;\n  getFirstLedgerDevice().then(function (device) {\n    if (!device) {\n      observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n    } else if (!unsubscribed) {\n      var deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel: deviceModel\n      });\n      observer.complete();\n    }\n  }, function (error) {\n    observer.error(new TransportOpenUserCancelled(error.message));\n  });\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n  return {\n    unsubscribe: unsubscribe\n  };\n};","map":{"version":3,"sources":["../src/TransportWebHID.js"],"names":["Transport","hidFraming","identifyUSBProductId","ledgerUSBVendorId","log","TransportOpenUserCancelled","DisconnectedDeviceDuringOperation","DisconnectedDevice","TransportError","ledgerDevices","vendorId","isSupported","Promise","resolve","global","navigator","hid","getHID","requestLedgerDevices","device","requestDevice","filters","Array","isArray","getLedgerDevices","devices","getDevices","filter","d","getFirstLedgerDevice","existingDevices","length","TransportWebHID","deviceModel","channel","Math","floor","random","packetSize","constructor","productId","addEventListener","onInputReport","inputs","inputCallback","read","shift","success","e","buffer","Buffer","from","data","push","list","listen","observer","unsubscribed","then","error","next","type","descriptor","complete","message","unsubscribe","open","transport","onDisconnect","removeEventListener","_emitDisconnect","_disconnectEmitted","emit","exchangeBusyPromise","close","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","i","sendReport","result","getReducedResult","acc","reduceResponse","catch","includes","setScrambleKey"],"mappings":"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","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n  TransportError,\n} from \"@ledgerhq/errors\";\n\nconst ledgerDevices = [{ vendorId: ledgerUSBVendorId }];\n\nconst isSupported = () =>\n  Promise.resolve(!!(global.navigator && global.navigator.hid));\n\nconst getHID = (): HID => {\n  // $FlowFixMe\n  const { hid } = navigator;\n  if (!hid)\n    throw new TransportError(\n      \"navigator.hid is not supported\",\n      \"HIDNotSupported\"\n    );\n  return hid;\n};\n\nasync function requestLedgerDevices(): Promise<HIDDevice[]> {\n  const device = await getHID().requestDevice({ filters: ledgerDevices });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices(): Promise<HIDDevice[]> {\n  const devices = await getHID().getDevices();\n  return devices.filter((d) => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice(): Promise<HIDDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\nexport default class TransportWebHID extends Transport<HIDDevice> {\n  device: HIDDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: HIDDevice) {\n    super();\n    this.device = device;\n    this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  inputs = [];\n  inputCallback: ?(Buffer) => void;\n\n  read = (): Promise<Buffer> => {\n    if (this.inputs.length) {\n      return Promise.resolve(this.inputs.shift());\n    }\n    return new Promise((success) => {\n      this.inputCallback = success;\n    });\n  };\n\n  onInputReport = (e: InputReportEvent) => {\n    const buffer = Buffer.from(e.data.buffer);\n    if (this.inputCallback) {\n      this.inputCallback(buffer);\n      this.inputCallback = null;\n    } else {\n      this.inputs.push(buffer);\n    }\n  };\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<HIDDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!device) {\n          observer.error(\n            new TransportOpenUserCancelled(\"Access denied to use Ledger device\")\n          );\n        } else if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static async open(device: HIDDevice) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n"]},"metadata":{},"sourceType":"module"}