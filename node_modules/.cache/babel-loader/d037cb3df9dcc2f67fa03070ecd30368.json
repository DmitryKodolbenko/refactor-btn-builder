{"ast":null,"code":"\"use strict\";\n\n// See https://github.com/tendermint/tendermint/blob/f2ada0a604b4c0763bda2f64fac53d506d3beca7/docs/spec/blockchain/encoding.md#public-key-cryptography\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pubkeyToAddress = exports.pubkeyToRawAddress = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst encoding_2 = require(\"./encoding\");\nconst pubkeys_1 = require(\"./pubkeys\");\nfunction rawEd25519PubkeyToRawAddress(pubkeyData) {\n  if (pubkeyData.length !== 32) {\n    throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);\n  }\n  return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);\n}\nexports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;\nfunction rawSecp256k1PubkeyToRawAddress(pubkeyData) {\n  if (pubkeyData.length !== 33) {\n    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);\n  }\n  return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));\n}\nexports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;\n// For secp256k1 this assumes we already have a compressed pubkey.\nfunction pubkeyToRawAddress(pubkey) {\n  if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {\n    const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);\n    return rawSecp256k1PubkeyToRawAddress(pubkeyData);\n  } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {\n    const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);\n    return rawEd25519PubkeyToRawAddress(pubkeyData);\n  } else if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {\n    // https://github.com/tendermint/tendermint/blob/38b401657e4ad7a7eeb3c30a3cbf512037df3740/crypto/multisig/threshold_pubkey.go#L71-L74\n    const pubkeyData = (0, encoding_2.encodeAminoPubkey)(pubkey);\n    return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);\n  } else {\n    throw new Error(\"Unsupported public key type\");\n  }\n}\nexports.pubkeyToRawAddress = pubkeyToRawAddress;\nfunction pubkeyToAddress(pubkey, prefix) {\n  return (0, encoding_1.toBech32)(prefix, pubkeyToRawAddress(pubkey));\n}\nexports.pubkeyToAddress = pubkeyToAddress;","map":{"version":3,"sources":["../src/addresses.ts"],"names":[],"mappings":";;AAAA;;;;;AAEA,MAAA,QAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAEA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AAEA,SAAgB,4BAA4B,CAAC,UAAsB,EAAA;EACjE,IAAI,UAAU,CAAC,MAAM,KAAK,EAAE,EAAE;IAC5B,MAAM,IAAI,KAAK,CAAC,kCAAkC,UAAU,CAAC,MAAM,EAAE,CAAC;EACvE;EACD,OAAO,CAAA,CAAA,EAAA,QAAA,CAAA,MAAM,EAAC,UAAU,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;AACxC;AALA,OAAA,CAAA,4BAAA,GAAA,4BAAA;AAOA,SAAgB,8BAA8B,CAAC,UAAsB,EAAA;EACnE,IAAI,UAAU,CAAC,MAAM,KAAK,EAAE,EAAE;IAC5B,MAAM,IAAI,KAAK,CAAC,iDAAiD,UAAU,CAAC,MAAM,EAAE,CAAC;EACtF;EACD,OAAO,CAAA,CAAA,EAAA,QAAA,CAAA,SAAS,EAAC,CAAA,CAAA,EAAA,QAAA,CAAA,MAAM,EAAC,UAAU,CAAC,CAAC;AACtC;AALA,OAAA,CAAA,8BAAA,GAAA,8BAAA;AAOA;AACA,SAAgB,kBAAkB,CAAC,MAAc,EAAA;EAC/C,IAAI,CAAA,CAAA,EAAA,SAAA,CAAA,iBAAiB,EAAC,MAAM,CAAC,EAAE;IAC7B,MAAM,UAAU,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,UAAU,EAAC,MAAM,CAAC,KAAK,CAAC;IAC3C,OAAO,8BAA8B,CAAC,UAAU,CAAC;GAClD,MAAM,IAAI,CAAA,CAAA,EAAA,SAAA,CAAA,eAAe,EAAC,MAAM,CAAC,EAAE;IAClC,MAAM,UAAU,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,UAAU,EAAC,MAAM,CAAC,KAAK,CAAC;IAC3C,OAAO,4BAA4B,CAAC,UAAU,CAAC;GAChD,MAAM,IAAI,CAAA,CAAA,EAAA,SAAA,CAAA,yBAAyB,EAAC,MAAM,CAAC,EAAE;IAC5C;IACA,MAAM,UAAU,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,iBAAiB,EAAC,MAAM,CAAC;IAC5C,OAAO,CAAA,CAAA,EAAA,QAAA,CAAA,MAAM,EAAC,UAAU,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;GACvC,MAAM;IACL,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC;EAC/C;AACH;AAdA,OAAA,CAAA,kBAAA,GAAA,kBAAA;AAgBA,SAAgB,eAAe,CAAC,MAAc,EAAE,MAAc,EAAA;EAC5D,OAAO,CAAA,CAAA,EAAA,UAAA,CAAA,QAAQ,EAAC,MAAM,EAAE,kBAAkB,CAAC,MAAM,CAAC,CAAC;AACrD;AAFA,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// See https://github.com/tendermint/tendermint/blob/f2ada0a604b4c0763bda2f64fac53d506d3beca7/docs/spec/blockchain/encoding.md#public-key-cryptography\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pubkeyToAddress = exports.pubkeyToRawAddress = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst encoding_2 = require(\"./encoding\");\nconst pubkeys_1 = require(\"./pubkeys\");\nfunction rawEd25519PubkeyToRawAddress(pubkeyData) {\n    if (pubkeyData.length !== 32) {\n        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);\n    }\n    return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);\n}\nexports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;\nfunction rawSecp256k1PubkeyToRawAddress(pubkeyData) {\n    if (pubkeyData.length !== 33) {\n        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);\n    }\n    return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));\n}\nexports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;\n// For secp256k1 this assumes we already have a compressed pubkey.\nfunction pubkeyToRawAddress(pubkey) {\n    if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {\n        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);\n        return rawSecp256k1PubkeyToRawAddress(pubkeyData);\n    }\n    else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {\n        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);\n        return rawEd25519PubkeyToRawAddress(pubkeyData);\n    }\n    else if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {\n        // https://github.com/tendermint/tendermint/blob/38b401657e4ad7a7eeb3c30a3cbf512037df3740/crypto/multisig/threshold_pubkey.go#L71-L74\n        const pubkeyData = (0, encoding_2.encodeAminoPubkey)(pubkey);\n        return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);\n    }\n    else {\n        throw new Error(\"Unsupported public key type\");\n    }\n}\nexports.pubkeyToRawAddress = pubkeyToRawAddress;\nfunction pubkeyToAddress(pubkey, prefix) {\n    return (0, encoding_1.toBech32)(prefix, pubkeyToRawAddress(pubkey));\n}\nexports.pubkeyToAddress = pubkeyToAddress;\n//# sourceMappingURL=addresses.js.map"]},"metadata":{},"sourceType":"script"}