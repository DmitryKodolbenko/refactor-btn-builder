{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _slicedToArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _get = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConnectedWalletAccount = exports.WalletAccount = exports.WalletConnection = void 0;\n/**\n * The classes in this module are used in conjunction with the {@link BrowserLocalStorageKeyStore}. This module exposes two classes:\n * * {@link WalletConnection} which redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n * * {@link ConnectedWalletAccount} is an {@link Account} implementation that uses {@link WalletConnection} to get keys\n *\n * @module walletAccount\n */\nvar depd_1 = __importDefault(require(\"depd\"));\nvar account_1 = require(\"./account\");\nvar transaction_1 = require(\"./transaction\");\nvar utils_1 = require(\"./utils\");\nvar borsh_1 = require(\"borsh\");\nvar borsh_2 = require(\"borsh\");\nvar LOGIN_WALLET_URL_SUFFIX = '/login/';\nvar MULTISIG_HAS_METHOD = 'add_request_and_confirm';\nvar LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nvar PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\n/**\n * This class is used in conjunction with the {@link BrowserLocalStorageKeyStore}.\n * It redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n *\n * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#wallet}\n * @example\n * ```js\n * // create new WalletConnection instance\n * const wallet = new WalletConnection(near, 'my-app');\n *\n * // If not signed in redirect to the NEAR wallet to sign in\n * // keys will be stored in the BrowserLocalStorageKeyStore\n * if(!wallet.isSingnedIn()) return wallet.requestSignIn()\n * ```\n */\nvar WalletConnection = /*#__PURE__*/function () {\n  function WalletConnection(near, appKeyPrefix) {\n    _classCallCheck(this, WalletConnection);\n    this._near = near;\n    var authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n    var authData = JSON.parse(window.localStorage.getItem(authDataKey));\n    this._networkId = near.config.networkId;\n    this._walletBaseUrl = near.config.walletUrl;\n    appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n    this._keyStore = near.connection.signer.keyStore;\n    this._authData = authData || {\n      allKeys: []\n    };\n    this._authDataKey = authDataKey;\n    if (!this.isSignedIn()) {\n      this._completeSignInWithAccessKey();\n    }\n  }\n  /**\n   * Returns true, if this WalletAccount is authorized with the wallet.\n   * @example\n   * ```js\n   * const wallet = new WalletConnection(near, 'my-app');\n   * wallet.isSignedIn();\n   * ```\n   */\n  _createClass(WalletConnection, [{\n    key: \"isSignedIn\",\n    value: function isSignedIn() {\n      return !!this._authData.accountId;\n    }\n    /**\n     * Returns authorized Account ID.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.getAccountId();\n     * ```\n     */\n  }, {\n    key: \"getAccountId\",\n    value: function getAccountId() {\n      return this._authData.accountId || '';\n    }\n    /**\n     * Redirects current page to the wallet authentication page.\n     * @param options An optional options object\n     * @param options.contractId The NEAR account where the contract is deployed\n     * @param options.successUrl URL to redirect upon success. Default: current url\n     * @param options.failureUrl URL to redirect upon failure. Default: current url\n     *\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * // redirects to the NEAR Wallet\n     * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });\n     * ```\n     */\n  }, {\n    key: \"requestSignIn\",\n    value: function () {\n      var _requestSignIn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var contractIdOrOptions,\n          title,\n          successUrl,\n          failureUrl,\n          options,\n          deprecate,\n          currentUrl,\n          newUrl,\n          contractAccount,\n          accessKey,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                contractIdOrOptions = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n                title = _args.length > 1 ? _args[1] : undefined;\n                successUrl = _args.length > 2 ? _args[2] : undefined;\n                failureUrl = _args.length > 3 ? _args[3] : undefined;\n                if (typeof contractIdOrOptions === 'string') {\n                  deprecate = depd_1.default('requestSignIn(contractId, title)');\n                  deprecate('`title` ignored; use `requestSignIn({ contractId, methodNames, successUrl, failureUrl })` instead');\n                  options = {\n                    contractId: contractIdOrOptions,\n                    successUrl: successUrl,\n                    failureUrl: failureUrl\n                  };\n                } else {\n                  options = contractIdOrOptions;\n                }\n                currentUrl = new URL(window.location.href);\n                newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n                newUrl.searchParams.set('success_url', options.successUrl || currentUrl.href);\n                newUrl.searchParams.set('failure_url', options.failureUrl || currentUrl.href);\n                if (!options.contractId) {\n                  _context.next = 20;\n                  break;\n                }\n                _context.next = 12;\n                return this._near.account(options.contractId);\n              case 12:\n                contractAccount = _context.sent;\n                _context.next = 15;\n                return contractAccount.state();\n              case 15:\n                newUrl.searchParams.set('contract_id', options.contractId);\n                accessKey = utils_1.KeyPair.fromRandom('ed25519');\n                newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n                _context.next = 20;\n                return this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n              case 20:\n                if (options.methodNames) {\n                  options.methodNames.forEach(function (methodName) {\n                    newUrl.searchParams.append('methodNames', methodName);\n                  });\n                }\n                window.location.assign(newUrl.toString());\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function requestSignIn() {\n        return _requestSignIn.apply(this, arguments);\n      }\n      return requestSignIn;\n    }()\n  }, {\n    key: \"requestSignTransactions\",\n    value: function () {\n      var _requestSignTransactions2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var deprecate,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!Array.isArray(_args2.length <= 0 ? undefined : _args2[0])) {\n                  _context2.next = 4;\n                  break;\n                }\n                deprecate = depd_1.default('WalletConnection.requestSignTransactions(transactions, callbackUrl, meta)');\n                deprecate('use `WalletConnection.requestSignTransactions(RequestSignTransactionsOptions)` instead');\n                return _context2.abrupt(\"return\", this._requestSignTransactions({\n                  transactions: _args2.length <= 0 ? undefined : _args2[0],\n                  callbackUrl: _args2.length <= 1 ? undefined : _args2[1],\n                  meta: _args2.length <= 2 ? undefined : _args2[2]\n                }));\n              case 4:\n                return _context2.abrupt(\"return\", this._requestSignTransactions(_args2.length <= 0 ? undefined : _args2[0]));\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function requestSignTransactions() {\n        return _requestSignTransactions2.apply(this, arguments);\n      }\n      return requestSignTransactions;\n    }()\n  }, {\n    key: \"_requestSignTransactions\",\n    value: function () {\n      var _requestSignTransactions3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref) {\n        var transactions, meta, callbackUrl, currentUrl, newUrl;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                transactions = _ref.transactions, meta = _ref.meta, callbackUrl = _ref.callbackUrl;\n                currentUrl = new URL(window.location.href);\n                newUrl = new URL('sign', this._walletBaseUrl);\n                newUrl.searchParams.set('transactions', transactions.map(function (transaction) {\n                  return borsh_2.serialize(transaction_1.SCHEMA, transaction);\n                }).map(function (serialized) {\n                  return Buffer.from(serialized).toString('base64');\n                }).join(','));\n                newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n                if (meta) newUrl.searchParams.set('meta', meta);\n                window.location.assign(newUrl.toString());\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function _requestSignTransactions(_x) {\n        return _requestSignTransactions3.apply(this, arguments);\n      }\n      return _requestSignTransactions;\n    }()\n    /**\n     * @hidden\n     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n     */\n  }, {\n    key: \"_completeSignInWithAccessKey\",\n    value: function () {\n      var _completeSignInWithAccessKey2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var currentUrl, publicKey, allKeys, accountId;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                currentUrl = new URL(window.location.href);\n                publicKey = currentUrl.searchParams.get('public_key') || '';\n                allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n                accountId = currentUrl.searchParams.get('account_id') || ''; // TODO: Handle errors during login\n                if (!accountId) {\n                  _context4.next = 10;\n                  break;\n                }\n                this._authData = {\n                  accountId: accountId,\n                  allKeys: allKeys\n                };\n                window.localStorage.setItem(this._authDataKey, JSON.stringify(this._authData));\n                if (!publicKey) {\n                  _context4.next = 10;\n                  break;\n                }\n                _context4.next = 10;\n                return this._moveKeyFromTempToPermanent(accountId, publicKey);\n              case 10:\n                currentUrl.searchParams.delete('public_key');\n                currentUrl.searchParams.delete('all_keys');\n                currentUrl.searchParams.delete('account_id');\n                currentUrl.searchParams.delete('meta');\n                currentUrl.searchParams.delete('transactionHashes');\n                window.history.replaceState({}, document.title, currentUrl.toString());\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function _completeSignInWithAccessKey() {\n        return _completeSignInWithAccessKey2.apply(this, arguments);\n      }\n      return _completeSignInWithAccessKey;\n    }()\n    /**\n     * @hidden\n     * @param accountId The NEAR account owning the given public key\n     * @param publicKey The public key being set to the key store\n     */\n  }, {\n    key: \"_moveKeyFromTempToPermanent\",\n    value: function () {\n      var _moveKeyFromTempToPermanent2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(accountId, publicKey) {\n        var keyPair;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n              case 2:\n                keyPair = _context5.sent;\n                _context5.next = 5;\n                return this._keyStore.setKey(this._networkId, accountId, keyPair);\n              case 5:\n                _context5.next = 7;\n                return this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function _moveKeyFromTempToPermanent(_x2, _x3) {\n        return _moveKeyFromTempToPermanent2.apply(this, arguments);\n      }\n      return _moveKeyFromTempToPermanent;\n    }()\n    /**\n     * Sign out from the current account\n     * @example\n     * walletAccount.signOut();\n     */\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      this._authData = {};\n      window.localStorage.removeItem(this._authDataKey);\n    }\n    /**\n     * Returns the current connected wallet account\n     */\n  }, {\n    key: \"account\",\n    value: function account() {\n      if (!this._connectedAccount) {\n        this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n      }\n      return this._connectedAccount;\n    }\n  }]);\n  return WalletConnection;\n}();\nexports.WalletConnection = WalletConnection;\nexports.WalletAccount = WalletConnection;\n/**\n * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.\n */\nvar ConnectedWalletAccount = /*#__PURE__*/function (_account_1$Account) {\n  _inherits(ConnectedWalletAccount, _account_1$Account);\n  var _super = _createSuper(ConnectedWalletAccount);\n  function ConnectedWalletAccount(walletConnection, connection, accountId) {\n    var _this;\n    _classCallCheck(this, ConnectedWalletAccount);\n    _this = _super.call(this, connection, accountId);\n    _this.walletConnection = walletConnection;\n    return _this;\n  }\n  // Overriding Account methods\n  /**\n   * Sign a transaction by redirecting to the NEAR Wallet\n   * @see {@link WalletConnection.requestSignTransactions}\n   */\n  _createClass(ConnectedWalletAccount, [{\n    key: \"signAndSendTransaction\",\n    value: function signAndSendTransaction() {\n      if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {\n        return this._signAndSendTransaction({\n          receiverId: arguments.length <= 0 ? undefined : arguments[0],\n          actions: arguments.length <= 1 ? undefined : arguments[1]\n        });\n      }\n      return this._signAndSendTransaction(arguments.length <= 0 ? undefined : arguments[0]);\n    }\n  }, {\n    key: \"_signAndSendTransaction\",\n    value: function () {\n      var _signAndSendTransaction2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {\n        var receiverId, actions, walletMeta, _ref2$walletCallbackU, walletCallbackUrl, localKey, accessKey, block, blockHash, publicKey, nonce, transaction;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                receiverId = _ref2.receiverId, actions = _ref2.actions, walletMeta = _ref2.walletMeta, _ref2$walletCallbackU = _ref2.walletCallbackUrl, walletCallbackUrl = _ref2$walletCallbackU === void 0 ? window.location.href : _ref2$walletCallbackU;\n                _context6.next = 3;\n                return this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n              case 3:\n                localKey = _context6.sent;\n                _context6.next = 6;\n                return this.accessKeyForTransaction(receiverId, actions, localKey);\n              case 6:\n                accessKey = _context6.sent;\n                if (accessKey) {\n                  _context6.next = 9;\n                  break;\n                }\n                throw new Error(\"Cannot find matching key for transaction sent to \".concat(receiverId));\n              case 9:\n                if (!(localKey && localKey.toString() === accessKey.public_key)) {\n                  _context6.next = 25;\n                  break;\n                }\n                _context6.prev = 10;\n                _context6.next = 13;\n                return _get(_getPrototypeOf(ConnectedWalletAccount.prototype), \"signAndSendTransaction\", this).call(this, {\n                  receiverId: receiverId,\n                  actions: actions\n                });\n              case 13:\n                return _context6.abrupt(\"return\", _context6.sent);\n              case 16:\n                _context6.prev = 16;\n                _context6.t0 = _context6[\"catch\"](10);\n                if (!(_context6.t0.type === 'NotEnoughAllowance')) {\n                  _context6.next = 24;\n                  break;\n                }\n                _context6.next = 21;\n                return this.accessKeyForTransaction(receiverId, actions);\n              case 21:\n                accessKey = _context6.sent;\n                _context6.next = 25;\n                break;\n              case 24:\n                throw _context6.t0;\n              case 25:\n                _context6.next = 27;\n                return this.connection.provider.block({\n                  finality: 'final'\n                });\n              case 27:\n                block = _context6.sent;\n                blockHash = borsh_1.baseDecode(block.header.hash);\n                publicKey = utils_1.PublicKey.from(accessKey.public_key); // TODO: Cache & listen for nonce updates for given access key\n                nonce = accessKey.access_key.nonce + 1;\n                transaction = transaction_1.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n                _context6.next = 34;\n                return this.walletConnection.requestSignTransactions({\n                  transactions: [transaction],\n                  meta: walletMeta,\n                  callbackUrl: walletCallbackUrl\n                });\n              case 34:\n                return _context6.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  setTimeout(function () {\n                    reject(new Error('Failed to redirect to sign transaction'));\n                  }, 1000);\n                }));\n              case 35:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[10, 16]]);\n      }));\n      function _signAndSendTransaction(_x4) {\n        return _signAndSendTransaction2.apply(this, arguments);\n      }\n      return _signAndSendTransaction;\n    }()\n    /**\n     * Check if given access key allows the function call or method attempted in transaction\n     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\n     * @param receiverId The NEAR account attempting to have access\n     * @param actions The action(s) needed to be checked for access\n     */\n  }, {\n    key: \"accessKeyMatchesTransaction\",\n    value: function () {\n      var _accessKeyMatchesTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(accessKey, receiverId, actions) {\n        var permission, _permission$FunctionC, allowedReceiverId, allowedMethods, _actions, functionCall;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                permission = accessKey.access_key.permission;\n                if (!(permission === 'FullAccess')) {\n                  _context7.next = 3;\n                  break;\n                }\n                return _context7.abrupt(\"return\", true);\n              case 3:\n                if (!permission.FunctionCall) {\n                  _context7.next = 12;\n                  break;\n                }\n                _permission$FunctionC = permission.FunctionCall, allowedReceiverId = _permission$FunctionC.receiver_id, allowedMethods = _permission$FunctionC.method_names;\n                /********************************\n                Accept multisig access keys and let wallets attempt to signAndSendTransaction\n                If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\n                ********************************/\n                if (!(allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD))) {\n                  _context7.next = 7;\n                  break;\n                }\n                return _context7.abrupt(\"return\", true);\n              case 7:\n                if (!(allowedReceiverId === receiverId)) {\n                  _context7.next = 12;\n                  break;\n                }\n                if (!(actions.length !== 1)) {\n                  _context7.next = 10;\n                  break;\n                }\n                return _context7.abrupt(\"return\", false);\n              case 10:\n                _actions = _slicedToArray(actions, 1), functionCall = _actions[0].functionCall;\n                return _context7.abrupt(\"return\", functionCall && (!functionCall.deposit || functionCall.deposit.toString() === '0') && (\n                // TODO: Should support charging amount smaller than allowance?\n                allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName)));\n              case 12:\n                return _context7.abrupt(\"return\", false);\n              case 13:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function accessKeyMatchesTransaction(_x5, _x6, _x7) {\n        return _accessKeyMatchesTransaction.apply(this, arguments);\n      }\n      return accessKeyMatchesTransaction;\n    }()\n    /**\n     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n     * @param receiverId The NEAR account seeking the access key for a transaction\n     * @param actions The action(s) sought to gain access to\n     * @param localKey A local public key provided to check for access\n     * @returns Promise<any>\n     */\n  }, {\n    key: \"accessKeyForTransaction\",\n    value: function () {\n      var _accessKeyForTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(receiverId, actions, localKey) {\n        var accessKeys, accessKey, walletKeys, _iterator, _step, _accessKey;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.getAccessKeys();\n              case 2:\n                accessKeys = _context8.sent;\n                if (!localKey) {\n                  _context8.next = 12;\n                  break;\n                }\n                accessKey = accessKeys.find(function (key) {\n                  return key.public_key.toString() === localKey.toString();\n                });\n                _context8.t0 = accessKey;\n                if (!_context8.t0) {\n                  _context8.next = 10;\n                  break;\n                }\n                _context8.next = 9;\n                return this.accessKeyMatchesTransaction(accessKey, receiverId, actions);\n              case 9:\n                _context8.t0 = _context8.sent;\n              case 10:\n                if (!_context8.t0) {\n                  _context8.next = 12;\n                  break;\n                }\n                return _context8.abrupt(\"return\", accessKey);\n              case 12:\n                walletKeys = this.walletConnection._authData.allKeys;\n                _iterator = _createForOfIteratorHelper(accessKeys);\n                _context8.prev = 14;\n                _iterator.s();\n              case 16:\n                if ((_step = _iterator.n()).done) {\n                  _context8.next = 27;\n                  break;\n                }\n                _accessKey = _step.value;\n                _context8.t1 = walletKeys.indexOf(_accessKey.public_key) !== -1;\n                if (!_context8.t1) {\n                  _context8.next = 23;\n                  break;\n                }\n                _context8.next = 22;\n                return this.accessKeyMatchesTransaction(_accessKey, receiverId, actions);\n              case 22:\n                _context8.t1 = _context8.sent;\n              case 23:\n                if (!_context8.t1) {\n                  _context8.next = 25;\n                  break;\n                }\n                return _context8.abrupt(\"return\", _accessKey);\n              case 25:\n                _context8.next = 16;\n                break;\n              case 27:\n                _context8.next = 32;\n                break;\n              case 29:\n                _context8.prev = 29;\n                _context8.t2 = _context8[\"catch\"](14);\n                _iterator.e(_context8.t2);\n              case 32:\n                _context8.prev = 32;\n                _iterator.f();\n                return _context8.finish(32);\n              case 35:\n                return _context8.abrupt(\"return\", null);\n              case 36:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[14, 29, 32, 35]]);\n      }));\n      function accessKeyForTransaction(_x8, _x9, _x10) {\n        return _accessKeyForTransaction.apply(this, arguments);\n      }\n      return accessKeyForTransaction;\n    }()\n  }]);\n  return ConnectedWalletAccount;\n}(account_1.Account);\nexports.ConnectedWalletAccount = ConnectedWalletAccount;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","ConnectedWalletAccount","WalletAccount","WalletConnection","depd_1","require","account_1","transaction_1","utils_1","borsh_1","borsh_2","LOGIN_WALLET_URL_SUFFIX","MULTISIG_HAS_METHOD","LOCAL_STORAGE_KEY_SUFFIX","PENDING_ACCESS_KEY_PREFIX","near","appKeyPrefix","_near","authDataKey","authData","JSON","parse","window","localStorage","getItem","_networkId","config","networkId","_walletBaseUrl","walletUrl","contractName","_keyStore","connection","signer","keyStore","_authData","allKeys","_authDataKey","isSignedIn","_completeSignInWithAccessKey","accountId","contractIdOrOptions","title","successUrl","failureUrl","deprecate","default","options","contractId","currentUrl","URL","location","href","newUrl","searchParams","set","account","contractAccount","state","accessKey","KeyPair","fromRandom","getPublicKey","toString","setKey","methodNames","forEach","methodName","append","assign","Array","isArray","_requestSignTransactions","transactions","callbackUrl","meta","map","transaction","serialize","SCHEMA","serialized","Buffer","from","join","publicKey","get","split","setItem","stringify","_moveKeyFromTempToPermanent","delete","history","replaceState","document","getKey","keyPair","removeKey","removeItem","_connectedAccount","walletConnection","_signAndSendTransaction","receiverId","actions","walletMeta","walletCallbackUrl","localKey","accessKeyForTransaction","Error","public_key","type","provider","block","finality","blockHash","baseDecode","header","hash","PublicKey","nonce","access_key","createTransaction","requestSignTransactions","Promise","resolve","reject","setTimeout","permission","FunctionCall","allowedReceiverId","receiver_id","allowedMethods","method_names","includes","length","functionCall","deposit","getAccessKeys","accessKeys","find","key","accessKeyMatchesTransaction","walletKeys","indexOf","Account"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/@nightlylabs/connect-near/node_modules/near-api-js/lib/wallet-account.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConnectedWalletAccount = exports.WalletAccount = exports.WalletConnection = void 0;\n/**\n * The classes in this module are used in conjunction with the {@link BrowserLocalStorageKeyStore}. This module exposes two classes:\n * * {@link WalletConnection} which redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n * * {@link ConnectedWalletAccount} is an {@link Account} implementation that uses {@link WalletConnection} to get keys\n *\n * @module walletAccount\n */\nconst depd_1 = __importDefault(require(\"depd\"));\nconst account_1 = require(\"./account\");\nconst transaction_1 = require(\"./transaction\");\nconst utils_1 = require(\"./utils\");\nconst borsh_1 = require(\"borsh\");\nconst borsh_2 = require(\"borsh\");\nconst LOGIN_WALLET_URL_SUFFIX = '/login/';\nconst MULTISIG_HAS_METHOD = 'add_request_and_confirm';\nconst LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nconst PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\n/**\n * This class is used in conjunction with the {@link BrowserLocalStorageKeyStore}.\n * It redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n *\n * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#wallet}\n * @example\n * ```js\n * // create new WalletConnection instance\n * const wallet = new WalletConnection(near, 'my-app');\n *\n * // If not signed in redirect to the NEAR wallet to sign in\n * // keys will be stored in the BrowserLocalStorageKeyStore\n * if(!wallet.isSingnedIn()) return wallet.requestSignIn()\n * ```\n */\nclass WalletConnection {\n    constructor(near, appKeyPrefix) {\n        this._near = near;\n        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n        const authData = JSON.parse(window.localStorage.getItem(authDataKey));\n        this._networkId = near.config.networkId;\n        this._walletBaseUrl = near.config.walletUrl;\n        appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n        this._keyStore = near.connection.signer.keyStore;\n        this._authData = authData || { allKeys: [] };\n        this._authDataKey = authDataKey;\n        if (!this.isSignedIn()) {\n            this._completeSignInWithAccessKey();\n        }\n    }\n    /**\n     * Returns true, if this WalletAccount is authorized with the wallet.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.isSignedIn();\n     * ```\n     */\n    isSignedIn() {\n        return !!this._authData.accountId;\n    }\n    /**\n     * Returns authorized Account ID.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.getAccountId();\n     * ```\n     */\n    getAccountId() {\n        return this._authData.accountId || '';\n    }\n    /**\n     * Redirects current page to the wallet authentication page.\n     * @param options An optional options object\n     * @param options.contractId The NEAR account where the contract is deployed\n     * @param options.successUrl URL to redirect upon success. Default: current url\n     * @param options.failureUrl URL to redirect upon failure. Default: current url\n     *\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * // redirects to the NEAR Wallet\n     * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });\n     * ```\n     */\n    async requestSignIn(contractIdOrOptions = {}, title, successUrl, failureUrl) {\n        let options;\n        if (typeof contractIdOrOptions === 'string') {\n            const deprecate = depd_1.default('requestSignIn(contractId, title)');\n            deprecate('`title` ignored; use `requestSignIn({ contractId, methodNames, successUrl, failureUrl })` instead');\n            options = { contractId: contractIdOrOptions, successUrl, failureUrl };\n        }\n        else {\n            options = contractIdOrOptions;\n        }\n        const currentUrl = new URL(window.location.href);\n        const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n        newUrl.searchParams.set('success_url', options.successUrl || currentUrl.href);\n        newUrl.searchParams.set('failure_url', options.failureUrl || currentUrl.href);\n        if (options.contractId) {\n            /* Throws exception if contract account does not exist */\n            const contractAccount = await this._near.account(options.contractId);\n            await contractAccount.state();\n            newUrl.searchParams.set('contract_id', options.contractId);\n            const accessKey = utils_1.KeyPair.fromRandom('ed25519');\n            newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n            await this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n        }\n        if (options.methodNames) {\n            options.methodNames.forEach(methodName => {\n                newUrl.searchParams.append('methodNames', methodName);\n            });\n        }\n        window.location.assign(newUrl.toString());\n    }\n    async requestSignTransactions(...args) {\n        if (Array.isArray(args[0])) {\n            const deprecate = depd_1.default('WalletConnection.requestSignTransactions(transactions, callbackUrl, meta)');\n            deprecate('use `WalletConnection.requestSignTransactions(RequestSignTransactionsOptions)` instead');\n            return this._requestSignTransactions({\n                transactions: args[0],\n                callbackUrl: args[1],\n                meta: args[2]\n            });\n        }\n        return this._requestSignTransactions(args[0]);\n    }\n    async _requestSignTransactions({ transactions, meta, callbackUrl }) {\n        const currentUrl = new URL(window.location.href);\n        const newUrl = new URL('sign', this._walletBaseUrl);\n        newUrl.searchParams.set('transactions', transactions\n            .map(transaction => borsh_2.serialize(transaction_1.SCHEMA, transaction))\n            .map(serialized => Buffer.from(serialized).toString('base64'))\n            .join(','));\n        newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n        if (meta)\n            newUrl.searchParams.set('meta', meta);\n        window.location.assign(newUrl.toString());\n    }\n    /**\n     * @hidden\n     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n     */\n    async _completeSignInWithAccessKey() {\n        const currentUrl = new URL(window.location.href);\n        const publicKey = currentUrl.searchParams.get('public_key') || '';\n        const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n        const accountId = currentUrl.searchParams.get('account_id') || '';\n        // TODO: Handle errors during login\n        if (accountId) {\n            this._authData = {\n                accountId,\n                allKeys\n            };\n            window.localStorage.setItem(this._authDataKey, JSON.stringify(this._authData));\n            if (publicKey) {\n                await this._moveKeyFromTempToPermanent(accountId, publicKey);\n            }\n        }\n        currentUrl.searchParams.delete('public_key');\n        currentUrl.searchParams.delete('all_keys');\n        currentUrl.searchParams.delete('account_id');\n        currentUrl.searchParams.delete('meta');\n        currentUrl.searchParams.delete('transactionHashes');\n        window.history.replaceState({}, document.title, currentUrl.toString());\n    }\n    /**\n     * @hidden\n     * @param accountId The NEAR account owning the given public key\n     * @param publicKey The public key being set to the key store\n     */\n    async _moveKeyFromTempToPermanent(accountId, publicKey) {\n        const keyPair = await this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n        await this._keyStore.setKey(this._networkId, accountId, keyPair);\n        await this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n    }\n    /**\n     * Sign out from the current account\n     * @example\n     * walletAccount.signOut();\n     */\n    signOut() {\n        this._authData = {};\n        window.localStorage.removeItem(this._authDataKey);\n    }\n    /**\n     * Returns the current connected wallet account\n     */\n    account() {\n        if (!this._connectedAccount) {\n            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n        }\n        return this._connectedAccount;\n    }\n}\nexports.WalletConnection = WalletConnection;\nexports.WalletAccount = WalletConnection;\n/**\n * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.\n */\nclass ConnectedWalletAccount extends account_1.Account {\n    constructor(walletConnection, connection, accountId) {\n        super(connection, accountId);\n        this.walletConnection = walletConnection;\n    }\n    // Overriding Account methods\n    /**\n     * Sign a transaction by redirecting to the NEAR Wallet\n     * @see {@link WalletConnection.requestSignTransactions}\n     */\n    signAndSendTransaction(...args) {\n        if (typeof args[0] === 'string') {\n            return this._signAndSendTransaction({ receiverId: args[0], actions: args[1] });\n        }\n        return this._signAndSendTransaction(args[0]);\n    }\n    async _signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }) {\n        const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n        let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);\n        if (!accessKey) {\n            throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\n        }\n        if (localKey && localKey.toString() === accessKey.public_key) {\n            try {\n                return await super.signAndSendTransaction({ receiverId, actions });\n            }\n            catch (e) {\n                if (e.type === 'NotEnoughAllowance') {\n                    accessKey = await this.accessKeyForTransaction(receiverId, actions);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        const block = await this.connection.provider.block({ finality: 'final' });\n        const blockHash = borsh_1.baseDecode(block.header.hash);\n        const publicKey = utils_1.PublicKey.from(accessKey.public_key);\n        // TODO: Cache & listen for nonce updates for given access key\n        const nonce = accessKey.access_key.nonce + 1;\n        const transaction = transaction_1.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n        await this.walletConnection.requestSignTransactions({\n            transactions: [transaction],\n            meta: walletMeta,\n            callbackUrl: walletCallbackUrl\n        });\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                reject(new Error('Failed to redirect to sign transaction'));\n            }, 1000);\n        });\n        // TODO: Aggregate multiple transaction request with \"debounce\".\n        // TODO: Introduce TrasactionQueue which also can be used to watch for status?\n    }\n    /**\n     * Check if given access key allows the function call or method attempted in transaction\n     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\n     * @param receiverId The NEAR account attempting to have access\n     * @param actions The action(s) needed to be checked for access\n     */\n    async accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n        const { access_key: { permission } } = accessKey;\n        if (permission === 'FullAccess') {\n            return true;\n        }\n        if (permission.FunctionCall) {\n            const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;\n            /********************************\n            Accept multisig access keys and let wallets attempt to signAndSendTransaction\n            If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\n            ********************************/\n            if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\n                return true;\n            }\n            if (allowedReceiverId === receiverId) {\n                if (actions.length !== 1) {\n                    return false;\n                }\n                const [{ functionCall }] = actions;\n                return functionCall &&\n                    (!functionCall.deposit || functionCall.deposit.toString() === '0') && // TODO: Should support charging amount smaller than allowance?\n                    (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));\n                // TODO: Handle cases when allowance doesn't have enough to pay for gas\n            }\n        }\n        // TODO: Support other permissions than FunctionCall\n        return false;\n    }\n    /**\n     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n     * @param receiverId The NEAR account seeking the access key for a transaction\n     * @param actions The action(s) sought to gain access to\n     * @param localKey A local public key provided to check for access\n     * @returns Promise<any>\n     */\n    async accessKeyForTransaction(receiverId, actions, localKey) {\n        const accessKeys = await this.getAccessKeys();\n        if (localKey) {\n            const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());\n            if (accessKey && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {\n                return accessKey;\n            }\n        }\n        const walletKeys = this.walletConnection._authData.allKeys;\n        for (const accessKey of accessKeys) {\n            if (walletKeys.indexOf(accessKey.public_key) !== -1 && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {\n                return accessKey;\n            }\n        }\n        return null;\n    }\n}\nexports.ConnectedWalletAccount = ConnectedWalletAccount;\n"],"mappings":"AAAA,YAAY;;AAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACb,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,sBAAsB,GAAGF,OAAO,CAACG,aAAa,GAAGH,OAAO,CAACI,gBAAgB,GAAG,KAAK,CAAC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMC,MAAM,GAAGV,eAAe,CAACW,OAAO,CAAC,MAAM,CAAC,CAAC;AAC/C,IAAMC,SAAS,GAAGD,OAAO,CAAC,WAAW,CAAC;AACtC,IAAME,aAAa,GAAGF,OAAO,CAAC,eAAe,CAAC;AAC9C,IAAMG,OAAO,GAAGH,OAAO,CAAC,SAAS,CAAC;AAClC,IAAMI,OAAO,GAAGJ,OAAO,CAAC,OAAO,CAAC;AAChC,IAAMK,OAAO,GAAGL,OAAO,CAAC,OAAO,CAAC;AAChC,IAAMM,uBAAuB,GAAG,SAAS;AACzC,IAAMC,mBAAmB,GAAG,yBAAyB;AACrD,IAAMC,wBAAwB,GAAG,kBAAkB;AACnD,IAAMC,yBAAyB,GAAG,aAAa,CAAC,CAAC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA,IAeMX,gBAAgB;EAClB,0BAAYY,IAAI,EAAEC,YAAY,EAAE;IAAA;IAC5B,IAAI,CAACC,KAAK,GAAGF,IAAI;IACjB,IAAMG,WAAW,GAAGF,YAAY,GAAGH,wBAAwB;IAC3D,IAAMM,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACC,MAAM,CAACC,YAAY,CAACC,OAAO,CAACN,WAAW,CAAC,CAAC;IACrE,IAAI,CAACO,UAAU,GAAGV,IAAI,CAACW,MAAM,CAACC,SAAS;IACvC,IAAI,CAACC,cAAc,GAAGb,IAAI,CAACW,MAAM,CAACG,SAAS;IAC3Cb,YAAY,GAAGA,YAAY,IAAID,IAAI,CAACW,MAAM,CAACI,YAAY,IAAI,SAAS;IACpE,IAAI,CAACC,SAAS,GAAGhB,IAAI,CAACiB,UAAU,CAACC,MAAM,CAACC,QAAQ;IAChD,IAAI,CAACC,SAAS,GAAGhB,QAAQ,IAAI;MAAEiB,OAAO,EAAE;IAAG,CAAC;IAC5C,IAAI,CAACC,YAAY,GAAGnB,WAAW;IAC/B,IAAI,CAAC,IAAI,CAACoB,UAAU,EAAE,EAAE;MACpB,IAAI,CAACC,4BAA4B,EAAE;IACvC;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAPI;IAAA;IAAA,OAQA,sBAAa;MACT,OAAO,CAAC,CAAC,IAAI,CAACJ,SAAS,CAACK,SAAS;IACrC;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAPI;IAAA;IAAA,OAQA,wBAAe;MACX,OAAO,IAAI,CAACL,SAAS,CAACK,SAAS,IAAI,EAAE;IACzC;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAbI;IAAA;IAAA;MAAA,gFAcA;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBAAoBC,mBAAmB,2DAAG,CAAC,CAAC;gBAAEC,KAAK;gBAAEC,UAAU;gBAAEC,UAAU;gBAEvE,IAAI,OAAOH,mBAAmB,KAAK,QAAQ,EAAE;kBACnCI,SAAS,GAAGzC,MAAM,CAAC0C,OAAO,CAAC,kCAAkC,CAAC;kBACpED,SAAS,CAAC,mGAAmG,CAAC;kBAC9GE,OAAO,GAAG;oBAAEC,UAAU,EAAEP,mBAAmB;oBAAEE,UAAU,EAAVA,UAAU;oBAAEC,UAAU,EAAVA;kBAAW,CAAC;gBACzE,CAAC,MACI;kBACDG,OAAO,GAAGN,mBAAmB;gBACjC;gBACMQ,UAAU,GAAG,IAAIC,GAAG,CAAC5B,MAAM,CAAC6B,QAAQ,CAACC,IAAI,CAAC;gBAC1CC,MAAM,GAAG,IAAIH,GAAG,CAAC,IAAI,CAACtB,cAAc,GAAGjB,uBAAuB,CAAC;gBACrE0C,MAAM,CAACC,YAAY,CAACC,GAAG,CAAC,aAAa,EAAER,OAAO,CAACJ,UAAU,IAAIM,UAAU,CAACG,IAAI,CAAC;gBAC7EC,MAAM,CAACC,YAAY,CAACC,GAAG,CAAC,aAAa,EAAER,OAAO,CAACH,UAAU,IAAIK,UAAU,CAACG,IAAI,CAAC;gBAAC,KAC1EL,OAAO,CAACC,UAAU;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OAEY,IAAI,CAAC/B,KAAK,CAACuC,OAAO,CAACT,OAAO,CAACC,UAAU,CAAC;cAAA;gBAA9DS,eAAe;gBAAA;gBAAA,OACfA,eAAe,CAACC,KAAK,EAAE;cAAA;gBAC7BL,MAAM,CAACC,YAAY,CAACC,GAAG,CAAC,aAAa,EAAER,OAAO,CAACC,UAAU,CAAC;gBACpDW,SAAS,GAAGnD,OAAO,CAACoD,OAAO,CAACC,UAAU,CAAC,SAAS,CAAC;gBACvDR,MAAM,CAACC,YAAY,CAACC,GAAG,CAAC,YAAY,EAAEI,SAAS,CAACG,YAAY,EAAE,CAACC,QAAQ,EAAE,CAAC;gBAAC;gBAAA,OACrE,IAAI,CAAChC,SAAS,CAACiC,MAAM,CAAC,IAAI,CAACvC,UAAU,EAAEX,yBAAyB,GAAG6C,SAAS,CAACG,YAAY,EAAE,EAAEH,SAAS,CAAC;cAAA;gBAEjH,IAAIZ,OAAO,CAACkB,WAAW,EAAE;kBACrBlB,OAAO,CAACkB,WAAW,CAACC,OAAO,CAAC,UAAAC,UAAU,EAAI;oBACtCd,MAAM,CAACC,YAAY,CAACc,MAAM,CAAC,aAAa,EAAED,UAAU,CAAC;kBACzD,CAAC,CAAC;gBACN;gBACA7C,MAAM,CAAC6B,QAAQ,CAACkB,MAAM,CAAChB,MAAM,CAACU,QAAQ,EAAE,CAAC;cAAC;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAC7C;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,2FACD;QAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,KACQO,KAAK,CAACC,OAAO,4CAAS;kBAAA;kBAAA;gBAAA;gBAChB1B,SAAS,GAAGzC,MAAM,CAAC0C,OAAO,CAAC,2EAA2E,CAAC;gBAC7GD,SAAS,CAAC,wFAAwF,CAAC;gBAAC,kCAC7F,IAAI,CAAC2B,wBAAwB,CAAC;kBACjCC,YAAY,4CAAS;kBACrBC,WAAW,4CAAS;kBACpBC,IAAI;gBACR,CAAC,CAAC;cAAA;gBAAA,kCAEC,IAAI,CAACH,wBAAwB,4CAAS;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAChD;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,2FACD;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAiCC,YAAY,QAAZA,YAAY,EAAEE,IAAI,QAAJA,IAAI,EAAED,WAAW,QAAXA,WAAW;gBACtDzB,UAAU,GAAG,IAAIC,GAAG,CAAC5B,MAAM,CAAC6B,QAAQ,CAACC,IAAI,CAAC;gBAC1CC,MAAM,GAAG,IAAIH,GAAG,CAAC,MAAM,EAAE,IAAI,CAACtB,cAAc,CAAC;gBACnDyB,MAAM,CAACC,YAAY,CAACC,GAAG,CAAC,cAAc,EAAEkB,YAAY,CAC/CG,GAAG,CAAC,UAAAC,WAAW;kBAAA,OAAInE,OAAO,CAACoE,SAAS,CAACvE,aAAa,CAACwE,MAAM,EAAEF,WAAW,CAAC;gBAAA,EAAC,CACxED,GAAG,CAAC,UAAAI,UAAU;kBAAA,OAAIC,MAAM,CAACC,IAAI,CAACF,UAAU,CAAC,CAACjB,QAAQ,CAAC,QAAQ,CAAC;gBAAA,EAAC,CAC7DoB,IAAI,CAAC,GAAG,CAAC,CAAC;gBACf9B,MAAM,CAACC,YAAY,CAACC,GAAG,CAAC,aAAa,EAAEmB,WAAW,IAAIzB,UAAU,CAACG,IAAI,CAAC;gBACtE,IAAIuB,IAAI,EACJtB,MAAM,CAACC,YAAY,CAACC,GAAG,CAAC,MAAM,EAAEoB,IAAI,CAAC;gBACzCrD,MAAM,CAAC6B,QAAQ,CAACkB,MAAM,CAAChB,MAAM,CAACU,QAAQ,EAAE,CAAC;cAAC;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAC7C;MAAA;QAAA;MAAA;MAAA;IAAA;IACD;AACJ;AACA;AACA;EAHI;IAAA;IAAA;MAAA,+FAIA;QAAA;QAAA;UAAA;YAAA;cAAA;gBACUd,UAAU,GAAG,IAAIC,GAAG,CAAC5B,MAAM,CAAC6B,QAAQ,CAACC,IAAI,CAAC;gBAC1CgC,SAAS,GAAGnC,UAAU,CAACK,YAAY,CAAC+B,GAAG,CAAC,YAAY,CAAC,IAAI,EAAE;gBAC3DjD,OAAO,GAAG,CAACa,UAAU,CAACK,YAAY,CAAC+B,GAAG,CAAC,UAAU,CAAC,IAAI,EAAE,EAAEC,KAAK,CAAC,GAAG,CAAC;gBACpE9C,SAAS,GAAGS,UAAU,CAACK,YAAY,CAAC+B,GAAG,CAAC,YAAY,CAAC,IAAI,EAAE,EACjE;gBAAA,KACI7C,SAAS;kBAAA;kBAAA;gBAAA;gBACT,IAAI,CAACL,SAAS,GAAG;kBACbK,SAAS,EAATA,SAAS;kBACTJ,OAAO,EAAPA;gBACJ,CAAC;gBACDd,MAAM,CAACC,YAAY,CAACgE,OAAO,CAAC,IAAI,CAAClD,YAAY,EAAEjB,IAAI,CAACoE,SAAS,CAAC,IAAI,CAACrD,SAAS,CAAC,CAAC;gBAAC,KAC3EiD,SAAS;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACH,IAAI,CAACK,2BAA2B,CAACjD,SAAS,EAAE4C,SAAS,CAAC;cAAA;gBAGpEnC,UAAU,CAACK,YAAY,CAACoC,MAAM,CAAC,YAAY,CAAC;gBAC5CzC,UAAU,CAACK,YAAY,CAACoC,MAAM,CAAC,UAAU,CAAC;gBAC1CzC,UAAU,CAACK,YAAY,CAACoC,MAAM,CAAC,YAAY,CAAC;gBAC5CzC,UAAU,CAACK,YAAY,CAACoC,MAAM,CAAC,MAAM,CAAC;gBACtCzC,UAAU,CAACK,YAAY,CAACoC,MAAM,CAAC,mBAAmB,CAAC;gBACnDpE,MAAM,CAACqE,OAAO,CAACC,YAAY,CAAC,CAAC,CAAC,EAAEC,QAAQ,CAACnD,KAAK,EAAEO,UAAU,CAACc,QAAQ,EAAE,CAAC;cAAC;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAC1E;MAAA;QAAA;MAAA;MAAA;IAAA;IACD;AACJ;AACA;AACA;AACA;EAJI;IAAA;IAAA;MAAA,8FAKA,kBAAkCvB,SAAS,EAAE4C,SAAS;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAC5B,IAAI,CAACrD,SAAS,CAAC+D,MAAM,CAAC,IAAI,CAACrE,UAAU,EAAEX,yBAAyB,GAAGsE,SAAS,CAAC;cAAA;gBAA7FW,OAAO;gBAAA;gBAAA,OACP,IAAI,CAAChE,SAAS,CAACiC,MAAM,CAAC,IAAI,CAACvC,UAAU,EAAEe,SAAS,EAAEuD,OAAO,CAAC;cAAA;gBAAA;gBAAA,OAC1D,IAAI,CAAChE,SAAS,CAACiE,SAAS,CAAC,IAAI,CAACvE,UAAU,EAAEX,yBAAyB,GAAGsE,SAAS,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACzF;MAAA;QAAA;MAAA;MAAA;IAAA;IACD;AACJ;AACA;AACA;AACA;EAJI;IAAA;IAAA,OAKA,mBAAU;MACN,IAAI,CAACjD,SAAS,GAAG,CAAC,CAAC;MACnBb,MAAM,CAACC,YAAY,CAAC0E,UAAU,CAAC,IAAI,CAAC5D,YAAY,CAAC;IACrD;IACA;AACJ;AACA;EAFI;IAAA;IAAA,OAGA,mBAAU;MACN,IAAI,CAAC,IAAI,CAAC6D,iBAAiB,EAAE;QACzB,IAAI,CAACA,iBAAiB,GAAG,IAAIjG,sBAAsB,CAAC,IAAI,EAAE,IAAI,CAACgB,KAAK,CAACe,UAAU,EAAE,IAAI,CAACG,SAAS,CAACK,SAAS,CAAC;MAC9G;MACA,OAAO,IAAI,CAAC0D,iBAAiB;IACjC;EAAC;EAAA;AAAA;AAELnG,OAAO,CAACI,gBAAgB,GAAGA,gBAAgB;AAC3CJ,OAAO,CAACG,aAAa,GAAGC,gBAAgB;AACxC;AACA;AACA;AAFA,IAGMF,sBAAsB;EAAA;EAAA;EACxB,gCAAYkG,gBAAgB,EAAEnE,UAAU,EAAEQ,SAAS,EAAE;IAAA;IAAA;IACjD,0BAAMR,UAAU,EAAEQ,SAAS;IAC3B,MAAK2D,gBAAgB,GAAGA,gBAAgB;IAAC;EAC7C;EACA;EACA;AACJ;AACA;AACA;EAHI;IAAA;IAAA,OAIA,kCAAgC;MAC5B,IAAI,yDAAc,KAAK,QAAQ,EAAE;QAC7B,OAAO,IAAI,CAACC,uBAAuB,CAAC;UAAEC,UAAU,kDAAS;UAAEC,OAAO;QAAU,CAAC,CAAC;MAClF;MACA,OAAO,IAAI,CAACF,uBAAuB,kDAAS;IAChD;EAAC;IAAA;IAAA;MAAA,0FACD;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAgCC,UAAU,SAAVA,UAAU,EAAEC,OAAO,SAAPA,OAAO,EAAEC,UAAU,SAAVA,UAAU,gCAAEC,iBAAiB,EAAjBA,iBAAiB,sCAAGlF,MAAM,CAAC6B,QAAQ,CAACC,IAAI;gBAAA;gBAAA,OAC9E,IAAI,CAACpB,UAAU,CAACC,MAAM,CAAC6B,YAAY,CAAC,IAAI,CAACtB,SAAS,EAAE,IAAI,CAACR,UAAU,CAACL,SAAS,CAAC;cAAA;gBAA/F8E,QAAQ;gBAAA;gBAAA,OACQ,IAAI,CAACC,uBAAuB,CAACL,UAAU,EAAEC,OAAO,EAAEG,QAAQ,CAAC;cAAA;gBAA7E9C,SAAS;gBAAA,IACRA,SAAS;kBAAA;kBAAA;gBAAA;gBAAA,MACJ,IAAIgD,KAAK,4DAAqDN,UAAU,EAAG;cAAA;gBAAA,MAEjFI,QAAQ,IAAIA,QAAQ,CAAC1C,QAAQ,EAAE,KAAKJ,SAAS,CAACiD,UAAU;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA;gBAAA,0GAEV;kBAAEP,UAAU,EAAVA,UAAU;kBAAEC,OAAO,EAAPA;gBAAQ,CAAC;cAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA,MAG7D,aAAEO,IAAI,KAAK,oBAAoB;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACb,IAAI,CAACH,uBAAuB,CAACL,UAAU,EAAEC,OAAO,CAAC;cAAA;gBAAnE3C,SAAS;gBAAA;gBAAA;cAAA;gBAAA;cAAA;gBAAA;gBAAA,OAOD,IAAI,CAAC3B,UAAU,CAAC8E,QAAQ,CAACC,KAAK,CAAC;kBAAEC,QAAQ,EAAE;gBAAQ,CAAC,CAAC;cAAA;gBAAnED,KAAK;gBACLE,SAAS,GAAGxG,OAAO,CAACyG,UAAU,CAACH,KAAK,CAACI,MAAM,CAACC,IAAI,CAAC;gBACjDhC,SAAS,GAAG5E,OAAO,CAAC6G,SAAS,CAACnC,IAAI,CAACvB,SAAS,CAACiD,UAAU,CAAC,EAC9D;gBACMU,KAAK,GAAG3D,SAAS,CAAC4D,UAAU,CAACD,KAAK,GAAG,CAAC;gBACtCzC,WAAW,GAAGtE,aAAa,CAACiH,iBAAiB,CAAC,IAAI,CAAChF,SAAS,EAAE4C,SAAS,EAAEiB,UAAU,EAAEiB,KAAK,EAAEhB,OAAO,EAAEW,SAAS,CAAC;gBAAA;gBAAA,OAC/G,IAAI,CAACd,gBAAgB,CAACsB,uBAAuB,CAAC;kBAChDhD,YAAY,EAAE,CAACI,WAAW,CAAC;kBAC3BF,IAAI,EAAE4B,UAAU;kBAChB7B,WAAW,EAAE8B;gBACjB,CAAC,CAAC;cAAA;gBAAA,kCACK,IAAIkB,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAK;kBACpCC,UAAU,CAAC,YAAM;oBACbD,MAAM,CAAC,IAAIjB,KAAK,CAAC,wCAAwC,CAAC,CAAC;kBAC/D,CAAC,EAAE,IAAI,CAAC;gBACZ,CAAC,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAGL;MAAA;QAAA;MAAA;MAAA;IAAA;IACD;AACJ;AACA;AACA;AACA;AACA;EALI;IAAA;IAAA;MAAA,8FAMA,kBAAkChD,SAAS,EAAE0C,UAAU,EAAEC,OAAO;QAAA;QAAA;UAAA;YAAA;cAAA;gBACtCwB,UAAU,GAAOnE,SAAS,CAAxC4D,UAAU,CAAIO,UAAU;gBAAA,MAC5BA,UAAU,KAAK,YAAY;kBAAA;kBAAA;gBAAA;gBAAA,kCACpB,IAAI;cAAA;gBAAA,KAEXA,UAAU,CAACC,YAAY;kBAAA;kBAAA;gBAAA;gBAAA,wBACkDD,UAAU,CAACC,YAAY,EAA3EC,iBAAiB,yBAA9BC,WAAW,EAAmCC,cAAc,yBAA5BC,YAAY;gBACpD;AACZ;AACA;AACA;gBAHY,MAIIH,iBAAiB,KAAK,IAAI,CAACxF,SAAS,IAAI0F,cAAc,CAACE,QAAQ,CAACxH,mBAAmB,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,kCAC7E,IAAI;cAAA;gBAAA,MAEXoH,iBAAiB,KAAK3B,UAAU;kBAAA;kBAAA;gBAAA;gBAAA,MAC5BC,OAAO,CAAC+B,MAAM,KAAK,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,kCACb,KAAK;cAAA;gBAAA,0BAEW/B,OAAO,MAAzBgC,YAAY,eAAZA,YAAY;gBAAA,kCACdA,YAAY,KACd,CAACA,YAAY,CAACC,OAAO,IAAID,YAAY,CAACC,OAAO,CAACxE,QAAQ,EAAE,KAAK,GAAG,CAAC;gBAAI;gBACrEmE,cAAc,CAACG,MAAM,KAAK,CAAC,IAAIH,cAAc,CAACE,QAAQ,CAACE,YAAY,CAACnE,UAAU,CAAC,CAAC;cAAA;gBAAA,kCAKtF,KAAK;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACf;MAAA;QAAA;MAAA;MAAA;IAAA;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;EANI;IAAA;IAAA;MAAA,0FAOA,kBAA8BkC,UAAU,EAAEC,OAAO,EAAEG,QAAQ;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAC9B,IAAI,CAAC+B,aAAa,EAAE;cAAA;gBAAvCC,UAAU;gBAAA,KACZhC,QAAQ;kBAAA;kBAAA;gBAAA;gBACF9C,SAAS,GAAG8E,UAAU,CAACC,IAAI,CAAC,UAAAC,GAAG;kBAAA,OAAIA,GAAG,CAAC/B,UAAU,CAAC7C,QAAQ,EAAE,KAAK0C,QAAQ,CAAC1C,QAAQ,EAAE;gBAAA,EAAC;gBAAA,eACvFJ,SAAS;gBAAA;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OAAU,IAAI,CAACiF,2BAA2B,CAACjF,SAAS,EAAE0C,UAAU,EAAEC,OAAO,CAAC;cAAA;gBAAA;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAAA,kCAC5E3C,SAAS;cAAA;gBAGlBkF,UAAU,GAAG,IAAI,CAAC1C,gBAAgB,CAAChE,SAAS,CAACC,OAAO;gBAAA,uCAClCqG,UAAU;gBAAA;gBAAA;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAAvB9E,UAAS;gBAAA,eACZkF,UAAU,CAACC,OAAO,CAACnF,UAAS,CAACiD,UAAU,CAAC,KAAK,CAAC,CAAC;gBAAA;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OAAU,IAAI,CAACgC,2BAA2B,CAACjF,UAAS,EAAE0C,UAAU,EAAEC,OAAO,CAAC;cAAA;gBAAA;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAAA,kCAClH3C,UAAS;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA,kCAGjB,IAAI;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACd;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA,EA9GgCrD,SAAS,CAACyI,OAAO;AAgHtDhJ,OAAO,CAACE,sBAAsB,GAAGA,sBAAsB"},"metadata":{},"sourceType":"script"}