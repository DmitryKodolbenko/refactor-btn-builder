{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StargateClient = exports.assertIsDeliverTxFailure = exports.assertIsDeliverTxSuccess = exports.isDeliverTxSuccess = exports.isDeliverTxFailure = exports.TimeoutError = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst amino_1 = require(\"@cosmjs/amino\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nconst tendermint_rpc_1 = require(\"@cosmjs/tendermint-rpc\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst accounts_1 = require(\"./accounts\");\nconst modules_1 = require(\"./modules\");\nconst queryclient_1 = require(\"./queryclient\");\nconst search_1 = require(\"./search\");\nclass TimeoutError extends Error {\n  constructor(message, txId) {\n    super(message);\n    this.txId = txId;\n  }\n}\nexports.TimeoutError = TimeoutError;\nfunction isDeliverTxFailure(result) {\n  return !!result.code;\n}\nexports.isDeliverTxFailure = isDeliverTxFailure;\nfunction isDeliverTxSuccess(result) {\n  return !isDeliverTxFailure(result);\n}\nexports.isDeliverTxSuccess = isDeliverTxSuccess;\n/**\n * Ensures the given result is a success. Throws a detailed error message otherwise.\n */\nfunction assertIsDeliverTxSuccess(result) {\n  if (isDeliverTxFailure(result)) {\n    throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);\n  }\n}\nexports.assertIsDeliverTxSuccess = assertIsDeliverTxSuccess;\n/**\n * Ensures the given result is a failure. Throws a detailed error message otherwise.\n */\nfunction assertIsDeliverTxFailure(result) {\n  if (isDeliverTxSuccess(result)) {\n    throw new Error(`Transaction ${result.transactionHash} did not fail at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);\n  }\n}\nexports.assertIsDeliverTxFailure = assertIsDeliverTxFailure;\nclass StargateClient {\n  constructor(tmClient, options) {\n    if (tmClient) {\n      this.tmClient = tmClient;\n      this.queryClient = queryclient_1.QueryClient.withExtensions(tmClient, modules_1.setupAuthExtension, modules_1.setupBankExtension, modules_1.setupStakingExtension, modules_1.setupTxExtension);\n    }\n    const {\n      accountParser = accounts_1.accountFromAny\n    } = options;\n    this.accountParser = accountParser;\n  }\n  static async connect(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);\n    return new StargateClient(tmClient, options);\n  }\n  getTmClient() {\n    return this.tmClient;\n  }\n  forceGetTmClient() {\n    if (!this.tmClient) {\n      throw new Error(\"Tendermint client not available. You cannot use online functionality in offline mode.\");\n    }\n    return this.tmClient;\n  }\n  getQueryClient() {\n    return this.queryClient;\n  }\n  forceGetQueryClient() {\n    if (!this.queryClient) {\n      throw new Error(\"Query client not available. You cannot use online functionality in offline mode.\");\n    }\n    return this.queryClient;\n  }\n  async getChainId() {\n    if (!this.chainId) {\n      const response = await this.forceGetTmClient().status();\n      const chainId = response.nodeInfo.network;\n      if (!chainId) throw new Error(\"Chain ID must not be empty\");\n      this.chainId = chainId;\n    }\n    return this.chainId;\n  }\n  async getHeight() {\n    const status = await this.forceGetTmClient().status();\n    return status.syncInfo.latestBlockHeight;\n  }\n  async getAccount(searchAddress) {\n    try {\n      const account = await this.forceGetQueryClient().auth.account(searchAddress);\n      return account ? this.accountParser(account) : null;\n    } catch (error) {\n      if (/rpc error: code = NotFound/i.test(error.toString())) {\n        return null;\n      }\n      throw error;\n    }\n  }\n  async getSequence(address) {\n    const account = await this.getAccount(address);\n    if (!account) {\n      throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n    }\n    return {\n      accountNumber: account.accountNumber,\n      sequence: account.sequence\n    };\n  }\n  async getBlock(height) {\n    const response = await this.forceGetTmClient().block(height);\n    return {\n      id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),\n      header: {\n        version: {\n          block: new math_1.Uint53(response.block.header.version.block).toString(),\n          app: new math_1.Uint53(response.block.header.version.app).toString()\n        },\n        height: response.block.header.height,\n        chainId: response.block.header.chainId,\n        time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)\n      },\n      txs: response.block.txs\n    };\n  }\n  async getBalance(address, searchDenom) {\n    return this.forceGetQueryClient().bank.balance(address, searchDenom);\n  }\n  /**\n   * Queries all balances for all denoms that belong to this address.\n   *\n   * Uses the grpc queries (which iterates over the store internally), and we cannot get\n   * proofs from such a method.\n   */\n  async getAllBalances(address) {\n    return this.forceGetQueryClient().bank.allBalances(address);\n  }\n  async getBalanceStaked(address) {\n    const allDelegations = [];\n    let startAtKey = undefined;\n    do {\n      const {\n        delegationResponses,\n        pagination\n      } = await this.forceGetQueryClient().staking.delegatorDelegations(address, startAtKey);\n      const loadedDelegations = delegationResponses || [];\n      allDelegations.push(...loadedDelegations);\n      startAtKey = pagination === null || pagination === void 0 ? void 0 : pagination.nextKey;\n    } while (startAtKey !== undefined && startAtKey.length !== 0);\n    const sumValues = allDelegations.reduce((previousValue, currentValue) => {\n      // Safe because field is set to non-nullable (https://github.com/cosmos/cosmos-sdk/blob/v0.45.3/proto/cosmos/staking/v1beta1/staking.proto#L295)\n      (0, utils_1.assert)(currentValue.balance);\n      return previousValue !== null ? (0, amino_1.addCoins)(previousValue, currentValue.balance) : currentValue.balance;\n    }, null);\n    return sumValues;\n  }\n  async getDelegation(delegatorAddress, validatorAddress) {\n    var _a;\n    let delegatedAmount;\n    try {\n      delegatedAmount = (_a = (await this.forceGetQueryClient().staking.delegation(delegatorAddress, validatorAddress)).delegationResponse) === null || _a === void 0 ? void 0 : _a.balance;\n    } catch (e) {\n      if (e.toString().includes(\"key not found\")) {\n        // ignore, `delegatedAmount` remains undefined\n      } else {\n        throw e;\n      }\n    }\n    return delegatedAmount || null;\n  }\n  async getTx(id) {\n    var _a;\n    const results = await this.txsQuery(`tx.hash='${id}'`);\n    return (_a = results[0]) !== null && _a !== void 0 ? _a : null;\n  }\n  async searchTx(query) {\n    let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const minHeight = filter.minHeight || 0;\n    const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n    if (maxHeight < minHeight) return []; // optional optimization\n    function withFilters(originalQuery) {\n      return `${originalQuery} AND tx.height>=${minHeight} AND tx.height<=${maxHeight}`;\n    }\n    let txs;\n    if ((0, search_1.isSearchByHeightQuery)(query)) {\n      txs = query.height >= minHeight && query.height <= maxHeight ? await this.txsQuery(`tx.height=${query.height}`) : [];\n    } else if ((0, search_1.isSearchBySentFromOrToQuery)(query)) {\n      const sentQuery = withFilters(`message.module='bank' AND transfer.sender='${query.sentFromOrTo}'`);\n      const receivedQuery = withFilters(`message.module='bank' AND transfer.recipient='${query.sentFromOrTo}'`);\n      const [sent, received] = await Promise.all([sentQuery, receivedQuery].map(rawQuery => this.txsQuery(rawQuery)));\n      const sentHashes = sent.map(t => t.hash);\n      txs = [...sent, ...received.filter(t => !sentHashes.includes(t.hash))];\n    } else if ((0, search_1.isSearchByTagsQuery)(query)) {\n      const rawQuery = withFilters(query.tags.map(t => `${t.key}='${t.value}'`).join(\" AND \"));\n      txs = await this.txsQuery(rawQuery);\n    } else {\n      throw new Error(\"Unknown query type\");\n    }\n    const filtered = txs.filter(tx => tx.height >= minHeight && tx.height <= maxHeight);\n    return filtered;\n  }\n  disconnect() {\n    if (this.tmClient) this.tmClient.disconnect();\n  }\n  /**\n   * Broadcasts a signed transaction to the network and monitors its inclusion in a block.\n   *\n   * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),\n   * an error is thrown.\n   *\n   * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.\n   *\n   * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then\n   * usually needs to check for execution success or failure.\n   */\n  async broadcastTx(tx) {\n    let timeoutMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60000;\n    let pollIntervalMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3000;\n    let timedOut = false;\n    const txPollTimeout = setTimeout(() => {\n      timedOut = true;\n    }, timeoutMs);\n    const pollForTx = async txId => {\n      if (timedOut) {\n        throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1000} seconds.`, txId);\n      }\n      await (0, utils_1.sleep)(pollIntervalMs);\n      const result = await this.getTx(txId);\n      return result ? {\n        code: result.code,\n        height: result.height,\n        rawLog: result.rawLog,\n        transactionHash: txId,\n        gasUsed: result.gasUsed,\n        gasWanted: result.gasWanted\n      } : pollForTx(txId);\n    };\n    const broadcasted = await this.forceGetTmClient().broadcastTxSync({\n      tx\n    });\n    if (broadcasted.code) {\n      return Promise.reject(new Error(`Broadcasting transaction failed with code ${broadcasted.code} (codespace: ${broadcasted.codeSpace}). Log: ${broadcasted.log}`));\n    }\n    const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();\n    return new Promise((resolve, reject) => pollForTx(transactionId).then(value => {\n      clearTimeout(txPollTimeout);\n      resolve(value);\n    }, error => {\n      clearTimeout(txPollTimeout);\n      reject(error);\n    }));\n  }\n  async txsQuery(query) {\n    const results = await this.forceGetTmClient().txSearchAll({\n      query: query\n    });\n    return results.txs.map(tx => {\n      return {\n        height: tx.height,\n        hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),\n        code: tx.result.code,\n        rawLog: tx.result.log || \"\",\n        tx: tx.tx,\n        gasUsed: tx.result.gasUsed,\n        gasWanted: tx.result.gasWanted\n      };\n    });\n  }\n}\nexports.StargateClient = StargateClient;","map":{"version":3,"sources":["../src/stargateclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StargateClient = exports.assertIsDeliverTxFailure = exports.assertIsDeliverTxSuccess = exports.isDeliverTxSuccess = exports.isDeliverTxFailure = exports.TimeoutError = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst amino_1 = require(\"@cosmjs/amino\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nconst tendermint_rpc_1 = require(\"@cosmjs/tendermint-rpc\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst accounts_1 = require(\"./accounts\");\nconst modules_1 = require(\"./modules\");\nconst queryclient_1 = require(\"./queryclient\");\nconst search_1 = require(\"./search\");\nclass TimeoutError extends Error {\n    constructor(message, txId) {\n        super(message);\n        this.txId = txId;\n    }\n}\nexports.TimeoutError = TimeoutError;\nfunction isDeliverTxFailure(result) {\n    return !!result.code;\n}\nexports.isDeliverTxFailure = isDeliverTxFailure;\nfunction isDeliverTxSuccess(result) {\n    return !isDeliverTxFailure(result);\n}\nexports.isDeliverTxSuccess = isDeliverTxSuccess;\n/**\n * Ensures the given result is a success. Throws a detailed error message otherwise.\n */\nfunction assertIsDeliverTxSuccess(result) {\n    if (isDeliverTxFailure(result)) {\n        throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);\n    }\n}\nexports.assertIsDeliverTxSuccess = assertIsDeliverTxSuccess;\n/**\n * Ensures the given result is a failure. Throws a detailed error message otherwise.\n */\nfunction assertIsDeliverTxFailure(result) {\n    if (isDeliverTxSuccess(result)) {\n        throw new Error(`Transaction ${result.transactionHash} did not fail at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);\n    }\n}\nexports.assertIsDeliverTxFailure = assertIsDeliverTxFailure;\nclass StargateClient {\n    constructor(tmClient, options) {\n        if (tmClient) {\n            this.tmClient = tmClient;\n            this.queryClient = queryclient_1.QueryClient.withExtensions(tmClient, modules_1.setupAuthExtension, modules_1.setupBankExtension, modules_1.setupStakingExtension, modules_1.setupTxExtension);\n        }\n        const { accountParser = accounts_1.accountFromAny } = options;\n        this.accountParser = accountParser;\n    }\n    static async connect(endpoint, options = {}) {\n        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);\n        return new StargateClient(tmClient, options);\n    }\n    getTmClient() {\n        return this.tmClient;\n    }\n    forceGetTmClient() {\n        if (!this.tmClient) {\n            throw new Error(\"Tendermint client not available. You cannot use online functionality in offline mode.\");\n        }\n        return this.tmClient;\n    }\n    getQueryClient() {\n        return this.queryClient;\n    }\n    forceGetQueryClient() {\n        if (!this.queryClient) {\n            throw new Error(\"Query client not available. You cannot use online functionality in offline mode.\");\n        }\n        return this.queryClient;\n    }\n    async getChainId() {\n        if (!this.chainId) {\n            const response = await this.forceGetTmClient().status();\n            const chainId = response.nodeInfo.network;\n            if (!chainId)\n                throw new Error(\"Chain ID must not be empty\");\n            this.chainId = chainId;\n        }\n        return this.chainId;\n    }\n    async getHeight() {\n        const status = await this.forceGetTmClient().status();\n        return status.syncInfo.latestBlockHeight;\n    }\n    async getAccount(searchAddress) {\n        try {\n            const account = await this.forceGetQueryClient().auth.account(searchAddress);\n            return account ? this.accountParser(account) : null;\n        }\n        catch (error) {\n            if (/rpc error: code = NotFound/i.test(error.toString())) {\n                return null;\n            }\n            throw error;\n        }\n    }\n    async getSequence(address) {\n        const account = await this.getAccount(address);\n        if (!account) {\n            throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n        }\n        return {\n            accountNumber: account.accountNumber,\n            sequence: account.sequence,\n        };\n    }\n    async getBlock(height) {\n        const response = await this.forceGetTmClient().block(height);\n        return {\n            id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),\n            header: {\n                version: {\n                    block: new math_1.Uint53(response.block.header.version.block).toString(),\n                    app: new math_1.Uint53(response.block.header.version.app).toString(),\n                },\n                height: response.block.header.height,\n                chainId: response.block.header.chainId,\n                time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time),\n            },\n            txs: response.block.txs,\n        };\n    }\n    async getBalance(address, searchDenom) {\n        return this.forceGetQueryClient().bank.balance(address, searchDenom);\n    }\n    /**\n     * Queries all balances for all denoms that belong to this address.\n     *\n     * Uses the grpc queries (which iterates over the store internally), and we cannot get\n     * proofs from such a method.\n     */\n    async getAllBalances(address) {\n        return this.forceGetQueryClient().bank.allBalances(address);\n    }\n    async getBalanceStaked(address) {\n        const allDelegations = [];\n        let startAtKey = undefined;\n        do {\n            const { delegationResponses, pagination } = await this.forceGetQueryClient().staking.delegatorDelegations(address, startAtKey);\n            const loadedDelegations = delegationResponses || [];\n            allDelegations.push(...loadedDelegations);\n            startAtKey = pagination === null || pagination === void 0 ? void 0 : pagination.nextKey;\n        } while (startAtKey !== undefined && startAtKey.length !== 0);\n        const sumValues = allDelegations.reduce((previousValue, currentValue) => {\n            // Safe because field is set to non-nullable (https://github.com/cosmos/cosmos-sdk/blob/v0.45.3/proto/cosmos/staking/v1beta1/staking.proto#L295)\n            (0, utils_1.assert)(currentValue.balance);\n            return previousValue !== null ? (0, amino_1.addCoins)(previousValue, currentValue.balance) : currentValue.balance;\n        }, null);\n        return sumValues;\n    }\n    async getDelegation(delegatorAddress, validatorAddress) {\n        var _a;\n        let delegatedAmount;\n        try {\n            delegatedAmount = (_a = (await this.forceGetQueryClient().staking.delegation(delegatorAddress, validatorAddress)).delegationResponse) === null || _a === void 0 ? void 0 : _a.balance;\n        }\n        catch (e) {\n            if (e.toString().includes(\"key not found\")) {\n                // ignore, `delegatedAmount` remains undefined\n            }\n            else {\n                throw e;\n            }\n        }\n        return delegatedAmount || null;\n    }\n    async getTx(id) {\n        var _a;\n        const results = await this.txsQuery(`tx.hash='${id}'`);\n        return (_a = results[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    async searchTx(query, filter = {}) {\n        const minHeight = filter.minHeight || 0;\n        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n        if (maxHeight < minHeight)\n            return []; // optional optimization\n        function withFilters(originalQuery) {\n            return `${originalQuery} AND tx.height>=${minHeight} AND tx.height<=${maxHeight}`;\n        }\n        let txs;\n        if ((0, search_1.isSearchByHeightQuery)(query)) {\n            txs =\n                query.height >= minHeight && query.height <= maxHeight\n                    ? await this.txsQuery(`tx.height=${query.height}`)\n                    : [];\n        }\n        else if ((0, search_1.isSearchBySentFromOrToQuery)(query)) {\n            const sentQuery = withFilters(`message.module='bank' AND transfer.sender='${query.sentFromOrTo}'`);\n            const receivedQuery = withFilters(`message.module='bank' AND transfer.recipient='${query.sentFromOrTo}'`);\n            const [sent, received] = await Promise.all([sentQuery, receivedQuery].map((rawQuery) => this.txsQuery(rawQuery)));\n            const sentHashes = sent.map((t) => t.hash);\n            txs = [...sent, ...received.filter((t) => !sentHashes.includes(t.hash))];\n        }\n        else if ((0, search_1.isSearchByTagsQuery)(query)) {\n            const rawQuery = withFilters(query.tags.map((t) => `${t.key}='${t.value}'`).join(\" AND \"));\n            txs = await this.txsQuery(rawQuery);\n        }\n        else {\n            throw new Error(\"Unknown query type\");\n        }\n        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);\n        return filtered;\n    }\n    disconnect() {\n        if (this.tmClient)\n            this.tmClient.disconnect();\n    }\n    /**\n     * Broadcasts a signed transaction to the network and monitors its inclusion in a block.\n     *\n     * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),\n     * an error is thrown.\n     *\n     * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.\n     *\n     * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then\n     * usually needs to check for execution success or failure.\n     */\n    async broadcastTx(tx, timeoutMs = 60000, pollIntervalMs = 3000) {\n        let timedOut = false;\n        const txPollTimeout = setTimeout(() => {\n            timedOut = true;\n        }, timeoutMs);\n        const pollForTx = async (txId) => {\n            if (timedOut) {\n                throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1000} seconds.`, txId);\n            }\n            await (0, utils_1.sleep)(pollIntervalMs);\n            const result = await this.getTx(txId);\n            return result\n                ? {\n                    code: result.code,\n                    height: result.height,\n                    rawLog: result.rawLog,\n                    transactionHash: txId,\n                    gasUsed: result.gasUsed,\n                    gasWanted: result.gasWanted,\n                }\n                : pollForTx(txId);\n        };\n        const broadcasted = await this.forceGetTmClient().broadcastTxSync({ tx });\n        if (broadcasted.code) {\n            return Promise.reject(new Error(`Broadcasting transaction failed with code ${broadcasted.code} (codespace: ${broadcasted.codeSpace}). Log: ${broadcasted.log}`));\n        }\n        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();\n        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {\n            clearTimeout(txPollTimeout);\n            resolve(value);\n        }, (error) => {\n            clearTimeout(txPollTimeout);\n            reject(error);\n        }));\n    }\n    async txsQuery(query) {\n        const results = await this.forceGetTmClient().txSearchAll({ query: query });\n        return results.txs.map((tx) => {\n            return {\n                height: tx.height,\n                hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),\n                code: tx.result.code,\n                rawLog: tx.result.log || \"\",\n                tx: tx.tx,\n                gasUsed: tx.result.gasUsed,\n                gasWanted: tx.result.gasWanted,\n            };\n        });\n    }\n}\nexports.StargateClient = StargateClient;\n//# sourceMappingURL=stargateclient.js.map"]},"metadata":{},"sourceType":"script"}