{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReconnectingSocket = void 0;\nconst xstream_1 = require(\"xstream\");\nconst queueingstreamingsocket_1 = require(\"./queueingstreamingsocket\");\n/**\n * A wrapper around QueueingStreamingSocket that reconnects automatically.\n */\nclass ReconnectingSocket {\n  constructor(url) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    let reconnectedHandler = arguments.length > 2 ? arguments[2] : undefined;\n    this.unconnected = true;\n    this.disconnected = false;\n    this.timeoutIndex = 0;\n    this.reconnectTimeout = null;\n    const eventProducer = {\n      start: listener => this.eventProducerListener = listener,\n      stop: () => this.eventProducerListener = undefined\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n    this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);\n    this.socket.events.subscribe({\n      next: event => {\n        if (this.eventProducerListener) {\n          this.eventProducerListener.next(event);\n        }\n      },\n      error: error => {\n        if (this.eventProducerListener) {\n          this.eventProducerListener.error(error);\n        }\n      }\n    });\n    this.connectionStatus = this.socket.connectionStatus;\n    this.connectionStatus.updates.subscribe({\n      next: status => {\n        if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {\n          this.timeoutIndex = 0;\n        }\n        if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {\n          if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n          }\n          this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), ReconnectingSocket.calculateTimeout(this.timeoutIndex++));\n        }\n      }\n    });\n  }\n  /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */\n  static calculateTimeout(index) {\n    return Math.min(2 ** index * 100, 5000);\n  }\n  connect() {\n    if (!this.unconnected) {\n      throw new Error(\"Cannot connect: socket has already connected\");\n    }\n    this.socket.connect();\n    this.unconnected = false;\n  }\n  disconnect() {\n    if (this.unconnected) {\n      throw new Error(\"Cannot disconnect: socket has not yet connected\");\n    }\n    this.socket.disconnect();\n    if (this.eventProducerListener) {\n      this.eventProducerListener.complete();\n    }\n    this.disconnected = true;\n  }\n  queueRequest(request) {\n    if (this.disconnected) {\n      throw new Error(\"Cannot queue request: socket has disconnected\");\n    }\n    this.socket.queueRequest(request);\n  }\n}\nexports.ReconnectingSocket = ReconnectingSocket;","map":{"version":3,"sources":["../src/reconnectingsocket.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReconnectingSocket = void 0;\nconst xstream_1 = require(\"xstream\");\nconst queueingstreamingsocket_1 = require(\"./queueingstreamingsocket\");\n/**\n * A wrapper around QueueingStreamingSocket that reconnects automatically.\n */\nclass ReconnectingSocket {\n    constructor(url, timeout = 10000, reconnectedHandler) {\n        this.unconnected = true;\n        this.disconnected = false;\n        this.timeoutIndex = 0;\n        this.reconnectTimeout = null;\n        const eventProducer = {\n            start: (listener) => (this.eventProducerListener = listener),\n            stop: () => (this.eventProducerListener = undefined),\n        };\n        this.events = xstream_1.Stream.create(eventProducer);\n        this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);\n        this.socket.events.subscribe({\n            next: (event) => {\n                if (this.eventProducerListener) {\n                    this.eventProducerListener.next(event);\n                }\n            },\n            error: (error) => {\n                if (this.eventProducerListener) {\n                    this.eventProducerListener.error(error);\n                }\n            },\n        });\n        this.connectionStatus = this.socket.connectionStatus;\n        this.connectionStatus.updates.subscribe({\n            next: (status) => {\n                if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {\n                    this.timeoutIndex = 0;\n                }\n                if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {\n                    if (this.reconnectTimeout) {\n                        clearTimeout(this.reconnectTimeout);\n                        this.reconnectTimeout = null;\n                    }\n                    this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), ReconnectingSocket.calculateTimeout(this.timeoutIndex++));\n                }\n            },\n        });\n    }\n    /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */\n    static calculateTimeout(index) {\n        return Math.min(2 ** index * 100, 5000);\n    }\n    connect() {\n        if (!this.unconnected) {\n            throw new Error(\"Cannot connect: socket has already connected\");\n        }\n        this.socket.connect();\n        this.unconnected = false;\n    }\n    disconnect() {\n        if (this.unconnected) {\n            throw new Error(\"Cannot disconnect: socket has not yet connected\");\n        }\n        this.socket.disconnect();\n        if (this.eventProducerListener) {\n            this.eventProducerListener.complete();\n        }\n        this.disconnected = true;\n    }\n    queueRequest(request) {\n        if (this.disconnected) {\n            throw new Error(\"Cannot queue request: socket has disconnected\");\n        }\n        this.socket.queueRequest(request);\n    }\n}\nexports.ReconnectingSocket = ReconnectingSocket;\n//# sourceMappingURL=reconnectingsocket.js.map"]},"metadata":{},"sourceType":"script"}