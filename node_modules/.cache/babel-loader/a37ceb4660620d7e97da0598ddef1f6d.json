{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ensureLeftNeighbor = exports.ensureSpec = exports.calculateExistenceRoot = exports.verifyNonExistence = exports.verifyExistence = exports.smtSpec = exports.tendermintSpec = exports.iavlSpec = void 0;\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nconst ops_1 = require(\"./ops\");\nconst specs_1 = require(\"./specs\");\nexports.iavlSpec = {\n  leafSpec: {\n    prefix: Uint8Array.from([0]),\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    minPrefixLength: 4,\n    maxPrefixLength: 12,\n    childSize: 33,\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  }\n};\nexports.tendermintSpec = {\n  leafSpec: {\n    prefix: Uint8Array.from([0]),\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    minPrefixLength: 1,\n    maxPrefixLength: 1,\n    childSize: 32,\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  }\n};\nexports.smtSpec = {\n  leafSpec: {\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    length: codecimpl_1.ics23.LengthOp.NO_PREFIX,\n    prefix: Uint8Array.from([0])\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    childSize: 32,\n    minPrefixLength: 1,\n    maxPrefixLength: 1,\n    emptyChild: new Uint8Array(32),\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  },\n  maxDepth: 256\n};\n// verifyExistence will throw an error if the proof doesn't link key, value -> root\n// or if it doesn't fulfill the spec\nfunction verifyExistence(proof, spec, root, key, value) {\n  ensureSpec(proof, spec);\n  const calc = calculateExistenceRoot(proof);\n  (0, specs_1.ensureBytesEqual)(calc, root);\n  (0, specs_1.ensureBytesEqual)(key, proof.key);\n  (0, specs_1.ensureBytesEqual)(value, proof.value);\n}\nexports.verifyExistence = verifyExistence;\n// Verify does all checks to ensure the proof has valid non-existence proofs,\n// and they ensure the given key is not in the CommitmentState,\n// throwing an error if there is an issue\nfunction verifyNonExistence(proof, spec, root, key) {\n  let leftKey;\n  let rightKey;\n  if (proof.left) {\n    verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);\n    leftKey = proof.left.key;\n  }\n  if (proof.right) {\n    verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);\n    rightKey = proof.right.key;\n  }\n  if (!leftKey && !rightKey) {\n    throw new Error(\"neither left nor right proof defined\");\n  }\n  if (leftKey) {\n    (0, specs_1.ensureBytesBefore)(leftKey, key);\n  }\n  if (rightKey) {\n    (0, specs_1.ensureBytesBefore)(key, rightKey);\n  }\n  if (!spec.innerSpec) {\n    throw new Error(\"no inner spec\");\n  }\n  if (!leftKey) {\n    ensureLeftMost(spec.innerSpec, proof.right.path);\n  } else if (!rightKey) {\n    ensureRightMost(spec.innerSpec, proof.left.path);\n  } else {\n    ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);\n  }\n  return;\n}\nexports.verifyNonExistence = verifyNonExistence;\n// Calculate determines the root hash that matches the given proof.\n// You must validate the result is what you have in a header.\n// Returns error if the calculations cannot be performed.\nfunction calculateExistenceRoot(proof) {\n  if (!proof.key || !proof.value) {\n    throw new Error(\"Existence proof needs key and value set\");\n  }\n  if (!proof.leaf) {\n    throw new Error(\"Existence proof must start with a leaf operation\");\n  }\n  const path = proof.path || [];\n  let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);\n  for (const inner of path) {\n    res = (0, ops_1.applyInner)(inner, res);\n  }\n  return res;\n}\nexports.calculateExistenceRoot = calculateExistenceRoot;\n// ensureSpec throws an Error if proof doesn't fulfill spec\nfunction ensureSpec(proof, spec) {\n  if (!proof.leaf) {\n    throw new Error(\"Existence proof must start with a leaf operation\");\n  }\n  if (!spec.leafSpec) {\n    throw new Error(\"Spec must include leafSpec\");\n  }\n  if (!spec.innerSpec) {\n    throw new Error(\"Spec must include innerSpec\");\n  }\n  (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);\n  const path = proof.path || [];\n  if (spec.minDepth && path.length < spec.minDepth) {\n    throw new Error(`Too few inner nodes ${path.length}`);\n  }\n  if (spec.maxDepth && path.length > spec.maxDepth) {\n    throw new Error(`Too many inner nodes ${path.length}`);\n  }\n  for (const inner of path) {\n    (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);\n  }\n}\nexports.ensureSpec = ensureSpec;\nfunction ensureLeftMost(spec, path) {\n  const {\n    minPrefix,\n    maxPrefix,\n    suffix\n  } = getPadding(spec, 0);\n  // ensure every step has a prefix and suffix defined to be leftmost\n  for (const step of path) {\n    if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n      throw new Error(\"Step not leftmost\");\n    }\n  }\n}\nfunction ensureRightMost(spec, path) {\n  const len = spec.childOrder.length - 1;\n  const {\n    minPrefix,\n    maxPrefix,\n    suffix\n  } = getPadding(spec, len);\n  // ensure every step has a prefix and suffix defined to be leftmost\n  for (const step of path) {\n    if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n      throw new Error(\"Step not leftmost\");\n    }\n  }\n}\nfunction ensureLeftNeighbor(spec, left, right) {\n  const mutleft = [...left];\n  const mutright = [...right];\n  let topleft = mutleft.pop();\n  let topright = mutright.pop();\n  while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) && (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {\n    topleft = mutleft.pop();\n    topright = mutright.pop();\n  }\n  // now topleft and topright are the first divergent nodes\n  // make sure they are left and right of each other\n  if (!isLeftStep(spec, topleft, topright)) {\n    throw new Error(`Not left neightbor at first divergent step`);\n  }\n  // make sure the paths are left and right most possibilities respectively\n  ensureRightMost(spec, mutleft);\n  ensureLeftMost(spec, mutright);\n}\nexports.ensureLeftNeighbor = ensureLeftNeighbor;\n// isLeftStep assumes left and right have common parents\n// checks if left is exactly one slot to the left of right\nfunction isLeftStep(spec, left, right) {\n  const leftidx = orderFromPadding(spec, left);\n  const rightidx = orderFromPadding(spec, right);\n  return rightidx === leftidx + 1;\n}\nfunction orderFromPadding(spec, inner) {\n  for (let branch = 0; branch < spec.childOrder.length; branch++) {\n    const {\n      minPrefix,\n      maxPrefix,\n      suffix\n    } = getPadding(spec, branch);\n    if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {\n      return branch;\n    }\n  }\n  throw new Error(`Cannot find any valid spacing for this node`);\n}\nfunction hasPadding(op, minPrefix, maxPrefix, suffix) {\n  if ((op.prefix || []).length < minPrefix) {\n    return false;\n  }\n  if ((op.prefix || []).length > maxPrefix) {\n    return false;\n  }\n  return (op.suffix || []).length === suffix;\n}\nfunction getPadding(spec, branch) {\n  const idx = getPosition(spec.childOrder, branch);\n  // count how many children are in the prefix\n  const prefix = idx * spec.childSize;\n  const minPrefix = prefix + spec.minPrefixLength;\n  const maxPrefix = prefix + spec.maxPrefixLength;\n  // count how many children are in the suffix\n  const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;\n  return {\n    minPrefix,\n    maxPrefix,\n    suffix\n  };\n}\nfunction getPosition(order, branch) {\n  if (branch < 0 || branch >= order.length) {\n    throw new Error(`Invalid branch: ${branch}`);\n  }\n  return order.findIndex(val => val === branch);\n}","map":{"version":3,"sources":["../src/proofs.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ensureLeftNeighbor = exports.ensureSpec = exports.calculateExistenceRoot = exports.verifyNonExistence = exports.verifyExistence = exports.smtSpec = exports.tendermintSpec = exports.iavlSpec = void 0;\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nconst ops_1 = require(\"./ops\");\nconst specs_1 = require(\"./specs\");\nexports.iavlSpec = {\n    leafSpec: {\n        prefix: Uint8Array.from([0]),\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n        prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n        length: codecimpl_1.ics23.LengthOp.VAR_PROTO,\n    },\n    innerSpec: {\n        childOrder: [0, 1],\n        minPrefixLength: 4,\n        maxPrefixLength: 12,\n        childSize: 33,\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n    },\n};\nexports.tendermintSpec = {\n    leafSpec: {\n        prefix: Uint8Array.from([0]),\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n        prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n        length: codecimpl_1.ics23.LengthOp.VAR_PROTO,\n    },\n    innerSpec: {\n        childOrder: [0, 1],\n        minPrefixLength: 1,\n        maxPrefixLength: 1,\n        childSize: 32,\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n    },\n};\nexports.smtSpec = {\n    leafSpec: {\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n        prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n        length: codecimpl_1.ics23.LengthOp.NO_PREFIX,\n        prefix: Uint8Array.from([0]),\n    },\n    innerSpec: {\n        childOrder: [0, 1],\n        childSize: 32,\n        minPrefixLength: 1,\n        maxPrefixLength: 1,\n        emptyChild: new Uint8Array(32),\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n    },\n    maxDepth: 256,\n};\n// verifyExistence will throw an error if the proof doesn't link key, value -> root\n// or if it doesn't fulfill the spec\nfunction verifyExistence(proof, spec, root, key, value) {\n    ensureSpec(proof, spec);\n    const calc = calculateExistenceRoot(proof);\n    (0, specs_1.ensureBytesEqual)(calc, root);\n    (0, specs_1.ensureBytesEqual)(key, proof.key);\n    (0, specs_1.ensureBytesEqual)(value, proof.value);\n}\nexports.verifyExistence = verifyExistence;\n// Verify does all checks to ensure the proof has valid non-existence proofs,\n// and they ensure the given key is not in the CommitmentState,\n// throwing an error if there is an issue\nfunction verifyNonExistence(proof, spec, root, key) {\n    let leftKey;\n    let rightKey;\n    if (proof.left) {\n        verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);\n        leftKey = proof.left.key;\n    }\n    if (proof.right) {\n        verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);\n        rightKey = proof.right.key;\n    }\n    if (!leftKey && !rightKey) {\n        throw new Error(\"neither left nor right proof defined\");\n    }\n    if (leftKey) {\n        (0, specs_1.ensureBytesBefore)(leftKey, key);\n    }\n    if (rightKey) {\n        (0, specs_1.ensureBytesBefore)(key, rightKey);\n    }\n    if (!spec.innerSpec) {\n        throw new Error(\"no inner spec\");\n    }\n    if (!leftKey) {\n        ensureLeftMost(spec.innerSpec, proof.right.path);\n    }\n    else if (!rightKey) {\n        ensureRightMost(spec.innerSpec, proof.left.path);\n    }\n    else {\n        ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);\n    }\n    return;\n}\nexports.verifyNonExistence = verifyNonExistence;\n// Calculate determines the root hash that matches the given proof.\n// You must validate the result is what you have in a header.\n// Returns error if the calculations cannot be performed.\nfunction calculateExistenceRoot(proof) {\n    if (!proof.key || !proof.value) {\n        throw new Error(\"Existence proof needs key and value set\");\n    }\n    if (!proof.leaf) {\n        throw new Error(\"Existence proof must start with a leaf operation\");\n    }\n    const path = proof.path || [];\n    let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);\n    for (const inner of path) {\n        res = (0, ops_1.applyInner)(inner, res);\n    }\n    return res;\n}\nexports.calculateExistenceRoot = calculateExistenceRoot;\n// ensureSpec throws an Error if proof doesn't fulfill spec\nfunction ensureSpec(proof, spec) {\n    if (!proof.leaf) {\n        throw new Error(\"Existence proof must start with a leaf operation\");\n    }\n    if (!spec.leafSpec) {\n        throw new Error(\"Spec must include leafSpec\");\n    }\n    if (!spec.innerSpec) {\n        throw new Error(\"Spec must include innerSpec\");\n    }\n    (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);\n    const path = proof.path || [];\n    if (spec.minDepth && path.length < spec.minDepth) {\n        throw new Error(`Too few inner nodes ${path.length}`);\n    }\n    if (spec.maxDepth && path.length > spec.maxDepth) {\n        throw new Error(`Too many inner nodes ${path.length}`);\n    }\n    for (const inner of path) {\n        (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);\n    }\n}\nexports.ensureSpec = ensureSpec;\nfunction ensureLeftMost(spec, path) {\n    const { minPrefix, maxPrefix, suffix } = getPadding(spec, 0);\n    // ensure every step has a prefix and suffix defined to be leftmost\n    for (const step of path) {\n        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n            throw new Error(\"Step not leftmost\");\n        }\n    }\n}\nfunction ensureRightMost(spec, path) {\n    const len = spec.childOrder.length - 1;\n    const { minPrefix, maxPrefix, suffix } = getPadding(spec, len);\n    // ensure every step has a prefix and suffix defined to be leftmost\n    for (const step of path) {\n        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n            throw new Error(\"Step not leftmost\");\n        }\n    }\n}\nfunction ensureLeftNeighbor(spec, left, right) {\n    const mutleft = [...left];\n    const mutright = [...right];\n    let topleft = mutleft.pop();\n    let topright = mutright.pop();\n    while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) &&\n        (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {\n        topleft = mutleft.pop();\n        topright = mutright.pop();\n    }\n    // now topleft and topright are the first divergent nodes\n    // make sure they are left and right of each other\n    if (!isLeftStep(spec, topleft, topright)) {\n        throw new Error(`Not left neightbor at first divergent step`);\n    }\n    // make sure the paths are left and right most possibilities respectively\n    ensureRightMost(spec, mutleft);\n    ensureLeftMost(spec, mutright);\n}\nexports.ensureLeftNeighbor = ensureLeftNeighbor;\n// isLeftStep assumes left and right have common parents\n// checks if left is exactly one slot to the left of right\nfunction isLeftStep(spec, left, right) {\n    const leftidx = orderFromPadding(spec, left);\n    const rightidx = orderFromPadding(spec, right);\n    return rightidx === leftidx + 1;\n}\nfunction orderFromPadding(spec, inner) {\n    for (let branch = 0; branch < spec.childOrder.length; branch++) {\n        const { minPrefix, maxPrefix, suffix } = getPadding(spec, branch);\n        if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {\n            return branch;\n        }\n    }\n    throw new Error(`Cannot find any valid spacing for this node`);\n}\nfunction hasPadding(op, minPrefix, maxPrefix, suffix) {\n    if ((op.prefix || []).length < minPrefix) {\n        return false;\n    }\n    if ((op.prefix || []).length > maxPrefix) {\n        return false;\n    }\n    return (op.suffix || []).length === suffix;\n}\nfunction getPadding(spec, branch) {\n    const idx = getPosition(spec.childOrder, branch);\n    // count how many children are in the prefix\n    const prefix = idx * spec.childSize;\n    const minPrefix = prefix + spec.minPrefixLength;\n    const maxPrefix = prefix + spec.maxPrefixLength;\n    // count how many children are in the suffix\n    const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;\n    return { minPrefix, maxPrefix, suffix };\n}\nfunction getPosition(order, branch) {\n    if (branch < 0 || branch >= order.length) {\n        throw new Error(`Invalid branch: ${branch}`);\n    }\n    return order.findIndex((val) => val === branch);\n}\n//# sourceMappingURL=proofs.js.map"]},"metadata":{},"sourceType":"script"}