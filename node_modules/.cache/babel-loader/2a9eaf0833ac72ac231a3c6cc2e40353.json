{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _defineProperty = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _known;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSupportedInterfaces = exports.getSupportedInterfacesRaw = exports.resolveKnownInterface = void 0;\nvar TupleSlice_1 = require(\"../boc/TupleSlice\");\nvar known = (_known = {}, _defineProperty(_known, '123515602279859691144772641439386770278', 'org.ton.introspection.v0'), _defineProperty(_known, '256184278959413194623484780286929323492', 'com.tonwhales.nominators:v0'), _defineProperty(_known, '242422353946785872806511191513850808027', 'org.ton.jetton.master.v1'), _defineProperty(_known, '311736387032003861293477945447179662681', 'org.ton.jetton.wallet.v1'), _known);\n/**\n * Resolves known interface\n * @param src source id\n * @returns known interface\n */\nfunction resolveKnownInterface(src) {\n  var kn = known[src];\n  if (kn) {\n    return kn;\n  } else {\n    return null;\n  }\n}\nexports.resolveKnownInterface = resolveKnownInterface;\n/**\n * Fetching supported interfaces\n * @param src address\n * @param client client\n * @returns array of supported interfaces\n */\nfunction getSupportedInterfacesRaw(_x, _x2) {\n  return _getSupportedInterfacesRaw.apply(this, arguments);\n}\nfunction _getSupportedInterfacesRaw() {\n  _getSupportedInterfacesRaw = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(src, client) {\n    var res, slice, firstNumber, interfaces;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return client.callGetMethodWithError(src, 'supported_interfaces');\n          case 2:\n            res = _context.sent;\n            if (!(res.exit_code !== 0 && res.exit_code !== 1)) {\n              _context.next = 5;\n              break;\n            }\n            return _context.abrupt(\"return\", []);\n          case 5:\n            _context.prev = 5;\n            slice = new TupleSlice_1.TupleSlice(res.stack); // First interface have to be introspection\n            firstNumber = slice.readBigNumber().toString();\n            if (!(firstNumber !== '123515602279859691144772641439386770278')) {\n              _context.next = 10;\n              break;\n            }\n            return _context.abrupt(\"return\", []);\n          case 10:\n            // Read all remaining\n            interfaces = [];\n            while (slice.remaining > 0) {\n              interfaces.push(slice.readBigNumber().toString());\n            }\n            return _context.abrupt(\"return\", interfaces);\n          case 15:\n            _context.prev = 15;\n            _context.t0 = _context[\"catch\"](5);\n            // In case of error: exit\n            console.warn(_context.t0);\n            return _context.abrupt(\"return\", []);\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[5, 15]]);\n  }));\n  return _getSupportedInterfacesRaw.apply(this, arguments);\n}\nexports.getSupportedInterfacesRaw = getSupportedInterfacesRaw;\n/**\n * Fetching supported interfaces\n * @param src address\n * @param client client\n * @returns array of supported interfaces\n */\nfunction getSupportedInterfaces(_x3, _x4) {\n  return _getSupportedInterfaces.apply(this, arguments);\n}\nfunction _getSupportedInterfaces() {\n  _getSupportedInterfaces = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(src, client) {\n    var supprotedRaw;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return getSupportedInterfacesRaw(src, client);\n          case 2:\n            supprotedRaw = _context2.sent;\n            return _context2.abrupt(\"return\", supprotedRaw.map(function (v) {\n              var k = resolveKnownInterface(v);\n              if (k) {\n                return {\n                  type: 'known',\n                  name: k\n                };\n              } else {\n                return {\n                  type: 'unknown',\n                  value: v\n                };\n              }\n            }));\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getSupportedInterfaces.apply(this, arguments);\n}\nexports.getSupportedInterfaces = getSupportedInterfaces;","map":{"version":3,"names":["Object","defineProperty","exports","value","getSupportedInterfaces","getSupportedInterfacesRaw","resolveKnownInterface","TupleSlice_1","require","known","src","kn","client","callGetMethodWithError","res","exit_code","slice","TupleSlice","stack","firstNumber","readBigNumber","toString","interfaces","remaining","push","console","warn","supprotedRaw","map","v","k","type","name"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/introspection/getSupportedInterfaces.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSupportedInterfaces = exports.getSupportedInterfacesRaw = exports.resolveKnownInterface = void 0;\nconst TupleSlice_1 = require(\"../boc/TupleSlice\");\nconst known = {\n    ['123515602279859691144772641439386770278']: 'org.ton.introspection.v0',\n    ['256184278959413194623484780286929323492']: 'com.tonwhales.nominators:v0',\n    ['242422353946785872806511191513850808027']: 'org.ton.jetton.master.v1',\n    ['311736387032003861293477945447179662681']: 'org.ton.jetton.wallet.v1',\n};\n/**\n * Resolves known interface\n * @param src source id\n * @returns known interface\n */\nfunction resolveKnownInterface(src) {\n    let kn = known[src];\n    if (kn) {\n        return kn;\n    }\n    else {\n        return null;\n    }\n}\nexports.resolveKnownInterface = resolveKnownInterface;\n/**\n * Fetching supported interfaces\n * @param src address\n * @param client client\n * @returns array of supported interfaces\n */\nasync function getSupportedInterfacesRaw(src, client) {\n    // Query interfaces\n    let res = await client.callGetMethodWithError(src, 'supported_interfaces');\n    // If not successful: return empty\n    if (res.exit_code !== 0 && res.exit_code !== 1) {\n        return [];\n    }\n    try {\n        let slice = new TupleSlice_1.TupleSlice(res.stack);\n        // First interface have to be introspection\n        let firstNumber = slice.readBigNumber().toString();\n        if (firstNumber !== '123515602279859691144772641439386770278') {\n            return [];\n        }\n        // Read all remaining\n        let interfaces = [];\n        while (slice.remaining > 0) {\n            interfaces.push(slice.readBigNumber().toString());\n        }\n        return interfaces;\n    }\n    catch (e) {\n        // In case of error: exit\n        console.warn(e);\n        return [];\n    }\n}\nexports.getSupportedInterfacesRaw = getSupportedInterfacesRaw;\n/**\n * Fetching supported interfaces\n * @param src address\n * @param client client\n * @returns array of supported interfaces\n */\nasync function getSupportedInterfaces(src, client) {\n    let supprotedRaw = await getSupportedInterfacesRaw(src, client);\n    return supprotedRaw.map((v) => {\n        let k = resolveKnownInterface(v);\n        if (k) {\n            return { type: 'known', name: k };\n        }\n        else {\n            return { type: 'unknown', value: v };\n        }\n    });\n}\nexports.getSupportedInterfaces = getSupportedInterfaces;\n"],"mappings":"AAAA,YAAY;;AAAC;AAAA;AAAA;AAAA;AACbA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,sBAAsB,GAAGF,OAAO,CAACG,yBAAyB,GAAGH,OAAO,CAACI,qBAAqB,GAAG,KAAK,CAAC;AAC3G,IAAMC,YAAY,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AACjD,IAAMC,KAAK,yCACN,yCAAyC,EAAG,0BAA0B,2BACtE,yCAAyC,EAAG,6BAA6B,2BACzE,yCAAyC,EAAG,0BAA0B,2BACtE,yCAAyC,EAAG,0BAA0B,UAC1E;AACD;AACA;AACA;AACA;AACA;AACA,SAASH,qBAAqB,CAACI,GAAG,EAAE;EAChC,IAAIC,EAAE,GAAGF,KAAK,CAACC,GAAG,CAAC;EACnB,IAAIC,EAAE,EAAE;IACJ,OAAOA,EAAE;EACb,CAAC,MACI;IACD,OAAO,IAAI;EACf;AACJ;AACAT,OAAO,CAACI,qBAAqB,GAAGA,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AALA,SAMeD,yBAAyB;EAAA;AAAA;AAAA;EAAA,wFAAxC,iBAAyCK,GAAG,EAAEE,MAAM;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,OAEhCA,MAAM,CAACC,sBAAsB,CAACH,GAAG,EAAE,sBAAsB,CAAC;UAAA;YAAtEI,GAAG;YAAA,MAEHA,GAAG,CAACC,SAAS,KAAK,CAAC,IAAID,GAAG,CAACC,SAAS,KAAK,CAAC;cAAA;cAAA;YAAA;YAAA,iCACnC,EAAE;UAAA;YAAA;YAGLC,KAAK,GAAG,IAAIT,YAAY,CAACU,UAAU,CAACH,GAAG,CAACI,KAAK,CAAC,EAClD;YACIC,WAAW,GAAGH,KAAK,CAACI,aAAa,EAAE,CAACC,QAAQ,EAAE;YAAA,MAC9CF,WAAW,KAAK,yCAAyC;cAAA;cAAA;YAAA;YAAA,iCAClD,EAAE;UAAA;YAEb;YACIG,UAAU,GAAG,EAAE;YACnB,OAAON,KAAK,CAACO,SAAS,GAAG,CAAC,EAAE;cACxBD,UAAU,CAACE,IAAI,CAACR,KAAK,CAACI,aAAa,EAAE,CAACC,QAAQ,EAAE,CAAC;YACrD;YAAC,iCACMC,UAAU;UAAA;YAAA;YAAA;YAGjB;YACAG,OAAO,CAACC,IAAI,aAAG;YAAC,iCACT,EAAE;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAEhB;EAAA;AAAA;AACDxB,OAAO,CAACG,yBAAyB,GAAGA,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AALA,SAMeD,sBAAsB;EAAA;AAAA;AAAA;EAAA,qFAArC,kBAAsCM,GAAG,EAAEE,MAAM;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,OACpBP,yBAAyB,CAACK,GAAG,EAAEE,MAAM,CAAC;UAAA;YAA3De,YAAY;YAAA,kCACTA,YAAY,CAACC,GAAG,CAAC,UAACC,CAAC,EAAK;cAC3B,IAAIC,CAAC,GAAGxB,qBAAqB,CAACuB,CAAC,CAAC;cAChC,IAAIC,CAAC,EAAE;gBACH,OAAO;kBAAEC,IAAI,EAAE,OAAO;kBAAEC,IAAI,EAAEF;gBAAE,CAAC;cACrC,CAAC,MACI;gBACD,OAAO;kBAAEC,IAAI,EAAE,SAAS;kBAAE5B,KAAK,EAAE0B;gBAAE,CAAC;cACxC;YACJ,CAAC,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACL;EAAA;AAAA;AACD3B,OAAO,CAACE,sBAAsB,GAAGA,sBAAsB"},"metadata":{},"sourceType":"script"}