{"ast":null,"code":"import Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, DisconnectedDeviceDuringOperation, DisconnectedDevice, TransportError } from \"@ledgerhq/errors\";\nconst ledgerDevices = [{\n  vendorId: ledgerUSBVendorId\n}];\nconst isSupported = () => Promise.resolve(!!(global.navigator && global.navigator.hid));\nconst getHID = () => {\n  // $FlowFixMe\n  const {\n    hid\n  } = navigator;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\nasync function requestLedgerDevices() {\n  const device = await getHID().requestDevice({\n    filters: ledgerDevices\n  });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\nasync function getLedgerDevices() {\n  const devices = await getHID().getDevices();\n  return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n}\nasync function getFirstLedgerDevice() {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\n\nexport default class TransportWebHID extends Transport {\n  constructor(device) {\n    super();\n    this.device = void 0;\n    this.deviceModel = void 0;\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.inputs = [];\n    this.inputCallback = void 0;\n    this.read = () => {\n      if (this.inputs.length) {\n        return Promise.resolve(this.inputs.shift());\n      }\n      return new Promise(success => {\n        this.inputCallback = success;\n      });\n    };\n    this.onInputReport = e => {\n      const buffer = Buffer.from(e.data.buffer);\n      if (this.inputCallback) {\n        this.inputCallback(buffer);\n        this.inputCallback = null;\n      } else {\n        this.inputs.push(buffer);\n      }\n    };\n    this._disconnectEmitted = false;\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n    this.exchange = apdu => this.exchangeAtomicImpl(async () => {\n      const {\n        channel,\n        packetSize\n      } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize); // Write...\n\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      } // Read...\n\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n    this.device = device;\n    this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n\n  static async open(device) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n    const onDisconnect = e => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  /**\n   * Release the transport device\n   */\n  async close() {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n  setScrambleKey() {}\n}\nTransportWebHID.isSupported = isSupported;\nTransportWebHID.list = getLedgerDevices;\nTransportWebHID.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!device) {\n      observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n    } else if (!unsubscribed) {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    observer.error(new TransportOpenUserCancelled(error.message));\n  });\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n  return {\n    unsubscribe\n  };\n};","map":{"version":3,"sources":["../src/TransportWebHID.js"],"names":["Transport","hidFraming","identifyUSBProductId","ledgerUSBVendorId","log","TransportOpenUserCancelled","DisconnectedDeviceDuringOperation","DisconnectedDevice","TransportError","ledgerDevices","vendorId","isSupported","Promise","resolve","global","navigator","hid","getHID","requestLedgerDevices","device","requestDevice","filters","Array","isArray","getLedgerDevices","devices","getDevices","filter","d","getFirstLedgerDevice","existingDevices","length","TransportWebHID","deviceModel","channel","Math","floor","random","packetSize","constructor","productId","addEventListener","onInputReport","inputs","inputCallback","read","shift","success","e","buffer","Buffer","from","data","push","list","listen","observer","unsubscribed","then","error","next","type","descriptor","complete","message","unsubscribe","request","open","openConnected","transport","onDisconnect","removeEventListener","_emitDisconnect","_disconnectEmitted","emit","close","exchangeBusyPromise","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","i","sendReport","result","acc","getReducedResult","reduceResponse","catch","includes","setScrambleKey"],"mappings":"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","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n  TransportError,\n} from \"@ledgerhq/errors\";\n\nconst ledgerDevices = [{ vendorId: ledgerUSBVendorId }];\n\nconst isSupported = () =>\n  Promise.resolve(!!(global.navigator && global.navigator.hid));\n\nconst getHID = (): HID => {\n  // $FlowFixMe\n  const { hid } = navigator;\n  if (!hid)\n    throw new TransportError(\n      \"navigator.hid is not supported\",\n      \"HIDNotSupported\"\n    );\n  return hid;\n};\n\nasync function requestLedgerDevices(): Promise<HIDDevice[]> {\n  const device = await getHID().requestDevice({ filters: ledgerDevices });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices(): Promise<HIDDevice[]> {\n  const devices = await getHID().getDevices();\n  return devices.filter((d) => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice(): Promise<HIDDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\nexport default class TransportWebHID extends Transport<HIDDevice> {\n  device: HIDDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: HIDDevice) {\n    super();\n    this.device = device;\n    this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  inputs = [];\n  inputCallback: ?(Buffer) => void;\n\n  read = (): Promise<Buffer> => {\n    if (this.inputs.length) {\n      return Promise.resolve(this.inputs.shift());\n    }\n    return new Promise((success) => {\n      this.inputCallback = success;\n    });\n  };\n\n  onInputReport = (e: InputReportEvent) => {\n    const buffer = Buffer.from(e.data.buffer);\n    if (this.inputCallback) {\n      this.inputCallback(buffer);\n      this.inputCallback = null;\n    } else {\n      this.inputs.push(buffer);\n    }\n  };\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<HIDDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!device) {\n          observer.error(\n            new TransportOpenUserCancelled(\"Access denied to use Ledger device\")\n          );\n        } else if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static async open(device: HIDDevice) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n"]},"metadata":{},"sourceType":"module"}