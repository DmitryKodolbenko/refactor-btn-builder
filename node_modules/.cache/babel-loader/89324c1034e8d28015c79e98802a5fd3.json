{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _slicedToArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _toConsumableArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryClient = void 0;\n/* eslint-disable no-dupe-class-members, @typescript-eslint/ban-types, @typescript-eslint/naming-convention */\nvar ics23_1 = require(\"@confio/ics23\");\nvar encoding_1 = require(\"@cosmjs/encoding\");\nvar stream_1 = require(\"@cosmjs/stream\");\nvar utils_1 = require(\"@cosmjs/utils\");\nfunction checkAndParseOp(op, kind, key) {\n  if (op.type !== kind) {\n    throw new Error(\"Op expected to be \".concat(kind, \", got \\\"\").concat(op.type));\n  }\n  if (!(0, utils_1.arrayContentEquals)(key, op.key)) {\n    throw new Error(\"Proven key different than queried key.\\nQuery: \".concat((0, encoding_1.toHex)(key), \"\\nProven: \").concat((0, encoding_1.toHex)(op.key)));\n  }\n  return ics23_1.ics23.CommitmentProof.decode(op.data);\n}\nvar QueryClient = /*#__PURE__*/function () {\n  function QueryClient(tmClient) {\n    _classCallCheck(this, QueryClient);\n    this.tmClient = tmClient;\n  }\n  _createClass(QueryClient, [{\n    key: \"queryVerified\",\n    value: function () {\n      var _queryVerified = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(store, key, desiredHeight) {\n        var _yield$this$queryRawP, height, proof, value, subProof, storeProof, header;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.queryRawProof(store, key, desiredHeight);\n              case 2:\n                _yield$this$queryRawP = _context.sent;\n                height = _yield$this$queryRawP.height;\n                proof = _yield$this$queryRawP.proof;\n                value = _yield$this$queryRawP.value;\n                subProof = checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n                storeProof = checkAndParseOp(proof.ops[1], \"ics23:simple\", (0, encoding_1.toAscii)(store)); // this must always be existence, if the store is not a typo\n                (0, utils_1.assert)(storeProof.exist);\n                (0, utils_1.assert)(storeProof.exist.value);\n                // this may be exist or non-exist, depends on response\n                if (!value || value.length === 0) {\n                  // non-existence check\n                  (0, utils_1.assert)(subProof.nonexist);\n                  // the subproof must map the desired key to the \"value\" of the storeProof\n                  (0, ics23_1.verifyNonExistence)(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, key);\n                } else {\n                  // existence check\n                  (0, utils_1.assert)(subProof.exist);\n                  (0, utils_1.assert)(subProof.exist.value);\n                  // the subproof must map the desired key to the \"value\" of the storeProof\n                  (0, ics23_1.verifyExistence)(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, key, value);\n                }\n                // the store proof must map its declared value (root of subProof) to the appHash of the next block\n                _context.next = 13;\n                return this.getNextHeader(height);\n              case 13:\n                header = _context.sent;\n                (0, ics23_1.verifyExistence)(storeProof.exist, ics23_1.tendermintSpec, header.appHash, (0, encoding_1.toAscii)(store), storeProof.exist.value);\n                return _context.abrupt(\"return\", value);\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function queryVerified(_x, _x2, _x3) {\n        return _queryVerified.apply(this, arguments);\n      }\n      return queryVerified;\n    }()\n  }, {\n    key: \"queryRawProof\",\n    value: function () {\n      var _queryRawProof = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(store, queryKey, desiredHeight) {\n        var _a, _yield$this$tmClient$, key, value, height, proof, code, log;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.tmClient.abciQuery({\n                  // we need the StoreKey for the module, not the module name\n                  // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12\n                  path: \"/store/\".concat(store, \"/key\"),\n                  data: queryKey,\n                  prove: true,\n                  height: desiredHeight\n                });\n              case 2:\n                _yield$this$tmClient$ = _context2.sent;\n                key = _yield$this$tmClient$.key;\n                value = _yield$this$tmClient$.value;\n                height = _yield$this$tmClient$.height;\n                proof = _yield$this$tmClient$.proof;\n                code = _yield$this$tmClient$.code;\n                log = _yield$this$tmClient$.log;\n                if (!code) {\n                  _context2.next = 11;\n                  break;\n                }\n                throw new Error(\"Query failed with (\".concat(code, \"): \").concat(log));\n              case 11:\n                if ((0, utils_1.arrayContentEquals)(queryKey, key)) {\n                  _context2.next = 13;\n                  break;\n                }\n                throw new Error(\"Response key \".concat((0, encoding_1.toHex)(key), \" doesn't match query key \").concat((0, encoding_1.toHex)(queryKey)));\n              case 13:\n                if (height) {\n                  _context2.next = 15;\n                  break;\n                }\n                throw new Error(\"No query height returned\");\n              case 15:\n                if (!(!proof || proof.ops.length !== 2)) {\n                  _context2.next = 17;\n                  break;\n                }\n                throw new Error(\"Expected 2 proof ops, got \".concat((_a = proof === null || proof === void 0 ? void 0 : proof.ops.length) !== null && _a !== void 0 ? _a : 0, \". Are you using stargate?\"));\n              case 17:\n                // we don't need the results, but we can ensure the data is the proper format\n                checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n                checkAndParseOp(proof.ops[1], \"ics23:simple\", (0, encoding_1.toAscii)(store));\n                return _context2.abrupt(\"return\", {\n                  key: key,\n                  value: value,\n                  height: height,\n                  // need to clone this: readonly input / writeable output\n                  proof: {\n                    ops: _toConsumableArray(proof.ops)\n                  }\n                });\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function queryRawProof(_x4, _x5, _x6) {\n        return _queryRawProof.apply(this, arguments);\n      }\n      return queryRawProof;\n    }()\n  }, {\n    key: \"queryUnverified\",\n    value: function () {\n      var _queryUnverified = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(path, request) {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.tmClient.abciQuery({\n                  path: path,\n                  data: request,\n                  prove: false\n                });\n              case 2:\n                response = _context3.sent;\n                if (!response.code) {\n                  _context3.next = 5;\n                  break;\n                }\n                throw new Error(\"Query failed with (\".concat(response.code, \"): \").concat(response.log));\n              case 5:\n                return _context3.abrupt(\"return\", response.value);\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function queryUnverified(_x7, _x8) {\n        return _queryUnverified.apply(this, arguments);\n      }\n      return queryUnverified;\n    }() // this must return the header for height+1\n    // throws an error if height is 0 or undefined\n  }, {\n    key: \"getNextHeader\",\n    value: function () {\n      var _getNextHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(height) {\n        var searchHeight, nextHeader, headersSubscription, firstHeader, correctHeader;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                (0, utils_1.assertDefined)(height);\n                if (!(height === 0)) {\n                  _context4.next = 3;\n                  break;\n                }\n                throw new Error(\"Query returned height 0, cannot prove it\");\n              case 3:\n                searchHeight = height + 1;\n                try {\n                  headersSubscription = this.tmClient.subscribeNewBlockHeader();\n                } catch (_a) {\n                  // Ignore exception caused by non-WebSocket Tendermint clients\n                }\n                if (!headersSubscription) {\n                  _context4.next = 10;\n                  break;\n                }\n                _context4.next = 8;\n                return (0, stream_1.firstEvent)(headersSubscription);\n              case 8:\n                firstHeader = _context4.sent;\n                // The first header we get might not be n+1 but n+2 or even higher. In such cases we fall back on a query.\n                if (firstHeader.height === searchHeight) {\n                  nextHeader = firstHeader;\n                }\n              case 10:\n                if (nextHeader) {\n                  _context4.next = 22;\n                  break;\n                }\n                _context4.next = 13;\n                return this.tmClient.blockchain(height, searchHeight);\n              case 13:\n                correctHeader = _context4.sent.blockMetas.map(function (meta) {\n                  return meta.header;\n                }).find(function (h) {\n                  return h.height === searchHeight;\n                });\n                if (!correctHeader) {\n                  _context4.next = 18;\n                  break;\n                }\n                nextHeader = correctHeader;\n                _context4.next = 20;\n                break;\n              case 18:\n                _context4.next = 20;\n                return (0, utils_1.sleep)(1000);\n              case 20:\n                _context4.next = 10;\n                break;\n              case 22:\n                (0, utils_1.assert)(nextHeader.height === searchHeight, \"Got wrong header. This is a bug in the logic above.\");\n                return _context4.abrupt(\"return\", nextHeader);\n              case 24:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function getNextHeader(_x9) {\n        return _getNextHeader.apply(this, arguments);\n      }\n      return getNextHeader;\n    }()\n  }], [{\n    key: \"withExtensions\",\n    value: function withExtensions(tmClient) {\n      var client = new QueryClient(tmClient);\n      for (var _len = arguments.length, extensionSetups = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        extensionSetups[_key - 1] = arguments[_key];\n      }\n      var extensions = extensionSetups.map(function (setupExtension) {\n        return setupExtension(client);\n      });\n      var _iterator = _createForOfIteratorHelper(extensions),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var extension = _step.value;\n          (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), \"Extension must be a non-null object\");\n          for (var _i = 0, _Object$entries = Object.entries(extension); _i < _Object$entries.length; _i++) {\n            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n              moduleKey = _Object$entries$_i[0],\n              moduleValue = _Object$entries$_i[1];\n            (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), \"Module must be a non-null object. Found type \".concat(typeof moduleValue, \" for module \\\"\").concat(moduleKey, \"\\\".\"));\n            var current = client[moduleKey] || {};\n            client[moduleKey] = _objectSpread(_objectSpread({}, current), moduleValue);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return client;\n    }\n  }]);\n  return QueryClient;\n}();\nexports.QueryClient = QueryClient;","map":{"version":3,"sources":["../../src/queryclient/queryclient.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAMA,SAAS,eAAe,CAAC,EAAwB,EAAE,IAAY,EAAE,GAAe,EAAA;EAC9E,IAAI,EAAE,CAAC,IAAI,KAAK,IAAI,EAAE;IACpB,MAAM,IAAI,KAAK,6BAAsB,IAAI,qBAAU,EAAE,CAAC,IAAI,EAAG;EAC9D;EACD,IAAI,CAAC,CAAA,CAAA,EAAA,OAAA,CAAA,kBAAkB,EAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE;IACpC,MAAM,IAAI,KAAK,0DAAmD,CAAA,CAAA,EAAA,UAAA,CAAA,KAAK,EAAC,GAAG,CAAC,uBAAa,CAAA,CAAA,EAAA,UAAA,CAAA,KAAK,EAAC,EAAE,CAAC,GAAG,CAAC,EAAG;EAC1G;EACD,OAAO,OAAA,CAAA,KAAK,CAAC,eAAe,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC;AAC9C;AAAC,IASY,WAAW;EAidtB,qBAAmB,QAA4B,EAAA;IAAA;IAC7C,IAAI,CAAC,QAAQ,GAAG,QAAQ;EAC1B;EAAC;IAAA;IAAA;MAAA,gFAEM,iBAAoB,KAAa,EAAE,GAAe,EAAE,aAAsB;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACxC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,GAAG,EAAE,aAAa,CAAC;cAAA;gBAAA;gBAA5E,MAAM,yBAAN,MAAM;gBAAE,KAAK,yBAAL,KAAK;gBAAE,KAAK,yBAAL,KAAK;gBAEtB,QAAQ,GAAG,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,YAAY,EAAE,GAAG,CAAC;gBAC3D,UAAU,GAAG,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,cAAc,EAAE,CAAA,CAAA,EAAA,UAAA,CAAA,OAAO,EAAC,KAAK,CAAC,CAAC,EAEhF;gBACA,CAAA,CAAA,EAAA,OAAA,CAAA,MAAM,EAAC,UAAU,CAAC,KAAK,CAAC;gBACxB,CAAA,CAAA,EAAA,OAAA,CAAA,MAAM,EAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC;gBAE9B;gBACA,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;kBAChC;kBACA,CAAA,CAAA,EAAA,OAAA,CAAA,MAAM,EAAC,QAAQ,CAAC,QAAQ,CAAC;kBACzB;kBACA,CAAA,CAAA,EAAA,OAAA,CAAA,kBAAkB,EAAC,QAAQ,CAAC,QAAQ,EAAE,OAAA,CAAA,QAAQ,EAAE,UAAU,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC;iBAC7E,MAAM;kBACL;kBACA,CAAA,CAAA,EAAA,OAAA,CAAA,MAAM,EAAC,QAAQ,CAAC,KAAK,CAAC;kBACtB,CAAA,CAAA,EAAA,OAAA,CAAA,MAAM,EAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC;kBAC5B;kBACA,CAAA,CAAA,EAAA,OAAA,CAAA,eAAe,EAAC,QAAQ,CAAC,KAAK,EAAE,OAAA,CAAA,QAAQ,EAAE,UAAU,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,CAAC;gBAC9E;gBAED;gBAAA;gBAAA,OACqB,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC;cAAA;gBAAzC,MAAM;gBACZ,CAAA,CAAA,EAAA,OAAA,CAAA,eAAe,EAAC,UAAU,CAAC,KAAK,EAAE,OAAA,CAAA,cAAc,EAAE,MAAM,CAAC,OAAO,EAAE,CAAA,CAAA,EAAA,UAAA,CAAA,OAAO,EAAC,KAAK,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC;gBAAC,iCAEnG,KAAK;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACb;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,gFAEM,kBACL,KAAa,EACb,QAAoB,EACpB,aAAsB;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAEiC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;kBAC7E;kBACA;kBACA,IAAI,mBAAY,KAAK,SAAM;kBAC3B,IAAI,EAAE,QAAQ;kBACd,KAAK,EAAE,IAAI;kBACX,MAAM,EAAE;iBACT,CAAC;cAAA;gBAAA;gBAPM,GAAG,yBAAH,GAAG;gBAAE,KAAK,yBAAL,KAAK;gBAAE,MAAM,yBAAN,MAAM;gBAAE,KAAK,yBAAL,KAAK;gBAAE,IAAI,yBAAJ,IAAI;gBAAE,GAAG,yBAAH,GAAG;gBAAA,KASxC,IAAI;kBAAA;kBAAA;gBAAA;gBAAA,MACA,IAAI,KAAK,8BAAuB,IAAI,gBAAM,GAAG,EAAG;cAAA;gBAAA,IAGnD,CAAA,CAAA,EAAA,OAAA,CAAA,kBAAkB,EAAC,QAAQ,EAAE,GAAG,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,MAC9B,IAAI,KAAK,wBAAiB,CAAA,CAAA,EAAA,UAAA,CAAA,KAAK,EAAC,GAAG,CAAC,sCAA4B,CAAA,CAAA,EAAA,UAAA,CAAA,KAAK,EAAC,QAAQ,CAAC,EAAG;cAAA;gBAAA,IAGrF,MAAM;kBAAA;kBAAA;gBAAA;gBAAA,MACH,IAAI,KAAK,CAAC,0BAA0B,CAAC;cAAA;gBAAA,MAEzC,CAAC,KAAK,IAAI,KAAK,CAAC,GAAG,CAAC,MAAM,KAAK,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,MAC5B,IAAI,KAAK,qCAA8B,CAAA,EAAA,GAAA,KAAK,KAAA,IAAA,IAAL,KAAK,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAL,KAAK,CAAE,GAAG,CAAC,MAAM,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,CAAC,+BAA4B;cAAA;gBAGjG;gBACA,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,YAAY,EAAE,GAAG,CAAC;gBAChD,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,cAAc,EAAE,CAAA,CAAA,EAAA,UAAA,CAAA,OAAO,EAAC,KAAK,CAAC,CAAC;gBAAC,kCAEvD;kBACL,GAAG,EAAE,GAAG;kBACR,KAAK,EAAE,KAAK;kBACZ,MAAM,EAAE,MAAM;kBACd;kBACA,KAAK,EAAE;oBACL,GAAG,qBAAM,KAAK,CAAC,GAAG;kBACnB;iBACF;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACF;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,kFAEM,kBAAsB,IAAY,EAAE,OAAmB;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACrC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;kBAC7C,IAAI,EAAE,IAAI;kBACV,IAAI,EAAE,OAAO;kBACb,KAAK,EAAE;iBACR,CAAC;cAAA;gBAJI,QAAQ;gBAAA,KAMV,QAAQ,CAAC,IAAI;kBAAA;kBAAA;gBAAA;gBAAA,MACT,IAAI,KAAK,8BAAuB,QAAQ,CAAC,IAAI,gBAAM,QAAQ,CAAC,GAAG,EAAG;cAAA;gBAAA,kCAGnE,QAAQ,CAAC,KAAK;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACtB;MAAA;QAAA;MAAA;MAAA;IAAA,IAED;IACA;EAAA;IAAA;IAAA;MAAA,gFACQ,kBAAoB,MAAe;QAAA;QAAA;UAAA;YAAA;cAAA;gBACzC,CAAA,CAAA,EAAA,OAAA,CAAA,aAAa,EAAC,MAAM,CAAC;gBAAC,MAClB,MAAM,KAAK,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,MACR,IAAI,KAAK,CAAC,0CAA0C,CAAC;cAAA;gBAGvD,YAAY,GAAG,MAAM,GAAG,CAAC;gBAG/B,IAAI;kBACF,mBAAmB,GAAG,IAAI,CAAC,QAAQ,CAAC,uBAAuB,EAAE;iBAC9D,CAAC,OAAA,EAAA,EAAM;kBACN;gBAAA;gBACD,KAEG,mBAAmB;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACK,CAAA,CAAA,EAAA,QAAA,CAAA,UAAU,EAAC,mBAAmB,CAAC;cAAA;gBAAnD,WAAW;gBACjB;gBACA,IAAI,WAAW,CAAC,MAAM,KAAK,YAAY,EAAE;kBACvC,UAAU,GAAG,WAAW;;cACzB;gBAAA,IAGK,UAAU;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OAEa,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,YAAY,CAAC;cAAA;gBAArE,aAAa,kBAA0D,UAAU,CACpF,GAAG,CAAC,UAAC,IAAI;kBAAA,OAAK,IAAI,CAAC,MAAM;gBAAA,GACzB,IAAI,CAAC,UAAC,CAAC;kBAAA,OAAK,CAAC,CAAC,MAAM,KAAK,YAAY;gBAAA;gBAAA,KACpC,aAAa;kBAAA;kBAAA;gBAAA;gBACf,UAAU,GAAG,aAAa;gBAAC;gBAAA;cAAA;gBAAA;gBAAA,OAErB,CAAA,CAAA,EAAA,OAAA,CAAA,KAAK,EAAC,IAAI,CAAC;cAAA;gBAAA;gBAAA;cAAA;gBAIrB,CAAA,CAAA,EAAA,OAAA,CAAA,MAAM,EAAC,UAAU,CAAC,MAAM,KAAK,YAAY,EAAE,qDAAqD,CAAC;gBAAC,kCAC3F,UAAU;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAClB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OA7JM,wBACL,QAA4B,EAC0B;MAEtD,IAAM,MAAM,GAAG,IAAI,WAAW,CAAC,QAAQ,CAAC;MAAC,kCAFtC,eAAmD;QAAnD,eAAmD;MAAA;MAGtD,IAAM,UAAU,GAAG,eAAe,CAAC,GAAG,CAAC,UAAC,cAAc;QAAA,OAAK,cAAc,CAAC,MAAM,CAAC;MAAA,EAAC;MAAC,2CAC3D,UAAU;QAAA;MAAA;QAAlC,oDAAoC;UAAA,IAAzB,SAAS;UAClB,CAAA,CAAA,EAAA,OAAA,CAAA,MAAM,EAAC,CAAA,CAAA,EAAA,OAAA,CAAA,eAAe,EAAC,SAAS,CAAC,wCAAwC;UACzE,mCAAuC,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,qCAAE;YAA7D;cAAO,SAAS;cAAE,WAAW;YAChC,CAAA,CAAA,EAAA,OAAA,CAAA,MAAM,EACJ,CAAA,CAAA,EAAA,OAAA,CAAA,eAAe,EAAC,WAAW,CAAC,yDACoB,OAAO,WAAW,2BAAgB,SAAS,SAC5F;YACD,IAAM,OAAO,GAAI,MAAc,CAAC,SAAS,CAAC,IAAI,CAAA,CAAE;YAC/C,MAAc,CAAC,SAAS,CAAC,mCACrB,OAAO,GACP,WAAW,CACf;UACF;;MACF;QAAA;MAAA;QAAA;MAAA;MACD,OAAO,MAAM;IACf;EAAC;EAAA;AAAA;AA7cH,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueryClient = void 0;\n/* eslint-disable no-dupe-class-members, @typescript-eslint/ban-types, @typescript-eslint/naming-convention */\nconst ics23_1 = require(\"@confio/ics23\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst stream_1 = require(\"@cosmjs/stream\");\nconst utils_1 = require(\"@cosmjs/utils\");\nfunction checkAndParseOp(op, kind, key) {\n    if (op.type !== kind) {\n        throw new Error(`Op expected to be ${kind}, got \"${op.type}`);\n    }\n    if (!(0, utils_1.arrayContentEquals)(key, op.key)) {\n        throw new Error(`Proven key different than queried key.\\nQuery: ${(0, encoding_1.toHex)(key)}\\nProven: ${(0, encoding_1.toHex)(op.key)}`);\n    }\n    return ics23_1.ics23.CommitmentProof.decode(op.data);\n}\nclass QueryClient {\n    constructor(tmClient) {\n        this.tmClient = tmClient;\n    }\n    static withExtensions(tmClient, ...extensionSetups) {\n        const client = new QueryClient(tmClient);\n        const extensions = extensionSetups.map((setupExtension) => setupExtension(client));\n        for (const extension of extensions) {\n            (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);\n            for (const [moduleKey, moduleValue] of Object.entries(extension)) {\n                (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module \"${moduleKey}\".`);\n                const current = client[moduleKey] || {};\n                client[moduleKey] = {\n                    ...current,\n                    ...moduleValue,\n                };\n            }\n        }\n        return client;\n    }\n    async queryVerified(store, key, desiredHeight) {\n        const { height, proof, value } = await this.queryRawProof(store, key, desiredHeight);\n        const subProof = checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n        const storeProof = checkAndParseOp(proof.ops[1], \"ics23:simple\", (0, encoding_1.toAscii)(store));\n        // this must always be existence, if the store is not a typo\n        (0, utils_1.assert)(storeProof.exist);\n        (0, utils_1.assert)(storeProof.exist.value);\n        // this may be exist or non-exist, depends on response\n        if (!value || value.length === 0) {\n            // non-existence check\n            (0, utils_1.assert)(subProof.nonexist);\n            // the subproof must map the desired key to the \"value\" of the storeProof\n            (0, ics23_1.verifyNonExistence)(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, key);\n        }\n        else {\n            // existence check\n            (0, utils_1.assert)(subProof.exist);\n            (0, utils_1.assert)(subProof.exist.value);\n            // the subproof must map the desired key to the \"value\" of the storeProof\n            (0, ics23_1.verifyExistence)(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, key, value);\n        }\n        // the store proof must map its declared value (root of subProof) to the appHash of the next block\n        const header = await this.getNextHeader(height);\n        (0, ics23_1.verifyExistence)(storeProof.exist, ics23_1.tendermintSpec, header.appHash, (0, encoding_1.toAscii)(store), storeProof.exist.value);\n        return value;\n    }\n    async queryRawProof(store, queryKey, desiredHeight) {\n        var _a;\n        const { key, value, height, proof, code, log } = await this.tmClient.abciQuery({\n            // we need the StoreKey for the module, not the module name\n            // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12\n            path: `/store/${store}/key`,\n            data: queryKey,\n            prove: true,\n            height: desiredHeight,\n        });\n        if (code) {\n            throw new Error(`Query failed with (${code}): ${log}`);\n        }\n        if (!(0, utils_1.arrayContentEquals)(queryKey, key)) {\n            throw new Error(`Response key ${(0, encoding_1.toHex)(key)} doesn't match query key ${(0, encoding_1.toHex)(queryKey)}`);\n        }\n        if (!height) {\n            throw new Error(\"No query height returned\");\n        }\n        if (!proof || proof.ops.length !== 2) {\n            throw new Error(`Expected 2 proof ops, got ${(_a = proof === null || proof === void 0 ? void 0 : proof.ops.length) !== null && _a !== void 0 ? _a : 0}. Are you using stargate?`);\n        }\n        // we don't need the results, but we can ensure the data is the proper format\n        checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n        checkAndParseOp(proof.ops[1], \"ics23:simple\", (0, encoding_1.toAscii)(store));\n        return {\n            key: key,\n            value: value,\n            height: height,\n            // need to clone this: readonly input / writeable output\n            proof: {\n                ops: [...proof.ops],\n            },\n        };\n    }\n    async queryUnverified(path, request) {\n        const response = await this.tmClient.abciQuery({\n            path: path,\n            data: request,\n            prove: false,\n        });\n        if (response.code) {\n            throw new Error(`Query failed with (${response.code}): ${response.log}`);\n        }\n        return response.value;\n    }\n    // this must return the header for height+1\n    // throws an error if height is 0 or undefined\n    async getNextHeader(height) {\n        (0, utils_1.assertDefined)(height);\n        if (height === 0) {\n            throw new Error(\"Query returned height 0, cannot prove it\");\n        }\n        const searchHeight = height + 1;\n        let nextHeader;\n        let headersSubscription;\n        try {\n            headersSubscription = this.tmClient.subscribeNewBlockHeader();\n        }\n        catch (_a) {\n            // Ignore exception caused by non-WebSocket Tendermint clients\n        }\n        if (headersSubscription) {\n            const firstHeader = await (0, stream_1.firstEvent)(headersSubscription);\n            // The first header we get might not be n+1 but n+2 or even higher. In such cases we fall back on a query.\n            if (firstHeader.height === searchHeight) {\n                nextHeader = firstHeader;\n            }\n        }\n        while (!nextHeader) {\n            // start from current height to avoid backend error for minHeight in the future\n            const correctHeader = (await this.tmClient.blockchain(height, searchHeight)).blockMetas\n                .map((meta) => meta.header)\n                .find((h) => h.height === searchHeight);\n            if (correctHeader) {\n                nextHeader = correctHeader;\n            }\n            else {\n                await (0, utils_1.sleep)(1000);\n            }\n        }\n        (0, utils_1.assert)(nextHeader.height === searchHeight, \"Got wrong header. This is a bug in the logic above.\");\n        return nextHeader;\n    }\n}\nexports.QueryClient = QueryClient;\n//# sourceMappingURL=queryclient.js.map"]},"metadata":{},"sourceType":"script"}