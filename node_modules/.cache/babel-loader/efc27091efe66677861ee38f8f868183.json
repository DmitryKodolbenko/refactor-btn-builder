{"ast":null,"code":"import _classCallCheck from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/* eslint-disable prefer-template */\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { DisconnectedDevice, TransportOpenUserCancelled } from \"@ledgerhq/errors\";\nimport { getBluetoothServiceUuids, getInfosForServiceUuid } from \"@ledgerhq/devices\";\nimport { sendAPDU } from \"@ledgerhq/devices/lib/ble/sendAPDU\";\nimport { receiveAPDU } from \"@ledgerhq/devices/lib/ble/receiveAPDU\";\nimport { log } from \"@ledgerhq/logs\";\nimport { Observable, defer, merge, from } from \"rxjs\";\nimport { share, ignoreElements, first, map, tap } from \"rxjs/operators\";\nimport { monitorCharacteristic } from \"./monitorCharacteristic\";\nvar requiresBluetooth = function requiresBluetooth() {\n  // $FlowFixMe\n  var _navigator = navigator,\n    bluetooth = _navigator.bluetooth;\n  if (typeof bluetooth === \"undefined\") {\n    throw new Error(\"web bluetooth not supported\");\n  }\n  return bluetooth;\n};\nvar availability = function availability() {\n  return Observable.create(function (observer) {\n    var bluetooth = requiresBluetooth();\n    var onAvailabilityChanged = function onAvailabilityChanged(e) {\n      observer.next(e.value);\n    };\n    bluetooth.addEventListener(\"availabilitychanged\", onAvailabilityChanged);\n    var unsubscribed = false;\n    bluetooth.getAvailability().then(function (available) {\n      if (!unsubscribed) {\n        observer.next(available);\n      }\n    });\n    return function () {\n      unsubscribed = true;\n      bluetooth.removeEventListener(\"availabilitychanged\", onAvailabilityChanged);\n    };\n  });\n};\nvar transportsCache = {};\nvar requestDeviceParam = function requestDeviceParam() {\n  return {\n    filters: getBluetoothServiceUuids().map(function (uuid) {\n      return {\n        services: [uuid]\n      };\n    })\n  };\n};\nvar retrieveService = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(device) {\n    var _yield$device$gatt$ge, _yield$device$gatt$ge2, service, infos;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (device.gatt) {\n              _context.next = 2;\n              break;\n            }\n            throw new Error(\"bluetooth gatt not found\");\n          case 2:\n            _context.next = 4;\n            return device.gatt.getPrimaryServices();\n          case 4:\n            _yield$device$gatt$ge = _context.sent;\n            _yield$device$gatt$ge2 = _slicedToArray(_yield$device$gatt$ge, 1);\n            service = _yield$device$gatt$ge2[0];\n            if (service) {\n              _context.next = 9;\n              break;\n            }\n            throw new Error(\"bluetooth service not found\");\n          case 9:\n            infos = getInfosForServiceUuid(service.uuid);\n            if (infos) {\n              _context.next = 12;\n              break;\n            }\n            throw new Error(\"bluetooth service infos not found\");\n          case 12:\n            return _context.abrupt(\"return\", [service, infos]);\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return function retrieveService(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nfunction _open2(_x2, _x3) {\n  return _open.apply(this, arguments);\n}\n/**\n * react-native bluetooth BLE implementation\n * @example\n * import BluetoothTransport from \"@ledgerhq/hw-transport-web-ble\";\n */\nfunction _open() {\n  _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(deviceOrId, needsReconnect) {\n    var device, bluetooth, _yield$retrieveServic, _yield$retrieveServic2, service, infos, deviceModel, writeUuid, notifyUuid, _yield$Promise$all, _yield$Promise$all2, writeC, notifyC, notifyObservable, notif, transport, onDisconnect, beforeMTUTime, afterMTUTime;\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            if (!(typeof deviceOrId === \"string\")) {\n              _context10.next = 10;\n              break;\n            }\n            if (!transportsCache[deviceOrId]) {\n              _context10.next = 4;\n              break;\n            }\n            log(\"ble-verbose\", \"Transport in cache, using that.\");\n            return _context10.abrupt(\"return\", transportsCache[deviceOrId]);\n          case 4:\n            bluetooth = requiresBluetooth(); // TODO instead we should \"query\" the device by its ID\n            _context10.next = 7;\n            return bluetooth.requestDevice(requestDeviceParam());\n          case 7:\n            device = _context10.sent;\n            _context10.next = 11;\n            break;\n          case 10:\n            device = deviceOrId;\n          case 11:\n            if (device.gatt.connected) {\n              _context10.next = 15;\n              break;\n            }\n            log(\"ble-verbose\", \"not connected. connecting...\");\n            _context10.next = 15;\n            return device.gatt.connect();\n          case 15:\n            _context10.next = 17;\n            return retrieveService(device);\n          case 17:\n            _yield$retrieveServic = _context10.sent;\n            _yield$retrieveServic2 = _slicedToArray(_yield$retrieveServic, 2);\n            service = _yield$retrieveServic2[0];\n            infos = _yield$retrieveServic2[1];\n            deviceModel = infos.deviceModel, writeUuid = infos.writeUuid, notifyUuid = infos.notifyUuid;\n            _context10.next = 24;\n            return Promise.all([service.getCharacteristic(writeUuid), service.getCharacteristic(notifyUuid)]);\n          case 24:\n            _yield$Promise$all = _context10.sent;\n            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n            writeC = _yield$Promise$all2[0];\n            notifyC = _yield$Promise$all2[1];\n            notifyObservable = monitorCharacteristic(notifyC).pipe(tap(function (value) {\n              log(\"ble-frame\", \"<= \" + value.toString(\"hex\"));\n            }), share());\n            notif = notifyObservable.subscribe();\n            transport = new BluetoothTransport(device, writeC, notifyObservable, deviceModel);\n            if (device.gatt.connected) {\n              _context10.next = 33;\n              break;\n            }\n            throw new DisconnectedDevice();\n          case 33:\n            // eslint-disable-next-line require-atomic-updates\n\n            transportsCache[transport.id] = transport;\n            onDisconnect = function onDisconnect(e) {\n              console.log(\"onDisconnect!\", e);\n              delete transportsCache[transport.id];\n              transport.notYetDisconnected = false;\n              notif.unsubscribe();\n              device.removeEventListener(\"gattserverdisconnected\", onDisconnect);\n              log(\"ble-verbose\", \"BleTransport(\".concat(transport.id, \") disconnected\"));\n              transport.emit(\"disconnect\", e);\n            };\n            device.addEventListener(\"gattserverdisconnected\", onDisconnect);\n            beforeMTUTime = Date.now();\n            _context10.prev = 37;\n            _context10.next = 40;\n            return transport.inferMTU();\n          case 40:\n            _context10.prev = 40;\n            afterMTUTime = Date.now(); // workaround for #279: we need to open() again if we come the first time here,\n            // to make sure we do a disconnect() after the first pairing time\n            // because of a firmware bug\n            if (afterMTUTime - beforeMTUTime < 1000) {\n              needsReconnect = false; // (optim) there is likely no new pairing done because mtu answer was fast.\n            }\n            if (!needsReconnect) {\n              _context10.next = 48;\n              break;\n            }\n            _context10.next = 46;\n            return device.gatt.disconnect();\n          case 46:\n            _context10.next = 48;\n            return new Promise(function (s) {\n              return setTimeout(s, 4000);\n            });\n          case 48:\n            return _context10.finish(40);\n          case 49:\n            if (!needsReconnect) {\n              _context10.next = 51;\n              break;\n            }\n            return _context10.abrupt(\"return\", _open2(device, false));\n          case 51:\n            return _context10.abrupt(\"return\", transport);\n          case 52:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10, null, [[37,, 40, 49]]);\n  }));\n  return _open.apply(this, arguments);\n}\nvar BluetoothTransport = /*#__PURE__*/function (_Transport) {\n  _inherits(BluetoothTransport, _Transport);\n  var _super = _createSuper(BluetoothTransport);\n  /**\n   * globally disconnect a bluetooth device by its id.\n   */\n\n  function BluetoothTransport(device, writeCharacteristic, notifyObservable, deviceModel) {\n    var _this;\n    _classCallCheck(this, BluetoothTransport);\n    _this = _super.call(this);\n    _this.id = void 0;\n    _this.device = void 0;\n    _this.mtuSize = 20;\n    _this.writeCharacteristic = void 0;\n    _this.notifyObservable = void 0;\n    _this.notYetDisconnected = true;\n    _this.deviceModel = void 0;\n    _this.exchange = function (apdu) {\n      return _this.exchangeAtomicImpl( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var msgIn, data, msgOut;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                msgIn = apdu.toString(\"hex\");\n                log(\"apdu\", \"=> \".concat(msgIn));\n                _context2.next = 5;\n                return merge(_this.notifyObservable.pipe(receiveAPDU), sendAPDU(_this.write, apdu, _this.mtuSize)).toPromise();\n              case 5:\n                data = _context2.sent;\n                msgOut = data.toString(\"hex\");\n                log(\"apdu\", \"<= \".concat(msgOut));\n                return _context2.abrupt(\"return\", data);\n              case 11:\n                _context2.prev = 11;\n                _context2.t0 = _context2[\"catch\"](0);\n                log(\"ble-error\", \"exchange got \" + String(_context2.t0));\n                if (_this.notYetDisconnected) {\n                  // in such case we will always disconnect because something is bad.\n                  _this.device.gatt.disconnect();\n                }\n                throw _context2.t0;\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[0, 11]]);\n      })));\n    };\n    _this.write = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(buffer) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                log(\"ble-frame\", \"=> \" + buffer.toString(\"hex\"));\n                _context3.next = 3;\n                return _this.writeCharacteristic.writeValue(buffer);\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      return function (_x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n    _this.id = device.id;\n    _this.device = device;\n    _this.writeCharacteristic = writeCharacteristic;\n    _this.notifyObservable = notifyObservable;\n    _this.deviceModel = deviceModel;\n    log(\"ble-verbose\", \"BleTransport(\".concat(String(_this.id), \") new instance\"));\n    return _this;\n  }\n  _createClass(BluetoothTransport, [{\n    key: \"inferMTU\",\n    value: function () {\n      var _inferMTU = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _this2 = this;\n        var mtu, mtuSize;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                mtu = 23;\n                _context5.next = 3;\n                return this.exchangeAtomicImpl( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          _context4.prev = 0;\n                          _context4.next = 3;\n                          return merge(_this2.notifyObservable.pipe(first(function (buffer) {\n                            return buffer.readUInt8(0) === 0x08;\n                          }), map(function (buffer) {\n                            return buffer.readUInt8(5);\n                          })), defer(function () {\n                            return from(_this2.write(Buffer.from([0x08, 0, 0, 0, 0])));\n                          }).pipe(ignoreElements())).toPromise();\n                        case 3:\n                          _context4.t0 = _context4.sent;\n                          mtu = _context4.t0 + 3;\n                          _context4.next = 12;\n                          break;\n                        case 7:\n                          _context4.prev = 7;\n                          _context4.t1 = _context4[\"catch\"](0);\n                          log(\"ble-error\", \"inferMTU got \" + String(_context4.t1));\n                          _this2.device.gatt.disconnect();\n                          throw _context4.t1;\n                        case 12:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4, null, [[0, 7]]);\n                })));\n              case 3:\n                if (mtu > 23) {\n                  mtuSize = mtu - 3;\n                  log(\"ble-verbose\", \"BleTransport(\".concat(String(this.id), \") mtu set to \").concat(String(mtuSize)));\n                  this.mtuSize = mtuSize;\n                }\n                return _context5.abrupt(\"return\", this.mtuSize);\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function inferMTU() {\n        return _inferMTU.apply(this, arguments);\n      }\n      return inferMTU;\n    }()\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey() {}\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!this.exchangeBusyPromise) {\n                  _context6.next = 3;\n                  break;\n                }\n                _context6.next = 3;\n                return this.exchangeBusyPromise;\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function close() {\n        return _close.apply(this, arguments);\n      }\n      return close;\n    }()\n  }], [{\n    key: \"listen\",\n    value:\n    /**\n     * observe event with { available: bool, type: string }\n     * (available is generic, type is specific)\n     * an event is emit once and then each time it changes\n     */\n\n    /**\n     * Scan for Ledger Bluetooth devices.\n     * On this web implementation, it only emits ONE device, the one that was selected in the UI (if any).\n     */\n    function listen(observer) {\n      log(\"ble-verbose\", \"listen...\");\n      var unsubscribed;\n      var bluetooth = requiresBluetooth();\n      bluetooth.requestDevice(requestDeviceParam()).then( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(device) {\n          return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  if (!unsubscribed) {\n                    observer.next({\n                      type: \"add\",\n                      descriptor: device\n                    });\n                    observer.complete();\n                  }\n                case 1:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7);\n        }));\n        return function (_x5) {\n          return _ref5.apply(this, arguments);\n        };\n      }(), function (error) {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      });\n      function unsubscribe() {\n        unsubscribed = true;\n      }\n      return {\n        unsubscribe: unsubscribe\n      };\n    }\n    /**\n     * open a bluetooth device.\n     */\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(deviceOrId) {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", _open2(deviceOrId, true));\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n      function open(_x6) {\n        return _open3.apply(this, arguments);\n      }\n      return open;\n    }()\n  }]);\n  return BluetoothTransport;\n}(Transport);\nexport { BluetoothTransport as default };\nBluetoothTransport.isSupported = function () {\n  return Promise.resolve().then(requiresBluetooth).then(function () {\n    return true;\n  }, function () {\n    return false;\n  });\n};\nBluetoothTransport.observeAvailability = function (observer) {\n  return availability.subscribe(observer);\n};\nBluetoothTransport.list = function () {\n  return Promise.resolve([]);\n};\nBluetoothTransport.disconnect = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(id) {\n    var transport;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            log(\"ble-verbose\", \"user disconnect(\".concat(id, \")\"));\n            transport = transportsCache[id];\n            if (transport) {\n              transport.device.gatt.disconnect();\n            }\n          case 3:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return function (_x7) {\n    return _ref6.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["../src/TransportWebBLE.js"],"names":["Transport","DisconnectedDevice","TransportOpenUserCancelled","getBluetoothServiceUuids","getInfosForServiceUuid","sendAPDU","receiveAPDU","log","Observable","defer","merge","from","share","ignoreElements","first","map","tap","monitorCharacteristic","requiresBluetooth","bluetooth","navigator","Error","availability","create","observer","onAvailabilityChanged","e","next","value","addEventListener","unsubscribed","getAvailability","then","available","removeEventListener","transportsCache","requestDeviceParam","filters","uuid","services","retrieveService","device","gatt","service","getPrimaryServices","infos","open","deviceOrId","needsReconnect","requestDevice","connected","connect","deviceModel","writeUuid","notifyUuid","writeC","notifyC","Promise","all","getCharacteristic","notifyObservable","pipe","toString","notif","subscribe","transport","BluetoothTransport","id","onDisconnect","console","notYetDisconnected","unsubscribe","emit","beforeMTUTime","Date","now","inferMTU","afterMTUTime","disconnect","s","setTimeout","isSupported","resolve","observeAvailability","list","type","descriptor","complete","error","message","mtuSize","writeCharacteristic","constructor","String","mtu","exchangeAtomicImpl","buffer","readUInt8","write","Buffer","toPromise","exchange","apdu","msgIn","data","msgOut","setScrambleKey","writeValue","exchangeBusyPromise"],"mappings":"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","sourcesContent":["// @flow\n/* eslint-disable prefer-template */\n\nimport Transport from \"@ledgerhq/hw-transport\";\nimport {\n  DisconnectedDevice,\n  TransportOpenUserCancelled,\n} from \"@ledgerhq/errors\";\nimport {\n  getBluetoothServiceUuids,\n  getInfosForServiceUuid,\n} from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { sendAPDU } from \"@ledgerhq/devices/lib/ble/sendAPDU\";\nimport { receiveAPDU } from \"@ledgerhq/devices/lib/ble/receiveAPDU\";\nimport { log } from \"@ledgerhq/logs\";\nimport { Observable, defer, merge, from } from \"rxjs\";\nimport { share, ignoreElements, first, map, tap } from \"rxjs/operators\";\nimport type { Device, Characteristic } from \"./types\";\nimport { monitorCharacteristic } from \"./monitorCharacteristic\";\n\nconst requiresBluetooth = () => {\n  // $FlowFixMe\n  const { bluetooth } = navigator;\n  if (typeof bluetooth === \"undefined\") {\n    throw new Error(\"web bluetooth not supported\");\n  }\n  return bluetooth;\n};\n\nconst availability = (): Observable<boolean> =>\n  Observable.create((observer) => {\n    const bluetooth = requiresBluetooth();\n    const onAvailabilityChanged = (e) => {\n      observer.next(e.value);\n    };\n    bluetooth.addEventListener(\"availabilitychanged\", onAvailabilityChanged);\n    let unsubscribed = false;\n    bluetooth.getAvailability().then((available) => {\n      if (!unsubscribed) {\n        observer.next(available);\n      }\n    });\n    return () => {\n      unsubscribed = true;\n      bluetooth.removeEventListener(\n        \"availabilitychanged\",\n        onAvailabilityChanged\n      );\n    };\n  });\n\nconst transportsCache = {};\n\nconst requestDeviceParam = () => ({\n  filters: getBluetoothServiceUuids().map((uuid) => ({\n    services: [uuid],\n  })),\n});\n\nconst retrieveService = async (device) => {\n  if (!device.gatt) throw new Error(\"bluetooth gatt not found\");\n  const [service] = await device.gatt.getPrimaryServices();\n  if (!service) throw new Error(\"bluetooth service not found\");\n  const infos = getInfosForServiceUuid(service.uuid);\n  if (!infos) throw new Error(\"bluetooth service infos not found\");\n  return [service, infos];\n};\n\nasync function open(deviceOrId: Device | string, needsReconnect: boolean) {\n  let device;\n  if (typeof deviceOrId === \"string\") {\n    if (transportsCache[deviceOrId]) {\n      log(\"ble-verbose\", \"Transport in cache, using that.\");\n      return transportsCache[deviceOrId];\n    }\n\n    const bluetooth = requiresBluetooth();\n\n    // TODO instead we should \"query\" the device by its ID\n    device = await bluetooth.requestDevice(requestDeviceParam());\n  } else {\n    device = deviceOrId;\n  }\n\n  if (!device.gatt.connected) {\n    log(\"ble-verbose\", \"not connected. connecting...\");\n    await device.gatt.connect();\n  }\n\n  const [service, infos] = await retrieveService(device);\n  const { deviceModel, writeUuid, notifyUuid } = infos;\n  const [writeC, notifyC] = await Promise.all([\n    service.getCharacteristic(writeUuid),\n    service.getCharacteristic(notifyUuid),\n  ]);\n\n  const notifyObservable = monitorCharacteristic(notifyC).pipe(\n    tap((value) => {\n      log(\"ble-frame\", \"<= \" + value.toString(\"hex\"));\n    }),\n    share()\n  );\n\n  const notif = notifyObservable.subscribe();\n\n  const transport = new BluetoothTransport(\n    device,\n    writeC,\n    notifyObservable,\n    deviceModel\n  );\n\n  if (!device.gatt.connected) {\n    throw new DisconnectedDevice();\n  }\n\n  // eslint-disable-next-line require-atomic-updates\n  transportsCache[transport.id] = transport;\n  const onDisconnect = (e) => {\n    console.log(\"onDisconnect!\", e);\n    delete transportsCache[transport.id];\n    transport.notYetDisconnected = false;\n    notif.unsubscribe();\n    device.removeEventListener(\"gattserverdisconnected\", onDisconnect);\n    log(\"ble-verbose\", `BleTransport(${transport.id}) disconnected`);\n    transport.emit(\"disconnect\", e);\n  };\n  device.addEventListener(\"gattserverdisconnected\", onDisconnect);\n\n  let beforeMTUTime = Date.now();\n  try {\n    await transport.inferMTU();\n  } finally {\n    let afterMTUTime = Date.now();\n\n    // workaround for #279: we need to open() again if we come the first time here,\n    // to make sure we do a disconnect() after the first pairing time\n    // because of a firmware bug\n\n    if (afterMTUTime - beforeMTUTime < 1000) {\n      needsReconnect = false; // (optim) there is likely no new pairing done because mtu answer was fast.\n    }\n\n    if (needsReconnect) {\n      await device.gatt.disconnect();\n      // necessary time for the bonding workaround\n      await new Promise((s) => setTimeout(s, 4000));\n    }\n  }\n\n  if (needsReconnect) {\n    return open(device, false);\n  }\n\n  return transport;\n}\n\n/**\n * react-native bluetooth BLE implementation\n * @example\n * import BluetoothTransport from \"@ledgerhq/hw-transport-web-ble\";\n */\nexport default class BluetoothTransport extends Transport<Device | string> {\n  static isSupported = (): Promise<boolean> =>\n    Promise.resolve()\n      .then(requiresBluetooth)\n      .then(\n        () => true,\n        () => false\n      );\n\n  /**\n   * observe event with { available: bool, type: string }\n   * (available is generic, type is specific)\n   * an event is emit once and then each time it changes\n   */\n  static observeAvailability = (observer: *) =>\n    availability.subscribe(observer);\n\n  static list = (): * => Promise.resolve([]);\n\n  /**\n   * Scan for Ledger Bluetooth devices.\n   * On this web implementation, it only emits ONE device, the one that was selected in the UI (if any).\n   */\n  static listen(observer: *) {\n    log(\"ble-verbose\", \"listen...\");\n    let unsubscribed;\n\n    const bluetooth = requiresBluetooth();\n\n    bluetooth.requestDevice(requestDeviceParam()).then(\n      async (device) => {\n        if (!unsubscribed) {\n          observer.next({\n            type: \"add\",\n            descriptor: device,\n          });\n          observer.complete();\n        }\n      },\n      (error) => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  }\n\n  /**\n   * open a bluetooth device.\n   */\n  static async open(deviceOrId: Device | string) {\n    return open(deviceOrId, true);\n  }\n\n  /**\n   * globally disconnect a bluetooth device by its id.\n   */\n  static disconnect = async (id: *) => {\n    log(\"ble-verbose\", `user disconnect(${id})`);\n    const transport = transportsCache[id];\n    if (transport) {\n      transport.device.gatt.disconnect();\n    }\n  };\n\n  id: string;\n\n  device: Device;\n\n  mtuSize: number = 20;\n\n  writeCharacteristic: Characteristic;\n\n  notifyObservable: Observable<Buffer>;\n\n  notYetDisconnected = true;\n\n  deviceModel: DeviceModel;\n\n  constructor(\n    device: Device,\n    writeCharacteristic: Characteristic,\n    notifyObservable: Observable<*>,\n    deviceModel: DeviceModel\n  ) {\n    super();\n    this.id = device.id;\n    this.device = device;\n    this.writeCharacteristic = writeCharacteristic;\n    this.notifyObservable = notifyObservable;\n    this.deviceModel = deviceModel;\n\n    log(\"ble-verbose\", `BleTransport(${String(this.id)}) new instance`);\n  }\n\n  async inferMTU() {\n    let mtu = 23;\n\n    await this.exchangeAtomicImpl(async () => {\n      try {\n        mtu =\n          (await merge(\n            this.notifyObservable.pipe(\n              first((buffer) => buffer.readUInt8(0) === 0x08),\n              map((buffer) => buffer.readUInt8(5))\n            ),\n            defer(() => from(this.write(Buffer.from([0x08, 0, 0, 0, 0])))).pipe(\n              ignoreElements()\n            )\n          ).toPromise()) + 3;\n      } catch (e) {\n        log(\"ble-error\", \"inferMTU got \" + String(e));\n        this.device.gatt.disconnect();\n        throw e;\n      }\n    });\n\n    if (mtu > 23) {\n      const mtuSize = mtu - 3;\n      log(\n        \"ble-verbose\",\n        `BleTransport(${String(this.id)}) mtu set to ${String(mtuSize)}`\n      );\n      this.mtuSize = mtuSize;\n    }\n\n    return this.mtuSize;\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      try {\n        const msgIn = apdu.toString(\"hex\");\n        log(\"apdu\", `=> ${msgIn}`);\n\n        const data = await merge(\n          this.notifyObservable.pipe(receiveAPDU),\n          sendAPDU(this.write, apdu, this.mtuSize)\n        ).toPromise();\n\n        const msgOut = data.toString(\"hex\");\n        log(\"apdu\", `<= ${msgOut}`);\n\n        return data;\n      } catch (e) {\n        log(\"ble-error\", \"exchange got \" + String(e));\n        if (this.notYetDisconnected) {\n          // in such case we will always disconnect because something is bad.\n          this.device.gatt.disconnect();\n        }\n        throw e;\n      }\n    });\n\n  setScrambleKey() {}\n\n  write = async (buffer: Buffer) => {\n    log(\"ble-frame\", \"=> \" + buffer.toString(\"hex\"));\n    await this.writeCharacteristic.writeValue(buffer);\n  };\n\n  async close() {\n    if (this.exchangeBusyPromise) {\n      await this.exchangeBusyPromise;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}