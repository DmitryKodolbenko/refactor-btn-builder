{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require(\"./BitString\"),\n  BitString = _require.BitString;\nvar _require2 = require(\"../utils\"),\n  bytesToBase64 = _require2.bytesToBase64,\n  compareBytes = _require2.compareBytes,\n  concatBytes = _require2.concatBytes,\n  crc32c = _require2.crc32c,\n  hexToBytes = _require2.hexToBytes,\n  readNBytesUIntFromArray = _require2.readNBytesUIntFromArray,\n  sha256 = _require2.sha256,\n  bytesToHex = _require2.bytesToHex;\nvar reachBocMagicPrefix = hexToBytes('B5EE9C72');\nvar leanBocMagicPrefix = hexToBytes('68ff65f3');\nvar leanBocMagicPrefixCRC = hexToBytes('acc3a728');\nvar Cell = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Cell() {\n    _classCallCheck(this, Cell);\n    this.bits = new BitString(1023);\n    this.refs = [];\n    this.isExotic = false;\n  }\n\n  /**\n   * @param serializedBoc  {string | Uint8Array} hex or bytearray\n   * @return {Cell[]} root cells\n   */\n  _createClass(Cell, [{\n    key: \"writeCell\",\n    value:\n    /**\n     * Write another cell to this cell\n     * @param anotherCell  {Cell}\n     */\n    function writeCell(anotherCell) {\n      // XXX we do not check that there are anough place in cell\n      this.bits.writeBitString(anotherCell.bits);\n      this.refs = this.refs.concat(anotherCell.refs);\n    }\n\n    /**\n     * @return {number}\n     */\n  }, {\n    key: \"getMaxLevel\",\n    value: function getMaxLevel() {\n      //TODO level calculation differ for exotic cells\n      var maxLevel = 0;\n      for (var k in this.refs) {\n        var i = this.refs[k];\n        if (i.getMaxLevel() > maxLevel) {\n          maxLevel = i.getMaxLevel();\n        }\n      }\n      return maxLevel;\n    }\n\n    /**\n     * @return {number}\n     */\n  }, {\n    key: \"isExplicitlyStoredHashes\",\n    value: function isExplicitlyStoredHashes() {\n      return 0;\n    }\n\n    /**\n     * @return {number}\n     */\n  }, {\n    key: \"getMaxDepth\",\n    value: function getMaxDepth() {\n      var maxDepth = 0;\n      if (this.refs.length > 0) {\n        for (var k in this.refs) {\n          var i = this.refs[k];\n          if (i.getMaxDepth() > maxDepth) {\n            maxDepth = i.getMaxDepth();\n          }\n        }\n        maxDepth = maxDepth + 1;\n      }\n      return maxDepth;\n    }\n\n    /**\n     * @private\n     * @return {Uint8Array}\n     */\n  }, {\n    key: \"getMaxDepthAsArray\",\n    value: function getMaxDepthAsArray() {\n      var maxDepth = this.getMaxDepth();\n      var d = Uint8Array.from({\n        length: 2\n      }, function () {\n        return 0;\n      });\n      d[1] = maxDepth % 256;\n      d[0] = Math.floor(maxDepth / 256);\n      return d;\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n  }, {\n    key: \"getRefsDescriptor\",\n    value: function getRefsDescriptor() {\n      var d1 = Uint8Array.from({\n        length: 1\n      }, function () {\n        return 0;\n      });\n      d1[0] = this.refs.length + this.isExotic * 8 + this.getMaxLevel() * 32;\n      return d1;\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n  }, {\n    key: \"getBitsDescriptor\",\n    value: function getBitsDescriptor() {\n      var d2 = Uint8Array.from({\n        length: 1\n      }, function () {\n        return 0;\n      });\n      d2[0] = Math.ceil(this.bits.cursor / 8) + Math.floor(this.bits.cursor / 8);\n      return d2;\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n  }, {\n    key: \"getDataWithDescriptors\",\n    value: function getDataWithDescriptors() {\n      var d1 = this.getRefsDescriptor();\n      var d2 = this.getBitsDescriptor();\n      var tuBits = this.bits.getTopUppedArray();\n      return concatBytes(concatBytes(d1, d2), tuBits);\n    }\n\n    /**\n     * @return {Promise<Uint8Array>}\n     */\n  }, {\n    key: \"getRepr\",\n    value: function () {\n      var _getRepr = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var reprArray, k, i, _k, _i, x, _k2, _i2;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                reprArray = [];\n                reprArray.push(this.getDataWithDescriptors());\n                for (k in this.refs) {\n                  i = this.refs[k];\n                  reprArray.push(i.getMaxDepthAsArray());\n                }\n                _context.t0 = _regeneratorRuntime().keys(this.refs);\n              case 4:\n                if ((_context.t1 = _context.t0()).done) {\n                  _context.next = 14;\n                  break;\n                }\n                _k = _context.t1.value;\n                _i = this.refs[_k];\n                _context.t2 = reprArray;\n                _context.next = 10;\n                return _i.hash();\n              case 10:\n                _context.t3 = _context.sent;\n                _context.t2.push.call(_context.t2, _context.t3);\n                _context.next = 4;\n                break;\n              case 14:\n                x = new Uint8Array();\n                for (_k2 in reprArray) {\n                  _i2 = reprArray[_k2];\n                  x = concatBytes(x, _i2);\n                }\n                return _context.abrupt(\"return\", x);\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function getRepr() {\n        return _getRepr.apply(this, arguments);\n      }\n      return getRepr;\n    }()\n    /**\n     * @return {Promise<Uint8Array>}\n     */\n  }, {\n    key: \"hash\",\n    value: function () {\n      var _hash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.t0 = Uint8Array;\n                _context2.t1 = sha256;\n                _context2.next = 4;\n                return this.getRepr();\n              case 4:\n                _context2.t2 = _context2.sent;\n                _context2.next = 7;\n                return (0, _context2.t1)(_context2.t2);\n              case 7:\n                _context2.t3 = _context2.sent;\n                return _context2.abrupt(\"return\", new _context2.t0(_context2.t3));\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function hash() {\n        return _hash.apply(this, arguments);\n      }\n      return hash;\n    }()\n    /**\n     * Recursively prints cell's content like Fift\n     * @return  {string}\n     */\n  }, {\n    key: \"print\",\n    value: function print(indent) {\n      indent = indent || '';\n      var s = indent + 'x{' + this.bits.toHex() + '}\\n';\n      for (var k in this.refs) {\n        var i = this.refs[k];\n        s += i.print(indent + ' ');\n      }\n      return s;\n    }\n\n    //serialized_boc#b5ee9c72 has_idx:(## 1) has_crc32c:(## 1)\n    //  has_cache_bits:(## 1) flags:(## 2) { flags = 0 }\n    //  size:(## 3) { size <= 4 }\n    //  off_bytes:(## 8) { off_bytes <= 8 }\n    //  cells:(##(size * 8))\n    //  roots:(##(size * 8)) { roots >= 1 }\n    //  absent:(##(size * 8)) { roots + absent <= cells }\n    //  tot_cells_size:(##(off_bytes * 8))\n    //  root_list:(roots * ##(size * 8))\n    //  index:has_idx?(cells * ##(off_bytes * 8))\n    //  cell_data:(tot_cells_size * [ uint8 ])\n    //  crc32c:has_crc32c?uint32\n    // = BagOfCells;\n    /**\n     * create boc bytearray\n     * @param has_idx? {boolean}\n     * @param hash_crc32?  {boolean}\n     * @param has_cache_bits?  {boolean}\n     * @param flags? {number}\n     * @return {Promise<Uint8Array>}\n     */\n  }, {\n    key: \"toBoc\",\n    value: function () {\n      var _toBoc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var has_idx,\n          hash_crc32,\n          has_cache_bits,\n          flags,\n          root_cell,\n          allcells,\n          topologicalOrder,\n          cellsIndex,\n          cells_num,\n          s,\n          s_bytes,\n          full_size,\n          sizeIndex,\n          _iterator,\n          _step,\n          cell_info,\n          offset_bits,\n          offset_bytes,\n          serialization,\n          _iterator2,\n          _step2,\n          _cell_info,\n          refcell_ser,\n          ser_arr,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                has_idx = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : true;\n                hash_crc32 = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : true;\n                has_cache_bits = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : false;\n                flags = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : 0;\n                root_cell = this;\n                _context3.next = 7;\n                return root_cell.treeWalk();\n              case 7:\n                allcells = _context3.sent;\n                topologicalOrder = allcells[0];\n                cellsIndex = allcells[1];\n                cells_num = topologicalOrder.length;\n                s = cells_num.toString(2).length; // Minimal number of bits to represent reference (unused?)\n                s_bytes = Math.min(Math.ceil(s / 8), 1);\n                full_size = 0;\n                sizeIndex = [];\n                _iterator = _createForOfIteratorHelper(topologicalOrder);\n                _context3.prev = 16;\n                _iterator.s();\n              case 18:\n                if ((_step = _iterator.n()).done) {\n                  _context3.next = 28;\n                  break;\n                }\n                cell_info = _step.value;\n                //TODO it should be async map or async for\n                sizeIndex.push(full_size);\n                _context3.t0 = full_size;\n                _context3.next = 24;\n                return cell_info[1].bocSerializationSize(cellsIndex, s_bytes);\n              case 24:\n                _context3.t1 = _context3.sent;\n                full_size = _context3.t0 + _context3.t1;\n              case 26:\n                _context3.next = 18;\n                break;\n              case 28:\n                _context3.next = 33;\n                break;\n              case 30:\n                _context3.prev = 30;\n                _context3.t2 = _context3[\"catch\"](16);\n                _iterator.e(_context3.t2);\n              case 33:\n                _context3.prev = 33;\n                _iterator.f();\n                return _context3.finish(33);\n              case 36:\n                offset_bits = full_size.toString(2).length; // Minimal number of bits to offset/len (unused?)\n                offset_bytes = Math.max(Math.ceil(offset_bits / 8), 1);\n                serialization = new BitString((1023 + 32 * 4 + 32 * 3) * topologicalOrder.length);\n                serialization.writeBytes(reachBocMagicPrefix);\n                serialization.writeBitArray([has_idx, hash_crc32, has_cache_bits]);\n                serialization.writeUint(flags, 2);\n                serialization.writeUint(s_bytes, 3);\n                serialization.writeUint8(offset_bytes);\n                serialization.writeUint(cells_num, s_bytes * 8);\n                serialization.writeUint(1, s_bytes * 8); // One root for now\n                serialization.writeUint(0, s_bytes * 8); // Complete BOCs only\n                serialization.writeUint(full_size, offset_bytes * 8);\n                serialization.writeUint(0, s_bytes * 8); // Root shoulh have index 0\n                if (has_idx) {\n                  topologicalOrder.forEach(function (cell_data, index) {\n                    return serialization.writeUint(sizeIndex[index], offset_bytes * 8);\n                  });\n                }\n                _iterator2 = _createForOfIteratorHelper(topologicalOrder);\n                _context3.prev = 51;\n                _iterator2.s();\n              case 53:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context3.next = 61;\n                  break;\n                }\n                _cell_info = _step2.value;\n                _context3.next = 57;\n                return _cell_info[1].serializeForBoc(cellsIndex, s_bytes);\n              case 57:\n                refcell_ser = _context3.sent;\n                serialization.writeBytes(refcell_ser);\n              case 59:\n                _context3.next = 53;\n                break;\n              case 61:\n                _context3.next = 66;\n                break;\n              case 63:\n                _context3.prev = 63;\n                _context3.t3 = _context3[\"catch\"](51);\n                _iterator2.e(_context3.t3);\n              case 66:\n                _context3.prev = 66;\n                _iterator2.f();\n                return _context3.finish(66);\n              case 69:\n                ser_arr = serialization.getTopUppedArray();\n                if (hash_crc32) {\n                  ser_arr = concatBytes(ser_arr, crc32c(ser_arr));\n                }\n                return _context3.abrupt(\"return\", ser_arr);\n              case 72:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[16, 30, 33, 36], [51, 63, 66, 69]]);\n      }));\n      function toBoc() {\n        return _toBoc.apply(this, arguments);\n      }\n      return toBoc;\n    }()\n    /**\n     * @private\n     * @param cellsIndex\n     * @param refSize\n     * @return {Promise<Uint8Array>}\n     */\n  }, {\n    key: \"serializeForBoc\",\n    value: function () {\n      var _serializeForBoc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cellsIndex, refSize) {\n        var reprArray, k, i, refHash, refIndexInt, refIndexHex, reference, x, _k3, _i3;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                reprArray = [];\n                reprArray.push(this.getDataWithDescriptors());\n                if (!this.isExplicitlyStoredHashes()) {\n                  _context4.next = 4;\n                  break;\n                }\n                throw new Error(\"Cell hashes explicit storing is not implemented\");\n              case 4:\n                _context4.t0 = _regeneratorRuntime().keys(this.refs);\n              case 5:\n                if ((_context4.t1 = _context4.t0()).done) {\n                  _context4.next = 18;\n                  break;\n                }\n                k = _context4.t1.value;\n                i = this.refs[k];\n                _context4.next = 10;\n                return i.hash();\n              case 10:\n                refHash = _context4.sent;\n                refIndexInt = cellsIndex[refHash];\n                refIndexHex = refIndexInt.toString(16);\n                if (refIndexHex.length % 2) {\n                  refIndexHex = \"0\" + refIndexHex;\n                }\n                reference = hexToBytes(refIndexHex);\n                reprArray.push(reference);\n                _context4.next = 5;\n                break;\n              case 18:\n                x = new Uint8Array();\n                for (_k3 in reprArray) {\n                  _i3 = reprArray[_k3];\n                  x = concatBytes(x, _i3);\n                }\n                return _context4.abrupt(\"return\", x);\n              case 21:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function serializeForBoc(_x, _x2) {\n        return _serializeForBoc.apply(this, arguments);\n      }\n      return serializeForBoc;\n    }()\n    /**\n     * @private\n     * @param cellsIndex\n     * @param refSize\n     * @return {Promise<number>}\n     */\n  }, {\n    key: \"bocSerializationSize\",\n    value: function () {\n      var _bocSerializationSize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(cellsIndex, refSize) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.serializeForBoc(cellsIndex, refSize);\n              case 2:\n                return _context5.abrupt(\"return\", _context5.sent.length);\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function bocSerializationSize(_x3, _x4) {\n        return _bocSerializationSize.apply(this, arguments);\n      }\n      return bocSerializationSize;\n    }()\n    /**\n     * @private\n     * @return {[[], {}]} topologicalOrderArray and indexHashmap\n     */\n  }, {\n    key: \"treeWalk\",\n    value: function () {\n      var _treeWalk2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", _treeWalk(this, [], {}));\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function treeWalk() {\n        return _treeWalk2.apply(this, arguments);\n      }\n      return treeWalk;\n    }()\n  }], [{\n    key: \"fromBoc\",\n    value: function fromBoc(serializedBoc) {\n      return deserializeBoc(serializedBoc);\n    }\n\n    /**\n     * @param serializedBoc  {string | Uint8Array} hex or bytearray\n     * @return {Cell} root cell\n     */\n  }, {\n    key: \"oneFromBoc\",\n    value: function oneFromBoc(serializedBoc) {\n      var cells = deserializeBoc(serializedBoc);\n      if (cells.length !== 1) throw new Error('expected 1 root cell but have ' + cells.length);\n      return cells[0];\n    }\n  }]);\n  return Cell;\n}();\nfunction moveToTheEnd(_x5, _x6, _x7) {\n  return _moveToTheEnd.apply(this, arguments);\n}\n/**\n * @param cell  {Cell}\n * @param topologicalOrderArray array of pairs: cellHash: Uint8Array, cell: Cell, ...\n * @param indexHashmap cellHash: Uint8Array -> cellIndex: number\n * @return {[[], {}]} topologicalOrderArray and indexHashmap\n */\nfunction _moveToTheEnd() {\n  _moveToTheEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(indexHashmap, topologicalOrderArray, target) {\n    var targetIndex, h, data, _iterator4, _step4, subCell;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            targetIndex = indexHashmap[target];\n            for (h in indexHashmap) {\n              if (indexHashmap[h] > targetIndex) {\n                indexHashmap[h] = indexHashmap[h] - 1;\n              }\n            }\n            indexHashmap[target] = topologicalOrderArray.length - 1;\n            data = topologicalOrderArray.splice(targetIndex, 1)[0];\n            topologicalOrderArray.push(data);\n            _iterator4 = _createForOfIteratorHelper(data[1].refs);\n            _context7.prev = 6;\n            _iterator4.s();\n          case 8:\n            if ((_step4 = _iterator4.n()).done) {\n              _context7.next = 20;\n              break;\n            }\n            subCell = _step4.value;\n            _context7.t0 = moveToTheEnd;\n            _context7.t1 = indexHashmap;\n            _context7.t2 = topologicalOrderArray;\n            _context7.next = 15;\n            return subCell.hash();\n          case 15:\n            _context7.t3 = _context7.sent;\n            _context7.next = 18;\n            return (0, _context7.t0)(_context7.t1, _context7.t2, _context7.t3);\n          case 18:\n            _context7.next = 8;\n            break;\n          case 20:\n            _context7.next = 25;\n            break;\n          case 22:\n            _context7.prev = 22;\n            _context7.t4 = _context7[\"catch\"](6);\n            _iterator4.e(_context7.t4);\n          case 25:\n            _context7.prev = 25;\n            _iterator4.f();\n            return _context7.finish(25);\n          case 28:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7, null, [[6, 22, 25, 28]]);\n  }));\n  return _moveToTheEnd.apply(this, arguments);\n}\nfunction _treeWalk(_x8, _x9, _x10) {\n  return _treeWalk3.apply(this, arguments);\n}\nfunction _treeWalk3() {\n  _treeWalk3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(cell, topologicalOrderArray, indexHashmap) {\n    var parentHash,\n      cellHash,\n      _iterator5,\n      _step5,\n      subCell,\n      res,\n      _args8 = arguments;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            parentHash = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : null;\n            _context8.next = 3;\n            return cell.hash();\n          case 3:\n            cellHash = _context8.sent;\n            if (!(cellHash in indexHashmap)) {\n              _context8.next = 10;\n              break;\n            }\n            if (!parentHash) {\n              _context8.next = 9;\n              break;\n            }\n            if (!(indexHashmap[parentHash] > indexHashmap[cellHash])) {\n              _context8.next = 9;\n              break;\n            }\n            _context8.next = 9;\n            return moveToTheEnd(indexHashmap, topologicalOrderArray, cellHash);\n          case 9:\n            return _context8.abrupt(\"return\", [topologicalOrderArray, indexHashmap]);\n          case 10:\n            indexHashmap[cellHash] = topologicalOrderArray.length;\n            topologicalOrderArray.push([cellHash, cell]);\n            _iterator5 = _createForOfIteratorHelper(cell.refs);\n            _context8.prev = 13;\n            _iterator5.s();\n          case 15:\n            if ((_step5 = _iterator5.n()).done) {\n              _context8.next = 24;\n              break;\n            }\n            subCell = _step5.value;\n            _context8.next = 19;\n            return _treeWalk(subCell, topologicalOrderArray, indexHashmap, cellHash);\n          case 19:\n            res = _context8.sent;\n            topologicalOrderArray = res[0];\n            indexHashmap = res[1];\n          case 22:\n            _context8.next = 15;\n            break;\n          case 24:\n            _context8.next = 29;\n            break;\n          case 26:\n            _context8.prev = 26;\n            _context8.t0 = _context8[\"catch\"](13);\n            _iterator5.e(_context8.t0);\n          case 29:\n            _context8.prev = 29;\n            _iterator5.f();\n            return _context8.finish(29);\n          case 32:\n            return _context8.abrupt(\"return\", [topologicalOrderArray, indexHashmap]);\n          case 33:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, null, [[13, 26, 29, 32]]);\n  }));\n  return _treeWalk3.apply(this, arguments);\n}\nfunction parseBocHeader(serializedBoc) {\n  // snake_case is used to match TON docs\n  if (serializedBoc.length < 4 + 1) throw \"Not enough bytes for magic prefix\";\n  var inputData = serializedBoc; // Save copy for crc32\n  var prefix = serializedBoc.slice(0, 4);\n  serializedBoc = serializedBoc.slice(4);\n  var has_idx, hash_crc32, has_cache_bits, flags, size_bytes;\n  if (compareBytes(prefix, reachBocMagicPrefix)) {\n    var flags_byte = serializedBoc[0];\n    has_idx = flags_byte & 128;\n    hash_crc32 = flags_byte & 64;\n    has_cache_bits = flags_byte & 32;\n    flags = (flags_byte & 16) * 2 + (flags_byte & 8);\n    size_bytes = flags_byte % 8;\n  }\n  if (compareBytes(prefix, leanBocMagicPrefix)) {\n    has_idx = 1;\n    hash_crc32 = 0;\n    has_cache_bits = 0;\n    flags = 0;\n    size_bytes = serializedBoc[0];\n  }\n  if (compareBytes(prefix, leanBocMagicPrefixCRC)) {\n    has_idx = 1;\n    hash_crc32 = 1;\n    has_cache_bits = 0;\n    flags = 0;\n    size_bytes = serializedBoc[0];\n  }\n  serializedBoc = serializedBoc.slice(1);\n  if (serializedBoc.length < 1 + 5 * size_bytes) throw \"Not enough bytes for encoding cells counters\";\n  var offset_bytes = serializedBoc[0];\n  serializedBoc = serializedBoc.slice(1);\n  var cells_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(size_bytes);\n  var roots_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(size_bytes);\n  var absent_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(size_bytes);\n  var tot_cells_size = readNBytesUIntFromArray(offset_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(offset_bytes);\n  if (serializedBoc.length < roots_num * size_bytes) throw \"Not enough bytes for encoding root cells hashes\";\n  var root_list = [];\n  for (var c = 0; c < roots_num; c++) {\n    root_list.push(readNBytesUIntFromArray(size_bytes, serializedBoc));\n    serializedBoc = serializedBoc.slice(size_bytes);\n  }\n  var index = false;\n  if (has_idx) {\n    index = [];\n    if (serializedBoc.length < offset_bytes * cells_num) throw \"Not enough bytes for index encoding\";\n    for (var _c = 0; _c < cells_num; _c++) {\n      index.push(readNBytesUIntFromArray(offset_bytes, serializedBoc));\n      serializedBoc = serializedBoc.slice(offset_bytes);\n    }\n  }\n  if (serializedBoc.length < tot_cells_size) throw \"Not enough bytes for cells data\";\n  var cells_data = serializedBoc.slice(0, tot_cells_size);\n  serializedBoc = serializedBoc.slice(tot_cells_size);\n  if (hash_crc32) {\n    if (serializedBoc.length < 4) throw \"Not enough bytes for crc32c hashsum\";\n    var length = inputData.length;\n    if (!compareBytes(crc32c(inputData.slice(0, length - 4)), serializedBoc.slice(0, 4))) throw \"Crc32c hashsum mismatch\";\n    serializedBoc = serializedBoc.slice(4);\n  }\n  if (serializedBoc.length) throw \"Too much bytes in BoC serialization\";\n  return {\n    has_idx: has_idx,\n    hash_crc32: hash_crc32,\n    has_cache_bits: has_cache_bits,\n    flags: flags,\n    size_bytes: size_bytes,\n    off_bytes: offset_bytes,\n    cells_num: cells_num,\n    roots_num: roots_num,\n    absent_num: absent_num,\n    tot_cells_size: tot_cells_size,\n    root_list: root_list,\n    index: index,\n    cells_data: cells_data\n  };\n}\nfunction deserializeCellData(cellData, referenceIndexSize) {\n  if (cellData.length < 2) throw \"Not enough bytes to encode cell descriptors\";\n  var d1 = cellData[0],\n    d2 = cellData[1];\n  cellData = cellData.slice(2);\n  var level = Math.floor(d1 / 32);\n  var isExotic = d1 & 8;\n  var refNum = d1 % 8;\n  var dataBytesize = Math.ceil(d2 / 2);\n  var fullfilledBytes = !(d2 % 2);\n  var cell = new Cell();\n  cell.isExotic = isExotic;\n  if (cellData.length < dataBytesize + referenceIndexSize * refNum) throw \"Not enough bytes to encode cell data\";\n  cell.bits.setTopUppedArray(cellData.slice(0, dataBytesize), fullfilledBytes);\n  cellData = cellData.slice(dataBytesize);\n  for (var r = 0; r < refNum; r++) {\n    cell.refs.push(readNBytesUIntFromArray(referenceIndexSize, cellData));\n    cellData = cellData.slice(referenceIndexSize);\n  }\n  return {\n    cell: cell,\n    residue: cellData\n  };\n}\n\n/**\n * @param serializedBoc  {string | Uint8Array} hex or bytearray\n * @return {Cell[]} root cells\n */\nfunction deserializeBoc(serializedBoc) {\n  if (typeof serializedBoc == 'string') {\n    serializedBoc = hexToBytes(serializedBoc);\n  }\n  var header = parseBocHeader(serializedBoc);\n  var cells_data = header.cells_data;\n  var cells_array = [];\n  for (var ci = 0; ci < header.cells_num; ci++) {\n    var dd = deserializeCellData(cells_data, header.size_bytes);\n    cells_data = dd.residue;\n    cells_array.push(dd.cell);\n  }\n  for (var _ci = header.cells_num - 1; _ci >= 0; _ci--) {\n    var c = cells_array[_ci];\n    for (var ri = 0; ri < c.refs.length; ri++) {\n      var r = c.refs[ri];\n      if (r < _ci) {\n        throw \"Topological order is broken\";\n      }\n      c.refs[ri] = cells_array[r];\n    }\n  }\n  var root_cells = [];\n  var _iterator3 = _createForOfIteratorHelper(header.root_list),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _ri = _step3.value;\n      root_cells.push(cells_array[_ri]);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return root_cells;\n}\nmodule.exports = {\n  Cell: Cell\n};","map":{"version":3,"names":["require","BitString","bytesToBase64","compareBytes","concatBytes","crc32c","hexToBytes","readNBytesUIntFromArray","sha256","bytesToHex","reachBocMagicPrefix","leanBocMagicPrefix","leanBocMagicPrefixCRC","Cell","bits","refs","isExotic","anotherCell","writeBitString","concat","maxLevel","k","i","getMaxLevel","maxDepth","length","getMaxDepth","d","Uint8Array","from","Math","floor","d1","d2","ceil","cursor","getRefsDescriptor","getBitsDescriptor","tuBits","getTopUppedArray","reprArray","push","getDataWithDescriptors","getMaxDepthAsArray","hash","x","getRepr","indent","s","toHex","print","has_idx","hash_crc32","has_cache_bits","flags","root_cell","treeWalk","allcells","topologicalOrder","cellsIndex","cells_num","toString","s_bytes","min","full_size","sizeIndex","cell_info","bocSerializationSize","offset_bits","offset_bytes","max","serialization","writeBytes","writeBitArray","writeUint","writeUint8","forEach","cell_data","index","serializeForBoc","refcell_ser","ser_arr","refSize","isExplicitlyStoredHashes","Error","refHash","refIndexInt","refIndexHex","reference","serializedBoc","deserializeBoc","cells","moveToTheEnd","indexHashmap","topologicalOrderArray","target","targetIndex","h","data","splice","subCell","cell","parentHash","cellHash","res","parseBocHeader","inputData","prefix","slice","size_bytes","flags_byte","roots_num","absent_num","tot_cells_size","root_list","c","cells_data","off_bytes","deserializeCellData","cellData","referenceIndexSize","level","refNum","dataBytesize","fullfilledBytes","setTopUppedArray","r","residue","header","cells_array","ci","dd","ri","root_cells","module","exports"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/tonweb/src/boc/Cell.js"],"sourcesContent":["const {BitString} = require(\"./BitString\");\nconst {\n    bytesToBase64,\n    compareBytes,\n    concatBytes,\n    crc32c,\n    hexToBytes,\n    readNBytesUIntFromArray,\n    sha256,\n    bytesToHex\n} = require(\"../utils\");\n\nconst reachBocMagicPrefix = hexToBytes('B5EE9C72');\nconst leanBocMagicPrefix = hexToBytes('68ff65f3');\nconst leanBocMagicPrefixCRC = hexToBytes('acc3a728');\n\nclass Cell {\n    constructor() {\n        this.bits = new BitString(1023);\n        this.refs = [];\n        this.isExotic = false;\n    }\n\n    /**\n     * @param serializedBoc  {string | Uint8Array} hex or bytearray\n     * @return {Cell[]} root cells\n     */\n    static fromBoc(serializedBoc) {\n        return deserializeBoc(serializedBoc);\n    }\n\n    /**\n     * @param serializedBoc  {string | Uint8Array} hex or bytearray\n     * @return {Cell} root cell\n     */\n    static oneFromBoc(serializedBoc) {\n        const cells = deserializeBoc(serializedBoc);\n        if (cells.length !== 1) throw new Error('expected 1 root cell but have ' + cells.length);\n        return cells[0];\n    }\n\n    /**\n     * Write another cell to this cell\n     * @param anotherCell  {Cell}\n     */\n    writeCell(anotherCell) {\n        // XXX we do not check that there are anough place in cell\n        this.bits.writeBitString(anotherCell.bits);\n        this.refs = this.refs.concat(anotherCell.refs);\n    }\n\n    /**\n     * @return {number}\n     */\n    getMaxLevel() {\n        //TODO level calculation differ for exotic cells\n        let maxLevel = 0;\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            if (i.getMaxLevel() > maxLevel) {\n                maxLevel = i.getMaxLevel();\n            }\n        }\n        return maxLevel;\n    }\n\n    /**\n     * @return {number}\n     */\n    isExplicitlyStoredHashes() {\n        return 0;\n    }\n\n    /**\n     * @return {number}\n     */\n    getMaxDepth() {\n        let maxDepth = 0;\n        if (this.refs.length > 0) {\n            for (let k in this.refs) {\n                const i = this.refs[k];\n                if (i.getMaxDepth() > maxDepth) {\n                    maxDepth = i.getMaxDepth();\n                }\n            }\n            maxDepth = maxDepth + 1;\n        }\n        return maxDepth;\n    }\n\n    /**\n     * @private\n     * @return {Uint8Array}\n     */\n    getMaxDepthAsArray() {\n        const maxDepth = this.getMaxDepth();\n        const d = Uint8Array.from({length: 2}, () => 0);\n        d[1] = maxDepth % 256;\n        d[0] = Math.floor(maxDepth / 256);\n        return d;\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n    getRefsDescriptor() {\n        const d1 = Uint8Array.from({length: 1}, () => 0);\n        d1[0] = this.refs.length + this.isExotic * 8 + this.getMaxLevel() * 32;\n        return d1;\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n    getBitsDescriptor() {\n        const d2 = Uint8Array.from({length: 1}, () => 0);\n        d2[0] = Math.ceil(this.bits.cursor / 8) + Math.floor(this.bits.cursor / 8);\n        return d2;\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n    getDataWithDescriptors() {\n        const d1 = this.getRefsDescriptor();\n        const d2 = this.getBitsDescriptor();\n        const tuBits = this.bits.getTopUppedArray();\n        return concatBytes(concatBytes(d1, d2), tuBits);\n    }\n\n    /**\n     * @return {Promise<Uint8Array>}\n     */\n    async getRepr() {\n        const reprArray = [];\n\n        reprArray.push(this.getDataWithDescriptors());\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            reprArray.push(i.getMaxDepthAsArray());\n        }\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            reprArray.push(await i.hash());\n        }\n        let x = new Uint8Array();\n        for (let k in reprArray) {\n            const i = reprArray[k];\n            x = concatBytes(x, i);\n        }\n        return x;\n    }\n\n    /**\n     * @return {Promise<Uint8Array>}\n     */\n    async hash() {\n        return new Uint8Array(\n            await sha256(await this.getRepr())\n        );\n    }\n\n    /**\n     * Recursively prints cell's content like Fift\n     * @return  {string}\n     */\n    print(indent) {\n        indent = indent || '';\n        let s = indent + 'x{' + this.bits.toHex() + '}\\n';\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            s += i.print(indent + ' ');\n        }\n        return s;\n    }\n\n    //serialized_boc#b5ee9c72 has_idx:(## 1) has_crc32c:(## 1)\n    //  has_cache_bits:(## 1) flags:(## 2) { flags = 0 }\n    //  size:(## 3) { size <= 4 }\n    //  off_bytes:(## 8) { off_bytes <= 8 }\n    //  cells:(##(size * 8))\n    //  roots:(##(size * 8)) { roots >= 1 }\n    //  absent:(##(size * 8)) { roots + absent <= cells }\n    //  tot_cells_size:(##(off_bytes * 8))\n    //  root_list:(roots * ##(size * 8))\n    //  index:has_idx?(cells * ##(off_bytes * 8))\n    //  cell_data:(tot_cells_size * [ uint8 ])\n    //  crc32c:has_crc32c?uint32\n    // = BagOfCells;\n    /**\n     * create boc bytearray\n     * @param has_idx? {boolean}\n     * @param hash_crc32?  {boolean}\n     * @param has_cache_bits?  {boolean}\n     * @param flags? {number}\n     * @return {Promise<Uint8Array>}\n     */\n    async toBoc(has_idx = true, hash_crc32 = true, has_cache_bits = false, flags = 0) {\n        const root_cell = this;\n\n        const allcells = await root_cell.treeWalk();\n        const topologicalOrder = allcells[0];\n        const cellsIndex = allcells[1];\n\n        const cells_num = topologicalOrder.length;\n        const s = cells_num.toString(2).length; // Minimal number of bits to represent reference (unused?)\n        const s_bytes = Math.min(Math.ceil(s / 8), 1);\n        let full_size = 0;\n        let sizeIndex = [];\n        for (let cell_info of topologicalOrder) {\n            //TODO it should be async map or async for\n            sizeIndex.push(full_size);\n            full_size = full_size + await cell_info[1].bocSerializationSize(cellsIndex, s_bytes);\n        }\n        const offset_bits = full_size.toString(2).length; // Minimal number of bits to offset/len (unused?)\n        const offset_bytes = Math.max(Math.ceil(offset_bits / 8), 1);\n\n        const serialization = new BitString((1023 + 32 * 4 + 32 * 3) * topologicalOrder.length);\n        serialization.writeBytes(reachBocMagicPrefix);\n        serialization.writeBitArray([has_idx, hash_crc32, has_cache_bits]);\n        serialization.writeUint(flags, 2);\n        serialization.writeUint(s_bytes, 3);\n        serialization.writeUint8(offset_bytes);\n        serialization.writeUint(cells_num, s_bytes * 8);\n        serialization.writeUint(1, s_bytes * 8); // One root for now\n        serialization.writeUint(0, s_bytes * 8); // Complete BOCs only\n        serialization.writeUint(full_size, offset_bytes * 8);\n        serialization.writeUint(0, s_bytes * 8); // Root shoulh have index 0\n        if (has_idx) {\n            topologicalOrder.forEach(\n                (cell_data, index) =>\n                    serialization.writeUint(sizeIndex[index], offset_bytes * 8));\n        }\n        for (let cell_info of topologicalOrder) {\n            //TODO it should be async map or async for\n            const refcell_ser = await cell_info[1].serializeForBoc(cellsIndex, s_bytes);\n            serialization.writeBytes(refcell_ser);\n        }\n        let ser_arr = serialization.getTopUppedArray();\n        if (hash_crc32) {\n            ser_arr = concatBytes(ser_arr, crc32c(ser_arr));\n        }\n\n        return ser_arr;\n    }\n\n    /**\n     * @private\n     * @param cellsIndex\n     * @param refSize\n     * @return {Promise<Uint8Array>}\n     */\n    async serializeForBoc(cellsIndex, refSize) {\n        const reprArray = [];\n\n        reprArray.push(this.getDataWithDescriptors());\n        if (this.isExplicitlyStoredHashes()) {\n            throw new Error(\"Cell hashes explicit storing is not implemented\");\n        }\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            const refHash = await i.hash();\n            const refIndexInt = cellsIndex[refHash];\n            let refIndexHex = refIndexInt.toString(16);\n            if (refIndexHex.length % 2) {\n                refIndexHex = \"0\" + refIndexHex;\n            }\n            const reference = hexToBytes(refIndexHex);\n            reprArray.push(reference);\n        }\n        let x = new Uint8Array();\n        for (let k in reprArray) {\n            const i = reprArray[k];\n            x = concatBytes(x, i);\n        }\n        return x;\n    }\n\n    /**\n     * @private\n     * @param cellsIndex\n     * @param refSize\n     * @return {Promise<number>}\n     */\n    async bocSerializationSize(cellsIndex, refSize) {\n        return (await this.serializeForBoc(cellsIndex, refSize)).length;\n    }\n\n    /**\n     * @private\n     * @return {[[], {}]} topologicalOrderArray and indexHashmap\n     */\n    async treeWalk() {\n        return treeWalk(this, [], {});\n    }\n}\n\nasync function moveToTheEnd(indexHashmap, topologicalOrderArray, target) {\n    const targetIndex = indexHashmap[target];\n    for (let h in indexHashmap) {\n        if (indexHashmap[h] > targetIndex) {\n            indexHashmap[h] = indexHashmap[h] - 1;\n        }\n    }\n    indexHashmap[target] = topologicalOrderArray.length - 1;\n    const data = topologicalOrderArray.splice(targetIndex, 1)[0];\n    topologicalOrderArray.push(data);\n    for (let subCell of data[1].refs) {\n        await moveToTheEnd(indexHashmap, topologicalOrderArray, await subCell.hash());\n    }\n}\n\n/**\n * @param cell  {Cell}\n * @param topologicalOrderArray array of pairs: cellHash: Uint8Array, cell: Cell, ...\n * @param indexHashmap cellHash: Uint8Array -> cellIndex: number\n * @return {[[], {}]} topologicalOrderArray and indexHashmap\n */\nasync function treeWalk(cell, topologicalOrderArray, indexHashmap, parentHash = null) {\n    const cellHash = await cell.hash();\n    if (cellHash in indexHashmap) { // Duplication cell\n        //it is possible that already seen cell is a children of more deep cell\n        if (parentHash) {\n            if (indexHashmap[parentHash] > indexHashmap[cellHash]) {\n                await moveToTheEnd(indexHashmap, topologicalOrderArray, cellHash);\n            }\n        }\n        return [topologicalOrderArray, indexHashmap];\n    }\n    indexHashmap[cellHash] = topologicalOrderArray.length;\n    topologicalOrderArray.push([cellHash, cell]);\n    for (let subCell of cell.refs) {\n        const res = await treeWalk(subCell, topologicalOrderArray, indexHashmap, cellHash);\n        topologicalOrderArray = res[0];\n        indexHashmap = res[1];\n    }\n\n    return [topologicalOrderArray, indexHashmap];\n}\n\n\nfunction parseBocHeader(serializedBoc) {\n    // snake_case is used to match TON docs\n    if (serializedBoc.length < 4 + 1)\n        throw \"Not enough bytes for magic prefix\";\n    const inputData = serializedBoc; // Save copy for crc32\n    const prefix = serializedBoc.slice(0, 4);\n    serializedBoc = serializedBoc.slice(4);\n    let has_idx, hash_crc32, has_cache_bits, flags, size_bytes;\n    if (compareBytes(prefix, reachBocMagicPrefix)) {\n        const flags_byte = serializedBoc[0];\n        has_idx = flags_byte & 128;\n        hash_crc32 = flags_byte & 64;\n        has_cache_bits = flags_byte & 32;\n        flags = (flags_byte & 16) * 2 + (flags_byte & 8);\n        size_bytes = flags_byte % 8;\n    }\n    if (compareBytes(prefix, leanBocMagicPrefix)) {\n        has_idx = 1;\n        hash_crc32 = 0;\n        has_cache_bits = 0;\n        flags = 0;\n        size_bytes = serializedBoc[0];\n    }\n    if (compareBytes(prefix, leanBocMagicPrefixCRC)) {\n        has_idx = 1;\n        hash_crc32 = 1;\n        has_cache_bits = 0;\n        flags = 0;\n        size_bytes = serializedBoc[0];\n    }\n    serializedBoc = serializedBoc.slice(1);\n    if (serializedBoc.length < 1 + 5 * size_bytes)\n        throw \"Not enough bytes for encoding cells counters\";\n    const offset_bytes = serializedBoc[0];\n    serializedBoc = serializedBoc.slice(1);\n    const cells_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(size_bytes);\n    const roots_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(size_bytes);\n    const absent_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(size_bytes);\n    const tot_cells_size = readNBytesUIntFromArray(offset_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(offset_bytes);\n    if (serializedBoc.length < roots_num * size_bytes)\n        throw \"Not enough bytes for encoding root cells hashes\";\n    let root_list = [];\n    for (let c = 0; c < roots_num; c++) {\n        root_list.push(readNBytesUIntFromArray(size_bytes, serializedBoc));\n        serializedBoc = serializedBoc.slice(size_bytes);\n    }\n    let index = false;\n    if (has_idx) {\n        index = [];\n        if (serializedBoc.length < offset_bytes * cells_num)\n            throw \"Not enough bytes for index encoding\";\n        for (let c = 0; c < cells_num; c++) {\n            index.push(readNBytesUIntFromArray(offset_bytes, serializedBoc));\n            serializedBoc = serializedBoc.slice(offset_bytes);\n        }\n    }\n\n    if (serializedBoc.length < tot_cells_size)\n        throw \"Not enough bytes for cells data\";\n    const cells_data = serializedBoc.slice(0, tot_cells_size);\n    serializedBoc = serializedBoc.slice(tot_cells_size);\n    if (hash_crc32) {\n        if (serializedBoc.length < 4)\n            throw \"Not enough bytes for crc32c hashsum\";\n        const length = inputData.length;\n        if (!compareBytes(crc32c(inputData.slice(0, length - 4)), serializedBoc.slice(0, 4)))\n            throw \"Crc32c hashsum mismatch\";\n        serializedBoc = serializedBoc.slice(4);\n    }\n    if (serializedBoc.length)\n        throw \"Too much bytes in BoC serialization\";\n    return {\n        has_idx: has_idx, hash_crc32: hash_crc32, has_cache_bits: has_cache_bits, flags: flags, size_bytes: size_bytes,\n        off_bytes: offset_bytes, cells_num: cells_num, roots_num: roots_num, absent_num: absent_num,\n        tot_cells_size: tot_cells_size, root_list: root_list, index: index,\n        cells_data: cells_data\n    };\n}\n\nfunction deserializeCellData(cellData, referenceIndexSize) {\n    if (cellData.length < 2)\n        throw \"Not enough bytes to encode cell descriptors\";\n    const d1 = cellData[0], d2 = cellData[1];\n    cellData = cellData.slice(2);\n    const level = Math.floor(d1 / 32);\n    const isExotic = d1 & 8;\n    const refNum = d1 % 8;\n    const dataBytesize = Math.ceil(d2 / 2);\n    const fullfilledBytes = !(d2 % 2);\n    let cell = new Cell();\n    cell.isExotic = isExotic;\n    if (cellData.length < dataBytesize + referenceIndexSize * refNum)\n        throw \"Not enough bytes to encode cell data\";\n    cell.bits.setTopUppedArray(cellData.slice(0, dataBytesize), fullfilledBytes);\n    cellData = cellData.slice(dataBytesize);\n    for (let r = 0; r < refNum; r++) {\n        cell.refs.push(readNBytesUIntFromArray(referenceIndexSize, cellData));\n        cellData = cellData.slice(referenceIndexSize);\n    }\n    return {cell: cell, residue: cellData};\n}\n\n\n/**\n * @param serializedBoc  {string | Uint8Array} hex or bytearray\n * @return {Cell[]} root cells\n */\nfunction deserializeBoc(serializedBoc) {\n    if (typeof (serializedBoc) == 'string') {\n        serializedBoc = hexToBytes(serializedBoc);\n    }\n    const header = parseBocHeader(serializedBoc);\n    let cells_data = header.cells_data;\n    let cells_array = [];\n    for (let ci = 0; ci < header.cells_num; ci++) {\n        let dd = deserializeCellData(cells_data, header.size_bytes);\n        cells_data = dd.residue;\n        cells_array.push(dd.cell);\n    }\n    for (let ci = header.cells_num - 1; ci >= 0; ci--) {\n        let c = cells_array[ci];\n        for (let ri = 0; ri < c.refs.length; ri++) {\n            const r = c.refs[ri];\n            if (r < ci) {\n                throw \"Topological order is broken\";\n            }\n            c.refs[ri] = cells_array[r];\n        }\n    }\n    let root_cells = [];\n    for (let ri of header.root_list) {\n        root_cells.push(cells_array[ri]);\n    }\n    return root_cells;\n}\n\nmodule.exports = {Cell};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}