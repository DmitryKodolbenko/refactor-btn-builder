{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decrypt = exports.encrypt = exports.supportedAlgorithms = exports.executeKdf = exports.cosmjsSalt = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\n/**\n * A fixed salt is chosen to archive a deterministic password to key derivation.\n * This reduces the scope of a potential rainbow attack to all CosmJS users.\n * Must be 16 bytes due to implementation limitations.\n */\nexports.cosmjsSalt = (0, encoding_1.toAscii)(\"The CosmJS salt.\");\nasync function executeKdf(password, configuration) {\n  switch (configuration.algorithm) {\n    case \"argon2id\":\n      {\n        const options = configuration.params;\n        if (!(0, crypto_1.isArgon2idOptions)(options)) throw new Error(\"Invalid format of argon2id params\");\n        return crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);\n      }\n    default:\n      throw new Error(\"Unsupported KDF algorithm\");\n  }\n}\nexports.executeKdf = executeKdf;\nexports.supportedAlgorithms = {\n  xchacha20poly1305Ietf: \"xchacha20poly1305-ietf\"\n};\nasync function encrypt(plaintext, encryptionKey, config) {\n  switch (config.algorithm) {\n    case exports.supportedAlgorithms.xchacha20poly1305Ietf:\n      {\n        const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);\n        // Prepend fixed-length nonce to ciphertext as suggested in the example from https://github.com/jedisct1/libsodium.js#api\n        return new Uint8Array([...nonce, ...(await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce))]);\n      }\n    default:\n      throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);\n  }\n}\nexports.encrypt = encrypt;\nasync function decrypt(ciphertext, encryptionKey, config) {\n  switch (config.algorithm) {\n    case exports.supportedAlgorithms.xchacha20poly1305Ietf:\n      {\n        const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);\n        return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);\n      }\n    default:\n      throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);\n  }\n}\nexports.decrypt = decrypt;","map":{"version":3,"sources":["../src/wallet.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;AAOA,MAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAEA;;;;AAIG;AACU,OAAA,CAAA,UAAU,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,OAAO,EAAC,kBAAkB,CAAC;AAW9C,eAAe,UAAU,CAAC,QAAgB,EAAE,aAA+B,EAAA;EAChF,QAAQ,aAAa,CAAC,SAAS;IAC7B,KAAK,UAAU;MAAE;QACf,MAAM,OAAO,GAAG,aAAa,CAAC,MAAM;QACpC,IAAI,CAAC,CAAA,CAAA,EAAA,QAAA,CAAA,iBAAiB,EAAC,OAAO,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC;QACrF,OAAO,QAAA,CAAA,QAAQ,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAA,CAAA,UAAU,EAAE,OAAO,CAAC;MACvD;IACD;MACE,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC;EAAC;AAEnD;AAVA,OAAA,CAAA,UAAA,GAAA,UAAA;AAyBa,OAAA,CAAA,mBAAmB,GAAG;EACjC,qBAAqB,EAAE;CACxB;AAEM,eAAe,OAAO,CAC3B,SAAqB,EACrB,aAAyB,EACzB,MAA+B,EAAA;EAE/B,QAAQ,MAAM,CAAC,SAAS;IACtB,KAAK,OAAA,CAAA,mBAAmB,CAAC,qBAAqB;MAAE;QAC9C,MAAM,KAAK,GAAG,QAAA,CAAA,MAAM,CAAC,QAAQ,CAAC,QAAA,CAAA,oBAAoB,CAAC;QACnD;QACA,OAAO,IAAI,UAAU,CAAC,CACpB,GAAG,KAAK,EACR,IAAI,MAAM,QAAA,CAAA,qBAAqB,CAAC,OAAO,CAAC,SAAS,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC,CAC1E,CAAC;MACH;IACD;MACE,MAAM,IAAI,KAAK,CAAC,sCAAsC,MAAM,CAAC,SAAS,GAAG,CAAC;EAAC;AAEjF;AAjBA,OAAA,CAAA,OAAA,GAAA,OAAA;AAmBO,eAAe,OAAO,CAC3B,UAAsB,EACtB,aAAyB,EACzB,MAA+B,EAAA;EAE/B,QAAQ,MAAM,CAAC,SAAS;IACtB,KAAK,OAAA,CAAA,mBAAmB,CAAC,qBAAqB;MAAE;QAC9C,MAAM,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,QAAA,CAAA,oBAAoB,CAAC;QACvD,OAAO,QAAA,CAAA,qBAAqB,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,QAAA,CAAA,oBAAoB,CAAC,EAAE,aAAa,EAAE,KAAK,CAAC;MACnG;IACD;MACE,MAAM,IAAI,KAAK,CAAC,sCAAsC,MAAM,CAAC,SAAS,GAAG,CAAC;EAAC;AAEjF;AAbA,OAAA,CAAA,OAAA,GAAA,OAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decrypt = exports.encrypt = exports.supportedAlgorithms = exports.executeKdf = exports.cosmjsSalt = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\n/**\n * A fixed salt is chosen to archive a deterministic password to key derivation.\n * This reduces the scope of a potential rainbow attack to all CosmJS users.\n * Must be 16 bytes due to implementation limitations.\n */\nexports.cosmjsSalt = (0, encoding_1.toAscii)(\"The CosmJS salt.\");\nasync function executeKdf(password, configuration) {\n    switch (configuration.algorithm) {\n        case \"argon2id\": {\n            const options = configuration.params;\n            if (!(0, crypto_1.isArgon2idOptions)(options))\n                throw new Error(\"Invalid format of argon2id params\");\n            return crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);\n        }\n        default:\n            throw new Error(\"Unsupported KDF algorithm\");\n    }\n}\nexports.executeKdf = executeKdf;\nexports.supportedAlgorithms = {\n    xchacha20poly1305Ietf: \"xchacha20poly1305-ietf\",\n};\nasync function encrypt(plaintext, encryptionKey, config) {\n    switch (config.algorithm) {\n        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {\n            const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);\n            // Prepend fixed-length nonce to ciphertext as suggested in the example from https://github.com/jedisct1/libsodium.js#api\n            return new Uint8Array([\n                ...nonce,\n                ...(await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)),\n            ]);\n        }\n        default:\n            throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);\n    }\n}\nexports.encrypt = encrypt;\nasync function decrypt(ciphertext, encryptionKey, config) {\n    switch (config.algorithm) {\n        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {\n            const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);\n            return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);\n        }\n        default:\n            throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);\n    }\n}\nexports.decrypt = decrypt;\n//# sourceMappingURL=wallet.js.map"]},"metadata":{},"sourceType":"script"}