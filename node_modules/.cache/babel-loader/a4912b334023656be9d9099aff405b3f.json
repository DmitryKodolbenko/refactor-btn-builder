{"ast":null,"code":"import _regeneratorRuntime from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, TransportInterfaceNotAvailable, TransportWebUSBGestureRequired, DisconnectedDeviceDuringOperation, DisconnectedDevice } from \"@ledgerhq/errors\";\nimport { getLedgerDevices, getFirstLedgerDevice, requestLedgerDevice, isSupported } from \"./webusb\";\nvar configurationValue = 1;\nvar endpointNumber = 3;\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nvar TransportWebUSB = /*#__PURE__*/function (_Transport) {\n  _inherits(TransportWebUSB, _Transport);\n  var _super = _createSuper(TransportWebUSB);\n  function TransportWebUSB(device, interfaceNumber) {\n    var _this;\n    _classCallCheck(this, TransportWebUSB);\n    _this = _super.call(this);\n    _this.device = void 0;\n    _this.deviceModel = void 0;\n    _this.channel = Math.floor(Math.random() * 0xffff);\n    _this.packetSize = 64;\n    _this.interfaceNumber = void 0;\n    _this._disconnectEmitted = false;\n    _this._emitDisconnect = function (e) {\n      if (_this._disconnectEmitted) return;\n      _this._disconnectEmitted = true;\n      _this.emit(\"disconnect\", e);\n    };\n    _this.exchange = function (apdu) {\n      return _this.exchangeAtomicImpl( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _assertThisInitialize, channel, packetSize, framing, blocks, i, result, acc, r, buffer;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _assertThisInitialize = _assertThisInitialized(_this), channel = _assertThisInitialize.channel, packetSize = _assertThisInitialize.packetSize;\n                log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n                framing = hidFraming(channel, packetSize); // Write...\n                blocks = framing.makeBlocks(apdu);\n                i = 0;\n              case 5:\n                if (!(i < blocks.length)) {\n                  _context.next = 11;\n                  break;\n                }\n                _context.next = 8;\n                return _this.device.transferOut(endpointNumber, blocks[i]);\n              case 8:\n                i++;\n                _context.next = 5;\n                break;\n              case 11:\n                if (result = framing.getReducedResult(acc)) {\n                  _context.next = 19;\n                  break;\n                }\n                _context.next = 14;\n                return _this.device.transferIn(endpointNumber, packetSize);\n              case 14:\n                r = _context.sent;\n                buffer = Buffer.from(r.data.buffer);\n                acc = framing.reduceResponse(acc, buffer);\n                _context.next = 11;\n                break;\n              case 19:\n                log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n                return _context.abrupt(\"return\", result);\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))).catch(function (e) {\n        if (e && e.message && e.message.includes(\"disconnected\")) {\n          _this._emitDisconnect(e);\n          throw new DisconnectedDeviceDuringOperation(e.message);\n        }\n        throw e;\n      });\n    };\n    _this.device = device;\n    _this.interfaceNumber = interfaceNumber;\n    _this.deviceModel = identifyUSBProductId(device.productId);\n    return _this;\n  }\n  /**\n   * Check if WebUSB transport is supported.\n   */\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  _createClass(TransportWebUSB, [{\n    key: \"close\",\n    value:\n    /**\n     * Release the transport device\n     */\n    function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.exchangeBusyPromise;\n              case 2:\n                _context2.next = 4;\n                return this.device.releaseInterface(this.interfaceNumber);\n              case 4:\n                _context2.next = 6;\n                return gracefullyResetDevice(this.device);\n              case 6:\n                _context2.next = 8;\n                return this.device.close();\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function close() {\n        return _close.apply(this, arguments);\n      }\n      return close;\n    }()\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey() {}\n  }], [{\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var device;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return requestLedgerDevice();\n              case 2:\n                device = _context3.sent;\n                return _context3.abrupt(\"return\", TransportWebUSB.open(device));\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      function request() {\n        return _request.apply(this, arguments);\n      }\n      return request;\n    }()\n    /**\n     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n     */\n  }, {\n    key: \"openConnected\",\n    value: function () {\n      var _openConnected = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var devices;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return getLedgerDevices();\n              case 2:\n                devices = _context4.sent;\n                if (!(devices.length === 0)) {\n                  _context4.next = 5;\n                  break;\n                }\n                return _context4.abrupt(\"return\", null);\n              case 5:\n                return _context4.abrupt(\"return\", TransportWebUSB.open(devices[0]));\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n      function openConnected() {\n        return _openConnected.apply(this, arguments);\n      }\n      return openConnected;\n    }()\n    /**\n     * Create a Ledger transport with a USBDevice\n     */\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(device) {\n        var iface, interfaceNumber, transport, onDisconnect;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return device.open();\n              case 2:\n                if (!(device.configuration === null)) {\n                  _context5.next = 5;\n                  break;\n                }\n                _context5.next = 5;\n                return device.selectConfiguration(configurationValue);\n              case 5:\n                _context5.next = 7;\n                return gracefullyResetDevice(device);\n              case 7:\n                iface = device.configurations[0].interfaces.find(function (_ref2) {\n                  var alternates = _ref2.alternates;\n                  return alternates.some(function (a) {\n                    return a.interfaceClass === 255;\n                  });\n                });\n                if (iface) {\n                  _context5.next = 10;\n                  break;\n                }\n                throw new TransportInterfaceNotAvailable(\"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\");\n              case 10:\n                interfaceNumber = iface.interfaceNumber;\n                _context5.prev = 11;\n                _context5.next = 14;\n                return device.claimInterface(interfaceNumber);\n              case 14:\n                _context5.next = 21;\n                break;\n              case 16:\n                _context5.prev = 16;\n                _context5.t0 = _context5[\"catch\"](11);\n                _context5.next = 20;\n                return device.close();\n              case 20:\n                throw new TransportInterfaceNotAvailable(_context5.t0.message);\n              case 21:\n                transport = new TransportWebUSB(device, interfaceNumber);\n                onDisconnect = function onDisconnect(e) {\n                  if (device === e.device) {\n                    // $FlowFixMe\n                    navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n                    transport._emitDisconnect(new DisconnectedDevice());\n                  }\n                }; // $FlowFixMe\n                navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n                return _context5.abrupt(\"return\", transport);\n              case 25:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[11, 16]]);\n      }));\n      function open(_x) {\n        return _open.apply(this, arguments);\n      }\n      return open;\n    }()\n  }]);\n  return TransportWebUSB;\n}(Transport);\nexport { TransportWebUSB as default };\nTransportWebUSB.isSupported = isSupported;\nTransportWebUSB.list = getLedgerDevices;\nTransportWebUSB.listen = function (observer) {\n  var unsubscribed = false;\n  getFirstLedgerDevice().then(function (device) {\n    if (!unsubscribed) {\n      var deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel: deviceModel\n      });\n      observer.complete();\n    }\n  }, function (error) {\n    if (window.DOMException && error instanceof window.DOMException && error.code === 18) {\n      observer.error(new TransportWebUSBGestureRequired(error.message));\n    } else {\n      observer.error(new TransportOpenUserCancelled(error.message));\n    }\n  });\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n  return {\n    unsubscribe: unsubscribe\n  };\n};\nfunction gracefullyResetDevice(_x2) {\n  return _gracefullyResetDevice.apply(this, arguments);\n}\nfunction _gracefullyResetDevice() {\n  _gracefullyResetDevice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(device) {\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.prev = 0;\n            _context6.next = 3;\n            return device.reset();\n          case 3:\n            _context6.next = 8;\n            break;\n          case 5:\n            _context6.prev = 5;\n            _context6.t0 = _context6[\"catch\"](0);\n            console.warn(_context6.t0);\n          case 8:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6, null, [[0, 5]]);\n  }));\n  return _gracefullyResetDevice.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/TransportWebUSB.js"],"names":["Transport","hidFraming","identifyUSBProductId","log","TransportOpenUserCancelled","TransportInterfaceNotAvailable","TransportWebUSBGestureRequired","DisconnectedDeviceDuringOperation","DisconnectedDevice","getLedgerDevices","getFirstLedgerDevice","requestLedgerDevice","isSupported","configurationValue","endpointNumber","TransportWebUSB","device","deviceModel","channel","Math","floor","random","packetSize","interfaceNumber","constructor","productId","list","listen","observer","unsubscribed","then","next","type","descriptor","complete","error","window","DOMException","code","message","unsubscribe","open","devices","length","configuration","selectConfiguration","gracefullyResetDevice","iface","configurations","interfaces","find","alternates","some","a","interfaceClass","claimInterface","close","e","transport","onDisconnect","navigator","usb","removeEventListener","_emitDisconnect","addEventListener","_disconnectEmitted","emit","exchangeBusyPromise","releaseInterface","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","i","transferOut","result","getReducedResult","acc","r","transferIn","buffer","Buffer","from","data","reduceResponse","catch","includes","setScrambleKey","reset","console","warn"],"mappings":"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","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable,\n  TransportWebUSBGestureRequired,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n} from \"@ledgerhq/errors\";\nimport {\n  getLedgerDevices,\n  getFirstLedgerDevice,\n  requestLedgerDevice,\n  isSupported,\n} from \"./webusb\";\n\nconst configurationValue = 1;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  interfaceNumber: number;\n\n  constructor(device: USBDevice, interfaceNumber: number) {\n    super();\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        if (\n          window.DOMException &&\n          error instanceof window.DOMException &&\n          error.code === 18\n        ) {\n          observer.error(new TransportWebUSBGestureRequired(error.message));\n        } else {\n          observer.error(new TransportOpenUserCancelled(error.message));\n        }\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    await gracefullyResetDevice(device);\n    const iface = device.configurations[0].interfaces.find(({ alternates }) =>\n      alternates.some((a) => a.interfaceClass === 255)\n    );\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\n        \"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\"\n      );\n    }\n    const interfaceNumber = iface.interfaceNumber;\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n    const transport = new TransportWebUSB(device, interfaceNumber);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    // $FlowFixMe\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n\nasync function gracefullyResetDevice(device: USBDevice) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}