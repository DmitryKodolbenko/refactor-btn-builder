{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SocketWrapper = void 0;\nconst isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\nfunction environmentIsNodeJs() {\n  return typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.node !== \"undefined\";\n}\n/**\n * A thin wrapper around isomorphic-ws' WebSocket class that adds\n * - constant message/error/open/close handlers\n * - explict connection via a connect() method\n * - type support for events\n * - handling of corner cases in the open and close behaviour\n */\nclass SocketWrapper {\n  constructor(url, messageHandler, errorHandler, openHandler, closeHandler) {\n    let timeout = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10000;\n    this.closed = false;\n    this.connected = new Promise((resolve, reject) => {\n      this.connectedResolver = resolve;\n      this.connectedRejecter = reject;\n    });\n    this.url = url;\n    this.messageHandler = messageHandler;\n    this.errorHandler = errorHandler;\n    this.openHandler = openHandler;\n    this.closeHandler = closeHandler;\n    this.timeout = timeout;\n  }\n  /**\n   * returns a promise that resolves when connection is open\n   */\n  connect() {\n    const socket = new isomorphic_ws_1.default(this.url);\n    socket.onerror = error => {\n      this.clearTimeout();\n      if (this.errorHandler) {\n        this.errorHandler(error);\n      }\n    };\n    socket.onmessage = messageEvent => {\n      this.messageHandler({\n        type: messageEvent.type,\n        data: messageEvent.data\n      });\n    };\n    socket.onopen = _ => {\n      this.clearTimeout();\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.connectedResolver();\n      if (this.openHandler) {\n        this.openHandler();\n      }\n    };\n    socket.onclose = closeEvent => {\n      this.closed = true;\n      if (this.closeHandler) {\n        this.closeHandler(closeEvent);\n      }\n    };\n    const started = Date.now();\n    this.timeoutId = setTimeout(() => {\n      socket.onmessage = () => 0;\n      socket.onerror = () => 0;\n      socket.onopen = () => 0;\n      socket.onclose = () => 0;\n      socket.close();\n      this.socket = undefined;\n      const elapsed = Math.floor(Date.now() - started);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.connectedRejecter(`Connection attempt timed out after ${elapsed} ms`);\n    }, this.timeout);\n    this.socket = socket;\n  }\n  /**\n   * Closes an established connection and aborts other connection states\n   */\n  disconnect() {\n    if (!this.socket) {\n      throw new Error(\"Socket undefined. This must be called after connecting.\");\n    }\n    this.clearTimeout();\n    switch (this.socket.readyState) {\n      case isomorphic_ws_1.default.OPEN:\n        this.socket.close(1000 /* Normal Closure */);\n        break;\n      case isomorphic_ws_1.default.CLOSED:\n        // nothing to be done\n        break;\n      case isomorphic_ws_1.default.CONNECTING:\n        // imitate missing abort API\n        this.socket.onopen = () => 0;\n        this.socket.onclose = () => 0;\n        this.socket.onerror = () => 0;\n        this.socket.onmessage = () => 0;\n        this.socket = undefined;\n        if (this.closeHandler) {\n          this.closeHandler({\n            wasClean: false,\n            code: 4001\n          });\n        }\n        break;\n      case isomorphic_ws_1.default.CLOSING:\n        // already closing. Let it proceed\n        break;\n      default:\n        throw new Error(`Unknown readyState: ${this.socket.readyState}`);\n    }\n  }\n  async send(data) {\n    return new Promise((resolve, reject) => {\n      if (!this.socket) {\n        throw new Error(\"Socket undefined. This must be called after connecting.\");\n      }\n      if (this.closed) {\n        throw new Error(\"Socket was closed, so no data can be sent anymore.\");\n      }\n      // this exception should be thrown by send() automatically according to\n      // https://developer.mozilla.org/de/docs/Web/API/WebSocket#send() but it does not work in browsers\n      if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {\n        throw new Error(\"Websocket is not open\");\n      }\n      if (environmentIsNodeJs()) {\n        this.socket.send(data, err => err ? reject(err) : resolve());\n      } else {\n        // Browser websocket send method does not accept a callback\n        this.socket.send(data);\n        resolve();\n      }\n    });\n  }\n  /**\n   * Clears the timeout function, such that no timeout error will be raised anymore. This should be\n   * called when the connection is established, a connection error occurred or the socket is disconnected.\n   *\n   * This method must not be called before `connect()`.\n   * This method is idempotent.\n   */\n  clearTimeout() {\n    if (!this.timeoutId) {\n      throw new Error(\"Timeout ID not set. This should not happen and usually means connect() was not called.\");\n    }\n    // Note: do not unset this.timeoutId to allow multiple calls to this function\n    clearTimeout(this.timeoutId);\n  }\n}\nexports.SocketWrapper = SocketWrapper;","map":{"version":3,"sources":["../src/socketwrapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SocketWrapper = void 0;\nconst isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\nfunction environmentIsNodeJs() {\n    return (typeof process !== \"undefined\" &&\n        typeof process.versions !== \"undefined\" &&\n        typeof process.versions.node !== \"undefined\");\n}\n/**\n * A thin wrapper around isomorphic-ws' WebSocket class that adds\n * - constant message/error/open/close handlers\n * - explict connection via a connect() method\n * - type support for events\n * - handling of corner cases in the open and close behaviour\n */\nclass SocketWrapper {\n    constructor(url, messageHandler, errorHandler, openHandler, closeHandler, timeout = 10000) {\n        this.closed = false;\n        this.connected = new Promise((resolve, reject) => {\n            this.connectedResolver = resolve;\n            this.connectedRejecter = reject;\n        });\n        this.url = url;\n        this.messageHandler = messageHandler;\n        this.errorHandler = errorHandler;\n        this.openHandler = openHandler;\n        this.closeHandler = closeHandler;\n        this.timeout = timeout;\n    }\n    /**\n     * returns a promise that resolves when connection is open\n     */\n    connect() {\n        const socket = new isomorphic_ws_1.default(this.url);\n        socket.onerror = (error) => {\n            this.clearTimeout();\n            if (this.errorHandler) {\n                this.errorHandler(error);\n            }\n        };\n        socket.onmessage = (messageEvent) => {\n            this.messageHandler({\n                type: messageEvent.type,\n                data: messageEvent.data,\n            });\n        };\n        socket.onopen = (_) => {\n            this.clearTimeout();\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.connectedResolver();\n            if (this.openHandler) {\n                this.openHandler();\n            }\n        };\n        socket.onclose = (closeEvent) => {\n            this.closed = true;\n            if (this.closeHandler) {\n                this.closeHandler(closeEvent);\n            }\n        };\n        const started = Date.now();\n        this.timeoutId = setTimeout(() => {\n            socket.onmessage = () => 0;\n            socket.onerror = () => 0;\n            socket.onopen = () => 0;\n            socket.onclose = () => 0;\n            socket.close();\n            this.socket = undefined;\n            const elapsed = Math.floor(Date.now() - started);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.connectedRejecter(`Connection attempt timed out after ${elapsed} ms`);\n        }, this.timeout);\n        this.socket = socket;\n    }\n    /**\n     * Closes an established connection and aborts other connection states\n     */\n    disconnect() {\n        if (!this.socket) {\n            throw new Error(\"Socket undefined. This must be called after connecting.\");\n        }\n        this.clearTimeout();\n        switch (this.socket.readyState) {\n            case isomorphic_ws_1.default.OPEN:\n                this.socket.close(1000 /* Normal Closure */);\n                break;\n            case isomorphic_ws_1.default.CLOSED:\n                // nothing to be done\n                break;\n            case isomorphic_ws_1.default.CONNECTING:\n                // imitate missing abort API\n                this.socket.onopen = () => 0;\n                this.socket.onclose = () => 0;\n                this.socket.onerror = () => 0;\n                this.socket.onmessage = () => 0;\n                this.socket = undefined;\n                if (this.closeHandler) {\n                    this.closeHandler({ wasClean: false, code: 4001 });\n                }\n                break;\n            case isomorphic_ws_1.default.CLOSING:\n                // already closing. Let it proceed\n                break;\n            default:\n                throw new Error(`Unknown readyState: ${this.socket.readyState}`);\n        }\n    }\n    async send(data) {\n        return new Promise((resolve, reject) => {\n            if (!this.socket) {\n                throw new Error(\"Socket undefined. This must be called after connecting.\");\n            }\n            if (this.closed) {\n                throw new Error(\"Socket was closed, so no data can be sent anymore.\");\n            }\n            // this exception should be thrown by send() automatically according to\n            // https://developer.mozilla.org/de/docs/Web/API/WebSocket#send() but it does not work in browsers\n            if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {\n                throw new Error(\"Websocket is not open\");\n            }\n            if (environmentIsNodeJs()) {\n                this.socket.send(data, (err) => (err ? reject(err) : resolve()));\n            }\n            else {\n                // Browser websocket send method does not accept a callback\n                this.socket.send(data);\n                resolve();\n            }\n        });\n    }\n    /**\n     * Clears the timeout function, such that no timeout error will be raised anymore. This should be\n     * called when the connection is established, a connection error occurred or the socket is disconnected.\n     *\n     * This method must not be called before `connect()`.\n     * This method is idempotent.\n     */\n    clearTimeout() {\n        if (!this.timeoutId) {\n            throw new Error(\"Timeout ID not set. This should not happen and usually means connect() was not called.\");\n        }\n        // Note: do not unset this.timeoutId to allow multiple calls to this function\n        clearTimeout(this.timeoutId);\n    }\n}\nexports.SocketWrapper = SocketWrapper;\n//# sourceMappingURL=socketwrapper.js.map"]},"metadata":{},"sourceType":"script"}