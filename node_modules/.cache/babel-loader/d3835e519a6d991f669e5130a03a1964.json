{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.topologicalSort = void 0;\nfunction topologicalSort(src) {\n  let pending = [src];\n  let allCells = new Map();\n  let notPermCells = new Set();\n  let sorted = [];\n  while (pending.length > 0) {\n    const cells = [...pending];\n    pending = [];\n    for (let cell of cells) {\n      const hash = cell.hash().toString('hex');\n      if (allCells.has(hash)) {\n        continue;\n      }\n      notPermCells.add(hash);\n      allCells.set(hash, {\n        cell: cell,\n        refs: cell.refs.map(v => v.hash().toString('hex'))\n      });\n      for (let r of cell.refs) {\n        pending.push(r);\n      }\n    }\n  }\n  let tempMark = new Set();\n  function visit(hash) {\n    if (!notPermCells.has(hash)) {\n      return;\n    }\n    if (tempMark.has(hash)) {\n      throw Error('Not a DAG');\n    }\n    tempMark.add(hash);\n    for (let c of allCells.get(hash).refs) {\n      visit(c);\n    }\n    sorted.unshift(hash);\n    tempMark.delete(hash);\n    notPermCells.delete(hash);\n  }\n  while (notPermCells.size > 0) {\n    const id = Array.from(notPermCells)[0];\n    visit(id);\n  }\n  let indexes = new Map();\n  for (let i = 0; i < sorted.length; i++) {\n    indexes.set(sorted[i], i);\n  }\n  let result = [];\n  for (let ent of sorted) {\n    const rrr = allCells.get(ent);\n    result.push({\n      cell: rrr.cell,\n      refs: rrr.refs.map(v => indexes.get(v))\n    });\n  }\n  return result;\n}\nexports.topologicalSort = topologicalSort;","map":{"version":3,"names":["Object","defineProperty","exports","value","topologicalSort","src","pending","allCells","Map","notPermCells","Set","sorted","length","cells","cell","hash","toString","has","add","set","refs","map","v","r","push","tempMark","visit","Error","c","get","unshift","delete","size","id","Array","from","indexes","i","result","ent","rrr"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/boc/utils/topologicalSort.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.topologicalSort = void 0;\nfunction topologicalSort(src) {\n    let pending = [src];\n    let allCells = new Map();\n    let notPermCells = new Set();\n    let sorted = [];\n    while (pending.length > 0) {\n        const cells = [...pending];\n        pending = [];\n        for (let cell of cells) {\n            const hash = cell.hash().toString('hex');\n            if (allCells.has(hash)) {\n                continue;\n            }\n            notPermCells.add(hash);\n            allCells.set(hash, { cell: cell, refs: cell.refs.map((v) => v.hash().toString('hex')) });\n            for (let r of cell.refs) {\n                pending.push(r);\n            }\n        }\n    }\n    let tempMark = new Set();\n    function visit(hash) {\n        if (!notPermCells.has(hash)) {\n            return;\n        }\n        if (tempMark.has(hash)) {\n            throw Error('Not a DAG');\n        }\n        tempMark.add(hash);\n        for (let c of allCells.get(hash).refs) {\n            visit(c);\n        }\n        sorted.unshift(hash);\n        tempMark.delete(hash);\n        notPermCells.delete(hash);\n    }\n    while (notPermCells.size > 0) {\n        const id = Array.from(notPermCells)[0];\n        visit(id);\n    }\n    let indexes = new Map();\n    for (let i = 0; i < sorted.length; i++) {\n        indexes.set(sorted[i], i);\n    }\n    let result = [];\n    for (let ent of sorted) {\n        const rrr = allCells.get(ent);\n        result.push({ cell: rrr.cell, refs: rrr.refs.map((v) => indexes.get(v)) });\n    }\n    return result;\n}\nexports.topologicalSort = topologicalSort;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}