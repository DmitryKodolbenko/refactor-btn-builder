{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\nconst crc16_1 = require(\"../utils/crc16\");\nconst bounceable_tag = 0x11;\nconst non_bounceable_tag = 0x51;\nconst test_flag = 0x80;\nfunction parseFriendlyAddress(src) {\n  const data = Buffer.isBuffer(src) ? src : Buffer.from(src, 'base64');\n  // 1byte tag + 1byte workchain + 32 bytes hash + 2 byte crc\n  if (data.length !== 36) {\n    throw new Error('Unknown address type: byte length is not equal to 36');\n  }\n  // Prepare data\n  const addr = data.slice(0, 34);\n  const crc = data.slice(34, 36);\n  const calcedCrc = (0, crc16_1.crc16)(addr);\n  if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {\n    throw new Error('Invalid checksum: ' + src);\n  }\n  // Parse tag\n  let tag = addr[0];\n  let isTestOnly = false;\n  let isBounceable = false;\n  if (tag & test_flag) {\n    isTestOnly = true;\n    tag = tag ^ test_flag;\n  }\n  if (tag !== bounceable_tag && tag !== non_bounceable_tag) throw \"Unknown address tag\";\n  isBounceable = tag === bounceable_tag;\n  let workchain = null;\n  if (addr[1] === 0xff) {\n    // TODO we should read signed integer here\n    workchain = -1;\n  } else {\n    workchain = addr[1];\n  }\n  const hashPart = addr.slice(2, 34);\n  return {\n    isTestOnly,\n    isBounceable,\n    workchain,\n    hashPart\n  };\n}\nclass Address {\n  constructor(workChain, hash) {\n    this.toString = () => {\n      return this.workChain + ':' + this.hash.toString('hex');\n    };\n    this.toBuffer = () => {\n      const addressWithChecksum = Buffer.alloc(36);\n      addressWithChecksum.set(this.hash);\n      addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);\n      return addressWithChecksum;\n    };\n    this.toFriendlyBuffer = args => {\n      let testOnly = args && args.testOnly !== undefined ? args.testOnly : false;\n      let bounceable = args && args.bounceable !== undefined ? args.bounceable : true;\n      let tag = bounceable ? bounceable_tag : non_bounceable_tag;\n      if (testOnly) {\n        tag |= test_flag;\n      }\n      const addr = Buffer.alloc(34);\n      addr[0] = tag;\n      addr[1] = this.workChain;\n      addr.set(this.hash, 2);\n      const addressWithChecksum = Buffer.alloc(36);\n      addressWithChecksum.set(addr);\n      addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);\n      return addressWithChecksum;\n    };\n    this.toFriendly = args => {\n      let urlSafe = args && args.urlSafe !== undefined ? args.urlSafe : true;\n      let buffer = this.toFriendlyBuffer(args);\n      if (urlSafe) {\n        return buffer.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_');\n      } else {\n        return buffer.toString('base64');\n      }\n    };\n    this[_a] = () => this.toFriendly();\n    this.workChain = workChain;\n    this.hash = hash;\n    Object.freeze(this);\n  }\n  static isFriendly(source) {\n    return source.indexOf(':') < 0;\n  }\n  static normalize(source) {\n    if (typeof source === 'string') {\n      return Address.parse(source).toFriendly();\n    } else {\n      return source.toFriendly();\n    }\n  }\n  static parse(source) {\n    if (Address.isFriendly(source)) {\n      return this.parseFriendly(source).address;\n    } else {\n      return this.parseRaw(source);\n    }\n  }\n  static parseRaw(source) {\n    let workChain = parseInt(source.split(\":\")[0]);\n    let hash = Buffer.from(source.split(\":\")[1], 'hex');\n    return new Address(workChain, hash);\n  }\n  static parseFriendly(source) {\n    if (Buffer.isBuffer(source)) {\n      let r = parseFriendlyAddress(source);\n      return {\n        isBounceable: r.isBounceable,\n        isTestOnly: r.isTestOnly,\n        address: new Address(r.workchain, r.hashPart)\n      };\n    } else {\n      let addr = source.replace(/\\-/g, '+').replace(/_/g, '\\/'); // Convert from url-friendly to true base64\n      let r = parseFriendlyAddress(addr);\n      return {\n        isBounceable: r.isBounceable,\n        isTestOnly: r.isTestOnly,\n        address: new Address(r.workchain, r.hashPart)\n      };\n    }\n  }\n  equals(src) {\n    if (src.workChain !== this.workChain) {\n      return false;\n    }\n    return src.hash.equals(this.hash);\n  }\n}\nexports.Address = Address;\n_a = symbol_inspect_1.default;","map":{"version":3,"names":["__importDefault","mod","__esModule","_a","Object","defineProperty","exports","value","Address","symbol_inspect_1","require","crc16_1","bounceable_tag","non_bounceable_tag","test_flag","parseFriendlyAddress","src","data","Buffer","isBuffer","from","length","Error","addr","slice","crc","calcedCrc","crc16","tag","isTestOnly","isBounceable","workchain","hashPart","constructor","workChain","hash","toString","toBuffer","addressWithChecksum","alloc","set","toFriendlyBuffer","args","testOnly","undefined","bounceable","toFriendly","urlSafe","buffer","replace","freeze","isFriendly","source","indexOf","normalize","parse","parseFriendly","address","parseRaw","parseInt","split","r","equals","default"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/address/Address.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Address = void 0;\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\nconst crc16_1 = require(\"../utils/crc16\");\nconst bounceable_tag = 0x11;\nconst non_bounceable_tag = 0x51;\nconst test_flag = 0x80;\nfunction parseFriendlyAddress(src) {\n    const data = Buffer.isBuffer(src) ? src : Buffer.from(src, 'base64');\n    // 1byte tag + 1byte workchain + 32 bytes hash + 2 byte crc\n    if (data.length !== 36) {\n        throw new Error('Unknown address type: byte length is not equal to 36');\n    }\n    // Prepare data\n    const addr = data.slice(0, 34);\n    const crc = data.slice(34, 36);\n    const calcedCrc = (0, crc16_1.crc16)(addr);\n    if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {\n        throw new Error('Invalid checksum: ' + src);\n    }\n    // Parse tag\n    let tag = addr[0];\n    let isTestOnly = false;\n    let isBounceable = false;\n    if (tag & test_flag) {\n        isTestOnly = true;\n        tag = tag ^ test_flag;\n    }\n    if ((tag !== bounceable_tag) && (tag !== non_bounceable_tag))\n        throw \"Unknown address tag\";\n    isBounceable = tag === bounceable_tag;\n    let workchain = null;\n    if (addr[1] === 0xff) { // TODO we should read signed integer here\n        workchain = -1;\n    }\n    else {\n        workchain = addr[1];\n    }\n    const hashPart = addr.slice(2, 34);\n    return { isTestOnly, isBounceable, workchain, hashPart };\n}\nclass Address {\n    constructor(workChain, hash) {\n        this.toString = () => {\n            return this.workChain + ':' + this.hash.toString('hex');\n        };\n        this.toBuffer = () => {\n            const addressWithChecksum = Buffer.alloc(36);\n            addressWithChecksum.set(this.hash);\n            addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);\n            return addressWithChecksum;\n        };\n        this.toFriendlyBuffer = (args) => {\n            let testOnly = (args && args.testOnly !== undefined) ? args.testOnly : false;\n            let bounceable = (args && args.bounceable !== undefined) ? args.bounceable : true;\n            let tag = bounceable ? bounceable_tag : non_bounceable_tag;\n            if (testOnly) {\n                tag |= test_flag;\n            }\n            const addr = Buffer.alloc(34);\n            addr[0] = tag;\n            addr[1] = this.workChain;\n            addr.set(this.hash, 2);\n            const addressWithChecksum = Buffer.alloc(36);\n            addressWithChecksum.set(addr);\n            addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);\n            return addressWithChecksum;\n        };\n        this.toFriendly = (args) => {\n            let urlSafe = (args && args.urlSafe !== undefined) ? args.urlSafe : true;\n            let buffer = this.toFriendlyBuffer(args);\n            if (urlSafe) {\n                return buffer.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_');\n            }\n            else {\n                return buffer.toString('base64');\n            }\n        };\n        this[_a] = () => this.toFriendly();\n        this.workChain = workChain;\n        this.hash = hash;\n        Object.freeze(this);\n    }\n    static isFriendly(source) {\n        return source.indexOf(':') < 0;\n    }\n    static normalize(source) {\n        if (typeof source === 'string') {\n            return Address.parse(source).toFriendly();\n        }\n        else {\n            return source.toFriendly();\n        }\n    }\n    static parse(source) {\n        if (Address.isFriendly(source)) {\n            return this.parseFriendly(source).address;\n        }\n        else {\n            return this.parseRaw(source);\n        }\n    }\n    static parseRaw(source) {\n        let workChain = parseInt(source.split(\":\")[0]);\n        let hash = Buffer.from(source.split(\":\")[1], 'hex');\n        return new Address(workChain, hash);\n    }\n    static parseFriendly(source) {\n        if (Buffer.isBuffer(source)) {\n            let r = parseFriendlyAddress(source);\n            return {\n                isBounceable: r.isBounceable,\n                isTestOnly: r.isTestOnly,\n                address: new Address(r.workchain, r.hashPart)\n            };\n        }\n        else {\n            let addr = source.replace(/\\-/g, '+').replace(/_/g, '\\/'); // Convert from url-friendly to true base64\n            let r = parseFriendlyAddress(addr);\n            return {\n                isBounceable: r.isBounceable,\n                isTestOnly: r.isTestOnly,\n                address: new Address(r.workchain, r.hashPart)\n            };\n        }\n    }\n    equals(src) {\n        if (src.workChain !== this.workChain) {\n            return false;\n        }\n        return src.hash.equals(this.hash);\n    }\n}\nexports.Address = Address;\n_a = symbol_inspect_1.default;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}