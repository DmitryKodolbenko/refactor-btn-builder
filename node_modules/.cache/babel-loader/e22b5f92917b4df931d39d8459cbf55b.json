{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ProofOps = exports.ProofOp = exports.DominoOp = exports.ValueOp = exports.Proof = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nexports.protobufPackage = \"tendermint.crypto\";\nconst baseProof = {\n  total: long_1.default.ZERO,\n  index: long_1.default.ZERO\n};\nexports.Proof = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (!message.total.isZero()) {\n      writer.uint32(8).int64(message.total);\n    }\n    if (!message.index.isZero()) {\n      writer.uint32(16).int64(message.index);\n    }\n    if (message.leafHash.length !== 0) {\n      writer.uint32(26).bytes(message.leafHash);\n    }\n    for (const v of message.aunts) {\n      writer.uint32(34).bytes(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseProof);\n    message.aunts = [];\n    message.leafHash = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.total = reader.int64();\n          break;\n        case 2:\n          message.index = reader.int64();\n          break;\n        case 3:\n          message.leafHash = reader.bytes();\n          break;\n        case 4:\n          message.aunts.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    var _a;\n    const message = Object.assign({}, baseProof);\n    message.total = object.total !== undefined && object.total !== null ? long_1.default.fromString(object.total) : long_1.default.ZERO;\n    message.index = object.index !== undefined && object.index !== null ? long_1.default.fromString(object.index) : long_1.default.ZERO;\n    message.leafHash = object.leafHash !== undefined && object.leafHash !== null ? bytesFromBase64(object.leafHash) : new Uint8Array();\n    message.aunts = ((_a = object.aunts) !== null && _a !== void 0 ? _a : []).map(e => bytesFromBase64(e));\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.total !== undefined && (obj.total = (message.total || long_1.default.ZERO).toString());\n    message.index !== undefined && (obj.index = (message.index || long_1.default.ZERO).toString());\n    message.leafHash !== undefined && (obj.leafHash = base64FromBytes(message.leafHash !== undefined ? message.leafHash : new Uint8Array()));\n    if (message.aunts) {\n      obj.aunts = message.aunts.map(e => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n    } else {\n      obj.aunts = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = Object.assign({}, baseProof);\n    message.total = object.total !== undefined && object.total !== null ? long_1.default.fromValue(object.total) : long_1.default.ZERO;\n    message.index = object.index !== undefined && object.index !== null ? long_1.default.fromValue(object.index) : long_1.default.ZERO;\n    message.leafHash = (_a = object.leafHash) !== null && _a !== void 0 ? _a : new Uint8Array();\n    message.aunts = ((_b = object.aunts) === null || _b === void 0 ? void 0 : _b.map(e => e)) || [];\n    return message;\n  }\n};\nconst baseValueOp = {};\nexports.ValueOp = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.proof !== undefined) {\n      exports.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseValueOp);\n    message.key = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.proof = exports.Proof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseValueOp);\n    message.key = object.key !== undefined && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();\n    message.proof = object.proof !== undefined && object.proof !== null ? exports.Proof.fromJSON(object.proof) : undefined;\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.proof !== undefined && (obj.proof = message.proof ? exports.Proof.toJSON(message.proof) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    var _a;\n    const message = Object.assign({}, baseValueOp);\n    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();\n    message.proof = object.proof !== undefined && object.proof !== null ? exports.Proof.fromPartial(object.proof) : undefined;\n    return message;\n  }\n};\nconst baseDominoOp = {\n  key: \"\",\n  input: \"\",\n  output: \"\"\n};\nexports.DominoOp = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.input !== \"\") {\n      writer.uint32(18).string(message.input);\n    }\n    if (message.output !== \"\") {\n      writer.uint32(26).string(message.output);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseDominoOp);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.string();\n          break;\n        case 2:\n          message.input = reader.string();\n          break;\n        case 3:\n          message.output = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseDominoOp);\n    message.key = object.key !== undefined && object.key !== null ? String(object.key) : \"\";\n    message.input = object.input !== undefined && object.input !== null ? String(object.input) : \"\";\n    message.output = object.output !== undefined && object.output !== null ? String(object.output) : \"\";\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = message.key);\n    message.input !== undefined && (obj.input = message.input);\n    message.output !== undefined && (obj.output = message.output);\n    return obj;\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = Object.assign({}, baseDominoOp);\n    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n    message.input = (_b = object.input) !== null && _b !== void 0 ? _b : \"\";\n    message.output = (_c = object.output) !== null && _c !== void 0 ? _c : \"\";\n    return message;\n  }\n};\nconst baseProofOp = {\n  type: \"\"\n};\nexports.ProofOp = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.type !== \"\") {\n      writer.uint32(10).string(message.type);\n    }\n    if (message.key.length !== 0) {\n      writer.uint32(18).bytes(message.key);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(26).bytes(message.data);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseProofOp);\n    message.key = new Uint8Array();\n    message.data = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.string();\n          break;\n        case 2:\n          message.key = reader.bytes();\n          break;\n        case 3:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseProofOp);\n    message.type = object.type !== undefined && object.type !== null ? String(object.type) : \"\";\n    message.key = object.key !== undefined && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();\n    message.data = object.data !== undefined && object.data !== null ? bytesFromBase64(object.data) : new Uint8Array();\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.type !== undefined && (obj.type = message.type);\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = Object.assign({}, baseProofOp);\n    message.type = (_a = object.type) !== null && _a !== void 0 ? _a : \"\";\n    message.key = (_b = object.key) !== null && _b !== void 0 ? _b : new Uint8Array();\n    message.data = (_c = object.data) !== null && _c !== void 0 ? _c : new Uint8Array();\n    return message;\n  }\n};\nconst baseProofOps = {};\nexports.ProofOps = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    for (const v of message.ops) {\n      exports.ProofOp.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseProofOps);\n    message.ops = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.ops.push(exports.ProofOp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    var _a;\n    const message = Object.assign({}, baseProofOps);\n    message.ops = ((_a = object.ops) !== null && _a !== void 0 ? _a : []).map(e => exports.ProofOp.fromJSON(e));\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.ops) {\n      obj.ops = message.ops.map(e => e ? exports.ProofOp.toJSON(e) : undefined);\n    } else {\n      obj.ops = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _a;\n    const message = Object.assign({}, baseProofOps);\n    message.ops = ((_a = object.ops) === null || _a === void 0 ? void 0 : _a.map(e => exports.ProofOp.fromPartial(e))) || [];\n    return message;\n  }\n};\nvar globalThis = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || (b64 => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\nconst btoa = globalThis.btoa || (bin => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n  const bin = [];\n  for (const byte of arr) {\n    bin.push(String.fromCharCode(byte));\n  }\n  return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}","map":{"version":3,"sources":["../../../src/tendermint/crypto/proof.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProofOps = exports.ProofOp = exports.DominoOp = exports.ValueOp = exports.Proof = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nexports.protobufPackage = \"tendermint.crypto\";\nconst baseProof = { total: long_1.default.ZERO, index: long_1.default.ZERO };\nexports.Proof = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (!message.total.isZero()) {\n            writer.uint32(8).int64(message.total);\n        }\n        if (!message.index.isZero()) {\n            writer.uint32(16).int64(message.index);\n        }\n        if (message.leafHash.length !== 0) {\n            writer.uint32(26).bytes(message.leafHash);\n        }\n        for (const v of message.aunts) {\n            writer.uint32(34).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseProof);\n        message.aunts = [];\n        message.leafHash = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.total = reader.int64();\n                    break;\n                case 2:\n                    message.index = reader.int64();\n                    break;\n                case 3:\n                    message.leafHash = reader.bytes();\n                    break;\n                case 4:\n                    message.aunts.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        var _a;\n        const message = Object.assign({}, baseProof);\n        message.total =\n            object.total !== undefined && object.total !== null ? long_1.default.fromString(object.total) : long_1.default.ZERO;\n        message.index =\n            object.index !== undefined && object.index !== null ? long_1.default.fromString(object.index) : long_1.default.ZERO;\n        message.leafHash =\n            object.leafHash !== undefined && object.leafHash !== null\n                ? bytesFromBase64(object.leafHash)\n                : new Uint8Array();\n        message.aunts = ((_a = object.aunts) !== null && _a !== void 0 ? _a : []).map((e) => bytesFromBase64(e));\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.total !== undefined && (obj.total = (message.total || long_1.default.ZERO).toString());\n        message.index !== undefined && (obj.index = (message.index || long_1.default.ZERO).toString());\n        message.leafHash !== undefined &&\n            (obj.leafHash = base64FromBytes(message.leafHash !== undefined ? message.leafHash : new Uint8Array()));\n        if (message.aunts) {\n            obj.aunts = message.aunts.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.aunts = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = Object.assign({}, baseProof);\n        message.total =\n            object.total !== undefined && object.total !== null ? long_1.default.fromValue(object.total) : long_1.default.ZERO;\n        message.index =\n            object.index !== undefined && object.index !== null ? long_1.default.fromValue(object.index) : long_1.default.ZERO;\n        message.leafHash = (_a = object.leafHash) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.aunts = ((_b = object.aunts) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];\n        return message;\n    },\n};\nconst baseValueOp = {};\nexports.ValueOp = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        if (message.proof !== undefined) {\n            exports.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseValueOp);\n        message.key = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.proof = exports.Proof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseValueOp);\n        message.key =\n            object.key !== undefined && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();\n        message.proof =\n            object.proof !== undefined && object.proof !== null ? exports.Proof.fromJSON(object.proof) : undefined;\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined &&\n            (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n        message.proof !== undefined && (obj.proof = message.proof ? exports.Proof.toJSON(message.proof) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = Object.assign({}, baseValueOp);\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.proof =\n            object.proof !== undefined && object.proof !== null ? exports.Proof.fromPartial(object.proof) : undefined;\n        return message;\n    },\n};\nconst baseDominoOp = { key: \"\", input: \"\", output: \"\" };\nexports.DominoOp = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.input !== \"\") {\n            writer.uint32(18).string(message.input);\n        }\n        if (message.output !== \"\") {\n            writer.uint32(26).string(message.output);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseDominoOp);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.input = reader.string();\n                    break;\n                case 3:\n                    message.output = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseDominoOp);\n        message.key = object.key !== undefined && object.key !== null ? String(object.key) : \"\";\n        message.input = object.input !== undefined && object.input !== null ? String(object.input) : \"\";\n        message.output = object.output !== undefined && object.output !== null ? String(object.output) : \"\";\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.input !== undefined && (obj.input = message.input);\n        message.output !== undefined && (obj.output = message.output);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = Object.assign({}, baseDominoOp);\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.input = (_b = object.input) !== null && _b !== void 0 ? _b : \"\";\n        message.output = (_c = object.output) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nconst baseProofOp = { type: \"\" };\nexports.ProofOp = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.type !== \"\") {\n            writer.uint32(10).string(message.type);\n        }\n        if (message.key.length !== 0) {\n            writer.uint32(18).bytes(message.key);\n        }\n        if (message.data.length !== 0) {\n            writer.uint32(26).bytes(message.data);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseProofOp);\n        message.key = new Uint8Array();\n        message.data = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = reader.string();\n                    break;\n                case 2:\n                    message.key = reader.bytes();\n                    break;\n                case 3:\n                    message.data = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseProofOp);\n        message.type = object.type !== undefined && object.type !== null ? String(object.type) : \"\";\n        message.key =\n            object.key !== undefined && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();\n        message.data =\n            object.data !== undefined && object.data !== null ? bytesFromBase64(object.data) : new Uint8Array();\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined && (obj.type = message.type);\n        message.key !== undefined &&\n            (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n        message.data !== undefined &&\n            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = Object.assign({}, baseProofOp);\n        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : \"\";\n        message.key = (_b = object.key) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.data = (_c = object.data) !== null && _c !== void 0 ? _c : new Uint8Array();\n        return message;\n    },\n};\nconst baseProofOps = {};\nexports.ProofOps = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.ops) {\n            exports.ProofOp.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseProofOps);\n        message.ops = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ops.push(exports.ProofOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        var _a;\n        const message = Object.assign({}, baseProofOps);\n        message.ops = ((_a = object.ops) !== null && _a !== void 0 ? _a : []).map((e) => exports.ProofOp.fromJSON(e));\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.ops) {\n            obj.ops = message.ops.map((e) => (e ? exports.ProofOp.toJSON(e) : undefined));\n        }\n        else {\n            obj.ops = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = Object.assign({}, baseProofOps);\n        message.ops = ((_a = object.ops) === null || _a === void 0 ? void 0 : _a.map((e) => exports.ProofOp.fromPartial(e))) || [];\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\n//# sourceMappingURL=proof.js.map"]},"metadata":{},"sourceType":"script"}