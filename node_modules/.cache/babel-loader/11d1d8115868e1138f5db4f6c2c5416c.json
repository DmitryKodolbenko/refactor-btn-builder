{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.firstEvent = exports.toListPromise = exports.fromListPromise = void 0;\nvar xstream_1 = require(\"xstream\");\n/**\n * Emits one event for each list element as soon as the promise resolves\n */\nfunction fromListPromise(promise) {\n  var producer = {\n    start: function start(listener) {\n      // the code in `start` runs as soon as anyone listens to the stream\n      promise.then(function (iterable) {\n        var _iterator = _createForOfIteratorHelper(iterable),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var element = _step.value;\n            listener.next(element);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        listener.complete();\n      }).catch(function (error) {\n        return listener.error(error);\n      });\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    stop: function stop() {}\n  };\n  return xstream_1.Stream.create(producer);\n}\nexports.fromListPromise = fromListPromise;\n/**\n * Listens to stream and collects events. When `count` events are collected,\n * the promise resolves with an array of events.\n *\n * Rejects if stream completes before `count` events are collected.\n */\nfunction toListPromise(_x, _x2) {\n  return _toListPromise.apply(this, arguments);\n}\nfunction _toListPromise() {\n  _toListPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(stream, count) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n              if (count === 0) {\n                resolve([]);\n                return;\n              }\n              var events = new Array();\n              // take() unsubscribes from source stream automatically\n              stream.take(count).subscribe({\n                next: function next(event) {\n                  events.push(event);\n                  if (events.length === count) {\n                    resolve(events);\n                  }\n                },\n                complete: function complete() {\n                  reject(\"Stream completed before all events could be collected. \" + \"Collected \".concat(events.length, \", expected \").concat(count));\n                },\n                error: function error(_error) {\n                  return reject(_error);\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _toListPromise.apply(this, arguments);\n}\nexports.toListPromise = toListPromise;\n/**\n * Listens to stream, collects one event and revolves.\n *\n * Rejects if stream completes before one event was fired.\n */\nfunction firstEvent(_x3) {\n  return _firstEvent.apply(this, arguments);\n}\nfunction _firstEvent() {\n  _firstEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(stream) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return toListPromise(stream, 1);\n          case 2:\n            return _context2.abrupt(\"return\", _context2.sent[0]);\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _firstEvent.apply(this, arguments);\n}\nexports.firstEvent = firstEvent;","map":{"version":3,"sources":["../src/promise.ts"],"names":[],"mappings":";;;;;;;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA;;AAEG;AACH,SAAgB,eAAe,CAAI,OAA6B,EAAA;EAC9D,IAAM,QAAQ,GAAgB;IAC5B,KAAK,EAAE,eAAC,QAAQ,EAAI;MAClB;MACA,OAAO,CACJ,IAAI,CAAC,UAAC,QAAQ,EAAI;QAAA,2CACK,QAAQ;UAAA;QAAA;UAA9B,oDAAgC;YAAA,IAArB,OAAO;YAChB,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC;;QACvB;UAAA;QAAA;UAAA;QAAA;QACD,QAAQ,CAAC,QAAQ,EAAE;MACrB,CAAC,CAAC,CACD,KAAK,CAAC,UAAC,KAAK;QAAA,OAAK,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC;MAAA,EAAC;IAC5C,CAAC;IACD;IACA,IAAI,EAAE,gBAAK,CAAE;GACd;EAED,OAAO,SAAA,CAAA,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC;AAChC;AAlBA,OAAA,CAAA,eAAA,GAAA,eAAA;AAoBA;;;;;AAKG;AALH,SAMsB,aAAa;EAAA;AAAA;AAAA;EAAA,4EAA5B,iBAAgC,MAAiB,EAAE,KAAa;IAAA;MAAA;QAAA;UAAA;YAAA,iCAC9D,IAAI,OAAO,CAAe,UAAC,OAAO,EAAE,MAAM,EAAI;cACnD,IAAI,KAAK,KAAK,CAAC,EAAE;gBACf,OAAO,CAAC,EAAE,CAAC;gBACX;cACD;cAED,IAAM,MAAM,GAAG,IAAI,KAAK,EAAK;cAC7B;cACA,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC;gBAC3B,IAAI,EAAE,cAAC,KAAK,EAAI;kBACd,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;kBAElB,IAAI,MAAM,CAAC,MAAM,KAAK,KAAK,EAAE;oBAC3B,OAAO,CAAC,MAAM,CAAC;kBAChB;gBACH,CAAC;gBACD,QAAQ,EAAE,oBAAK;kBACb,MAAM,CACJ,gFACe,MAAM,CAAC,MAAM,wBAAc,KAAK,CAAE,CAClD;gBACH,CAAC;gBACD,KAAK,EAAE,eAAC,MAAK;kBAAA,OAAK,MAAM,CAAC,MAAK,CAAC;gBAAA;eAChC,CAAC;YACJ,CAAC,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACH;EAAA;AAAA;AA1BD,OAAA,CAAA,aAAA,GAAA,aAAA;AA4BA;;;;AAIG;AAJH,SAKsB,UAAU;EAAA;AAAA;AAAA;EAAA,yEAAzB,kBAA6B,MAAiB;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,OACrC,aAAa,CAAC,MAAM,EAAE,CAAC,CAAC;UAAA;YAAA,iDAAE,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAC1C;EAAA;AAAA;AAFD,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.firstEvent = exports.toListPromise = exports.fromListPromise = void 0;\nconst xstream_1 = require(\"xstream\");\n/**\n * Emits one event for each list element as soon as the promise resolves\n */\nfunction fromListPromise(promise) {\n    const producer = {\n        start: (listener) => {\n            // the code in `start` runs as soon as anyone listens to the stream\n            promise\n                .then((iterable) => {\n                for (const element of iterable) {\n                    listener.next(element);\n                }\n                listener.complete();\n            })\n                .catch((error) => listener.error(error));\n        },\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        stop: () => { },\n    };\n    return xstream_1.Stream.create(producer);\n}\nexports.fromListPromise = fromListPromise;\n/**\n * Listens to stream and collects events. When `count` events are collected,\n * the promise resolves with an array of events.\n *\n * Rejects if stream completes before `count` events are collected.\n */\nasync function toListPromise(stream, count) {\n    return new Promise((resolve, reject) => {\n        if (count === 0) {\n            resolve([]);\n            return;\n        }\n        const events = new Array();\n        // take() unsubscribes from source stream automatically\n        stream.take(count).subscribe({\n            next: (event) => {\n                events.push(event);\n                if (events.length === count) {\n                    resolve(events);\n                }\n            },\n            complete: () => {\n                reject(`Stream completed before all events could be collected. ` +\n                    `Collected ${events.length}, expected ${count}`);\n            },\n            error: (error) => reject(error),\n        });\n    });\n}\nexports.toListPromise = toListPromise;\n/**\n * Listens to stream, collects one event and revolves.\n *\n * Rejects if stream completes before one event was fired.\n */\nasync function firstEvent(stream) {\n    return (await toListPromise(stream, 1))[0];\n}\nexports.firstEvent = firstEvent;\n//# sourceMappingURL=promise.js.map"]},"metadata":{},"sourceType":"script"}