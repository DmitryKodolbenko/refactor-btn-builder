{"ast":null,"code":"const {\n  BN,\n  bytesToHex\n} = require(\"../utils\");\nclass BitString {\n  /**\n   * @param length {number}    length of BitString in bits\n   */\n  constructor(length) {\n    this.array = Uint8Array.from({\n      length: Math.ceil(length / 8)\n    }, () => 0);\n    this.cursor = 0;\n    this.length = length;\n  }\n\n  /**\n   * @return {number}\n   */\n  getFreeBits() {\n    return this.length - this.cursor;\n  }\n\n  /**\n   * @return {number}\n   */\n  getUsedBits() {\n    return this.cursor;\n  }\n\n  /**\n   * @return {number}\n   */\n  getUsedBytes() {\n    return Math.ceil(this.cursor / 8);\n  }\n\n  /**\n   * @param n {number}\n   * @return {boolean}    bit value at position `n`\n   */\n  get(n) {\n    return (this.array[n / 8 | 0] & 1 << 7 - n % 8) > 0;\n  }\n\n  /**\n   * @private\n   * @param n {number}\n   */\n  checkRange(n) {\n    if (n > this.length) {\n      throw Error(\"BitString overflow\");\n    }\n  }\n\n  /**\n   * Set bit value to 1 at position `n`\n   * @param n {number}\n   */\n  on(n) {\n    this.checkRange(n);\n    this.array[n / 8 | 0] |= 1 << 7 - n % 8;\n  }\n\n  /**\n   * Set bit value to 0 at position `n`\n   * @param n {number}\n   */\n  off(n) {\n    this.checkRange(n);\n    this.array[n / 8 | 0] &= ~(1 << 7 - n % 8);\n  }\n\n  /**\n   * Toggle bit value at position `n`\n   * @param n {number}\n   */\n  toggle(n) {\n    this.checkRange(n);\n    this.array[n / 8 | 0] ^= 1 << 7 - n % 8;\n  }\n\n  /**\n   * forEach every bit\n   * @param callback  {function(boolean): void}\n   */\n  forEach(callback) {\n    const max = this.cursor;\n    for (let x = 0; x < max; x++) {\n      callback(this.get(x));\n    }\n  }\n\n  /**\n   * Write bit and increase cursor\n   * @param b  {boolean | number}\n   */\n  writeBit(b) {\n    if (b && b > 0) {\n      this.on(this.cursor);\n    } else {\n      this.off(this.cursor);\n    }\n    this.cursor = this.cursor + 1;\n  }\n\n  /**\n   * @param ba  {Array<boolean | number>}\n   */\n  writeBitArray(ba) {\n    for (let i = 0; i < ba.length; i++) {\n      this.writeBit(ba[i]);\n    }\n  }\n\n  /**\n   * Write unsigned int\n   * @param number  {number | BN}\n   * @param bitLength  {number}  size of uint in bits\n   */\n  writeUint(number, bitLength) {\n    number = new BN(number);\n    if (bitLength == 0 || number.toString(2).length > bitLength) {\n      if (number == 0) return;\n      throw Error(\"bitLength is too small for number, got number=\" + number + \",bitLength=\" + bitLength);\n    }\n    const s = number.toString(2, bitLength);\n    for (let i = 0; i < bitLength; i++) {\n      this.writeBit(s[i] == 1);\n    }\n  }\n\n  /**\n   * Write signed int\n   * @param number  {number | BN}\n   * @param bitLength  {number}  size of int in bits\n   */\n  writeInt(number, bitLength) {\n    number = new BN(number);\n    if (bitLength == 1) {\n      if (number == -1) {\n        this.writeBit(true);\n        return;\n      }\n      if (number == 0) {\n        this.writeBit(false);\n        return;\n      }\n      throw Error(\"Bitlength is too small for number\");\n    } else {\n      if (number.isNeg()) {\n        this.writeBit(true);\n        const b = new BN(2);\n        const nb = b.pow(new BN(bitLength - 1));\n        this.writeUint(nb.add(number), bitLength - 1);\n      } else {\n        this.writeBit(false);\n        this.writeUint(number, bitLength - 1);\n      }\n    }\n  }\n\n  /**\n   * Write unsigned 8-bit int\n   * @param ui8 {number}\n   */\n  writeUint8(ui8) {\n    this.writeUint(ui8, 8);\n  }\n\n  /**\n   * Write array of unsigned 8-bit ints\n   * @param ui8 {Uint8Array}\n   */\n  writeBytes(ui8) {\n    for (let i = 0; i < ui8.length; i++) {\n      this.writeUint8(ui8[i]);\n    }\n  }\n\n  /**\n   * @param s {string}\n   */\n  writeString(s) {\n    for (let i = 0; i < s.length; i++) {\n      this.writeUint8(s.charCodeAt(i));\n    }\n  }\n\n  /**\n   * @param amount  {number | BN} in nanograms\n   */\n  writeGrams(amount) {\n    if (amount == 0) {\n      this.writeUint(0, 4);\n    } else {\n      amount = new BN(amount);\n      const l = Math.ceil(amount.toString(16).length / 2);\n      this.writeUint(l, 4);\n      this.writeUint(amount, l * 8);\n    }\n  }\n\n  /**\n   * @param amount  {number | BN} in nanotons\n   */\n  writeCoins(amount) {\n    this.writeGrams(amount);\n  }\n\n  //addr_none$00 = MsgAddressExt;\n  //addr_std$10 anycast:(Maybe Anycast)\n  // workchain_id:int8 address:uint256 = MsgAddressInt;\n  /**\n   * @param address {Address | null}\n   */\n  writeAddress(address) {\n    if (address == null) {\n      this.writeUint(0, 2);\n    } else {\n      this.writeUint(2, 2);\n      this.writeUint(0, 1); // TODO split addresses (anycast)\n      this.writeInt(address.wc, 8);\n      this.writeBytes(address.hashPart);\n    }\n  }\n\n  /**\n   * write another BitString to this BitString\n   * @param anotherBitString  {BitString}\n   */\n  writeBitString(anotherBitString) {\n    anotherBitString.forEach(x => {\n      this.writeBit(x);\n    });\n  }\n  clone() {\n    const result = new BitString(0);\n    result.array = this.array.slice(0);\n    result.length = this.length;\n    result.cursor = this.cursor;\n    return result;\n  }\n\n  /**\n   * @return {string} hex\n   */\n  toString() {\n    return this.toHex();\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  getTopUppedArray() {\n    const ret = this.clone();\n    let tu = Math.ceil(ret.cursor / 8) * 8 - ret.cursor;\n    if (tu > 0) {\n      tu = tu - 1;\n      ret.writeBit(true);\n      while (tu > 0) {\n        tu = tu - 1;\n        ret.writeBit(false);\n      }\n    }\n    ret.array = ret.array.slice(0, Math.ceil(ret.cursor / 8));\n    return ret.array;\n  }\n\n  /**\n   * like Fift\n   * @return {string}\n   */\n  toHex() {\n    if (this.cursor % 4 === 0) {\n      const s = bytesToHex(this.array.slice(0, Math.ceil(this.cursor / 8))).toUpperCase();\n      if (this.cursor % 8 === 0) {\n        return s;\n      } else {\n        return s.substr(0, s.length - 1);\n      }\n    } else {\n      const temp = this.clone();\n      temp.writeBit(1);\n      while (temp.cursor % 4 !== 0) {\n        temp.writeBit(0);\n      }\n      const hex = temp.toHex().toUpperCase();\n      return hex + '_';\n    }\n  }\n\n  /**\n   * set this cell data to match provided topUppedArray\n   * @param array  {Uint8Array}\n   * @param fullfilledBytes  {boolean}\n   */\n  setTopUppedArray(array) {\n    let fullfilledBytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.length = array.length * 8;\n    this.array = array;\n    this.cursor = this.length;\n    if (fullfilledBytes || !this.length) {\n      return;\n    } else {\n      let foundEndBit = false;\n      for (let c = 0; c < 7; c++) {\n        this.cursor -= 1;\n        if (this.get(this.cursor)) {\n          foundEndBit = true;\n          this.off(this.cursor);\n          break;\n        }\n      }\n      if (!foundEndBit) {\n        console.log(array, fullfilledBytes);\n        throw new Error(\"Incorrect TopUppedArray\");\n      }\n    }\n  }\n}\nmodule.exports = {\n  BitString\n};","map":{"version":3,"names":["BN","bytesToHex","require","BitString","constructor","length","array","Uint8Array","from","Math","ceil","cursor","getFreeBits","getUsedBits","getUsedBytes","get","n","checkRange","Error","on","off","toggle","forEach","callback","max","x","writeBit","b","writeBitArray","ba","i","writeUint","number","bitLength","toString","s","writeInt","isNeg","nb","pow","add","writeUint8","ui8","writeBytes","writeString","charCodeAt","writeGrams","amount","l","writeCoins","writeAddress","address","wc","hashPart","writeBitString","anotherBitString","clone","result","slice","toHex","getTopUppedArray","ret","tu","toUpperCase","substr","temp","hex","setTopUppedArray","fullfilledBytes","foundEndBit","c","console","log","module","exports"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/tonweb/src/boc/BitString.js"],"sourcesContent":["const {BN, bytesToHex} = require(\"../utils\");\n\nclass BitString {\n    /**\n     * @param length {number}    length of BitString in bits\n     */\n    constructor(length) {\n        this.array = Uint8Array.from({length: Math.ceil(length / 8)}, () => 0);\n        this.cursor = 0;\n        this.length = length;\n    }\n\n    /**\n     * @return {number}\n     */\n    getFreeBits() {\n        return this.length - this.cursor;\n    }\n\n    /**\n     * @return {number}\n     */\n    getUsedBits() {\n        return this.cursor;\n    }\n\n    /**\n     * @return {number}\n     */\n    getUsedBytes() {\n        return Math.ceil(this.cursor / 8);\n    }\n\n    /**\n     * @param n {number}\n     * @return {boolean}    bit value at position `n`\n     */\n    get(n) {\n        return (this.array[(n / 8) | 0] & (1 << (7 - (n % 8)))) > 0;\n    }\n\n    /**\n     * @private\n     * @param n {number}\n     */\n    checkRange(n) {\n        if (n > this.length) {\n            throw Error(\"BitString overflow\");\n        }\n    }\n\n    /**\n     * Set bit value to 1 at position `n`\n     * @param n {number}\n     */\n    on(n) {\n        this.checkRange(n);\n        this.array[(n / 8) | 0] |= 1 << (7 - (n % 8));\n    }\n\n    /**\n     * Set bit value to 0 at position `n`\n     * @param n {number}\n     */\n    off(n) {\n        this.checkRange(n);\n        this.array[(n / 8) | 0] &= ~(1 << (7 - (n % 8)));\n    }\n\n    /**\n     * Toggle bit value at position `n`\n     * @param n {number}\n     */\n    toggle(n) {\n        this.checkRange(n);\n        this.array[(n / 8) | 0] ^= 1 << (7 - (n % 8));\n    }\n\n    /**\n     * forEach every bit\n     * @param callback  {function(boolean): void}\n     */\n    forEach(callback) {\n        const max = this.cursor;\n        for (let x = 0; x < max; x++) {\n            callback(this.get(x));\n        }\n    }\n\n    /**\n     * Write bit and increase cursor\n     * @param b  {boolean | number}\n     */\n    writeBit(b) {\n        if (b && b > 0) {\n            this.on(this.cursor);\n        } else {\n            this.off(this.cursor);\n        }\n        this.cursor = this.cursor + 1;\n    }\n\n    /**\n     * @param ba  {Array<boolean | number>}\n     */\n    writeBitArray(ba) {\n        for (let i = 0; i < ba.length; i++) {\n            this.writeBit(ba[i]);\n        }\n    }\n\n    /**\n     * Write unsigned int\n     * @param number  {number | BN}\n     * @param bitLength  {number}  size of uint in bits\n     */\n    writeUint(number, bitLength) {\n        number = new BN(number);\n        if (\n            bitLength == 0 ||\n            (number.toString(2).length > bitLength)\n        ) {\n            if (number == 0) return;\n            throw Error(\"bitLength is too small for number, got number=\" + number + \",bitLength=\" + bitLength);\n        }\n        const s = number.toString(2, bitLength);\n        for (let i = 0; i < bitLength; i++) {\n            this.writeBit(s[i] == 1);\n        }\n    }\n\n    /**\n     * Write signed int\n     * @param number  {number | BN}\n     * @param bitLength  {number}  size of int in bits\n     */\n    writeInt(number, bitLength) {\n        number = new BN(number);\n        if (bitLength == 1) {\n            if (number == -1) {\n                this.writeBit(true);\n                return;\n            }\n            if (number == 0) {\n                this.writeBit(false);\n                return;\n            }\n            throw Error(\"Bitlength is too small for number\");\n        } else {\n            if (number.isNeg()) {\n                this.writeBit(true);\n                const b = new BN(2);\n                const nb = b.pow(new BN(bitLength - 1));\n                this.writeUint(nb.add(number), bitLength - 1);\n            } else {\n                this.writeBit(false);\n                this.writeUint(number, bitLength - 1);\n            }\n        }\n    }\n\n    /**\n     * Write unsigned 8-bit int\n     * @param ui8 {number}\n     */\n    writeUint8(ui8) {\n        this.writeUint(ui8, 8);\n    }\n\n    /**\n     * Write array of unsigned 8-bit ints\n     * @param ui8 {Uint8Array}\n     */\n    writeBytes(ui8) {\n        for (let i = 0; i < ui8.length; i++) {\n            this.writeUint8(ui8[i]);\n        }\n    }\n\n    /**\n     * @param s {string}\n     */\n    writeString(s) {\n        for (let i = 0; i < s.length; i++) {\n            this.writeUint8(s.charCodeAt(i));\n        }\n    }\n\n    /**\n     * @param amount  {number | BN} in nanograms\n     */\n    writeGrams(amount) {\n        if (amount == 0) {\n            this.writeUint(0, 4);\n        } else {\n            amount = new BN(amount);\n            const l = Math.ceil((amount.toString(16).length) / 2);\n            this.writeUint(l, 4);\n            this.writeUint(amount, l * 8);\n        }\n    }\n\n\n    /**\n     * @param amount  {number | BN} in nanotons\n     */\n    writeCoins(amount) {\n        this.writeGrams(amount);\n    }\n\n    //addr_none$00 = MsgAddressExt;\n    //addr_std$10 anycast:(Maybe Anycast)\n    // workchain_id:int8 address:uint256 = MsgAddressInt;\n    /**\n     * @param address {Address | null}\n     */\n    writeAddress(address) {\n        if (address == null) {\n            this.writeUint(0, 2);\n        } else {\n            this.writeUint(2, 2);\n            this.writeUint(0, 1); // TODO split addresses (anycast)\n            this.writeInt(address.wc, 8);\n            this.writeBytes(address.hashPart);\n        }\n    }\n\n    /**\n     * write another BitString to this BitString\n     * @param anotherBitString  {BitString}\n     */\n    writeBitString(anotherBitString) {\n        anotherBitString.forEach(x => {\n            this.writeBit(x);\n        });\n    }\n\n    clone() {\n        const result = new BitString(0);\n        result.array = this.array.slice(0);\n        result.length = this.length\n        result.cursor = this.cursor;\n        return result;\n    }\n\n    /**\n     * @return {string} hex\n     */\n    toString() {\n        return this.toHex();\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n    getTopUppedArray() {\n        const ret = this.clone();\n\n        let tu = Math.ceil(ret.cursor / 8) * 8 - ret.cursor;\n        if (tu > 0) {\n            tu = tu - 1;\n            ret.writeBit(true);\n            while (tu > 0) {\n                tu = tu - 1;\n                ret.writeBit(false);\n            }\n        }\n        ret.array = ret.array.slice(0, Math.ceil(ret.cursor / 8));\n        return ret.array;\n    }\n\n    /**\n     * like Fift\n     * @return {string}\n     */\n    toHex() {\n        if (this.cursor % 4 === 0) {\n            const s = bytesToHex(this.array.slice(0, Math.ceil(this.cursor / 8))).toUpperCase();\n            if (this.cursor % 8 === 0) {\n                return s;\n            } else {\n                return s.substr(0, s.length - 1);\n            }\n        } else {\n            const temp = this.clone();\n            temp.writeBit(1);\n            while (temp.cursor % 4 !== 0) {\n                temp.writeBit(0);\n            }\n            const hex = temp.toHex().toUpperCase();\n            return hex + '_';\n        }\n    }\n\n    /**\n     * set this cell data to match provided topUppedArray\n     * @param array  {Uint8Array}\n     * @param fullfilledBytes  {boolean}\n     */\n    setTopUppedArray(array, fullfilledBytes = true) {\n        this.length = array.length * 8;\n        this.array = array;\n        this.cursor = this.length;\n        if (fullfilledBytes || !this.length) {\n            return;\n        } else {\n            let foundEndBit = false;\n            for (let c = 0; c < 7; c++) {\n                this.cursor -= 1;\n                if (this.get(this.cursor)) {\n                    foundEndBit = true;\n                    this.off(this.cursor);\n                    break;\n                }\n            }\n            if (!foundEndBit) {\n                console.log(array, fullfilledBytes);\n                throw new Error(\"Incorrect TopUppedArray\");\n            }\n        }\n    }\n}\n\nmodule.exports = {BitString};"],"mappings":"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"},"metadata":{},"sourceType":"script"}