{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeCosmosSdkDecFromProto = exports.longify = exports.createProtobufRpcClient = exports.createPagination = exports.toAccAddress = void 0;\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nconst pagination_1 = require(\"cosmjs-types/cosmos/base/query/v1beta1/pagination\");\nconst long_1 = __importDefault(require(\"long\"));\n/**\n * Takes a bech32 encoded address and returns the data part. The prefix is ignored and discarded.\n * This is called AccAddress in Cosmos SDK, which is basically an alias for raw binary data.\n * The result is typically 20 bytes long but not restricted to that.\n */\nfunction toAccAddress(address) {\n  return (0, encoding_1.fromBech32)(address).data;\n}\nexports.toAccAddress = toAccAddress;\n/**\n * If paginationKey is set, return a `PageRequest` with the given key.\n * If paginationKey is unset, return `undefined`.\n *\n * Use this with a query response's pagination next key to\n * request the next page.\n */\nfunction createPagination(paginationKey) {\n  return paginationKey ? pagination_1.PageRequest.fromPartial({\n    key: paginationKey,\n    offset: long_1.default.fromNumber(0, true),\n    limit: long_1.default.fromNumber(0, true),\n    countTotal: false\n  }) : undefined;\n}\nexports.createPagination = createPagination;\nfunction createProtobufRpcClient(base) {\n  return {\n    request: (service, method, data) => {\n      const path = `/${service}/${method}`;\n      return base.queryUnverified(path, data);\n    }\n  };\n}\nexports.createProtobufRpcClient = createProtobufRpcClient;\n/**\n * Takes a uint64 value as string, number, Long or Uint64 and returns an unsigned Long instance\n * of it.\n */\nfunction longify(value) {\n  const checkedValue = math_1.Uint64.fromString(value.toString());\n  return long_1.default.fromBytesBE([...checkedValue.toBytesBigEndian()], true);\n}\nexports.longify = longify;\n/**\n * Takes a string or binary encoded `github.com/cosmos/cosmos-sdk/types.Dec` from the\n * protobuf API and converts it into a `Decimal` with 18 fractional digits.\n *\n * See https://github.com/cosmos/cosmos-sdk/issues/10863 for more context why this is needed.\n */\nfunction decodeCosmosSdkDecFromProto(input) {\n  const asString = typeof input === \"string\" ? input : (0, encoding_1.fromAscii)(input);\n  return math_1.Decimal.fromAtomics(asString, 18);\n}\nexports.decodeCosmosSdkDecFromProto = decodeCosmosSdkDecFromProto;","map":{"version":3,"sources":["../../src/queryclient/utils.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,MAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,mDAAA,CAAA;AACA,MAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;AAIA;;;;AAIG;AACH,SAAgB,YAAY,CAAC,OAAe,EAAA;EAC1C,OAAO,CAAA,CAAA,EAAA,UAAA,CAAA,UAAU,EAAC,OAAO,CAAC,CAAC,IAAI;AACjC;AAFA,OAAA,CAAA,YAAA,GAAA,YAAA;AAIA;;;;;;AAMG;AACH,SAAgB,gBAAgB,CAAC,aAA0B,EAAA;EACzD,OAAO,aAAa,GAChB,YAAA,CAAA,WAAW,CAAC,WAAW,CAAC;IACtB,GAAG,EAAE,aAAa;IAClB,MAAM,EAAE,MAAA,CAAA,OAAI,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC;IAChC,KAAK,EAAE,MAAA,CAAA,OAAI,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC;IAC/B,UAAU,EAAE;GACb,CAAC,GACF,SAAS;AACf;AATA,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAeA,SAAgB,uBAAuB,CAAC,IAAiB,EAAA;EACvD,OAAO;IACL,OAAO,EAAE,CAAC,OAAe,EAAE,MAAc,EAAE,IAAgB,KAAyB;MAClF,MAAM,IAAI,GAAG,IAAI,OAAO,IAAI,MAAM,EAAE;MACpC,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC;IACzC;GACD;AACH;AAPA,OAAA,CAAA,uBAAA,GAAA,uBAAA;AASA;;;AAGG;AACH,SAAgB,OAAO,CAAC,KAAsC,EAAA;EAC5D,MAAM,YAAY,GAAG,MAAA,CAAA,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;EACxD,OAAO,MAAA,CAAA,OAAI,CAAC,WAAW,CAAC,CAAC,GAAG,YAAY,CAAC,gBAAgB,EAAE,CAAC,EAAE,IAAI,CAAC;AACrE;AAHA,OAAA,CAAA,OAAA,GAAA,OAAA;AAKA;;;;;AAKG;AACH,SAAgB,2BAA2B,CAAC,KAA0B,EAAA;EACpE,MAAM,QAAQ,GAAG,OAAO,KAAK,KAAK,QAAQ,GAAG,KAAK,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,SAAS,EAAC,KAAK,CAAC;EACrE,OAAO,MAAA,CAAA,OAAO,CAAC,WAAW,CAAC,QAAQ,EAAE,EAAE,CAAC;AAC1C;AAHA,OAAA,CAAA,2BAAA,GAAA,2BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeCosmosSdkDecFromProto = exports.longify = exports.createProtobufRpcClient = exports.createPagination = exports.toAccAddress = void 0;\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nconst pagination_1 = require(\"cosmjs-types/cosmos/base/query/v1beta1/pagination\");\nconst long_1 = __importDefault(require(\"long\"));\n/**\n * Takes a bech32 encoded address and returns the data part. The prefix is ignored and discarded.\n * This is called AccAddress in Cosmos SDK, which is basically an alias for raw binary data.\n * The result is typically 20 bytes long but not restricted to that.\n */\nfunction toAccAddress(address) {\n    return (0, encoding_1.fromBech32)(address).data;\n}\nexports.toAccAddress = toAccAddress;\n/**\n * If paginationKey is set, return a `PageRequest` with the given key.\n * If paginationKey is unset, return `undefined`.\n *\n * Use this with a query response's pagination next key to\n * request the next page.\n */\nfunction createPagination(paginationKey) {\n    return paginationKey\n        ? pagination_1.PageRequest.fromPartial({\n            key: paginationKey,\n            offset: long_1.default.fromNumber(0, true),\n            limit: long_1.default.fromNumber(0, true),\n            countTotal: false,\n        })\n        : undefined;\n}\nexports.createPagination = createPagination;\nfunction createProtobufRpcClient(base) {\n    return {\n        request: (service, method, data) => {\n            const path = `/${service}/${method}`;\n            return base.queryUnverified(path, data);\n        },\n    };\n}\nexports.createProtobufRpcClient = createProtobufRpcClient;\n/**\n * Takes a uint64 value as string, number, Long or Uint64 and returns an unsigned Long instance\n * of it.\n */\nfunction longify(value) {\n    const checkedValue = math_1.Uint64.fromString(value.toString());\n    return long_1.default.fromBytesBE([...checkedValue.toBytesBigEndian()], true);\n}\nexports.longify = longify;\n/**\n * Takes a string or binary encoded `github.com/cosmos/cosmos-sdk/types.Dec` from the\n * protobuf API and converts it into a `Decimal` with 18 fractional digits.\n *\n * See https://github.com/cosmos/cosmos-sdk/issues/10863 for more context why this is needed.\n */\nfunction decodeCosmosSdkDecFromProto(input) {\n    const asString = typeof input === \"string\" ? input : (0, encoding_1.fromAscii)(input);\n    return math_1.Decimal.fromAtomics(asString, 18);\n}\nexports.decodeCosmosSdkDecFromProto = decodeCosmosSdkDecFromProto;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}