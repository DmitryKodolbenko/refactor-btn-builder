{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueAndUpdates = void 0;\nvar xstream_1 = require(\"xstream\");\n/**\n * A read only wrapper around DefaultValueProducer that allows\n * to synchronously get the current value using the .value property\n * and listen to to updates by suscribing to the .updates stream\n */\nvar ValueAndUpdates = /*#__PURE__*/function () {\n  function ValueAndUpdates(producer) {\n    _classCallCheck(this, ValueAndUpdates);\n    this.producer = producer;\n    this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);\n  }\n  _createClass(ValueAndUpdates, [{\n    key: \"value\",\n    get: function get() {\n      return this.producer.value;\n    }\n    /**\n     * Resolves as soon as search value is found.\n     *\n     * @param search either a value or a function that must return true when found\n     * @returns the value of the update that caused the search match\n     */\n  }, {\n    key: \"waitFor\",\n    value: function () {\n      var _waitFor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(search) {\n        var _this = this;\n        var searchImplementation;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                searchImplementation = typeof search === \"function\" ? search : function (value) {\n                  return value === search;\n                };\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var subscription = _this.updates.subscribe({\n                    next: function next(newValue) {\n                      if (searchImplementation(newValue)) {\n                        resolve(newValue);\n                        // MemoryStream.subscribe() calls next with the last value.\n                        // Make async to ensure the subscription exists\n                        setTimeout(function () {\n                          return subscription.unsubscribe();\n                        }, 0);\n                      }\n                    },\n                    complete: function complete() {\n                      subscription.unsubscribe();\n                      reject(\"Update stream completed without expected value\");\n                    },\n                    error: function error(_error) {\n                      reject(_error);\n                    }\n                  });\n                }));\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      function waitFor(_x) {\n        return _waitFor.apply(this, arguments);\n      }\n      return waitFor;\n    }()\n  }]);\n  return ValueAndUpdates;\n}();\nexports.ValueAndUpdates = ValueAndUpdates;","map":{"version":3,"sources":["../src/valueandupdates.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAMA;;;;AAIG;AAJH,IAKa,eAAe;EAS1B,yBAAmB,QAAiC,EAAA;IAAA;IAClD,IAAI,CAAC,QAAQ,GAAG,QAAQ;IACxB,IAAI,CAAC,OAAO,GAAG,SAAA,CAAA,YAAY,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC;EAC7D;EAAC;IAAA;IAAA,KATD,eAAgB;MACd,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK;IAC5B;IASA;;;;;AAKG;EALH;IAAA;IAAA;MAAA,0EAMO,iBAAc,MAA6B;QAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAC1C,oBAAoB,GACxB,OAAO,MAAM,KAAK,UAAU,GAAI,MAA4B,GAAG,UAAC,KAAQ;kBAAA,OAAc,KAAK,KAAK,MAAM;gBAAA;gBAAA,iCAEjG,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM,EAAI;kBACrC,IAAM,YAAY,GAAG,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC;oBAC1C,IAAI,EAAE,cAAC,QAAQ,EAAI;sBACjB,IAAI,oBAAoB,CAAC,QAAQ,CAAC,EAAE;wBAClC,OAAO,CAAC,QAAQ,CAAC;wBAEjB;wBACA;wBACA,UAAU,CAAC;0BAAA,OAAM,YAAY,CAAC,WAAW,EAAE;wBAAA,GAAE,CAAC,CAAC;sBAChD;oBACH,CAAC;oBACD,QAAQ,EAAE,oBAAK;sBACb,YAAY,CAAC,WAAW,EAAE;sBAC1B,MAAM,CAAC,gDAAgD,CAAC;oBAC1D,CAAC;oBACD,KAAK,EAAE,eAAC,MAAK,EAAI;sBACf,MAAM,CAAC,MAAK,CAAC;oBACf;mBACD,CAAC;gBACJ,CAAC,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACH;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA;AA5CH,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueAndUpdates = void 0;\nconst xstream_1 = require(\"xstream\");\n/**\n * A read only wrapper around DefaultValueProducer that allows\n * to synchronously get the current value using the .value property\n * and listen to to updates by suscribing to the .updates stream\n */\nclass ValueAndUpdates {\n    constructor(producer) {\n        this.producer = producer;\n        this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);\n    }\n    get value() {\n        return this.producer.value;\n    }\n    /**\n     * Resolves as soon as search value is found.\n     *\n     * @param search either a value or a function that must return true when found\n     * @returns the value of the update that caused the search match\n     */\n    async waitFor(search) {\n        const searchImplementation = typeof search === \"function\" ? search : (value) => value === search;\n        return new Promise((resolve, reject) => {\n            const subscription = this.updates.subscribe({\n                next: (newValue) => {\n                    if (searchImplementation(newValue)) {\n                        resolve(newValue);\n                        // MemoryStream.subscribe() calls next with the last value.\n                        // Make async to ensure the subscription exists\n                        setTimeout(() => subscription.unsubscribe(), 0);\n                    }\n                },\n                complete: () => {\n                    subscription.unsubscribe();\n                    reject(\"Update stream completed without expected value\");\n                },\n                error: (error) => {\n                    reject(error);\n                },\n            });\n        });\n    }\n}\nexports.ValueAndUpdates = ValueAndUpdates;\n//# sourceMappingURL=valueandupdates.js.map"]},"metadata":{},"sourceType":"script"}