{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doHash = exports.applyInner = exports.applyLeaf = void 0;\nvar ripemd160_1 = require(\"@noble/hashes/ripemd160\");\nvar sha256_1 = require(\"@noble/hashes/sha256\");\nvar sha512_1 = require(\"@noble/hashes/sha512\");\nvar codecimpl_1 = require(\"./generated/codecimpl\");\nfunction applyLeaf(leaf, key, value) {\n  if (key.length === 0) {\n    throw new Error(\"Missing key\");\n  }\n  if (value.length === 0) {\n    throw new Error(\"Missing value\");\n  }\n  var pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);\n  var pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);\n  var data = new Uint8Array([].concat(_toConsumableArray(ensureBytes(leaf.prefix)), _toConsumableArray(pkey), _toConsumableArray(pvalue)));\n  return doHash(ensureHash(leaf.hash), data);\n}\nexports.applyLeaf = applyLeaf;\nfunction applyInner(inner, child) {\n  if (child.length === 0) {\n    throw new Error(\"Inner op needs child value\");\n  }\n  var preimage = new Uint8Array([].concat(_toConsumableArray(ensureBytes(inner.prefix)), _toConsumableArray(child), _toConsumableArray(ensureBytes(inner.suffix))));\n  return doHash(ensureHash(inner.hash), preimage);\n}\nexports.applyInner = applyInner;\nfunction ensure(maybe, value) {\n  return maybe === undefined || maybe === null ? value : maybe;\n}\nvar ensureHash = function ensureHash(h) {\n  return ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);\n};\nvar ensureLength = function ensureLength(l) {\n  return ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);\n};\nvar ensureBytes = function ensureBytes(b) {\n  return ensure(b, new Uint8Array([]));\n};\nfunction prepareLeafData(hashOp, lengthOp, data) {\n  var h = doHashOrNoop(hashOp, data);\n  return doLengthOp(lengthOp, h);\n}\n// doHashOrNoop will return the preimage untouched if hashOp == NONE,\n// otherwise, perform doHash\nfunction doHashOrNoop(hashOp, preimage) {\n  if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {\n    return preimage;\n  }\n  return doHash(hashOp, preimage);\n}\n// doHash will preform the specified hash on the preimage.\n// if hashOp == NONE, it will return an error (use doHashOrNoop if you want different behavior)\nfunction doHash(hashOp, preimage) {\n  switch (hashOp) {\n    case codecimpl_1.ics23.HashOp.SHA256:\n      return (0, sha256_1.sha256)(preimage);\n    case codecimpl_1.ics23.HashOp.SHA512:\n      return (0, sha512_1.sha512)(preimage);\n    case codecimpl_1.ics23.HashOp.RIPEMD160:\n      return (0, ripemd160_1.ripemd160)(preimage);\n    case codecimpl_1.ics23.HashOp.BITCOIN:\n      return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(preimage));\n    case codecimpl_1.ics23.HashOp.SHA512_256:\n      return (0, sha512_1.sha512_256)(preimage);\n  }\n  throw new Error(\"Unsupported hashop: \".concat(hashOp));\n}\nexports.doHash = doHash;\n// doLengthOp will calculate the proper prefix and return it prepended\n//   doLengthOp(op, data) -> length(data) || data\nfunction doLengthOp(lengthOp, data) {\n  switch (lengthOp) {\n    case codecimpl_1.ics23.LengthOp.NO_PREFIX:\n      return data;\n    case codecimpl_1.ics23.LengthOp.VAR_PROTO:\n      return new Uint8Array([].concat(_toConsumableArray(encodeVarintProto(data.length)), _toConsumableArray(data)));\n    case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:\n      if (data.length !== 32) {\n        throw new Error(\"Length is \".concat(data.length, \", not 32 bytes\"));\n      }\n      return data;\n    case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:\n      if (data.length !== 64) {\n        throw new Error(\"Length is \".concat(data.length, \", not 64 bytes\"));\n      }\n      return data;\n    case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:\n      return new Uint8Array([].concat(_toConsumableArray(encodeFixed32Le(data.length)), _toConsumableArray(data)));\n    // TODO\n    // case LengthOp_VAR_RLP:\n    // case LengthOp_FIXED32_BIG:\n    // case LengthOp_FIXED64_BIG:\n    // case LengthOp_FIXED64_LITTLE:\n  }\n\n  throw new Error(\"Unsupported lengthop: \".concat(lengthOp));\n}\nfunction encodeVarintProto(n) {\n  var enc = [];\n  var l = n;\n  while (l >= 128) {\n    var b = l % 128 + 128;\n    enc = [].concat(_toConsumableArray(enc), [b]);\n    l = l / 128;\n  }\n  enc = [].concat(_toConsumableArray(enc), [l]);\n  return new Uint8Array(enc);\n}\nfunction encodeFixed32Le(n) {\n  var enc = new Uint8Array(4);\n  var l = n;\n  for (var i = enc.length; i > 0; i--) {\n    enc[Math.abs(i - enc.length)] = l % 256;\n    l = Math.floor(l / 256);\n  }\n  return enc;\n}","map":{"version":3,"sources":["../src/ops.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.doHash = exports.applyInner = exports.applyLeaf = void 0;\nconst ripemd160_1 = require(\"@noble/hashes/ripemd160\");\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst sha512_1 = require(\"@noble/hashes/sha512\");\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nfunction applyLeaf(leaf, key, value) {\n    if (key.length === 0) {\n        throw new Error(\"Missing key\");\n    }\n    if (value.length === 0) {\n        throw new Error(\"Missing value\");\n    }\n    const pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);\n    const pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);\n    const data = new Uint8Array([\n        ...ensureBytes(leaf.prefix),\n        ...pkey,\n        ...pvalue,\n    ]);\n    return doHash(ensureHash(leaf.hash), data);\n}\nexports.applyLeaf = applyLeaf;\nfunction applyInner(inner, child) {\n    if (child.length === 0) {\n        throw new Error(\"Inner op needs child value\");\n    }\n    const preimage = new Uint8Array([\n        ...ensureBytes(inner.prefix),\n        ...child,\n        ...ensureBytes(inner.suffix),\n    ]);\n    return doHash(ensureHash(inner.hash), preimage);\n}\nexports.applyInner = applyInner;\nfunction ensure(maybe, value) {\n    return maybe === undefined || maybe === null ? value : maybe;\n}\nconst ensureHash = (h) => ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);\nconst ensureLength = (l) => ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);\nconst ensureBytes = (b) => ensure(b, new Uint8Array([]));\nfunction prepareLeafData(hashOp, lengthOp, data) {\n    const h = doHashOrNoop(hashOp, data);\n    return doLengthOp(lengthOp, h);\n}\n// doHashOrNoop will return the preimage untouched if hashOp == NONE,\n// otherwise, perform doHash\nfunction doHashOrNoop(hashOp, preimage) {\n    if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {\n        return preimage;\n    }\n    return doHash(hashOp, preimage);\n}\n// doHash will preform the specified hash on the preimage.\n// if hashOp == NONE, it will return an error (use doHashOrNoop if you want different behavior)\nfunction doHash(hashOp, preimage) {\n    switch (hashOp) {\n        case codecimpl_1.ics23.HashOp.SHA256:\n            return (0, sha256_1.sha256)(preimage);\n        case codecimpl_1.ics23.HashOp.SHA512:\n            return (0, sha512_1.sha512)(preimage);\n        case codecimpl_1.ics23.HashOp.RIPEMD160:\n            return (0, ripemd160_1.ripemd160)(preimage);\n        case codecimpl_1.ics23.HashOp.BITCOIN:\n            return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(preimage));\n        case codecimpl_1.ics23.HashOp.SHA512_256:\n            return (0, sha512_1.sha512_256)(preimage);\n    }\n    throw new Error(`Unsupported hashop: ${hashOp}`);\n}\nexports.doHash = doHash;\n// doLengthOp will calculate the proper prefix and return it prepended\n//   doLengthOp(op, data) -> length(data) || data\nfunction doLengthOp(lengthOp, data) {\n    switch (lengthOp) {\n        case codecimpl_1.ics23.LengthOp.NO_PREFIX:\n            return data;\n        case codecimpl_1.ics23.LengthOp.VAR_PROTO:\n            return new Uint8Array([...encodeVarintProto(data.length), ...data]);\n        case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:\n            if (data.length !== 32) {\n                throw new Error(`Length is ${data.length}, not 32 bytes`);\n            }\n            return data;\n        case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:\n            if (data.length !== 64) {\n                throw new Error(`Length is ${data.length}, not 64 bytes`);\n            }\n            return data;\n        case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:\n            return new Uint8Array([...encodeFixed32Le(data.length), ...data]);\n        // TODO\n        // case LengthOp_VAR_RLP:\n        // case LengthOp_FIXED32_BIG:\n        // case LengthOp_FIXED64_BIG:\n        // case LengthOp_FIXED64_LITTLE:\n    }\n    throw new Error(`Unsupported lengthop: ${lengthOp}`);\n}\nfunction encodeVarintProto(n) {\n    let enc = [];\n    let l = n;\n    while (l >= 128) {\n        const b = (l % 128) + 128;\n        enc = [...enc, b];\n        l = l / 128;\n    }\n    enc = [...enc, l];\n    return new Uint8Array(enc);\n}\nfunction encodeFixed32Le(n) {\n    const enc = new Uint8Array(4);\n    let l = n;\n    for (let i = enc.length; i > 0; i--) {\n        enc[Math.abs(i - enc.length)] = l % 256;\n        l = Math.floor(l / 256);\n    }\n    return enc;\n}\n//# sourceMappingURL=ops.js.map"]},"metadata":{},"sourceType":"script"}