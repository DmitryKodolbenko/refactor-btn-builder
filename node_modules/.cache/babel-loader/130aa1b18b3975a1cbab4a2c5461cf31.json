{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) 2019-present, GraphQL Foundation\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// A Function, which when given an Array of keys, returns a Promise of an Array\n// of values or Errors.\n// Optionally turn off batching or caching or provide a cache key function or a\n// custom cache instance.\n// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\nvar DataLoader = /*#__PURE__*/\nfunction () {\n  function DataLoader(batchLoadFn, options) {\n    if (typeof batchLoadFn !== 'function') {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\n    }\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n  } // Private\n\n  var _proto = DataLoader.prototype;\n\n  /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */\n  _proto.load = function load(key) {\n    if (key === null || key === undefined) {\n      throw new TypeError('The loader.load() function must be called with a value, ' + (\"but got: \" + String(key) + \".\"));\n    }\n    var batch = getCurrentBatch(this);\n    var cacheMap = this._cacheMap;\n    var cacheKey = this._cacheKeyFn(key); // If caching and there is a cache-hit, return cached Promise.\n\n    if (cacheMap) {\n      var cachedPromise = cacheMap.get(cacheKey);\n      if (cachedPromise) {\n        var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise(function (resolve) {\n          cacheHits.push(function () {\n            resolve(cachedPromise);\n          });\n        });\n      }\n    } // Otherwise, produce a new Promise for this key, and enqueue it to be\n    // dispatched along with the current batch.\n\n    batch.keys.push(key);\n    var promise = new Promise(function (resolve, reject) {\n      batch.callbacks.push({\n        resolve: resolve,\n        reject: reject\n      });\n    }); // If caching, cache this promise.\n\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n    return promise;\n  }\n  /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */;\n\n  _proto.loadMany = function loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + (\"but got: \" + keys + \".\"));\n    } // Support ArrayLike by using only minimal property access\n\n    var loadPromises = [];\n    for (var i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i])[\"catch\"](function (error) {\n        return error;\n      }));\n    }\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */;\n\n  _proto.clear = function clear(key) {\n    var cacheMap = this._cacheMap;\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n      cacheMap[\"delete\"](cacheKey);\n    }\n    return this;\n  }\n  /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */;\n\n  _proto.clearAll = function clearAll() {\n    var cacheMap = this._cacheMap;\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n    return this;\n  }\n  /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */;\n\n  _proto.prime = function prime(key, value) {\n    var cacheMap = this._cacheMap;\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.\n\n      if (cacheMap.get(cacheKey) === undefined) {\n        // Cache a rejected promise if the value is an Error, in order to match\n        // the behavior of load(key).\n        var promise;\n        if (value instanceof Error) {\n          promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed\n          // for a given key, we want to disable unhandled promise rejection.\n\n          promise[\"catch\"](function () {});\n        } else {\n          promise = Promise.resolve(value);\n        }\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n    return this;\n  };\n  return DataLoader;\n}(); // Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\n\nvar enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function (fn) {\n  if (!resolvedPromise) {\n    resolvedPromise = Promise.resolve();\n  }\n  resolvedPromise.then(function () {\n    process.nextTick(fn);\n  });\n} : typeof setImmediate === 'function' ? function (fn) {\n  setImmediate(fn);\n} : function (fn) {\n  setTimeout(fn);\n}; // Private: cached resolved Promise instance\n\nvar resolvedPromise; // Private: Describes a batch of requests\n\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch(loader) {\n  // If there is an existing batch which has not yet dispatched and is within\n  // the limit of the batch size, then return it.\n  var existingBatch = loader._batch;\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {\n    return existingBatch;\n  } // Otherwise, create a new batch for this loader.\n\n  var newBatch = {\n    hasDispatched: false,\n    keys: [],\n    callbacks: []\n  }; // Store it on the loader so it may be reused.\n\n  loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.\n\n  loader._batchScheduleFn(function () {\n    dispatchBatch(loader, newBatch);\n  });\n  return newBatch;\n}\nfunction dispatchBatch(loader, batch) {\n  // Mark this batch as having been dispatched.\n  batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.\n\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  } // Call the provided batchLoadFn for this loader with the batch's keys and\n  // with the loader as the `this` context.\n\n  var batchPromise = loader._batchLoadFn(batch.keys); // Assert the expected response from batchLoadFn\n\n  if (!batchPromise || typeof batchPromise.then !== 'function') {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise: \" + String(batchPromise) + \".\")));\n  } // Await the resolution of the call to batchLoadFn.\n\n  batchPromise.then(function (values) {\n    // Assert the expected resolution from batchLoadFn.\n    if (!isArrayLike(values)) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise of an Array: \" + String(values) + \".\"));\n    }\n    if (values.length !== batch.keys.length) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\n    } // Resolve all cache hits in the same micro-task as freshly loaded values.\n\n    resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.\n\n    for (var i = 0; i < batch.callbacks.length; i++) {\n      var value = values[i];\n      if (value instanceof Error) {\n        batch.callbacks[i].reject(value);\n      } else {\n        batch.callbacks[i].resolve(value);\n      }\n    }\n  })[\"catch\"](function (error) {\n    failedDispatch(loader, batch, error);\n  });\n} // Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\n\nfunction failedDispatch(loader, batch, error) {\n  // Cache hits are resolved, even though the batch failed.\n  resolveCacheHits(batch);\n  for (var i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n} // Private: Resolves the Promises for any cache hits in this batch.\n\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (var i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n} // Private: given the DataLoader's options, produce a valid max batch size.\n\nfunction getValidMaxBatchSize(options) {\n  var shouldBatch = !options || options.batch !== false;\n  if (!shouldBatch) {\n    return 1;\n  }\n  var maxBatchSize = options && options.maxBatchSize;\n  if (maxBatchSize === undefined) {\n    return Infinity;\n  }\n  if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n    throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\n  }\n  return maxBatchSize;\n} // Private\n\nfunction getValidBatchScheduleFn(options) {\n  var batchScheduleFn = options && options.batchScheduleFn;\n  if (batchScheduleFn === undefined) {\n    return enqueuePostPromiseJob;\n  }\n  if (typeof batchScheduleFn !== 'function') {\n    throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\n  }\n  return batchScheduleFn;\n} // Private: given the DataLoader's options, produce a cache key function.\n\nfunction getValidCacheKeyFn(options) {\n  var cacheKeyFn = options && options.cacheKeyFn;\n  if (cacheKeyFn === undefined) {\n    return function (key) {\n      return key;\n    };\n  }\n  if (typeof cacheKeyFn !== 'function') {\n    throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\n  }\n  return cacheKeyFn;\n} // Private: given the DataLoader's options, produce a CacheMap to be used.\n\nfunction getValidCacheMap(options) {\n  var shouldCache = !options || options.cache !== false;\n  if (!shouldCache) {\n    return null;\n  }\n  var cacheMap = options && options.cacheMap;\n  if (cacheMap === undefined) {\n    return new Map();\n  }\n  if (cacheMap !== null) {\n    var cacheFunctions = ['get', 'set', 'delete', 'clear'];\n    var missingFunctions = cacheFunctions.filter(function (fnName) {\n      return cacheMap && typeof cacheMap[fnName] !== 'function';\n    });\n    if (missingFunctions.length !== 0) {\n      throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n    }\n  }\n  return cacheMap;\n} // Private\n\nfunction isArrayLike(x) {\n  return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\nmodule.exports = DataLoader;","map":{"version":3,"names":["DataLoader","batchLoadFn","options","TypeError","_batchLoadFn","_maxBatchSize","getValidMaxBatchSize","_batchScheduleFn","getValidBatchScheduleFn","_cacheKeyFn","getValidCacheKeyFn","_cacheMap","getValidCacheMap","_batch","_proto","prototype","load","key","undefined","String","batch","getCurrentBatch","cacheMap","cacheKey","cachedPromise","get","cacheHits","Promise","resolve","push","keys","promise","reject","callbacks","set","loadMany","isArrayLike","loadPromises","i","length","error","all","clear","clearAll","prime","value","Error","enqueuePostPromiseJob","process","nextTick","fn","resolvedPromise","then","setImmediate","setTimeout","loader","existingBatch","hasDispatched","newBatch","dispatchBatch","resolveCacheHits","batchPromise","failedDispatch","values","shouldBatch","maxBatchSize","Infinity","batchScheduleFn","cacheKeyFn","shouldCache","cache","Map","cacheFunctions","missingFunctions","filter","fnName","join","x","Object","hasOwnProperty","call","module","exports"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/dataloader/index.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Copyright (c) 2019-present, GraphQL Foundation\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// A Function, which when given an Array of keys, returns a Promise of an Array\n// of values or Errors.\n// Optionally turn off batching or caching or provide a cache key function or a\n// custom cache instance.\n// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\nvar DataLoader =\n/*#__PURE__*/\nfunction () {\n  function DataLoader(batchLoadFn, options) {\n    if (typeof batchLoadFn !== 'function') {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\n    }\n\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n  } // Private\n\n\n  var _proto = DataLoader.prototype;\n\n  /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */\n  _proto.load = function load(key) {\n    if (key === null || key === undefined) {\n      throw new TypeError('The loader.load() function must be called with a value, ' + (\"but got: \" + String(key) + \".\"));\n    }\n\n    var batch = getCurrentBatch(this);\n    var cacheMap = this._cacheMap;\n\n    var cacheKey = this._cacheKeyFn(key); // If caching and there is a cache-hit, return cached Promise.\n\n\n    if (cacheMap) {\n      var cachedPromise = cacheMap.get(cacheKey);\n\n      if (cachedPromise) {\n        var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise(function (resolve) {\n          cacheHits.push(function () {\n            resolve(cachedPromise);\n          });\n        });\n      }\n    } // Otherwise, produce a new Promise for this key, and enqueue it to be\n    // dispatched along with the current batch.\n\n\n    batch.keys.push(key);\n    var promise = new Promise(function (resolve, reject) {\n      batch.callbacks.push({\n        resolve: resolve,\n        reject: reject\n      });\n    }); // If caching, cache this promise.\n\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n\n    return promise;\n  }\n  /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */\n  ;\n\n  _proto.loadMany = function loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + (\"but got: \" + keys + \".\"));\n    } // Support ArrayLike by using only minimal property access\n\n\n    var loadPromises = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i])[\"catch\"](function (error) {\n        return error;\n      }));\n    }\n\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clear = function clear(key) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n\n      cacheMap[\"delete\"](cacheKey);\n    }\n\n    return this;\n  }\n  /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clearAll = function clearAll() {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n\n    return this;\n  }\n  /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */\n  ;\n\n  _proto.prime = function prime(key, value) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.\n\n\n      if (cacheMap.get(cacheKey) === undefined) {\n        // Cache a rejected promise if the value is an Error, in order to match\n        // the behavior of load(key).\n        var promise;\n\n        if (value instanceof Error) {\n          promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed\n          // for a given key, we want to disable unhandled promise rejection.\n\n          promise[\"catch\"](function () {});\n        } else {\n          promise = Promise.resolve(value);\n        }\n\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n\n    return this;\n  };\n\n  return DataLoader;\n}(); // Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\n\n\nvar enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function (fn) {\n  if (!resolvedPromise) {\n    resolvedPromise = Promise.resolve();\n  }\n\n  resolvedPromise.then(function () {\n    process.nextTick(fn);\n  });\n} : typeof setImmediate === 'function' ? function (fn) {\n  setImmediate(fn);\n} : function (fn) {\n  setTimeout(fn);\n}; // Private: cached resolved Promise instance\n\nvar resolvedPromise; // Private: Describes a batch of requests\n\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch(loader) {\n  // If there is an existing batch which has not yet dispatched and is within\n  // the limit of the batch size, then return it.\n  var existingBatch = loader._batch;\n\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {\n    return existingBatch;\n  } // Otherwise, create a new batch for this loader.\n\n\n  var newBatch = {\n    hasDispatched: false,\n    keys: [],\n    callbacks: []\n  }; // Store it on the loader so it may be reused.\n\n  loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.\n\n  loader._batchScheduleFn(function () {\n    dispatchBatch(loader, newBatch);\n  });\n\n  return newBatch;\n}\n\nfunction dispatchBatch(loader, batch) {\n  // Mark this batch as having been dispatched.\n  batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.\n\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  } // Call the provided batchLoadFn for this loader with the batch's keys and\n  // with the loader as the `this` context.\n\n\n  var batchPromise = loader._batchLoadFn(batch.keys); // Assert the expected response from batchLoadFn\n\n\n  if (!batchPromise || typeof batchPromise.then !== 'function') {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise: \" + String(batchPromise) + \".\")));\n  } // Await the resolution of the call to batchLoadFn.\n\n\n  batchPromise.then(function (values) {\n    // Assert the expected resolution from batchLoadFn.\n    if (!isArrayLike(values)) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise of an Array: \" + String(values) + \".\"));\n    }\n\n    if (values.length !== batch.keys.length) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\n    } // Resolve all cache hits in the same micro-task as freshly loaded values.\n\n\n    resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.\n\n    for (var i = 0; i < batch.callbacks.length; i++) {\n      var value = values[i];\n\n      if (value instanceof Error) {\n        batch.callbacks[i].reject(value);\n      } else {\n        batch.callbacks[i].resolve(value);\n      }\n    }\n  })[\"catch\"](function (error) {\n    failedDispatch(loader, batch, error);\n  });\n} // Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\n\n\nfunction failedDispatch(loader, batch, error) {\n  // Cache hits are resolved, even though the batch failed.\n  resolveCacheHits(batch);\n\n  for (var i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n} // Private: Resolves the Promises for any cache hits in this batch.\n\n\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (var i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n} // Private: given the DataLoader's options, produce a valid max batch size.\n\n\nfunction getValidMaxBatchSize(options) {\n  var shouldBatch = !options || options.batch !== false;\n\n  if (!shouldBatch) {\n    return 1;\n  }\n\n  var maxBatchSize = options && options.maxBatchSize;\n\n  if (maxBatchSize === undefined) {\n    return Infinity;\n  }\n\n  if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n    throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\n  }\n\n  return maxBatchSize;\n} // Private\n\n\nfunction getValidBatchScheduleFn(options) {\n  var batchScheduleFn = options && options.batchScheduleFn;\n\n  if (batchScheduleFn === undefined) {\n    return enqueuePostPromiseJob;\n  }\n\n  if (typeof batchScheduleFn !== 'function') {\n    throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\n  }\n\n  return batchScheduleFn;\n} // Private: given the DataLoader's options, produce a cache key function.\n\n\nfunction getValidCacheKeyFn(options) {\n  var cacheKeyFn = options && options.cacheKeyFn;\n\n  if (cacheKeyFn === undefined) {\n    return function (key) {\n      return key;\n    };\n  }\n\n  if (typeof cacheKeyFn !== 'function') {\n    throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\n  }\n\n  return cacheKeyFn;\n} // Private: given the DataLoader's options, produce a CacheMap to be used.\n\n\nfunction getValidCacheMap(options) {\n  var shouldCache = !options || options.cache !== false;\n\n  if (!shouldCache) {\n    return null;\n  }\n\n  var cacheMap = options && options.cacheMap;\n\n  if (cacheMap === undefined) {\n    return new Map();\n  }\n\n  if (cacheMap !== null) {\n    var cacheFunctions = ['get', 'set', 'delete', 'clear'];\n    var missingFunctions = cacheFunctions.filter(function (fnName) {\n      return cacheMap && typeof cacheMap[fnName] !== 'function';\n    });\n\n    if (missingFunctions.length !== 0) {\n      throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n    }\n  }\n\n  return cacheMap;\n} // Private\n\n\nfunction isArrayLike(x) {\n  return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\n\nmodule.exports = DataLoader;"],"mappings":"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"},"metadata":{},"sourceType":"script"}