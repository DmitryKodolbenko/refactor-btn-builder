{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.derivePath = exports.isValidPath = exports.getPublicKey = exports.getMasterKeyFromSeed = void 0;\nconst createHmac = require(\"create-hmac\");\nconst nacl = require(\"tweetnacl\");\nconst utils_1 = require(\"./utils\");\nconst ED25519_CURVE = 'ed25519 seed';\nconst HARDENED_OFFSET = 0x80000000;\nexports.getMasterKeyFromSeed = seed => {\n  const hmac = createHmac('sha512', ED25519_CURVE);\n  const I = hmac.update(Buffer.from(seed, 'hex')).digest();\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR\n  };\n};\nconst CKDPriv = (_ref, index) => {\n  let {\n    key,\n    chainCode\n  } = _ref;\n  const indexBuffer = Buffer.allocUnsafe(4);\n  indexBuffer.writeUInt32BE(index, 0);\n  const data = Buffer.concat([Buffer.alloc(1, 0), key, indexBuffer]);\n  const I = createHmac('sha512', chainCode).update(data).digest();\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR\n  };\n};\nexports.getPublicKey = function (privateKey) {\n  let withZeroByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const keyPair = nacl.sign.keyPair.fromSeed(privateKey);\n  const signPk = keyPair.secretKey.subarray(32);\n  const zero = Buffer.alloc(1, 0);\n  return withZeroByte ? Buffer.concat([zero, Buffer.from(signPk)]) : Buffer.from(signPk);\n};\nexports.isValidPath = path => {\n  if (!utils_1.pathRegex.test(path)) {\n    return false;\n  }\n  return !path.split('/').slice(1).map(utils_1.replaceDerive).some(isNaN);\n};\nexports.derivePath = function (path, seed) {\n  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : HARDENED_OFFSET;\n  if (!exports.isValidPath(path)) {\n    throw new Error('Invalid derivation path');\n  }\n  const {\n    key,\n    chainCode\n  } = exports.getMasterKeyFromSeed(seed);\n  const segments = path.split('/').slice(1).map(utils_1.replaceDerive).map(el => parseInt(el, 10));\n  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {\n    key,\n    chainCode\n  });\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","derivePath","isValidPath","getPublicKey","getMasterKeyFromSeed","createHmac","require","nacl","utils_1","ED25519_CURVE","HARDENED_OFFSET","seed","hmac","I","update","Buffer","from","digest","IL","slice","IR","key","chainCode","CKDPriv","index","indexBuffer","allocUnsafe","writeUInt32BE","data","concat","alloc","privateKey","withZeroByte","keyPair","sign","fromSeed","signPk","secretKey","subarray","zero","path","pathRegex","test","split","map","replaceDerive","some","isNaN","offset","Error","segments","el","parseInt","reduce","parentKeys","segment"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/near-hd-key/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.derivePath = exports.isValidPath = exports.getPublicKey = exports.getMasterKeyFromSeed = void 0;\nconst createHmac = require(\"create-hmac\");\nconst nacl = require(\"tweetnacl\");\nconst utils_1 = require(\"./utils\");\nconst ED25519_CURVE = 'ed25519 seed';\nconst HARDENED_OFFSET = 0x80000000;\nexports.getMasterKeyFromSeed = (seed) => {\n    const hmac = createHmac('sha512', ED25519_CURVE);\n    const I = hmac.update(Buffer.from(seed, 'hex')).digest();\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return {\n        key: IL,\n        chainCode: IR,\n    };\n};\nconst CKDPriv = ({ key, chainCode }, index) => {\n    const indexBuffer = Buffer.allocUnsafe(4);\n    indexBuffer.writeUInt32BE(index, 0);\n    const data = Buffer.concat([Buffer.alloc(1, 0), key, indexBuffer]);\n    const I = createHmac('sha512', chainCode)\n        .update(data)\n        .digest();\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return {\n        key: IL,\n        chainCode: IR,\n    };\n};\nexports.getPublicKey = (privateKey, withZeroByte = true) => {\n    const keyPair = nacl.sign.keyPair.fromSeed(privateKey);\n    const signPk = keyPair.secretKey.subarray(32);\n    const zero = Buffer.alloc(1, 0);\n    return withZeroByte ?\n        Buffer.concat([zero, Buffer.from(signPk)]) :\n        Buffer.from(signPk);\n};\nexports.isValidPath = (path) => {\n    if (!utils_1.pathRegex.test(path)) {\n        return false;\n    }\n    return !path\n        .split('/')\n        .slice(1)\n        .map(utils_1.replaceDerive)\n        .some(isNaN);\n};\nexports.derivePath = (path, seed, offset = HARDENED_OFFSET) => {\n    if (!exports.isValidPath(path)) {\n        throw new Error('Invalid derivation path');\n    }\n    const { key, chainCode } = exports.getMasterKeyFromSeed(seed);\n    const segments = path\n        .split('/')\n        .slice(1)\n        .map(utils_1.replaceDerive)\n        .map(el => parseInt(el, 10));\n    return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), { key, chainCode });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}