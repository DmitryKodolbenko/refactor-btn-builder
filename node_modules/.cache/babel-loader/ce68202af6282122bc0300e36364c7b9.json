{"ast":null,"code":"import { pipe } from './function';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromEquals = function (equals) {\n  return {\n    equals: function (x, y) {\n      return x === y || equals(x, y);\n    }\n  };\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nexport var struct = function (eqs) {\n  return fromEquals(function (first, second) {\n    for (var key in eqs) {\n      if (!eqs[key].equals(first[key], second[key])) {\n        return false;\n      }\n    }\n    return true;\n  });\n};\n/**\n * Given a tuple of `Eq`s returns a `Eq` for the tuple\n *\n * @example\n * import { tuple } from 'fp-ts/Eq'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import * as B from 'fp-ts/boolean'\n *\n * const E = tuple(S.Eq, N.Eq, B.Eq)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)\n * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n  var eqs = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    eqs[_i] = arguments[_i];\n  }\n  return fromEquals(function (first, second) {\n    return eqs.every(function (E, i) {\n      return E.equals(first[i], second[i]);\n    });\n  });\n};\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) {\n  return pipe(fa, contramap(f));\n};\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Eq<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for equality (meaning we have an `Eq<X>`)\n *\n * For example, given the following `User` type, we want to construct an `Eq<User>` that just looks at the `key` field\n * for each user (since it's known to be unique).\n *\n * If we have a way of comparing `UUID`s for equality (`eqUUID: Eq<UUID>`) and we know how to go from `User -> UUID`,\n * using `contramap` we can do this\n *\n * @example\n * import { contramap, Eq } from 'fp-ts/Eq'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/string'\n *\n * type UUID = string\n *\n * interface User {\n *   readonly key: UUID\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const eqUUID: Eq<UUID> = S.Eq\n *\n * const eqUserByKey: Eq<User> = pipe(\n *   eqUUID,\n *   contramap((user) => user.key)\n * )\n *\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k2', firstName: 'a1', lastName: 'b1' }\n *   ),\n *   false\n * )\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k1', firstName: 'a2', lastName: 'b1' }\n *   ),\n *   true\n * )\n *\n * @since 2.0.0\n */\nexport var contramap = function (f) {\n  return function (fa) {\n    return fromEquals(function (x, y) {\n      return fa.equals(f(x), f(y));\n    });\n  };\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Eq';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var eqStrict = {\n  equals: function (a, b) {\n    return a === b;\n  }\n};\nvar empty = {\n  equals: function () {\n    return true;\n  }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function () {\n  return {\n    concat: function (x, y) {\n      return fromEquals(function (a, b) {\n        return x.equals(a, b) && y.equals(a, b);\n      });\n    }\n  };\n};\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getMonoid = function () {\n  return {\n    concat: getSemigroup().concat,\n    empty: empty\n  };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n  URI: URI,\n  contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleEq = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructEq = struct;\n/**\n * Use [`eqStrict`](#eqstrict) instead\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var strictEqual = eqStrict.equals;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Contravariant` instance, pass `E.Contravariant` instead of `E.eq`\n * (where `E` is from `import E from 'fp-ts/Eq'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eq = Contravariant;\n/**\n * Use [`Eq`](./boolean.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqBoolean = eqStrict;\n/**\n * Use [`Eq`](./string.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqString = eqStrict;\n/**\n * Use [`Eq`](./number.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqNumber = eqStrict;\n/**\n * Use [`Eq`](./Date.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqDate = {\n  equals: function (first, second) {\n    return first.valueOf() === second.valueOf();\n  }\n};","map":{"version":3,"names":["pipe","fromEquals","equals","x","y","struct","eqs","first","second","key","tuple","_i","arguments","length","every","E","i","contramap_","fa","f","contramap","URI","eqStrict","a","b","empty","getSemigroup","concat","getMonoid","Contravariant","getTupleEq","getStructEq","strictEqual","eq","eqBoolean","eqString","eqNumber","eqDate","valueOf"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/fp-ts/es6/Eq.js"],"sourcesContent":["import { pipe } from './function';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromEquals = function (equals) { return ({\n    equals: function (x, y) { return x === y || equals(x, y); }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nexport var struct = function (eqs) {\n    return fromEquals(function (first, second) {\n        for (var key in eqs) {\n            if (!eqs[key].equals(first[key], second[key])) {\n                return false;\n            }\n        }\n        return true;\n    });\n};\n/**\n * Given a tuple of `Eq`s returns a `Eq` for the tuple\n *\n * @example\n * import { tuple } from 'fp-ts/Eq'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import * as B from 'fp-ts/boolean'\n *\n * const E = tuple(S.Eq, N.Eq, B.Eq)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)\n * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var eqs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        eqs[_i] = arguments[_i];\n    }\n    return fromEquals(function (first, second) { return eqs.every(function (E, i) { return E.equals(first[i], second[i]); }); });\n};\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return pipe(fa, contramap(f)); };\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Eq<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for equality (meaning we have an `Eq<X>`)\n *\n * For example, given the following `User` type, we want to construct an `Eq<User>` that just looks at the `key` field\n * for each user (since it's known to be unique).\n *\n * If we have a way of comparing `UUID`s for equality (`eqUUID: Eq<UUID>`) and we know how to go from `User -> UUID`,\n * using `contramap` we can do this\n *\n * @example\n * import { contramap, Eq } from 'fp-ts/Eq'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/string'\n *\n * type UUID = string\n *\n * interface User {\n *   readonly key: UUID\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const eqUUID: Eq<UUID> = S.Eq\n *\n * const eqUserByKey: Eq<User> = pipe(\n *   eqUUID,\n *   contramap((user) => user.key)\n * )\n *\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k2', firstName: 'a1', lastName: 'b1' }\n *   ),\n *   false\n * )\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k1', firstName: 'a2', lastName: 'b1' }\n *   ),\n *   true\n * )\n *\n * @since 2.0.0\n */\nexport var contramap = function (f) { return function (fa) {\n    return fromEquals(function (x, y) { return fa.equals(f(x), f(y)); });\n}; };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Eq';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var eqStrict = {\n    equals: function (a, b) { return a === b; }\n};\nvar empty = {\n    equals: function () { return true; }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (x, y) { return fromEquals(function (a, b) { return x.equals(a, b) && y.equals(a, b); }); }\n}); };\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleEq = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructEq = struct;\n/**\n * Use [`eqStrict`](#eqstrict) instead\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var strictEqual = eqStrict.equals;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Contravariant` instance, pass `E.Contravariant` instead of `E.eq`\n * (where `E` is from `import E from 'fp-ts/Eq'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eq = Contravariant;\n/**\n * Use [`Eq`](./boolean.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqBoolean = eqStrict;\n/**\n * Use [`Eq`](./string.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqString = eqStrict;\n/**\n * Use [`Eq`](./number.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqNumber = eqStrict;\n/**\n * Use [`Eq`](./Date.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqDate = {\n    equals: function (first, second) { return first.valueOf() === second.valueOf(); }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}