{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\n// NOTE: \"mc\" means masterchain, \"shards\" means shardchains\n\nvar MC_INTERVAL = 10 * 1000;\nvar SHARDS_INTERVAL = 1 * 1000;\nvar parseShardBlockNumber = function parseShardBlockNumber(x) {\n  return {\n    workchain: x.workchain,\n    shardId: x.shard,\n    shardBlockNumber: x.seqno\n  };\n};\nvar BlockSubscription = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * @param provider  {TonWeb.HttpProvider}\n   * @param storage   persistent storage for storing block numbers that we have already processed.\n   * @param onBlock {(blockHeader: BlockHeader) => Promise<void>} callback which is called for of each block.\n   *                                                       callback may throw an error, in this case the block processing will be interrupted and block will not be saved in the storage as processed.\n   *                                                       shardchain blocks are processed OUT of chronological order.\n   *                                                       masterchain blocks are processed in chronological order.\n   *                                                       for masterchain workchain === -1 and shardId === '-9223372036854775808'\n   * @param options? {startMcBlockNumber:? number, mcInterval?: number, shardsInterval?: number} start masterchain block number from which we start to process blocks.\n   *                                     if not specified, the subscription starts from the last block of the network at the time of launch.\n   */\n  function BlockSubscription(provider, storage, onBlock, options) {\n    _classCallCheck(this, BlockSubscription);\n    this.provider = provider;\n    this.storage = storage;\n    this.onBlock = onBlock;\n    this.startMcBlockNumber = options ? options.startMcBlockNumber : undefined;\n    this.mcInterval = (options ? options.mcInterval : undefined) || MC_INTERVAL;\n    this.shardsInterval = (options ? options.shardsInterval : undefined) || SHARDS_INTERVAL;\n  }\n  _createClass(BlockSubscription, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this = this;\n        var startMcBlockHeader, isMcProcessing, mcTick, isShardsProcessing, shardsTick;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.stop();\n                if (this.startMcBlockNumber) {\n                  _context3.next = 7;\n                  break;\n                }\n                _context3.next = 4;\n                return this.provider.getMasterchainInfo();\n              case 4:\n                this.startMcBlockNumber = _context3.sent.last.seqno;\n                if (this.startMcBlockNumber) {\n                  _context3.next = 7;\n                  break;\n                }\n                throw new Error('Cannot get start mc block number from provider');\n              case 7:\n                _context3.next = 9;\n                return this.provider.getMasterchainBlockHeader(this.startMcBlockNumber);\n              case 9:\n                startMcBlockHeader = _context3.sent;\n                this.startLT = startMcBlockHeader.end_lt;\n                if (this.startLT) {\n                  _context3.next = 13;\n                  break;\n                }\n                throw new Error('Cannot get startLT from provider');\n              case 13:\n                // MASTERCHAIN\n                isMcProcessing = false;\n                mcTick = /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                    var lastSavedMcBlock, lastMcBlock, i, blockShards, blockHeader;\n                    return _regeneratorRuntime().wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            if (!isMcProcessing) {\n                              _context.next = 2;\n                              break;\n                            }\n                            return _context.abrupt(\"return\");\n                          case 2:\n                            isMcProcessing = true;\n                            _context.prev = 3;\n                            _context.next = 6;\n                            return _this.storage.getLastMasterchainBlockNumber();\n                          case 6:\n                            _context.t0 = _context.sent;\n                            if (_context.t0) {\n                              _context.next = 9;\n                              break;\n                            }\n                            _context.t0 = _this.startMcBlockNumber;\n                          case 9:\n                            lastSavedMcBlock = _context.t0;\n                            if (lastSavedMcBlock) {\n                              _context.next = 12;\n                              break;\n                            }\n                            throw new Error('no init masterchain block in storage');\n                          case 12:\n                            _context.next = 14;\n                            return _this.provider.getMasterchainInfo();\n                          case 14:\n                            lastMcBlock = _context.sent.last.seqno;\n                            if (lastMcBlock) {\n                              _context.next = 17;\n                              break;\n                            }\n                            throw new Error('invalid last masterchain block from provider');\n                          case 17:\n                            i = lastSavedMcBlock + 1;\n                          case 18:\n                            if (!(i < lastMcBlock)) {\n                              _context.next = 32;\n                              break;\n                            }\n                            _context.next = 21;\n                            return _this.provider.getBlockShards(i);\n                          case 21:\n                            blockShards = _context.sent;\n                            _context.next = 24;\n                            return _this.provider.getMasterchainBlockHeader(i);\n                          case 24:\n                            blockHeader = _context.sent;\n                            _context.next = 27;\n                            return _this.onBlock(blockHeader, blockShards);\n                          case 27:\n                            _context.next = 29;\n                            return _this.storage.insertBlocks(i, blockShards.shards.map(parseShardBlockNumber));\n                          case 29:\n                            i++;\n                            _context.next = 18;\n                            break;\n                          case 32:\n                            _context.next = 37;\n                            break;\n                          case 34:\n                            _context.prev = 34;\n                            _context.t1 = _context[\"catch\"](3);\n                            console.error(_context.t1);\n                          case 37:\n                            isMcProcessing = false;\n                          case 38:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, null, [[3, 34]]);\n                  }));\n                  return function mcTick() {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n                this.mcIntervalId = setInterval(function () {\n                  return mcTick();\n                }, this.mcInterval);\n                mcTick();\n\n                // SHARDCHAINS\n                isShardsProcessing = false;\n                shardsTick = /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                    var shardBlock, workchain, shardId, shardBlockNumber, blockHeader, prevBlocks;\n                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            if (!isShardsProcessing) {\n                              _context2.next = 2;\n                              break;\n                            }\n                            return _context2.abrupt(\"return\");\n                          case 2:\n                            isShardsProcessing = true;\n                            _context2.prev = 3;\n                            _context2.next = 6;\n                            return _this.storage.getUnprocessedShardBlock();\n                          case 6:\n                            shardBlock = _context2.sent;\n                            if (!shardBlock) {\n                              _context2.next = 22;\n                              break;\n                            }\n                            workchain = shardBlock.workchain, shardId = shardBlock.shardId, shardBlockNumber = shardBlock.shardBlockNumber;\n                            _context2.next = 11;\n                            return _this.provider.getBlockHeader(workchain, shardId, shardBlockNumber);\n                          case 11:\n                            blockHeader = _context2.sent;\n                            if (!(blockHeader.end_lt < _this.startLT)) {\n                              _context2.next = 17;\n                              break;\n                            }\n                            _context2.next = 15;\n                            return _this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, []);\n                          case 15:\n                            _context2.next = 22;\n                            break;\n                          case 17:\n                            _context2.next = 19;\n                            return _this.onBlock(blockHeader);\n                          case 19:\n                            prevBlocks = blockHeader.prev_blocks.map(parseShardBlockNumber);\n                            _context2.next = 22;\n                            return _this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, prevBlocks);\n                          case 22:\n                            _context2.next = 27;\n                            break;\n                          case 24:\n                            _context2.prev = 24;\n                            _context2.t0 = _context2[\"catch\"](3);\n                            console.log(_context2.t0);\n                          case 27:\n                            isShardsProcessing = false;\n                          case 28:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, null, [[3, 24]]);\n                  }));\n                  return function shardsTick() {\n                    return _ref2.apply(this, arguments);\n                  };\n                }();\n                this.shardsIntervalId = setInterval(function () {\n                  return shardsTick();\n                }, this.shardsInterval);\n              case 20:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      clearInterval(this.mcIntervalId);\n      clearInterval(this.shardsIntervalId);\n    }\n  }]);\n  return BlockSubscription;\n}();\nmodule.exports = {\n  BlockSubscription: BlockSubscription\n};","map":{"version":3,"names":["MC_INTERVAL","SHARDS_INTERVAL","parseShardBlockNumber","x","workchain","shardId","shard","shardBlockNumber","seqno","BlockSubscription","provider","storage","onBlock","options","startMcBlockNumber","undefined","mcInterval","shardsInterval","stop","getMasterchainInfo","last","Error","getMasterchainBlockHeader","startMcBlockHeader","startLT","end_lt","isMcProcessing","mcTick","getLastMasterchainBlockNumber","lastSavedMcBlock","lastMcBlock","i","getBlockShards","blockShards","blockHeader","insertBlocks","shards","map","console","error","mcIntervalId","setInterval","isShardsProcessing","shardsTick","getUnprocessedShardBlock","shardBlock","getBlockHeader","setBlockProcessed","prevBlocks","prev_blocks","log","shardsIntervalId","clearInterval","module","exports"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/tonweb/src/providers/blockSubscription/BlockSubscription.js"],"sourcesContent":["// NOTE: \"mc\" means masterchain, \"shards\" means shardchains\n\nconst MC_INTERVAL = 10 * 1000;\nconst SHARDS_INTERVAL = 1 * 1000;\n\nconst parseShardBlockNumber = x => {\n    return {\n        workchain: x.workchain,\n        shardId: x.shard,\n        shardBlockNumber: x.seqno\n    }\n}\n\nclass BlockSubscription {\n\n    /**\n     * @param provider  {TonWeb.HttpProvider}\n     * @param storage   persistent storage for storing block numbers that we have already processed.\n     * @param onBlock {(blockHeader: BlockHeader) => Promise<void>} callback which is called for of each block.\n     *                                                       callback may throw an error, in this case the block processing will be interrupted and block will not be saved in the storage as processed.\n     *                                                       shardchain blocks are processed OUT of chronological order.\n     *                                                       masterchain blocks are processed in chronological order.\n     *                                                       for masterchain workchain === -1 and shardId === '-9223372036854775808'\n     * @param options? {startMcBlockNumber:? number, mcInterval?: number, shardsInterval?: number} start masterchain block number from which we start to process blocks.\n     *                                     if not specified, the subscription starts from the last block of the network at the time of launch.\n     */\n    constructor(provider, storage, onBlock, options) {\n        this.provider = provider;\n        this.storage = storage;\n        this.onBlock = onBlock;\n        this.startMcBlockNumber = options ? options.startMcBlockNumber : undefined;\n        this.mcInterval = (options ? options.mcInterval : undefined) || MC_INTERVAL;\n        this.shardsInterval = (options ? options.shardsInterval : undefined) || SHARDS_INTERVAL;\n    }\n\n    async start() {\n        this.stop();\n\n        if (!this.startMcBlockNumber) {\n            this.startMcBlockNumber = (await this.provider.getMasterchainInfo()).last.seqno;\n            if (!this.startMcBlockNumber) throw new Error('Cannot get start mc block number from provider');\n        }\n        const startMcBlockHeader = await this.provider.getMasterchainBlockHeader(this.startMcBlockNumber);\n        this.startLT = startMcBlockHeader.end_lt;\n        if (!this.startLT) throw new Error('Cannot get startLT from provider');\n\n        // MASTERCHAIN\n\n        let isMcProcessing = false;\n\n        const mcTick = async () => {\n            if (isMcProcessing) return;\n\n            isMcProcessing = true;\n\n            try {\n                const lastSavedMcBlock = await this.storage.getLastMasterchainBlockNumber() || this.startMcBlockNumber;\n                if (!lastSavedMcBlock) throw new Error('no init masterchain block in storage');\n                const lastMcBlock = (await this.provider.getMasterchainInfo()).last.seqno;\n                if (!lastMcBlock) throw new Error('invalid last masterchain block from provider');\n\n                for (let i = lastSavedMcBlock + 1; i < lastMcBlock; i++) {\n                    const blockShards = await this.provider.getBlockShards(i);\n                    const blockHeader = await this.provider.getMasterchainBlockHeader(i);\n                    await this.onBlock(blockHeader, blockShards);\n                    await this.storage.insertBlocks(i, blockShards.shards.map(parseShardBlockNumber));\n                }\n            } catch (e) {\n                console.error(e);\n            }\n\n            isMcProcessing = false;\n        }\n\n        this.mcIntervalId = setInterval(() => mcTick(), this.mcInterval);\n        mcTick();\n\n        // SHARDCHAINS\n\n        let isShardsProcessing = false;\n\n        const shardsTick = async () => {\n            if (isShardsProcessing) return;\n\n            isShardsProcessing = true;\n            try {\n                const shardBlock = await this.storage.getUnprocessedShardBlock();\n                if (shardBlock) {\n                    const {workchain, shardId, shardBlockNumber} = shardBlock;\n                    const blockHeader = await this.provider.getBlockHeader(workchain, shardId, shardBlockNumber);\n                    if (blockHeader.end_lt < this.startLT) {\n                        await this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, []);\n                    } else {\n                        await this.onBlock(blockHeader);\n                        const prevBlocks = blockHeader.prev_blocks.map(parseShardBlockNumber);\n                        await this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, prevBlocks);\n                    }\n                }\n            } catch (e) {\n                console.log(e);\n            }\n            isShardsProcessing = false;\n        }\n\n        this.shardsIntervalId = setInterval(() => shardsTick(), this.shardsInterval);\n    }\n\n    stop() {\n        clearInterval(this.mcIntervalId);\n        clearInterval(this.shardsIntervalId);\n    }\n}\n\nmodule.exports = {BlockSubscription};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}