{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KeyPairEd25519 = exports.KeyPair = exports.PublicKey = exports.KeyType = void 0;\nvar tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nvar serialize_1 = require(\"./serialize\");\nvar enums_1 = require(\"./enums\");\n/** All supported key types */\nvar KeyType;\n(function (KeyType) {\n  KeyType[KeyType[\"ED25519\"] = 0] = \"ED25519\";\n})(KeyType = exports.KeyType || (exports.KeyType = {}));\nfunction key_type_to_str(keyType) {\n  switch (keyType) {\n    case KeyType.ED25519:\n      return 'ed25519';\n    default:\n      throw new Error(\"Unknown key type \".concat(keyType));\n  }\n}\nfunction str_to_key_type(keyType) {\n  switch (keyType.toLowerCase()) {\n    case 'ed25519':\n      return KeyType.ED25519;\n    default:\n      throw new Error(\"Unknown key type \".concat(keyType));\n  }\n}\n/**\n * PublicKey representation that has type and bytes of the key.\n */\nvar PublicKey = /*#__PURE__*/function (_enums_1$Assignable) {\n  _inherits(PublicKey, _enums_1$Assignable);\n  var _super = _createSuper(PublicKey);\n  function PublicKey() {\n    _classCallCheck(this, PublicKey);\n    return _super.apply(this, arguments);\n  }\n  _createClass(PublicKey, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(key_type_to_str(this.keyType), \":\").concat(serialize_1.base_encode(this.data));\n    }\n  }, {\n    key: \"verify\",\n    value: function verify(message, signature) {\n      switch (this.keyType) {\n        case KeyType.ED25519:\n          return tweetnacl_1.default.sign.detached.verify(message, signature, this.data);\n        default:\n          throw new Error(\"Unknown key type \".concat(this.keyType));\n      }\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === 'string') {\n        return PublicKey.fromString(value);\n      }\n      return value;\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(encodedKey) {\n      var parts = encodedKey.split(':');\n      if (parts.length === 1) {\n        return new PublicKey({\n          keyType: KeyType.ED25519,\n          data: serialize_1.base_decode(parts[0])\n        });\n      } else if (parts.length === 2) {\n        return new PublicKey({\n          keyType: str_to_key_type(parts[0]),\n          data: serialize_1.base_decode(parts[1])\n        });\n      } else {\n        throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\n      }\n    }\n  }]);\n  return PublicKey;\n}(enums_1.Assignable);\nexports.PublicKey = PublicKey;\nvar KeyPair = /*#__PURE__*/function () {\n  function KeyPair() {\n    _classCallCheck(this, KeyPair);\n  }\n  _createClass(KeyPair, null, [{\n    key: \"fromRandom\",\n    value:\n    /**\n     * @param curve Name of elliptical curve, case-insensitive\n     * @returns Random KeyPair based on the curve\n     */\n    function fromRandom(curve) {\n      switch (curve.toUpperCase()) {\n        case 'ED25519':\n          return KeyPairEd25519.fromRandom();\n        default:\n          throw new Error(\"Unknown curve \".concat(curve));\n      }\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(encodedKey) {\n      var parts = encodedKey.split(':');\n      if (parts.length === 1) {\n        return new KeyPairEd25519(parts[0]);\n      } else if (parts.length === 2) {\n        switch (parts[0].toUpperCase()) {\n          case 'ED25519':\n            return new KeyPairEd25519(parts[1]);\n          default:\n            throw new Error(\"Unknown curve: \".concat(parts[0]));\n        }\n      } else {\n        throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\n      }\n    }\n  }]);\n  return KeyPair;\n}();\nexports.KeyPair = KeyPair;\n/**\n * This class provides key pair functionality for Ed25519 curve:\n * generating key pairs, encoding key pairs, signing and verifying.\n */\nvar KeyPairEd25519 = /*#__PURE__*/function (_KeyPair) {\n  _inherits(KeyPairEd25519, _KeyPair);\n  var _super2 = _createSuper(KeyPairEd25519);\n  /**\n   * Construct an instance of key pair given a secret key.\n   * It's generally assumed that these are encoded in base58.\n   * @param {string} secretKey\n   */\n  function KeyPairEd25519(secretKey) {\n    var _this;\n    _classCallCheck(this, KeyPairEd25519);\n    _this = _super2.call(this);\n    var keyPair = tweetnacl_1.default.sign.keyPair.fromSecretKey(serialize_1.base_decode(secretKey));\n    _this.publicKey = new PublicKey({\n      keyType: KeyType.ED25519,\n      data: keyPair.publicKey\n    });\n    _this.secretKey = secretKey;\n    return _this;\n  }\n  /**\n   * Generate a new random keypair.\n   * @example\n   * const keyRandom = KeyPair.fromRandom();\n   * keyRandom.publicKey\n   * // returns [PUBLIC_KEY]\n   *\n   * keyRandom.secretKey\n   * // returns [SECRET_KEY]\n   */\n  _createClass(KeyPairEd25519, [{\n    key: \"sign\",\n    value: function sign(message) {\n      var signature = tweetnacl_1.default.sign.detached(message, serialize_1.base_decode(this.secretKey));\n      return {\n        signature: signature,\n        publicKey: this.publicKey\n      };\n    }\n  }, {\n    key: \"verify\",\n    value: function verify(message, signature) {\n      return this.publicKey.verify(message, signature);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"ed25519:\".concat(this.secretKey);\n    }\n  }, {\n    key: \"getPublicKey\",\n    value: function getPublicKey() {\n      return this.publicKey;\n    }\n  }], [{\n    key: \"fromRandom\",\n    value: function fromRandom() {\n      var newKeyPair = tweetnacl_1.default.sign.keyPair();\n      return new KeyPairEd25519(serialize_1.base_encode(newKeyPair.secretKey));\n    }\n  }]);\n  return KeyPairEd25519;\n}(KeyPair);\nexports.KeyPairEd25519 = KeyPairEd25519;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","KeyPairEd25519","KeyPair","PublicKey","KeyType","tweetnacl_1","require","serialize_1","enums_1","key_type_to_str","keyType","ED25519","Error","str_to_key_type","toLowerCase","base_encode","data","message","signature","default","sign","detached","verify","fromString","encodedKey","parts","split","length","base_decode","Assignable","curve","toUpperCase","fromRandom","secretKey","keyPair","fromSecretKey","publicKey","newKeyPair"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/near-api-js/lib/utils/key_pair.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KeyPairEd25519 = exports.KeyPair = exports.PublicKey = exports.KeyType = void 0;\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst serialize_1 = require(\"./serialize\");\nconst enums_1 = require(\"./enums\");\n/** All supported key types */\nvar KeyType;\n(function (KeyType) {\n    KeyType[KeyType[\"ED25519\"] = 0] = \"ED25519\";\n})(KeyType = exports.KeyType || (exports.KeyType = {}));\nfunction key_type_to_str(keyType) {\n    switch (keyType) {\n        case KeyType.ED25519: return 'ed25519';\n        default: throw new Error(`Unknown key type ${keyType}`);\n    }\n}\nfunction str_to_key_type(keyType) {\n    switch (keyType.toLowerCase()) {\n        case 'ed25519': return KeyType.ED25519;\n        default: throw new Error(`Unknown key type ${keyType}`);\n    }\n}\n/**\n * PublicKey representation that has type and bytes of the key.\n */\nclass PublicKey extends enums_1.Assignable {\n    static from(value) {\n        if (typeof value === 'string') {\n            return PublicKey.fromString(value);\n        }\n        return value;\n    }\n    static fromString(encodedKey) {\n        const parts = encodedKey.split(':');\n        if (parts.length === 1) {\n            return new PublicKey({ keyType: KeyType.ED25519, data: serialize_1.base_decode(parts[0]) });\n        }\n        else if (parts.length === 2) {\n            return new PublicKey({ keyType: str_to_key_type(parts[0]), data: serialize_1.base_decode(parts[1]) });\n        }\n        else {\n            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\n        }\n    }\n    toString() {\n        return `${key_type_to_str(this.keyType)}:${serialize_1.base_encode(this.data)}`;\n    }\n    verify(message, signature) {\n        switch (this.keyType) {\n            case KeyType.ED25519: return tweetnacl_1.default.sign.detached.verify(message, signature, this.data);\n            default: throw new Error(`Unknown key type ${this.keyType}`);\n        }\n    }\n}\nexports.PublicKey = PublicKey;\nclass KeyPair {\n    /**\n     * @param curve Name of elliptical curve, case-insensitive\n     * @returns Random KeyPair based on the curve\n     */\n    static fromRandom(curve) {\n        switch (curve.toUpperCase()) {\n            case 'ED25519': return KeyPairEd25519.fromRandom();\n            default: throw new Error(`Unknown curve ${curve}`);\n        }\n    }\n    static fromString(encodedKey) {\n        const parts = encodedKey.split(':');\n        if (parts.length === 1) {\n            return new KeyPairEd25519(parts[0]);\n        }\n        else if (parts.length === 2) {\n            switch (parts[0].toUpperCase()) {\n                case 'ED25519': return new KeyPairEd25519(parts[1]);\n                default: throw new Error(`Unknown curve: ${parts[0]}`);\n            }\n        }\n        else {\n            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\n        }\n    }\n}\nexports.KeyPair = KeyPair;\n/**\n * This class provides key pair functionality for Ed25519 curve:\n * generating key pairs, encoding key pairs, signing and verifying.\n */\nclass KeyPairEd25519 extends KeyPair {\n    /**\n     * Construct an instance of key pair given a secret key.\n     * It's generally assumed that these are encoded in base58.\n     * @param {string} secretKey\n     */\n    constructor(secretKey) {\n        super();\n        const keyPair = tweetnacl_1.default.sign.keyPair.fromSecretKey(serialize_1.base_decode(secretKey));\n        this.publicKey = new PublicKey({ keyType: KeyType.ED25519, data: keyPair.publicKey });\n        this.secretKey = secretKey;\n    }\n    /**\n     * Generate a new random keypair.\n     * @example\n     * const keyRandom = KeyPair.fromRandom();\n     * keyRandom.publicKey\n     * // returns [PUBLIC_KEY]\n     *\n     * keyRandom.secretKey\n     * // returns [SECRET_KEY]\n     */\n    static fromRandom() {\n        const newKeyPair = tweetnacl_1.default.sign.keyPair();\n        return new KeyPairEd25519(serialize_1.base_encode(newKeyPair.secretKey));\n    }\n    sign(message) {\n        const signature = tweetnacl_1.default.sign.detached(message, serialize_1.base_decode(this.secretKey));\n        return { signature, publicKey: this.publicKey };\n    }\n    verify(message, signature) {\n        return this.publicKey.verify(message, signature);\n    }\n    toString() {\n        return `ed25519:${this.secretKey}`;\n    }\n    getPublicKey() {\n        return this.publicKey;\n    }\n}\nexports.KeyPairEd25519 = KeyPairEd25519;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}