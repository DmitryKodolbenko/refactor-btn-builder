{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hashBlock = exports.hashTx = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encodings_1 = require(\"./encodings\");\n// hash is sha256\n// https://github.com/tendermint/tendermint/blob/master/UPGRADING.md#v0260\nfunction hashTx(tx) {\n  return (0, crypto_1.sha256)(tx);\n}\nexports.hashTx = hashTx;\nfunction getSplitPoint(n) {\n  if (n < 1) throw new Error(\"Cannot split an empty tree\");\n  const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));\n  return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;\n}\nfunction hashLeaf(leaf) {\n  const hash = new crypto_1.Sha256(Uint8Array.from([0]));\n  hash.update(leaf);\n  return hash.digest();\n}\nfunction hashInner(left, right) {\n  const hash = new crypto_1.Sha256(Uint8Array.from([1]));\n  hash.update(left);\n  hash.update(right);\n  return hash.digest();\n}\n// See https://github.com/tendermint/tendermint/blob/v0.31.8/docs/spec/blockchain/encoding.md#merkleroot\n// Note: the hashes input may not actually be hashes, especially before a recursive call\nfunction hashTree(hashes) {\n  switch (hashes.length) {\n    case 0:\n      throw new Error(\"Cannot hash empty tree\");\n    case 1:\n      return hashLeaf(hashes[0]);\n    default:\n      {\n        const slicePoint = getSplitPoint(hashes.length);\n        const left = hashTree(hashes.slice(0, slicePoint));\n        const right = hashTree(hashes.slice(slicePoint));\n        return hashInner(left, right);\n      }\n  }\n}\nfunction hashBlock(header) {\n  if (!header.lastBlockId) {\n    throw new Error(\"Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.\");\n  }\n  const encodedFields = [(0, encodings_1.encodeVersion)(header.version), (0, encodings_1.encodeString)(header.chainId), (0, encodings_1.encodeInt)(header.height), (0, encodings_1.encodeTime)(header.time), (0, encodings_1.encodeBlockId)(header.lastBlockId), (0, encodings_1.encodeBytes)(header.lastCommitHash), (0, encodings_1.encodeBytes)(header.dataHash), (0, encodings_1.encodeBytes)(header.validatorsHash), (0, encodings_1.encodeBytes)(header.nextValidatorsHash), (0, encodings_1.encodeBytes)(header.consensusHash), (0, encodings_1.encodeBytes)(header.appHash), (0, encodings_1.encodeBytes)(header.lastResultsHash), (0, encodings_1.encodeBytes)(header.evidenceHash), (0, encodings_1.encodeBytes)(header.proposerAddress)];\n  return hashTree(encodedFields);\n}\nexports.hashBlock = hashBlock;","map":{"version":3,"sources":["../../src/tendermint34/hasher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashBlock = exports.hashTx = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encodings_1 = require(\"./encodings\");\n// hash is sha256\n// https://github.com/tendermint/tendermint/blob/master/UPGRADING.md#v0260\nfunction hashTx(tx) {\n    return (0, crypto_1.sha256)(tx);\n}\nexports.hashTx = hashTx;\nfunction getSplitPoint(n) {\n    if (n < 1)\n        throw new Error(\"Cannot split an empty tree\");\n    const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));\n    return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;\n}\nfunction hashLeaf(leaf) {\n    const hash = new crypto_1.Sha256(Uint8Array.from([0]));\n    hash.update(leaf);\n    return hash.digest();\n}\nfunction hashInner(left, right) {\n    const hash = new crypto_1.Sha256(Uint8Array.from([1]));\n    hash.update(left);\n    hash.update(right);\n    return hash.digest();\n}\n// See https://github.com/tendermint/tendermint/blob/v0.31.8/docs/spec/blockchain/encoding.md#merkleroot\n// Note: the hashes input may not actually be hashes, especially before a recursive call\nfunction hashTree(hashes) {\n    switch (hashes.length) {\n        case 0:\n            throw new Error(\"Cannot hash empty tree\");\n        case 1:\n            return hashLeaf(hashes[0]);\n        default: {\n            const slicePoint = getSplitPoint(hashes.length);\n            const left = hashTree(hashes.slice(0, slicePoint));\n            const right = hashTree(hashes.slice(slicePoint));\n            return hashInner(left, right);\n        }\n    }\n}\nfunction hashBlock(header) {\n    if (!header.lastBlockId) {\n        throw new Error(\"Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.\");\n    }\n    const encodedFields = [\n        (0, encodings_1.encodeVersion)(header.version),\n        (0, encodings_1.encodeString)(header.chainId),\n        (0, encodings_1.encodeInt)(header.height),\n        (0, encodings_1.encodeTime)(header.time),\n        (0, encodings_1.encodeBlockId)(header.lastBlockId),\n        (0, encodings_1.encodeBytes)(header.lastCommitHash),\n        (0, encodings_1.encodeBytes)(header.dataHash),\n        (0, encodings_1.encodeBytes)(header.validatorsHash),\n        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),\n        (0, encodings_1.encodeBytes)(header.consensusHash),\n        (0, encodings_1.encodeBytes)(header.appHash),\n        (0, encodings_1.encodeBytes)(header.lastResultsHash),\n        (0, encodings_1.encodeBytes)(header.evidenceHash),\n        (0, encodings_1.encodeBytes)(header.proposerAddress),\n    ];\n    return hashTree(encodedFields);\n}\nexports.hashBlock = hashBlock;\n//# sourceMappingURL=hasher.js.map"]},"metadata":{},"sourceType":"script"}