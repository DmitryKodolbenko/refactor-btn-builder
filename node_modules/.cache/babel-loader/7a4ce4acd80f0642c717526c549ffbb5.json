{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompress = exports.compress = void 0;\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nfunction compress(proof) {\n  if (!proof.batch) {\n    return proof;\n  }\n  return {\n    compressed: compressBatch(proof.batch)\n  };\n}\nexports.compress = compress;\nfunction decompress(proof) {\n  if (!proof.compressed) {\n    return proof;\n  }\n  return {\n    batch: decompressBatch(proof.compressed)\n  };\n}\nexports.decompress = decompress;\nfunction compressBatch(proof) {\n  const centries = [];\n  const lookup = [];\n  const registry = new Map();\n  for (const entry of proof.entries) {\n    if (entry.exist) {\n      const centry = {\n        exist: compressExist(entry.exist, lookup, registry)\n      };\n      centries.push(centry);\n    } else if (entry.nonexist) {\n      const non = entry.nonexist;\n      const centry = {\n        nonexist: {\n          key: non.key,\n          left: compressExist(non.left, lookup, registry),\n          right: compressExist(non.right, lookup, registry)\n        }\n      };\n      centries.push(centry);\n    } else {\n      throw new Error(\"Unexpected batch entry during compress\");\n    }\n  }\n  return {\n    entries: centries,\n    lookupInners: lookup\n  };\n}\nfunction compressExist(exist, lookup, registry) {\n  if (!exist) {\n    return undefined;\n  }\n  const path = exist.path.map(inner => {\n    const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();\n    let idx = registry.get(sig);\n    if (idx === undefined) {\n      idx = lookup.length;\n      lookup.push(inner);\n      registry.set(sig, idx);\n    }\n    return idx;\n  });\n  return {\n    key: exist.key,\n    value: exist.value,\n    leaf: exist.leaf,\n    path\n  };\n}\nfunction decompressBatch(proof) {\n  const lookup = proof.lookupInners;\n  const entries = proof.entries.map(comp => {\n    if (comp.exist) {\n      return {\n        exist: decompressExist(comp.exist, lookup)\n      };\n    } else if (comp.nonexist) {\n      const non = comp.nonexist;\n      return {\n        nonexist: {\n          key: non.key,\n          left: decompressExist(non.left, lookup),\n          right: decompressExist(non.right, lookup)\n        }\n      };\n    } else {\n      throw new Error(\"Unexpected batch entry during compress\");\n    }\n  });\n  return {\n    entries\n  };\n}\nfunction decompressExist(exist, lookup) {\n  if (!exist) {\n    return undefined;\n  }\n  const {\n    key,\n    value,\n    leaf,\n    path\n  } = exist;\n  const newPath = (path || []).map(idx => lookup[idx]);\n  return {\n    key,\n    value,\n    leaf,\n    path: newPath\n  };\n}","map":{"version":3,"sources":["../src/compress.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decompress = exports.compress = void 0;\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nfunction compress(proof) {\n    if (!proof.batch) {\n        return proof;\n    }\n    return { compressed: compressBatch(proof.batch) };\n}\nexports.compress = compress;\nfunction decompress(proof) {\n    if (!proof.compressed) {\n        return proof;\n    }\n    return { batch: decompressBatch(proof.compressed) };\n}\nexports.decompress = decompress;\nfunction compressBatch(proof) {\n    const centries = [];\n    const lookup = [];\n    const registry = new Map();\n    for (const entry of proof.entries) {\n        if (entry.exist) {\n            const centry = { exist: compressExist(entry.exist, lookup, registry) };\n            centries.push(centry);\n        }\n        else if (entry.nonexist) {\n            const non = entry.nonexist;\n            const centry = {\n                nonexist: {\n                    key: non.key,\n                    left: compressExist(non.left, lookup, registry),\n                    right: compressExist(non.right, lookup, registry),\n                },\n            };\n            centries.push(centry);\n        }\n        else {\n            throw new Error(\"Unexpected batch entry during compress\");\n        }\n    }\n    return {\n        entries: centries,\n        lookupInners: lookup,\n    };\n}\nfunction compressExist(exist, lookup, registry) {\n    if (!exist) {\n        return undefined;\n    }\n    const path = exist.path.map((inner) => {\n        const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();\n        let idx = registry.get(sig);\n        if (idx === undefined) {\n            idx = lookup.length;\n            lookup.push(inner);\n            registry.set(sig, idx);\n        }\n        return idx;\n    });\n    return {\n        key: exist.key,\n        value: exist.value,\n        leaf: exist.leaf,\n        path,\n    };\n}\nfunction decompressBatch(proof) {\n    const lookup = proof.lookupInners;\n    const entries = proof.entries.map((comp) => {\n        if (comp.exist) {\n            return { exist: decompressExist(comp.exist, lookup) };\n        }\n        else if (comp.nonexist) {\n            const non = comp.nonexist;\n            return {\n                nonexist: {\n                    key: non.key,\n                    left: decompressExist(non.left, lookup),\n                    right: decompressExist(non.right, lookup),\n                },\n            };\n        }\n        else {\n            throw new Error(\"Unexpected batch entry during compress\");\n        }\n    });\n    return {\n        entries,\n    };\n}\nfunction decompressExist(exist, lookup) {\n    if (!exist) {\n        return undefined;\n    }\n    const { key, value, leaf, path } = exist;\n    const newPath = (path || []).map((idx) => lookup[idx]);\n    return { key, value, leaf, path: newPath };\n}\n//# sourceMappingURL=compress.js.map"]},"metadata":{},"sourceType":"script"}