{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SocketWrapper = void 0;\nvar isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\nfunction environmentIsNodeJs() {\n  return typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.node !== \"undefined\";\n}\n/**\n * A thin wrapper around isomorphic-ws' WebSocket class that adds\n * - constant message/error/open/close handlers\n * - explict connection via a connect() method\n * - type support for events\n * - handling of corner cases in the open and close behaviour\n */\nvar SocketWrapper = /*#__PURE__*/function () {\n  function SocketWrapper(url, messageHandler, errorHandler, openHandler, closeHandler) {\n    var _this = this;\n    var timeout = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10000;\n    _classCallCheck(this, SocketWrapper);\n    this.closed = false;\n    this.connected = new Promise(function (resolve, reject) {\n      _this.connectedResolver = resolve;\n      _this.connectedRejecter = reject;\n    });\n    this.url = url;\n    this.messageHandler = messageHandler;\n    this.errorHandler = errorHandler;\n    this.openHandler = openHandler;\n    this.closeHandler = closeHandler;\n    this.timeout = timeout;\n  }\n  /**\n   * returns a promise that resolves when connection is open\n   */\n  _createClass(SocketWrapper, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n      var socket = new isomorphic_ws_1.default(this.url);\n      socket.onerror = function (error) {\n        _this2.clearTimeout();\n        if (_this2.errorHandler) {\n          _this2.errorHandler(error);\n        }\n      };\n      socket.onmessage = function (messageEvent) {\n        _this2.messageHandler({\n          type: messageEvent.type,\n          data: messageEvent.data\n        });\n      };\n      socket.onopen = function (_) {\n        _this2.clearTimeout();\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        _this2.connectedResolver();\n        if (_this2.openHandler) {\n          _this2.openHandler();\n        }\n      };\n      socket.onclose = function (closeEvent) {\n        _this2.closed = true;\n        if (_this2.closeHandler) {\n          _this2.closeHandler(closeEvent);\n        }\n      };\n      var started = Date.now();\n      this.timeoutId = setTimeout(function () {\n        socket.onmessage = function () {\n          return 0;\n        };\n        socket.onerror = function () {\n          return 0;\n        };\n        socket.onopen = function () {\n          return 0;\n        };\n        socket.onclose = function () {\n          return 0;\n        };\n        socket.close();\n        _this2.socket = undefined;\n        var elapsed = Math.floor(Date.now() - started);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        _this2.connectedRejecter(\"Connection attempt timed out after \".concat(elapsed, \" ms\"));\n      }, this.timeout);\n      this.socket = socket;\n    }\n    /**\n     * Closes an established connection and aborts other connection states\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (!this.socket) {\n        throw new Error(\"Socket undefined. This must be called after connecting.\");\n      }\n      this.clearTimeout();\n      switch (this.socket.readyState) {\n        case isomorphic_ws_1.default.OPEN:\n          this.socket.close(1000 /* Normal Closure */);\n          break;\n        case isomorphic_ws_1.default.CLOSED:\n          // nothing to be done\n          break;\n        case isomorphic_ws_1.default.CONNECTING:\n          // imitate missing abort API\n          this.socket.onopen = function () {\n            return 0;\n          };\n          this.socket.onclose = function () {\n            return 0;\n          };\n          this.socket.onerror = function () {\n            return 0;\n          };\n          this.socket.onmessage = function () {\n            return 0;\n          };\n          this.socket = undefined;\n          if (this.closeHandler) {\n            this.closeHandler({\n              wasClean: false,\n              code: 4001\n            });\n          }\n          break;\n        case isomorphic_ws_1.default.CLOSING:\n          // already closing. Let it proceed\n          break;\n        default:\n          throw new Error(\"Unknown readyState: \".concat(this.socket.readyState));\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data) {\n        var _this3 = this;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  if (!_this3.socket) {\n                    throw new Error(\"Socket undefined. This must be called after connecting.\");\n                  }\n                  if (_this3.closed) {\n                    throw new Error(\"Socket was closed, so no data can be sent anymore.\");\n                  }\n                  // this exception should be thrown by send() automatically according to\n                  // https://developer.mozilla.org/de/docs/Web/API/WebSocket#send() but it does not work in browsers\n                  if (_this3.socket.readyState !== isomorphic_ws_1.default.OPEN) {\n                    throw new Error(\"Websocket is not open\");\n                  }\n                  if (environmentIsNodeJs()) {\n                    _this3.socket.send(data, function (err) {\n                      return err ? reject(err) : resolve();\n                    });\n                  } else {\n                    // Browser websocket send method does not accept a callback\n                    _this3.socket.send(data);\n                    resolve();\n                  }\n                }));\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      function send(_x) {\n        return _send.apply(this, arguments);\n      }\n      return send;\n    }()\n    /**\n     * Clears the timeout function, such that no timeout error will be raised anymore. This should be\n     * called when the connection is established, a connection error occurred or the socket is disconnected.\n     *\n     * This method must not be called before `connect()`.\n     * This method is idempotent.\n     */\n  }, {\n    key: \"clearTimeout\",\n    value: function (_clearTimeout) {\n      function clearTimeout() {\n        return _clearTimeout.apply(this, arguments);\n      }\n      clearTimeout.toString = function () {\n        return _clearTimeout.toString();\n      };\n      return clearTimeout;\n    }(function () {\n      if (!this.timeoutId) {\n        throw new Error(\"Timeout ID not set. This should not happen and usually means connect() was not called.\");\n      }\n      // Note: do not unset this.timeoutId to allow multiple calls to this function\n      clearTimeout(this.timeoutId);\n    })\n  }]);\n  return SocketWrapper;\n}();\nexports.SocketWrapper = SocketWrapper;","map":{"version":3,"sources":["../src/socketwrapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SocketWrapper = void 0;\nconst isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\nfunction environmentIsNodeJs() {\n    return (typeof process !== \"undefined\" &&\n        typeof process.versions !== \"undefined\" &&\n        typeof process.versions.node !== \"undefined\");\n}\n/**\n * A thin wrapper around isomorphic-ws' WebSocket class that adds\n * - constant message/error/open/close handlers\n * - explict connection via a connect() method\n * - type support for events\n * - handling of corner cases in the open and close behaviour\n */\nclass SocketWrapper {\n    constructor(url, messageHandler, errorHandler, openHandler, closeHandler, timeout = 10000) {\n        this.closed = false;\n        this.connected = new Promise((resolve, reject) => {\n            this.connectedResolver = resolve;\n            this.connectedRejecter = reject;\n        });\n        this.url = url;\n        this.messageHandler = messageHandler;\n        this.errorHandler = errorHandler;\n        this.openHandler = openHandler;\n        this.closeHandler = closeHandler;\n        this.timeout = timeout;\n    }\n    /**\n     * returns a promise that resolves when connection is open\n     */\n    connect() {\n        const socket = new isomorphic_ws_1.default(this.url);\n        socket.onerror = (error) => {\n            this.clearTimeout();\n            if (this.errorHandler) {\n                this.errorHandler(error);\n            }\n        };\n        socket.onmessage = (messageEvent) => {\n            this.messageHandler({\n                type: messageEvent.type,\n                data: messageEvent.data,\n            });\n        };\n        socket.onopen = (_) => {\n            this.clearTimeout();\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.connectedResolver();\n            if (this.openHandler) {\n                this.openHandler();\n            }\n        };\n        socket.onclose = (closeEvent) => {\n            this.closed = true;\n            if (this.closeHandler) {\n                this.closeHandler(closeEvent);\n            }\n        };\n        const started = Date.now();\n        this.timeoutId = setTimeout(() => {\n            socket.onmessage = () => 0;\n            socket.onerror = () => 0;\n            socket.onopen = () => 0;\n            socket.onclose = () => 0;\n            socket.close();\n            this.socket = undefined;\n            const elapsed = Math.floor(Date.now() - started);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.connectedRejecter(`Connection attempt timed out after ${elapsed} ms`);\n        }, this.timeout);\n        this.socket = socket;\n    }\n    /**\n     * Closes an established connection and aborts other connection states\n     */\n    disconnect() {\n        if (!this.socket) {\n            throw new Error(\"Socket undefined. This must be called after connecting.\");\n        }\n        this.clearTimeout();\n        switch (this.socket.readyState) {\n            case isomorphic_ws_1.default.OPEN:\n                this.socket.close(1000 /* Normal Closure */);\n                break;\n            case isomorphic_ws_1.default.CLOSED:\n                // nothing to be done\n                break;\n            case isomorphic_ws_1.default.CONNECTING:\n                // imitate missing abort API\n                this.socket.onopen = () => 0;\n                this.socket.onclose = () => 0;\n                this.socket.onerror = () => 0;\n                this.socket.onmessage = () => 0;\n                this.socket = undefined;\n                if (this.closeHandler) {\n                    this.closeHandler({ wasClean: false, code: 4001 });\n                }\n                break;\n            case isomorphic_ws_1.default.CLOSING:\n                // already closing. Let it proceed\n                break;\n            default:\n                throw new Error(`Unknown readyState: ${this.socket.readyState}`);\n        }\n    }\n    async send(data) {\n        return new Promise((resolve, reject) => {\n            if (!this.socket) {\n                throw new Error(\"Socket undefined. This must be called after connecting.\");\n            }\n            if (this.closed) {\n                throw new Error(\"Socket was closed, so no data can be sent anymore.\");\n            }\n            // this exception should be thrown by send() automatically according to\n            // https://developer.mozilla.org/de/docs/Web/API/WebSocket#send() but it does not work in browsers\n            if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {\n                throw new Error(\"Websocket is not open\");\n            }\n            if (environmentIsNodeJs()) {\n                this.socket.send(data, (err) => (err ? reject(err) : resolve()));\n            }\n            else {\n                // Browser websocket send method does not accept a callback\n                this.socket.send(data);\n                resolve();\n            }\n        });\n    }\n    /**\n     * Clears the timeout function, such that no timeout error will be raised anymore. This should be\n     * called when the connection is established, a connection error occurred or the socket is disconnected.\n     *\n     * This method must not be called before `connect()`.\n     * This method is idempotent.\n     */\n    clearTimeout() {\n        if (!this.timeoutId) {\n            throw new Error(\"Timeout ID not set. This should not happen and usually means connect() was not called.\");\n        }\n        // Note: do not unset this.timeoutId to allow multiple calls to this function\n        clearTimeout(this.timeoutId);\n    }\n}\nexports.SocketWrapper = SocketWrapper;\n//# sourceMappingURL=socketwrapper.js.map"]},"metadata":{},"sourceType":"script"}