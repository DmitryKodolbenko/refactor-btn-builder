{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseShardStateUnsplit = exports.parseMasterchainStateExtra = exports.parseShardAccounts = exports.parseDepthBalanceInfo = exports.parseShardAccount = exports.parseShardIdent = exports.parseAccount = exports.parseAccountStorage = exports.parseAccountState = exports.parseStorageInfo = exports.parseStorageUsed = exports.parseTransaction = exports.parseTransactionDescription = exports.parseBouncePhase = exports.parseActionPhase = exports.parseComputePhase = exports.parseCreditPhase = exports.parseStoragePhase = exports.parseStorageUsedShort = exports.parseAccountChange = exports.parseHashUpdate = exports.parseMessage = exports.parseStateInit = exports.parseRawTickTock = exports.parseCommonMsgInfo = exports.parseCurrencyCollection = exports.parseAccountStatus = void 0;\nconst __1 = require(\"..\");\nconst parseDict_1 = require(\"../boc/dict/parseDict\");\nfunction parseAccountStatus(slice) {\n  const status = slice.readUintNumber(2);\n  if (status === 0x00) {\n    return 'uninitialized';\n  }\n  if (status === 0x01) {\n    return 'frozen';\n  }\n  if (status === 0x02) {\n    return 'active';\n  }\n  if (status === 0x03) {\n    return 'non-existing';\n  }\n  throw Error('Invalid data');\n}\nexports.parseAccountStatus = parseAccountStatus;\nfunction parseCurrencyCollection(slice) {\n  const coins = slice.readCoins();\n  // Read extra currencies\n  let extraCurrencies = null;\n  if (slice.readBit()) {\n    let dc = slice.readCell();\n    if (!dc.isExotic) {\n      let pd = (0, parseDict_1.parseDict)(dc.beginParse(), 32, s => s.readVarUIntNumber(5));\n      extraCurrencies = new Map();\n      for (let e of pd) {\n        extraCurrencies.set(parseInt(e[0], 10), e[1]);\n      }\n    }\n  }\n  return {\n    extraCurrencies,\n    coins\n  };\n}\nexports.parseCurrencyCollection = parseCurrencyCollection;\nfunction parseCommonMsgInfo(slice) {\n  if (!slice.readBit()) {\n    // Internal\n    let ihrDisabled = slice.readBit();\n    let bounce = slice.readBit();\n    let bounced = slice.readBit();\n    let src = slice.readAddress();\n    let dest = slice.readAddress();\n    let value = parseCurrencyCollection(slice);\n    let ihrFee = slice.readCoins();\n    let fwdFee = slice.readCoins();\n    let createdLt = slice.readUint(64);\n    let createdAt = slice.readUintNumber(32);\n    return {\n      type: 'internal',\n      ihrDisabled,\n      bounce,\n      bounced,\n      src,\n      dest,\n      value,\n      ihrFee,\n      fwdFee,\n      createdLt,\n      createdAt\n    };\n  } else if (slice.readBit()) {\n    // Outgoing external\n    let src = slice.readAddress();\n    let dest = slice.readAddress();\n    let createdLt = slice.readUint(64);\n    let createdAt = slice.readUintNumber(32);\n    return {\n      type: 'external-out',\n      src,\n      dest,\n      createdLt,\n      createdAt\n    };\n  } else {\n    // Incoming external\n    let src = slice.readAddress();\n    let dest = slice.readAddress();\n    let importFee = slice.readCoins();\n    return {\n      type: 'external-in',\n      src,\n      dest,\n      importFee\n    };\n  }\n}\nexports.parseCommonMsgInfo = parseCommonMsgInfo;\nfunction parseRawTickTock(slice) {\n  return {\n    tick: slice.readBit(),\n    tock: slice.readBit()\n  };\n}\nexports.parseRawTickTock = parseRawTickTock;\nfunction parseStateInit(slice) {\n  let raw = slice.toCell();\n  let splitDepth = null;\n  if (slice.readBit()) {\n    splitDepth = slice.readUintNumber(5);\n  }\n  const special = slice.readBit() ? parseRawTickTock(slice) : null;\n  const hasCode = slice.readBit();\n  const code = hasCode ? slice.readCell() : null;\n  const hasData = slice.readBit();\n  const data = hasData ? slice.readCell() : null;\n  if (slice.readBit()) {\n    slice.readCell(); // Skip libraries for now\n  }\n\n  return {\n    splitDepth,\n    data,\n    code,\n    special,\n    raw\n  };\n}\nexports.parseStateInit = parseStateInit;\nfunction parseMessage(slice) {\n  const raw = slice.toCell();\n  const info = parseCommonMsgInfo(slice);\n  const hasInit = slice.readBit();\n  let init = null;\n  if (hasInit) {\n    if (!slice.readBit()) {\n      init = parseStateInit(slice);\n    } else {\n      init = parseStateInit(slice.readRef());\n    }\n  }\n  const body = slice.readBit() ? slice.readRef().toCell() : slice.toCell();\n  return {\n    info,\n    init,\n    body,\n    raw\n  };\n}\nexports.parseMessage = parseMessage;\nfunction parseHashUpdate(slice) {\n  if (slice.readUintNumber(8) !== 0x72) {\n    throw Error('Invalid data');\n  }\n  const oldHash = slice.readBuffer(32);\n  const newHash = slice.readBuffer(32);\n  return {\n    oldHash,\n    newHash\n  };\n}\nexports.parseHashUpdate = parseHashUpdate;\nfunction parseAccountChange(slice) {\n  if (!slice.readBit()) {\n    return 'unchanged';\n  }\n  if (slice.readBit()) {\n    return 'frozen';\n  } else {\n    return 'deleted';\n  }\n}\nexports.parseAccountChange = parseAccountChange;\nfunction parseStorageUsedShort(slice) {\n  return {\n    cells: slice.readVarUIntNumber(3),\n    bits: slice.readVarUIntNumber(3)\n  };\n}\nexports.parseStorageUsedShort = parseStorageUsedShort;\nfunction parseStoragePhase(slice) {\n  const storageFeesCollected = slice.readCoins();\n  let storageFeesDue = null;\n  if (slice.readBit()) {\n    storageFeesDue = slice.readCoins();\n  }\n  const statusChange = parseAccountChange(slice);\n  return {\n    storageFeesCollected,\n    storageFeesDue,\n    statusChange\n  };\n}\nexports.parseStoragePhase = parseStoragePhase;\nfunction parseCreditPhase(slice) {\n  let dueFeesColelcted = slice.readBit() ? slice.readCoins() : null;\n  const credit = parseCurrencyCollection(slice);\n  return {\n    dueFeesColelcted,\n    credit\n  };\n}\nexports.parseCreditPhase = parseCreditPhase;\nfunction parseComputePhase(slice) {\n  if (!slice.readBit()) {\n    const skipReason = slice.readUintNumber(2);\n    if (skipReason === 0x00) {\n      return {\n        type: 'skipped',\n        reason: 'no-state'\n      };\n    }\n    if (skipReason === 0x01) {\n      return {\n        type: 'skipped',\n        reason: 'bad-state'\n      };\n    }\n    if (skipReason === 0x02) {\n      return {\n        type: 'skipped',\n        reason: 'no-gas'\n      };\n    }\n  }\n  const success = slice.readBit();\n  const messageStateUsed = slice.readBit();\n  const accountActivated = slice.readBit();\n  let gasFees = slice.readCoins();\n  const vmState = slice.readRef();\n  let gasUsed = vmState.readVarUInt(3);\n  let gasLimit = vmState.readVarUInt(3);\n  let gasCredit = vmState.readBit() ? vmState.readVarUInt(2) : null;\n  let mode = vmState.readUintNumber(8);\n  let exitCode = vmState.readUintNumber(32);\n  let exitArg = vmState.readBit() ? vmState.readUintNumber(32) : null; // TODO: change to int\n  let vmSteps = vmState.readUintNumber(32);\n  let vmInitStateHash = vmState.readBuffer(32);\n  let vmFinalStateHash = vmState.readBuffer(32);\n  return {\n    type: 'computed',\n    success,\n    messageStateUsed,\n    accountActivated,\n    gasFees,\n    gasUsed,\n    gasLimit,\n    gasCredit,\n    mode,\n    exitCode,\n    exitArg,\n    vmSteps,\n    vmInitStateHash,\n    vmFinalStateHash\n  };\n}\nexports.parseComputePhase = parseComputePhase;\nfunction parseActionPhase(slice) {\n  const success = slice.readBit();\n  const valid = slice.readBit();\n  const noFunds = slice.readBit();\n  const statusChange = parseAccountChange(slice);\n  const totalFwdFees = slice.readBit() ? slice.readCoins() : null;\n  const totalActionFees = slice.readBit() ? slice.readCoins() : null;\n  const resultCode = slice.readUintNumber(32); // TODO: Change to int32\n  const resultArg = slice.readBit() ? slice.readUintNumber(32) : null; // TODO: Change to int32\n  const totalActions = slice.readUintNumber(16);\n  const specialActions = slice.readUintNumber(16);\n  const skippedActions = slice.readUintNumber(16);\n  const messagesCreated = slice.readUintNumber(16);\n  const actionListHash = slice.readBuffer(32);\n  const totalMessageSizes = parseStorageUsedShort(slice);\n  return {\n    success,\n    valid,\n    noFunds,\n    statusChange,\n    totalFwdFees,\n    totalActionFees,\n    resultCode,\n    resultArg,\n    totalActions,\n    specialActions,\n    skippedActions,\n    messagesCreated,\n    actionListHash,\n    totalMessageSizes\n  };\n}\nexports.parseActionPhase = parseActionPhase;\nfunction parseBouncePhase(slice) {\n  // Is OK\n  if (slice.readBit()) {\n    const msgSize = parseStorageUsedShort(slice);\n    const msgFees = slice.readCoins();\n    const fwdFees = slice.readCoins();\n    return {\n      type: 'ok',\n      msgSize,\n      msgFees,\n      fwdFees\n    };\n  }\n  // No funds\n  if (slice.readBit()) {\n    const msgSize = parseStorageUsedShort(slice);\n    const fwdFees = slice.readCoins();\n    return {\n      type: 'no-funds',\n      msgSize,\n      fwdFees\n    };\n  }\n  return {\n    type: 'negative-funds'\n  };\n}\nexports.parseBouncePhase = parseBouncePhase;\nfunction parseTransactionDescription(slice) {\n  const type = slice.readUintNumber(4);\n  if (type === 0x00) {\n    const creditFirst = slice.readBit();\n    let storagePhase = null;\n    let creditPhase = null;\n    if (slice.readBit()) {\n      storagePhase = parseStoragePhase(slice);\n    }\n    if (slice.readBit()) {\n      creditPhase = parseCreditPhase(slice);\n    }\n    let computePhase = parseComputePhase(slice);\n    let actionPhase = null;\n    if (slice.readBit()) {\n      actionPhase = parseActionPhase(slice.readRef());\n    }\n    let aborted = slice.readBit();\n    let bouncePhase = null;\n    if (slice.readBit()) {\n      bouncePhase = parseBouncePhase(slice);\n    }\n    const destroyed = slice.readBit();\n    return {\n      type: 'generic',\n      creditFirst,\n      storagePhase,\n      creditPhase,\n      computePhase,\n      actionPhase,\n      bouncePhase,\n      aborted,\n      destroyed\n    };\n  }\n  if (type === 0x01) {\n    let storagePhase = parseStoragePhase(slice);\n    return {\n      type: 'storage',\n      storagePhase\n    };\n  }\n  if (type === 0x2 || type === 0x03) {\n    const isTock = type === 0x03;\n    let storagePhase = parseStoragePhase(slice);\n    let computePhase = parseComputePhase(slice);\n    let actionPhase = null;\n    if (slice.readBit()) {\n      actionPhase = parseActionPhase(slice.readRef());\n    }\n    const aborted = slice.readBit();\n    const destroyed = slice.readBit();\n    return {\n      type: 'tick-tock',\n      isTock,\n      storagePhase,\n      computePhase,\n      actionPhase,\n      aborted,\n      destroyed\n    };\n  }\n  throw Error('Unsupported transaction type');\n}\nexports.parseTransactionDescription = parseTransactionDescription;\nfunction parseTransaction(workchain, slice) {\n  if (slice.readUintNumber(4) !== 0x07) {\n    throw Error('Invalid data');\n  }\n  // Read address\n  const addressHash = slice.readBuffer(32);\n  const address = new __1.Address(workchain, addressHash);\n  // Read lt\n  const lt = slice.readUint(64);\n  // Read prevTrans\n  const prevTransHash = slice.readBuffer(32);\n  const prevTransLt = slice.readUint(64);\n  // Read time\n  const time = slice.readUintNumber(32);\n  // Output messages\n  const outMessagesCount = slice.readUintNumber(15);\n  // Status\n  const oldStatus = parseAccountStatus(slice);\n  const newStatus = parseAccountStatus(slice);\n  // Messages ref\n  const messages = slice.readRef();\n  let hasInMessage = messages.readBit();\n  let hasOutMessages = messages.readBit();\n  let inMessage = null;\n  if (hasInMessage) {\n    inMessage = parseMessage(messages.readRef());\n  }\n  let outMessages = [];\n  if (hasOutMessages) {\n    let dict = messages.readDict(15, slice => parseMessage(slice.readRef()));\n    for (let msg of Array.from(dict.values())) {\n      outMessages.push(msg);\n    }\n  }\n  // Currency collections\n  let fees = parseCurrencyCollection(slice);\n  // Hash update\n  let update = parseHashUpdate(slice.readRef());\n  // Description\n  let description = parseTransactionDescription(slice.readRef());\n  return {\n    address,\n    lt,\n    time,\n    outMessagesCount,\n    oldStatus,\n    newStatus,\n    fees,\n    update,\n    description,\n    inMessage,\n    outMessages,\n    prevTransaction: {\n      hash: prevTransHash,\n      lt: prevTransLt\n    }\n  };\n}\nexports.parseTransaction = parseTransaction;\nfunction parseStorageUsed(cs) {\n  return {\n    cells: cs.readVarUIntNumber(3),\n    bits: cs.readVarUIntNumber(3),\n    publicCells: cs.readVarUIntNumber(3)\n  };\n}\nexports.parseStorageUsed = parseStorageUsed;\nfunction parseStorageInfo(cs) {\n  return {\n    used: parseStorageUsed(cs),\n    lastPaid: cs.readUintNumber(32),\n    duePayment: cs.readBit() ? cs.readCoins() : null\n  };\n}\nexports.parseStorageInfo = parseStorageInfo;\nfunction parseAccountState(cs) {\n  if (cs.readBit()) {\n    return {\n      type: 'active',\n      state: parseStateInit(cs)\n    };\n  } else if (cs.readBit()) {\n    return {\n      type: 'frozen',\n      stateHash: cs.readBuffer(32)\n    };\n  } else {\n    return {\n      type: 'uninit'\n    };\n  }\n}\nexports.parseAccountState = parseAccountState;\nfunction parseAccountStorage(cs) {\n  return {\n    lastTransLt: cs.readUint(64),\n    balance: parseCurrencyCollection(cs),\n    state: parseAccountState(cs)\n  };\n}\nexports.parseAccountStorage = parseAccountStorage;\nfunction parseAccount(cs) {\n  if (cs.readBit()) {\n    return {\n      address: cs.readAddress(),\n      storageStat: parseStorageInfo(cs),\n      storage: parseAccountStorage(cs)\n    };\n  } else {\n    return null;\n  }\n}\nexports.parseAccount = parseAccount;\nfunction parseShardIdent(cs) {\n  if (cs.readUintNumber(2) !== 0) {\n    throw Error('Invalid data');\n  }\n  let shardPrefixBits = cs.readUintNumber(6);\n  let workchainId = cs.readIntNumber(32);\n  let shardPrefix = cs.readUint(64);\n  return {\n    shardPrefixBits,\n    workchainId,\n    shardPrefix\n  };\n}\nexports.parseShardIdent = parseShardIdent;\nfunction parseShardAccount(cs) {\n  let accountCell = cs.readCell();\n  let address = null;\n  if (!accountCell.isExotic) {\n    address = accountCell.beginParse().readAddress();\n  }\n  return {\n    address,\n    lastTransHash: cs.readBuffer(32),\n    lastTransLt: cs.readUint(64)\n  };\n}\nexports.parseShardAccount = parseShardAccount;\nfunction parseDepthBalanceInfo(cs) {\n  return {\n    splitDepth: cs.readUintNumber(5),\n    balance: parseCurrencyCollection(cs)\n  };\n}\nexports.parseDepthBalanceInfo = parseDepthBalanceInfo;\nfunction parseShardAccounts(cs) {\n  if (!cs.readBit()) {\n    return new Map();\n  }\n  return (0, parseDict_1.parseDict)(cs.readRef(), 256, cs2 => {\n    let depthBalanceInfo = parseDepthBalanceInfo(cs2);\n    let shardAccount = parseShardAccount(cs2);\n    return {\n      depthBalanceInfo,\n      shardAccount\n    };\n  });\n}\nexports.parseShardAccounts = parseShardAccounts;\nfunction parseMasterchainStateExtra(cs) {\n  // Check magic\n  if (cs.readUintNumber(16) !== 0xcc26) {\n    throw Error('Invalid data');\n  }\n  // Skip shard_hashes\n  if (cs.readBit()) {\n    cs.readCell();\n  }\n  // Read config\n  let configAddress = new __1.Address(-1, cs.readBuffer(32));\n  let config = cs.readCell();\n  // Rad global balance\n  const globalBalance = parseCurrencyCollection(cs);\n  return {\n    config,\n    configAddress,\n    globalBalance\n  };\n}\nexports.parseMasterchainStateExtra = parseMasterchainStateExtra;\nfunction parseShardStateUnsplit(cs) {\n  if (cs.readUintNumber(32) !== 0x9023afe2) {\n    throw Error('Invalid data');\n  }\n  let globalId = cs.readIntNumber(32);\n  let shardId = parseShardIdent(cs);\n  let seqno = cs.readUintNumber(32);\n  let vertSeqNo = cs.readUintNumber(32);\n  let genUtime = cs.readUintNumber(32);\n  let genLt = cs.readUint(64);\n  let minRefSeqno = cs.readUintNumber(32);\n  // Skip OutMsgQueueInfo: usually exotic\n  cs.readCell();\n  let beforeSplit = cs.readBit();\n  // Parse accounts\n  let accounts;\n  let accountsCell = cs.readCell();\n  if (accountsCell.isExotic) {\n    accounts = new Map();\n  } else {\n    accounts = parseShardAccounts(accountsCell.beginParse());\n  }\n  // Skip (not used by apps)\n  cs.readCell();\n  // Parse extras\n  let mcStateExtra = cs.readBit();\n  let extras = null;\n  if (mcStateExtra) {\n    let cell = cs.readCell();\n    if (!cell.isExotic) {\n      extras = parseMasterchainStateExtra(cell.beginParse());\n    }\n  }\n  ;\n  return {\n    globalId,\n    shardId,\n    seqno,\n    vertSeqNo,\n    genUtime,\n    genLt,\n    minRefSeqno,\n    beforeSplit,\n    accounts,\n    extras\n  };\n}\nexports.parseShardStateUnsplit = parseShardStateUnsplit;","map":{"version":3,"names":["Object","defineProperty","exports","value","parseShardStateUnsplit","parseMasterchainStateExtra","parseShardAccounts","parseDepthBalanceInfo","parseShardAccount","parseShardIdent","parseAccount","parseAccountStorage","parseAccountState","parseStorageInfo","parseStorageUsed","parseTransaction","parseTransactionDescription","parseBouncePhase","parseActionPhase","parseComputePhase","parseCreditPhase","parseStoragePhase","parseStorageUsedShort","parseAccountChange","parseHashUpdate","parseMessage","parseStateInit","parseRawTickTock","parseCommonMsgInfo","parseCurrencyCollection","parseAccountStatus","__1","require","parseDict_1","slice","status","readUintNumber","Error","coins","readCoins","extraCurrencies","readBit","dc","readCell","isExotic","pd","parseDict","beginParse","s","readVarUIntNumber","Map","e","set","parseInt","ihrDisabled","bounce","bounced","src","readAddress","dest","ihrFee","fwdFee","createdLt","readUint","createdAt","type","importFee","tick","tock","raw","toCell","splitDepth","special","hasCode","code","hasData","data","info","hasInit","init","readRef","body","oldHash","readBuffer","newHash","cells","bits","storageFeesCollected","storageFeesDue","statusChange","dueFeesColelcted","credit","skipReason","reason","success","messageStateUsed","accountActivated","gasFees","vmState","gasUsed","readVarUInt","gasLimit","gasCredit","mode","exitCode","exitArg","vmSteps","vmInitStateHash","vmFinalStateHash","valid","noFunds","totalFwdFees","totalActionFees","resultCode","resultArg","totalActions","specialActions","skippedActions","messagesCreated","actionListHash","totalMessageSizes","msgSize","msgFees","fwdFees","creditFirst","storagePhase","creditPhase","computePhase","actionPhase","aborted","bouncePhase","destroyed","isTock","workchain","addressHash","address","Address","lt","prevTransHash","prevTransLt","time","outMessagesCount","oldStatus","newStatus","messages","hasInMessage","hasOutMessages","inMessage","outMessages","dict","readDict","msg","Array","from","values","push","fees","update","description","prevTransaction","hash","cs","publicCells","used","lastPaid","duePayment","state","stateHash","lastTransLt","balance","storageStat","storage","shardPrefixBits","workchainId","readIntNumber","shardPrefix","accountCell","lastTransHash","cs2","depthBalanceInfo","shardAccount","configAddress","config","globalBalance","globalId","shardId","seqno","vertSeqNo","genUtime","genLt","minRefSeqno","beforeSplit","accounts","accountsCell","mcStateExtra","extras","cell"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/block/parse.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseShardStateUnsplit = exports.parseMasterchainStateExtra = exports.parseShardAccounts = exports.parseDepthBalanceInfo = exports.parseShardAccount = exports.parseShardIdent = exports.parseAccount = exports.parseAccountStorage = exports.parseAccountState = exports.parseStorageInfo = exports.parseStorageUsed = exports.parseTransaction = exports.parseTransactionDescription = exports.parseBouncePhase = exports.parseActionPhase = exports.parseComputePhase = exports.parseCreditPhase = exports.parseStoragePhase = exports.parseStorageUsedShort = exports.parseAccountChange = exports.parseHashUpdate = exports.parseMessage = exports.parseStateInit = exports.parseRawTickTock = exports.parseCommonMsgInfo = exports.parseCurrencyCollection = exports.parseAccountStatus = void 0;\nconst __1 = require(\"..\");\nconst parseDict_1 = require(\"../boc/dict/parseDict\");\nfunction parseAccountStatus(slice) {\n    const status = slice.readUintNumber(2);\n    if (status === 0x00) {\n        return 'uninitialized';\n    }\n    if (status === 0x01) {\n        return 'frozen';\n    }\n    if (status === 0x02) {\n        return 'active';\n    }\n    if (status === 0x03) {\n        return 'non-existing';\n    }\n    throw Error('Invalid data');\n}\nexports.parseAccountStatus = parseAccountStatus;\nfunction parseCurrencyCollection(slice) {\n    const coins = slice.readCoins();\n    // Read extra currencies\n    let extraCurrencies = null;\n    if (slice.readBit()) {\n        let dc = slice.readCell();\n        if (!dc.isExotic) {\n            let pd = (0, parseDict_1.parseDict)(dc.beginParse(), 32, (s) => s.readVarUIntNumber(5));\n            extraCurrencies = new Map();\n            for (let e of pd) {\n                extraCurrencies.set(parseInt(e[0], 10), e[1]);\n            }\n        }\n    }\n    return { extraCurrencies, coins };\n}\nexports.parseCurrencyCollection = parseCurrencyCollection;\nfunction parseCommonMsgInfo(slice) {\n    if (!slice.readBit()) {\n        // Internal\n        let ihrDisabled = slice.readBit();\n        let bounce = slice.readBit();\n        let bounced = slice.readBit();\n        let src = slice.readAddress();\n        let dest = slice.readAddress();\n        let value = parseCurrencyCollection(slice);\n        let ihrFee = slice.readCoins();\n        let fwdFee = slice.readCoins();\n        let createdLt = slice.readUint(64);\n        let createdAt = slice.readUintNumber(32);\n        return {\n            type: 'internal',\n            ihrDisabled,\n            bounce,\n            bounced,\n            src,\n            dest,\n            value,\n            ihrFee,\n            fwdFee,\n            createdLt,\n            createdAt\n        };\n    }\n    else if (slice.readBit()) {\n        // Outgoing external\n        let src = slice.readAddress();\n        let dest = slice.readAddress();\n        let createdLt = slice.readUint(64);\n        let createdAt = slice.readUintNumber(32);\n        return {\n            type: 'external-out',\n            src,\n            dest,\n            createdLt,\n            createdAt\n        };\n    }\n    else {\n        // Incoming external\n        let src = slice.readAddress();\n        let dest = slice.readAddress();\n        let importFee = slice.readCoins();\n        return {\n            type: 'external-in',\n            src,\n            dest,\n            importFee\n        };\n    }\n}\nexports.parseCommonMsgInfo = parseCommonMsgInfo;\nfunction parseRawTickTock(slice) {\n    return {\n        tick: slice.readBit(),\n        tock: slice.readBit()\n    };\n}\nexports.parseRawTickTock = parseRawTickTock;\nfunction parseStateInit(slice) {\n    let raw = slice.toCell();\n    let splitDepth = null;\n    if (slice.readBit()) {\n        splitDepth = slice.readUintNumber(5);\n    }\n    const special = slice.readBit() ? parseRawTickTock(slice) : null;\n    const hasCode = slice.readBit();\n    const code = hasCode ? slice.readCell() : null;\n    const hasData = slice.readBit();\n    const data = hasData ? slice.readCell() : null;\n    if (slice.readBit()) {\n        slice.readCell(); // Skip libraries for now\n    }\n    return { splitDepth, data, code, special, raw };\n}\nexports.parseStateInit = parseStateInit;\nfunction parseMessage(slice) {\n    const raw = slice.toCell();\n    const info = parseCommonMsgInfo(slice);\n    const hasInit = slice.readBit();\n    let init = null;\n    if (hasInit) {\n        if (!slice.readBit()) {\n            init = parseStateInit(slice);\n        }\n        else {\n            init = parseStateInit(slice.readRef());\n        }\n    }\n    const body = slice.readBit() ? slice.readRef().toCell() : slice.toCell();\n    return {\n        info,\n        init,\n        body,\n        raw\n    };\n}\nexports.parseMessage = parseMessage;\nfunction parseHashUpdate(slice) {\n    if (slice.readUintNumber(8) !== 0x72) {\n        throw Error('Invalid data');\n    }\n    const oldHash = slice.readBuffer(32);\n    const newHash = slice.readBuffer(32);\n    return { oldHash, newHash };\n}\nexports.parseHashUpdate = parseHashUpdate;\nfunction parseAccountChange(slice) {\n    if (!slice.readBit()) {\n        return 'unchanged';\n    }\n    if (slice.readBit()) {\n        return 'frozen';\n    }\n    else {\n        return 'deleted';\n    }\n}\nexports.parseAccountChange = parseAccountChange;\nfunction parseStorageUsedShort(slice) {\n    return {\n        cells: slice.readVarUIntNumber(3),\n        bits: slice.readVarUIntNumber(3)\n    };\n}\nexports.parseStorageUsedShort = parseStorageUsedShort;\nfunction parseStoragePhase(slice) {\n    const storageFeesCollected = slice.readCoins();\n    let storageFeesDue = null;\n    if (slice.readBit()) {\n        storageFeesDue = slice.readCoins();\n    }\n    const statusChange = parseAccountChange(slice);\n    return {\n        storageFeesCollected,\n        storageFeesDue,\n        statusChange\n    };\n}\nexports.parseStoragePhase = parseStoragePhase;\nfunction parseCreditPhase(slice) {\n    let dueFeesColelcted = slice.readBit() ? slice.readCoins() : null;\n    const credit = parseCurrencyCollection(slice);\n    return {\n        dueFeesColelcted,\n        credit\n    };\n}\nexports.parseCreditPhase = parseCreditPhase;\nfunction parseComputePhase(slice) {\n    if (!slice.readBit()) {\n        const skipReason = slice.readUintNumber(2);\n        if (skipReason === 0x00) {\n            return {\n                type: 'skipped',\n                reason: 'no-state'\n            };\n        }\n        if (skipReason === 0x01) {\n            return {\n                type: 'skipped',\n                reason: 'bad-state'\n            };\n        }\n        if (skipReason === 0x02) {\n            return {\n                type: 'skipped',\n                reason: 'no-gas'\n            };\n        }\n    }\n    const success = slice.readBit();\n    const messageStateUsed = slice.readBit();\n    const accountActivated = slice.readBit();\n    let gasFees = slice.readCoins();\n    const vmState = slice.readRef();\n    let gasUsed = vmState.readVarUInt(3);\n    let gasLimit = vmState.readVarUInt(3);\n    let gasCredit = vmState.readBit() ? vmState.readVarUInt(2) : null;\n    let mode = vmState.readUintNumber(8);\n    let exitCode = vmState.readUintNumber(32);\n    let exitArg = vmState.readBit() ? vmState.readUintNumber(32) : null; // TODO: change to int\n    let vmSteps = vmState.readUintNumber(32);\n    let vmInitStateHash = vmState.readBuffer(32);\n    let vmFinalStateHash = vmState.readBuffer(32);\n    return {\n        type: 'computed',\n        success,\n        messageStateUsed,\n        accountActivated,\n        gasFees,\n        gasUsed,\n        gasLimit,\n        gasCredit,\n        mode,\n        exitCode,\n        exitArg,\n        vmSteps,\n        vmInitStateHash,\n        vmFinalStateHash\n    };\n}\nexports.parseComputePhase = parseComputePhase;\nfunction parseActionPhase(slice) {\n    const success = slice.readBit();\n    const valid = slice.readBit();\n    const noFunds = slice.readBit();\n    const statusChange = parseAccountChange(slice);\n    const totalFwdFees = slice.readBit() ? slice.readCoins() : null;\n    const totalActionFees = slice.readBit() ? slice.readCoins() : null;\n    const resultCode = slice.readUintNumber(32); // TODO: Change to int32\n    const resultArg = slice.readBit() ? slice.readUintNumber(32) : null; // TODO: Change to int32\n    const totalActions = slice.readUintNumber(16);\n    const specialActions = slice.readUintNumber(16);\n    const skippedActions = slice.readUintNumber(16);\n    const messagesCreated = slice.readUintNumber(16);\n    const actionListHash = slice.readBuffer(32);\n    const totalMessageSizes = parseStorageUsedShort(slice);\n    return {\n        success,\n        valid,\n        noFunds,\n        statusChange,\n        totalFwdFees,\n        totalActionFees,\n        resultCode,\n        resultArg,\n        totalActions,\n        specialActions,\n        skippedActions,\n        messagesCreated,\n        actionListHash,\n        totalMessageSizes\n    };\n}\nexports.parseActionPhase = parseActionPhase;\nfunction parseBouncePhase(slice) {\n    // Is OK\n    if (slice.readBit()) {\n        const msgSize = parseStorageUsedShort(slice);\n        const msgFees = slice.readCoins();\n        const fwdFees = slice.readCoins();\n        return {\n            type: 'ok',\n            msgSize,\n            msgFees,\n            fwdFees\n        };\n    }\n    // No funds\n    if (slice.readBit()) {\n        const msgSize = parseStorageUsedShort(slice);\n        const fwdFees = slice.readCoins();\n        return {\n            type: 'no-funds',\n            msgSize,\n            fwdFees\n        };\n    }\n    return {\n        type: 'negative-funds'\n    };\n}\nexports.parseBouncePhase = parseBouncePhase;\nfunction parseTransactionDescription(slice) {\n    const type = slice.readUintNumber(4);\n    if (type === 0x00) {\n        const creditFirst = slice.readBit();\n        let storagePhase = null;\n        let creditPhase = null;\n        if (slice.readBit()) {\n            storagePhase = parseStoragePhase(slice);\n        }\n        if (slice.readBit()) {\n            creditPhase = parseCreditPhase(slice);\n        }\n        let computePhase = parseComputePhase(slice);\n        let actionPhase = null;\n        if (slice.readBit()) {\n            actionPhase = parseActionPhase(slice.readRef());\n        }\n        let aborted = slice.readBit();\n        let bouncePhase = null;\n        if (slice.readBit()) {\n            bouncePhase = parseBouncePhase(slice);\n        }\n        const destroyed = slice.readBit();\n        return {\n            type: 'generic',\n            creditFirst,\n            storagePhase,\n            creditPhase,\n            computePhase,\n            actionPhase,\n            bouncePhase,\n            aborted,\n            destroyed\n        };\n    }\n    if (type === 0x01) {\n        let storagePhase = parseStoragePhase(slice);\n        return {\n            type: 'storage',\n            storagePhase\n        };\n    }\n    if (type === 0x2 || type === 0x03) {\n        const isTock = type === 0x03;\n        let storagePhase = parseStoragePhase(slice);\n        let computePhase = parseComputePhase(slice);\n        let actionPhase = null;\n        if (slice.readBit()) {\n            actionPhase = parseActionPhase(slice.readRef());\n        }\n        const aborted = slice.readBit();\n        const destroyed = slice.readBit();\n        return {\n            type: 'tick-tock',\n            isTock,\n            storagePhase,\n            computePhase,\n            actionPhase,\n            aborted,\n            destroyed\n        };\n    }\n    throw Error('Unsupported transaction type');\n}\nexports.parseTransactionDescription = parseTransactionDescription;\nfunction parseTransaction(workchain, slice) {\n    if (slice.readUintNumber(4) !== 0x07) {\n        throw Error('Invalid data');\n    }\n    // Read address\n    const addressHash = slice.readBuffer(32);\n    const address = new __1.Address(workchain, addressHash);\n    // Read lt\n    const lt = slice.readUint(64);\n    // Read prevTrans\n    const prevTransHash = slice.readBuffer(32);\n    const prevTransLt = slice.readUint(64);\n    // Read time\n    const time = slice.readUintNumber(32);\n    // Output messages\n    const outMessagesCount = slice.readUintNumber(15);\n    // Status\n    const oldStatus = parseAccountStatus(slice);\n    const newStatus = parseAccountStatus(slice);\n    // Messages ref\n    const messages = slice.readRef();\n    let hasInMessage = messages.readBit();\n    let hasOutMessages = messages.readBit();\n    let inMessage = null;\n    if (hasInMessage) {\n        inMessage = parseMessage(messages.readRef());\n    }\n    let outMessages = [];\n    if (hasOutMessages) {\n        let dict = messages.readDict(15, (slice) => parseMessage(slice.readRef()));\n        for (let msg of Array.from(dict.values())) {\n            outMessages.push(msg);\n        }\n    }\n    // Currency collections\n    let fees = parseCurrencyCollection(slice);\n    // Hash update\n    let update = parseHashUpdate(slice.readRef());\n    // Description\n    let description = parseTransactionDescription(slice.readRef());\n    return {\n        address,\n        lt,\n        time,\n        outMessagesCount,\n        oldStatus,\n        newStatus,\n        fees,\n        update,\n        description,\n        inMessage,\n        outMessages,\n        prevTransaction: {\n            hash: prevTransHash,\n            lt: prevTransLt\n        }\n    };\n}\nexports.parseTransaction = parseTransaction;\nfunction parseStorageUsed(cs) {\n    return {\n        cells: cs.readVarUIntNumber(3),\n        bits: cs.readVarUIntNumber(3),\n        publicCells: cs.readVarUIntNumber(3),\n    };\n}\nexports.parseStorageUsed = parseStorageUsed;\nfunction parseStorageInfo(cs) {\n    return {\n        used: parseStorageUsed(cs),\n        lastPaid: cs.readUintNumber(32),\n        duePayment: cs.readBit() ? cs.readCoins() : null\n    };\n}\nexports.parseStorageInfo = parseStorageInfo;\nfunction parseAccountState(cs) {\n    if (cs.readBit()) {\n        return { type: 'active', state: parseStateInit(cs) };\n    }\n    else if (cs.readBit()) {\n        return { type: 'frozen', stateHash: cs.readBuffer(32) };\n    }\n    else {\n        return { type: 'uninit' };\n    }\n}\nexports.parseAccountState = parseAccountState;\nfunction parseAccountStorage(cs) {\n    return { lastTransLt: cs.readUint(64), balance: parseCurrencyCollection(cs), state: parseAccountState(cs) };\n}\nexports.parseAccountStorage = parseAccountStorage;\nfunction parseAccount(cs) {\n    if (cs.readBit()) {\n        return {\n            address: cs.readAddress(),\n            storageStat: parseStorageInfo(cs),\n            storage: parseAccountStorage(cs)\n        };\n    }\n    else {\n        return null;\n    }\n}\nexports.parseAccount = parseAccount;\nfunction parseShardIdent(cs) {\n    if (cs.readUintNumber(2) !== 0) {\n        throw Error('Invalid data');\n    }\n    let shardPrefixBits = cs.readUintNumber(6);\n    let workchainId = cs.readIntNumber(32);\n    let shardPrefix = cs.readUint(64);\n    return {\n        shardPrefixBits,\n        workchainId,\n        shardPrefix\n    };\n}\nexports.parseShardIdent = parseShardIdent;\nfunction parseShardAccount(cs) {\n    let accountCell = cs.readCell();\n    let address = null;\n    if (!accountCell.isExotic) {\n        address = accountCell.beginParse().readAddress();\n    }\n    return {\n        address,\n        lastTransHash: cs.readBuffer(32),\n        lastTransLt: cs.readUint(64)\n    };\n}\nexports.parseShardAccount = parseShardAccount;\nfunction parseDepthBalanceInfo(cs) {\n    return {\n        splitDepth: cs.readUintNumber(5),\n        balance: parseCurrencyCollection(cs)\n    };\n}\nexports.parseDepthBalanceInfo = parseDepthBalanceInfo;\nfunction parseShardAccounts(cs) {\n    if (!cs.readBit()) {\n        return new Map();\n    }\n    return (0, parseDict_1.parseDict)(cs.readRef(), 256, (cs2) => {\n        let depthBalanceInfo = parseDepthBalanceInfo(cs2);\n        let shardAccount = parseShardAccount(cs2);\n        return {\n            depthBalanceInfo,\n            shardAccount\n        };\n    });\n}\nexports.parseShardAccounts = parseShardAccounts;\nfunction parseMasterchainStateExtra(cs) {\n    // Check magic\n    if (cs.readUintNumber(16) !== 0xcc26) {\n        throw Error('Invalid data');\n    }\n    // Skip shard_hashes\n    if (cs.readBit()) {\n        cs.readCell();\n    }\n    // Read config\n    let configAddress = new __1.Address(-1, cs.readBuffer(32));\n    let config = cs.readCell();\n    // Rad global balance\n    const globalBalance = parseCurrencyCollection(cs);\n    return {\n        config,\n        configAddress,\n        globalBalance\n    };\n}\nexports.parseMasterchainStateExtra = parseMasterchainStateExtra;\nfunction parseShardStateUnsplit(cs) {\n    if (cs.readUintNumber(32) !== 0x9023afe2) {\n        throw Error('Invalid data');\n    }\n    let globalId = cs.readIntNumber(32);\n    let shardId = parseShardIdent(cs);\n    let seqno = cs.readUintNumber(32);\n    let vertSeqNo = cs.readUintNumber(32);\n    let genUtime = cs.readUintNumber(32);\n    let genLt = cs.readUint(64);\n    let minRefSeqno = cs.readUintNumber(32);\n    // Skip OutMsgQueueInfo: usually exotic\n    cs.readCell();\n    let beforeSplit = cs.readBit();\n    // Parse accounts\n    let accounts;\n    let accountsCell = cs.readCell();\n    if (accountsCell.isExotic) {\n        accounts = new Map();\n    }\n    else {\n        accounts = parseShardAccounts(accountsCell.beginParse());\n    }\n    // Skip (not used by apps)\n    cs.readCell();\n    // Parse extras\n    let mcStateExtra = cs.readBit();\n    let extras = null;\n    if (mcStateExtra) {\n        let cell = cs.readCell();\n        if (!cell.isExotic) {\n            extras = parseMasterchainStateExtra(cell.beginParse());\n        }\n    }\n    ;\n    return {\n        globalId,\n        shardId,\n        seqno,\n        vertSeqNo,\n        genUtime,\n        genLt,\n        minRefSeqno,\n        beforeSplit,\n        accounts,\n        extras\n    };\n}\nexports.parseShardStateUnsplit = parseShardStateUnsplit;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,sBAAsB,GAAGF,OAAO,CAACG,0BAA0B,GAAGH,OAAO,CAACI,kBAAkB,GAAGJ,OAAO,CAACK,qBAAqB,GAAGL,OAAO,CAACM,iBAAiB,GAAGN,OAAO,CAACO,eAAe,GAAGP,OAAO,CAACQ,YAAY,GAAGR,OAAO,CAACS,mBAAmB,GAAGT,OAAO,CAACU,iBAAiB,GAAGV,OAAO,CAACW,gBAAgB,GAAGX,OAAO,CAACY,gBAAgB,GAAGZ,OAAO,CAACa,gBAAgB,GAAGb,OAAO,CAACc,2BAA2B,GAAGd,OAAO,CAACe,gBAAgB,GAAGf,OAAO,CAACgB,gBAAgB,GAAGhB,OAAO,CAACiB,iBAAiB,GAAGjB,OAAO,CAACkB,gBAAgB,GAAGlB,OAAO,CAACmB,iBAAiB,GAAGnB,OAAO,CAACoB,qBAAqB,GAAGpB,OAAO,CAACqB,kBAAkB,GAAGrB,OAAO,CAACsB,eAAe,GAAGtB,OAAO,CAACuB,YAAY,GAAGvB,OAAO,CAACwB,cAAc,GAAGxB,OAAO,CAACyB,gBAAgB,GAAGzB,OAAO,CAAC0B,kBAAkB,GAAG1B,OAAO,CAAC2B,uBAAuB,GAAG3B,OAAO,CAAC4B,kBAAkB,GAAG,KAAK,CAAC;AAC9wB,MAAMC,GAAG,GAAGC,OAAO,CAAC,IAAI,CAAC;AACzB,MAAMC,WAAW,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AACpD,SAASF,kBAAkB,CAACI,KAAK,EAAE;EAC/B,MAAMC,MAAM,GAAGD,KAAK,CAACE,cAAc,CAAC,CAAC,CAAC;EACtC,IAAID,MAAM,KAAK,IAAI,EAAE;IACjB,OAAO,eAAe;EAC1B;EACA,IAAIA,MAAM,KAAK,IAAI,EAAE;IACjB,OAAO,QAAQ;EACnB;EACA,IAAIA,MAAM,KAAK,IAAI,EAAE;IACjB,OAAO,QAAQ;EACnB;EACA,IAAIA,MAAM,KAAK,IAAI,EAAE;IACjB,OAAO,cAAc;EACzB;EACA,MAAME,KAAK,CAAC,cAAc,CAAC;AAC/B;AACAnC,OAAO,CAAC4B,kBAAkB,GAAGA,kBAAkB;AAC/C,SAASD,uBAAuB,CAACK,KAAK,EAAE;EACpC,MAAMI,KAAK,GAAGJ,KAAK,CAACK,SAAS,EAAE;EAC/B;EACA,IAAIC,eAAe,GAAG,IAAI;EAC1B,IAAIN,KAAK,CAACO,OAAO,EAAE,EAAE;IACjB,IAAIC,EAAE,GAAGR,KAAK,CAACS,QAAQ,EAAE;IACzB,IAAI,CAACD,EAAE,CAACE,QAAQ,EAAE;MACd,IAAIC,EAAE,GAAG,CAAC,CAAC,EAAEZ,WAAW,CAACa,SAAS,EAAEJ,EAAE,CAACK,UAAU,EAAE,EAAE,EAAE,EAAGC,CAAC,IAAKA,CAAC,CAACC,iBAAiB,CAAC,CAAC,CAAC,CAAC;MACvFT,eAAe,GAAG,IAAIU,GAAG,EAAE;MAC3B,KAAK,IAAIC,CAAC,IAAIN,EAAE,EAAE;QACdL,eAAe,CAACY,GAAG,CAACC,QAAQ,CAACF,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,CAAC;MACjD;IACJ;EACJ;EACA,OAAO;IAAEX,eAAe;IAAEF;EAAM,CAAC;AACrC;AACApC,OAAO,CAAC2B,uBAAuB,GAAGA,uBAAuB;AACzD,SAASD,kBAAkB,CAACM,KAAK,EAAE;EAC/B,IAAI,CAACA,KAAK,CAACO,OAAO,EAAE,EAAE;IAClB;IACA,IAAIa,WAAW,GAAGpB,KAAK,CAACO,OAAO,EAAE;IACjC,IAAIc,MAAM,GAAGrB,KAAK,CAACO,OAAO,EAAE;IAC5B,IAAIe,OAAO,GAAGtB,KAAK,CAACO,OAAO,EAAE;IAC7B,IAAIgB,GAAG,GAAGvB,KAAK,CAACwB,WAAW,EAAE;IAC7B,IAAIC,IAAI,GAAGzB,KAAK,CAACwB,WAAW,EAAE;IAC9B,IAAIvD,KAAK,GAAG0B,uBAAuB,CAACK,KAAK,CAAC;IAC1C,IAAI0B,MAAM,GAAG1B,KAAK,CAACK,SAAS,EAAE;IAC9B,IAAIsB,MAAM,GAAG3B,KAAK,CAACK,SAAS,EAAE;IAC9B,IAAIuB,SAAS,GAAG5B,KAAK,CAAC6B,QAAQ,CAAC,EAAE,CAAC;IAClC,IAAIC,SAAS,GAAG9B,KAAK,CAACE,cAAc,CAAC,EAAE,CAAC;IACxC,OAAO;MACH6B,IAAI,EAAE,UAAU;MAChBX,WAAW;MACXC,MAAM;MACNC,OAAO;MACPC,GAAG;MACHE,IAAI;MACJxD,KAAK;MACLyD,MAAM;MACNC,MAAM;MACNC,SAAS;MACTE;IACJ,CAAC;EACL,CAAC,MACI,IAAI9B,KAAK,CAACO,OAAO,EAAE,EAAE;IACtB;IACA,IAAIgB,GAAG,GAAGvB,KAAK,CAACwB,WAAW,EAAE;IAC7B,IAAIC,IAAI,GAAGzB,KAAK,CAACwB,WAAW,EAAE;IAC9B,IAAII,SAAS,GAAG5B,KAAK,CAAC6B,QAAQ,CAAC,EAAE,CAAC;IAClC,IAAIC,SAAS,GAAG9B,KAAK,CAACE,cAAc,CAAC,EAAE,CAAC;IACxC,OAAO;MACH6B,IAAI,EAAE,cAAc;MACpBR,GAAG;MACHE,IAAI;MACJG,SAAS;MACTE;IACJ,CAAC;EACL,CAAC,MACI;IACD;IACA,IAAIP,GAAG,GAAGvB,KAAK,CAACwB,WAAW,EAAE;IAC7B,IAAIC,IAAI,GAAGzB,KAAK,CAACwB,WAAW,EAAE;IAC9B,IAAIQ,SAAS,GAAGhC,KAAK,CAACK,SAAS,EAAE;IACjC,OAAO;MACH0B,IAAI,EAAE,aAAa;MACnBR,GAAG;MACHE,IAAI;MACJO;IACJ,CAAC;EACL;AACJ;AACAhE,OAAO,CAAC0B,kBAAkB,GAAGA,kBAAkB;AAC/C,SAASD,gBAAgB,CAACO,KAAK,EAAE;EAC7B,OAAO;IACHiC,IAAI,EAAEjC,KAAK,CAACO,OAAO,EAAE;IACrB2B,IAAI,EAAElC,KAAK,CAACO,OAAO;EACvB,CAAC;AACL;AACAvC,OAAO,CAACyB,gBAAgB,GAAGA,gBAAgB;AAC3C,SAASD,cAAc,CAACQ,KAAK,EAAE;EAC3B,IAAImC,GAAG,GAAGnC,KAAK,CAACoC,MAAM,EAAE;EACxB,IAAIC,UAAU,GAAG,IAAI;EACrB,IAAIrC,KAAK,CAACO,OAAO,EAAE,EAAE;IACjB8B,UAAU,GAAGrC,KAAK,CAACE,cAAc,CAAC,CAAC,CAAC;EACxC;EACA,MAAMoC,OAAO,GAAGtC,KAAK,CAACO,OAAO,EAAE,GAAGd,gBAAgB,CAACO,KAAK,CAAC,GAAG,IAAI;EAChE,MAAMuC,OAAO,GAAGvC,KAAK,CAACO,OAAO,EAAE;EAC/B,MAAMiC,IAAI,GAAGD,OAAO,GAAGvC,KAAK,CAACS,QAAQ,EAAE,GAAG,IAAI;EAC9C,MAAMgC,OAAO,GAAGzC,KAAK,CAACO,OAAO,EAAE;EAC/B,MAAMmC,IAAI,GAAGD,OAAO,GAAGzC,KAAK,CAACS,QAAQ,EAAE,GAAG,IAAI;EAC9C,IAAIT,KAAK,CAACO,OAAO,EAAE,EAAE;IACjBP,KAAK,CAACS,QAAQ,EAAE,CAAC,CAAC;EACtB;;EACA,OAAO;IAAE4B,UAAU;IAAEK,IAAI;IAAEF,IAAI;IAAEF,OAAO;IAAEH;EAAI,CAAC;AACnD;AACAnE,OAAO,CAACwB,cAAc,GAAGA,cAAc;AACvC,SAASD,YAAY,CAACS,KAAK,EAAE;EACzB,MAAMmC,GAAG,GAAGnC,KAAK,CAACoC,MAAM,EAAE;EAC1B,MAAMO,IAAI,GAAGjD,kBAAkB,CAACM,KAAK,CAAC;EACtC,MAAM4C,OAAO,GAAG5C,KAAK,CAACO,OAAO,EAAE;EAC/B,IAAIsC,IAAI,GAAG,IAAI;EACf,IAAID,OAAO,EAAE;IACT,IAAI,CAAC5C,KAAK,CAACO,OAAO,EAAE,EAAE;MAClBsC,IAAI,GAAGrD,cAAc,CAACQ,KAAK,CAAC;IAChC,CAAC,MACI;MACD6C,IAAI,GAAGrD,cAAc,CAACQ,KAAK,CAAC8C,OAAO,EAAE,CAAC;IAC1C;EACJ;EACA,MAAMC,IAAI,GAAG/C,KAAK,CAACO,OAAO,EAAE,GAAGP,KAAK,CAAC8C,OAAO,EAAE,CAACV,MAAM,EAAE,GAAGpC,KAAK,CAACoC,MAAM,EAAE;EACxE,OAAO;IACHO,IAAI;IACJE,IAAI;IACJE,IAAI;IACJZ;EACJ,CAAC;AACL;AACAnE,OAAO,CAACuB,YAAY,GAAGA,YAAY;AACnC,SAASD,eAAe,CAACU,KAAK,EAAE;EAC5B,IAAIA,KAAK,CAACE,cAAc,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;IAClC,MAAMC,KAAK,CAAC,cAAc,CAAC;EAC/B;EACA,MAAM6C,OAAO,GAAGhD,KAAK,CAACiD,UAAU,CAAC,EAAE,CAAC;EACpC,MAAMC,OAAO,GAAGlD,KAAK,CAACiD,UAAU,CAAC,EAAE,CAAC;EACpC,OAAO;IAAED,OAAO;IAAEE;EAAQ,CAAC;AAC/B;AACAlF,OAAO,CAACsB,eAAe,GAAGA,eAAe;AACzC,SAASD,kBAAkB,CAACW,KAAK,EAAE;EAC/B,IAAI,CAACA,KAAK,CAACO,OAAO,EAAE,EAAE;IAClB,OAAO,WAAW;EACtB;EACA,IAAIP,KAAK,CAACO,OAAO,EAAE,EAAE;IACjB,OAAO,QAAQ;EACnB,CAAC,MACI;IACD,OAAO,SAAS;EACpB;AACJ;AACAvC,OAAO,CAACqB,kBAAkB,GAAGA,kBAAkB;AAC/C,SAASD,qBAAqB,CAACY,KAAK,EAAE;EAClC,OAAO;IACHmD,KAAK,EAAEnD,KAAK,CAACe,iBAAiB,CAAC,CAAC,CAAC;IACjCqC,IAAI,EAAEpD,KAAK,CAACe,iBAAiB,CAAC,CAAC;EACnC,CAAC;AACL;AACA/C,OAAO,CAACoB,qBAAqB,GAAGA,qBAAqB;AACrD,SAASD,iBAAiB,CAACa,KAAK,EAAE;EAC9B,MAAMqD,oBAAoB,GAAGrD,KAAK,CAACK,SAAS,EAAE;EAC9C,IAAIiD,cAAc,GAAG,IAAI;EACzB,IAAItD,KAAK,CAACO,OAAO,EAAE,EAAE;IACjB+C,cAAc,GAAGtD,KAAK,CAACK,SAAS,EAAE;EACtC;EACA,MAAMkD,YAAY,GAAGlE,kBAAkB,CAACW,KAAK,CAAC;EAC9C,OAAO;IACHqD,oBAAoB;IACpBC,cAAc;IACdC;EACJ,CAAC;AACL;AACAvF,OAAO,CAACmB,iBAAiB,GAAGA,iBAAiB;AAC7C,SAASD,gBAAgB,CAACc,KAAK,EAAE;EAC7B,IAAIwD,gBAAgB,GAAGxD,KAAK,CAACO,OAAO,EAAE,GAAGP,KAAK,CAACK,SAAS,EAAE,GAAG,IAAI;EACjE,MAAMoD,MAAM,GAAG9D,uBAAuB,CAACK,KAAK,CAAC;EAC7C,OAAO;IACHwD,gBAAgB;IAChBC;EACJ,CAAC;AACL;AACAzF,OAAO,CAACkB,gBAAgB,GAAGA,gBAAgB;AAC3C,SAASD,iBAAiB,CAACe,KAAK,EAAE;EAC9B,IAAI,CAACA,KAAK,CAACO,OAAO,EAAE,EAAE;IAClB,MAAMmD,UAAU,GAAG1D,KAAK,CAACE,cAAc,CAAC,CAAC,CAAC;IAC1C,IAAIwD,UAAU,KAAK,IAAI,EAAE;MACrB,OAAO;QACH3B,IAAI,EAAE,SAAS;QACf4B,MAAM,EAAE;MACZ,CAAC;IACL;IACA,IAAID,UAAU,KAAK,IAAI,EAAE;MACrB,OAAO;QACH3B,IAAI,EAAE,SAAS;QACf4B,MAAM,EAAE;MACZ,CAAC;IACL;IACA,IAAID,UAAU,KAAK,IAAI,EAAE;MACrB,OAAO;QACH3B,IAAI,EAAE,SAAS;QACf4B,MAAM,EAAE;MACZ,CAAC;IACL;EACJ;EACA,MAAMC,OAAO,GAAG5D,KAAK,CAACO,OAAO,EAAE;EAC/B,MAAMsD,gBAAgB,GAAG7D,KAAK,CAACO,OAAO,EAAE;EACxC,MAAMuD,gBAAgB,GAAG9D,KAAK,CAACO,OAAO,EAAE;EACxC,IAAIwD,OAAO,GAAG/D,KAAK,CAACK,SAAS,EAAE;EAC/B,MAAM2D,OAAO,GAAGhE,KAAK,CAAC8C,OAAO,EAAE;EAC/B,IAAImB,OAAO,GAAGD,OAAO,CAACE,WAAW,CAAC,CAAC,CAAC;EACpC,IAAIC,QAAQ,GAAGH,OAAO,CAACE,WAAW,CAAC,CAAC,CAAC;EACrC,IAAIE,SAAS,GAAGJ,OAAO,CAACzD,OAAO,EAAE,GAAGyD,OAAO,CAACE,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI;EACjE,IAAIG,IAAI,GAAGL,OAAO,CAAC9D,cAAc,CAAC,CAAC,CAAC;EACpC,IAAIoE,QAAQ,GAAGN,OAAO,CAAC9D,cAAc,CAAC,EAAE,CAAC;EACzC,IAAIqE,OAAO,GAAGP,OAAO,CAACzD,OAAO,EAAE,GAAGyD,OAAO,CAAC9D,cAAc,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;EACrE,IAAIsE,OAAO,GAAGR,OAAO,CAAC9D,cAAc,CAAC,EAAE,CAAC;EACxC,IAAIuE,eAAe,GAAGT,OAAO,CAACf,UAAU,CAAC,EAAE,CAAC;EAC5C,IAAIyB,gBAAgB,GAAGV,OAAO,CAACf,UAAU,CAAC,EAAE,CAAC;EAC7C,OAAO;IACHlB,IAAI,EAAE,UAAU;IAChB6B,OAAO;IACPC,gBAAgB;IAChBC,gBAAgB;IAChBC,OAAO;IACPE,OAAO;IACPE,QAAQ;IACRC,SAAS;IACTC,IAAI;IACJC,QAAQ;IACRC,OAAO;IACPC,OAAO;IACPC,eAAe;IACfC;EACJ,CAAC;AACL;AACA1G,OAAO,CAACiB,iBAAiB,GAAGA,iBAAiB;AAC7C,SAASD,gBAAgB,CAACgB,KAAK,EAAE;EAC7B,MAAM4D,OAAO,GAAG5D,KAAK,CAACO,OAAO,EAAE;EAC/B,MAAMoE,KAAK,GAAG3E,KAAK,CAACO,OAAO,EAAE;EAC7B,MAAMqE,OAAO,GAAG5E,KAAK,CAACO,OAAO,EAAE;EAC/B,MAAMgD,YAAY,GAAGlE,kBAAkB,CAACW,KAAK,CAAC;EAC9C,MAAM6E,YAAY,GAAG7E,KAAK,CAACO,OAAO,EAAE,GAAGP,KAAK,CAACK,SAAS,EAAE,GAAG,IAAI;EAC/D,MAAMyE,eAAe,GAAG9E,KAAK,CAACO,OAAO,EAAE,GAAGP,KAAK,CAACK,SAAS,EAAE,GAAG,IAAI;EAClE,MAAM0E,UAAU,GAAG/E,KAAK,CAACE,cAAc,CAAC,EAAE,CAAC,CAAC,CAAC;EAC7C,MAAM8E,SAAS,GAAGhF,KAAK,CAACO,OAAO,EAAE,GAAGP,KAAK,CAACE,cAAc,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;EACrE,MAAM+E,YAAY,GAAGjF,KAAK,CAACE,cAAc,CAAC,EAAE,CAAC;EAC7C,MAAMgF,cAAc,GAAGlF,KAAK,CAACE,cAAc,CAAC,EAAE,CAAC;EAC/C,MAAMiF,cAAc,GAAGnF,KAAK,CAACE,cAAc,CAAC,EAAE,CAAC;EAC/C,MAAMkF,eAAe,GAAGpF,KAAK,CAACE,cAAc,CAAC,EAAE,CAAC;EAChD,MAAMmF,cAAc,GAAGrF,KAAK,CAACiD,UAAU,CAAC,EAAE,CAAC;EAC3C,MAAMqC,iBAAiB,GAAGlG,qBAAqB,CAACY,KAAK,CAAC;EACtD,OAAO;IACH4D,OAAO;IACPe,KAAK;IACLC,OAAO;IACPrB,YAAY;IACZsB,YAAY;IACZC,eAAe;IACfC,UAAU;IACVC,SAAS;IACTC,YAAY;IACZC,cAAc;IACdC,cAAc;IACdC,eAAe;IACfC,cAAc;IACdC;EACJ,CAAC;AACL;AACAtH,OAAO,CAACgB,gBAAgB,GAAGA,gBAAgB;AAC3C,SAASD,gBAAgB,CAACiB,KAAK,EAAE;EAC7B;EACA,IAAIA,KAAK,CAACO,OAAO,EAAE,EAAE;IACjB,MAAMgF,OAAO,GAAGnG,qBAAqB,CAACY,KAAK,CAAC;IAC5C,MAAMwF,OAAO,GAAGxF,KAAK,CAACK,SAAS,EAAE;IACjC,MAAMoF,OAAO,GAAGzF,KAAK,CAACK,SAAS,EAAE;IACjC,OAAO;MACH0B,IAAI,EAAE,IAAI;MACVwD,OAAO;MACPC,OAAO;MACPC;IACJ,CAAC;EACL;EACA;EACA,IAAIzF,KAAK,CAACO,OAAO,EAAE,EAAE;IACjB,MAAMgF,OAAO,GAAGnG,qBAAqB,CAACY,KAAK,CAAC;IAC5C,MAAMyF,OAAO,GAAGzF,KAAK,CAACK,SAAS,EAAE;IACjC,OAAO;MACH0B,IAAI,EAAE,UAAU;MAChBwD,OAAO;MACPE;IACJ,CAAC;EACL;EACA,OAAO;IACH1D,IAAI,EAAE;EACV,CAAC;AACL;AACA/D,OAAO,CAACe,gBAAgB,GAAGA,gBAAgB;AAC3C,SAASD,2BAA2B,CAACkB,KAAK,EAAE;EACxC,MAAM+B,IAAI,GAAG/B,KAAK,CAACE,cAAc,CAAC,CAAC,CAAC;EACpC,IAAI6B,IAAI,KAAK,IAAI,EAAE;IACf,MAAM2D,WAAW,GAAG1F,KAAK,CAACO,OAAO,EAAE;IACnC,IAAIoF,YAAY,GAAG,IAAI;IACvB,IAAIC,WAAW,GAAG,IAAI;IACtB,IAAI5F,KAAK,CAACO,OAAO,EAAE,EAAE;MACjBoF,YAAY,GAAGxG,iBAAiB,CAACa,KAAK,CAAC;IAC3C;IACA,IAAIA,KAAK,CAACO,OAAO,EAAE,EAAE;MACjBqF,WAAW,GAAG1G,gBAAgB,CAACc,KAAK,CAAC;IACzC;IACA,IAAI6F,YAAY,GAAG5G,iBAAiB,CAACe,KAAK,CAAC;IAC3C,IAAI8F,WAAW,GAAG,IAAI;IACtB,IAAI9F,KAAK,CAACO,OAAO,EAAE,EAAE;MACjBuF,WAAW,GAAG9G,gBAAgB,CAACgB,KAAK,CAAC8C,OAAO,EAAE,CAAC;IACnD;IACA,IAAIiD,OAAO,GAAG/F,KAAK,CAACO,OAAO,EAAE;IAC7B,IAAIyF,WAAW,GAAG,IAAI;IACtB,IAAIhG,KAAK,CAACO,OAAO,EAAE,EAAE;MACjByF,WAAW,GAAGjH,gBAAgB,CAACiB,KAAK,CAAC;IACzC;IACA,MAAMiG,SAAS,GAAGjG,KAAK,CAACO,OAAO,EAAE;IACjC,OAAO;MACHwB,IAAI,EAAE,SAAS;MACf2D,WAAW;MACXC,YAAY;MACZC,WAAW;MACXC,YAAY;MACZC,WAAW;MACXE,WAAW;MACXD,OAAO;MACPE;IACJ,CAAC;EACL;EACA,IAAIlE,IAAI,KAAK,IAAI,EAAE;IACf,IAAI4D,YAAY,GAAGxG,iBAAiB,CAACa,KAAK,CAAC;IAC3C,OAAO;MACH+B,IAAI,EAAE,SAAS;MACf4D;IACJ,CAAC;EACL;EACA,IAAI5D,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,IAAI,EAAE;IAC/B,MAAMmE,MAAM,GAAGnE,IAAI,KAAK,IAAI;IAC5B,IAAI4D,YAAY,GAAGxG,iBAAiB,CAACa,KAAK,CAAC;IAC3C,IAAI6F,YAAY,GAAG5G,iBAAiB,CAACe,KAAK,CAAC;IAC3C,IAAI8F,WAAW,GAAG,IAAI;IACtB,IAAI9F,KAAK,CAACO,OAAO,EAAE,EAAE;MACjBuF,WAAW,GAAG9G,gBAAgB,CAACgB,KAAK,CAAC8C,OAAO,EAAE,CAAC;IACnD;IACA,MAAMiD,OAAO,GAAG/F,KAAK,CAACO,OAAO,EAAE;IAC/B,MAAM0F,SAAS,GAAGjG,KAAK,CAACO,OAAO,EAAE;IACjC,OAAO;MACHwB,IAAI,EAAE,WAAW;MACjBmE,MAAM;MACNP,YAAY;MACZE,YAAY;MACZC,WAAW;MACXC,OAAO;MACPE;IACJ,CAAC;EACL;EACA,MAAM9F,KAAK,CAAC,8BAA8B,CAAC;AAC/C;AACAnC,OAAO,CAACc,2BAA2B,GAAGA,2BAA2B;AACjE,SAASD,gBAAgB,CAACsH,SAAS,EAAEnG,KAAK,EAAE;EACxC,IAAIA,KAAK,CAACE,cAAc,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;IAClC,MAAMC,KAAK,CAAC,cAAc,CAAC;EAC/B;EACA;EACA,MAAMiG,WAAW,GAAGpG,KAAK,CAACiD,UAAU,CAAC,EAAE,CAAC;EACxC,MAAMoD,OAAO,GAAG,IAAIxG,GAAG,CAACyG,OAAO,CAACH,SAAS,EAAEC,WAAW,CAAC;EACvD;EACA,MAAMG,EAAE,GAAGvG,KAAK,CAAC6B,QAAQ,CAAC,EAAE,CAAC;EAC7B;EACA,MAAM2E,aAAa,GAAGxG,KAAK,CAACiD,UAAU,CAAC,EAAE,CAAC;EAC1C,MAAMwD,WAAW,GAAGzG,KAAK,CAAC6B,QAAQ,CAAC,EAAE,CAAC;EACtC;EACA,MAAM6E,IAAI,GAAG1G,KAAK,CAACE,cAAc,CAAC,EAAE,CAAC;EACrC;EACA,MAAMyG,gBAAgB,GAAG3G,KAAK,CAACE,cAAc,CAAC,EAAE,CAAC;EACjD;EACA,MAAM0G,SAAS,GAAGhH,kBAAkB,CAACI,KAAK,CAAC;EAC3C,MAAM6G,SAAS,GAAGjH,kBAAkB,CAACI,KAAK,CAAC;EAC3C;EACA,MAAM8G,QAAQ,GAAG9G,KAAK,CAAC8C,OAAO,EAAE;EAChC,IAAIiE,YAAY,GAAGD,QAAQ,CAACvG,OAAO,EAAE;EACrC,IAAIyG,cAAc,GAAGF,QAAQ,CAACvG,OAAO,EAAE;EACvC,IAAI0G,SAAS,GAAG,IAAI;EACpB,IAAIF,YAAY,EAAE;IACdE,SAAS,GAAG1H,YAAY,CAACuH,QAAQ,CAAChE,OAAO,EAAE,CAAC;EAChD;EACA,IAAIoE,WAAW,GAAG,EAAE;EACpB,IAAIF,cAAc,EAAE;IAChB,IAAIG,IAAI,GAAGL,QAAQ,CAACM,QAAQ,CAAC,EAAE,EAAGpH,KAAK,IAAKT,YAAY,CAACS,KAAK,CAAC8C,OAAO,EAAE,CAAC,CAAC;IAC1E,KAAK,IAAIuE,GAAG,IAAIC,KAAK,CAACC,IAAI,CAACJ,IAAI,CAACK,MAAM,EAAE,CAAC,EAAE;MACvCN,WAAW,CAACO,IAAI,CAACJ,GAAG,CAAC;IACzB;EACJ;EACA;EACA,IAAIK,IAAI,GAAG/H,uBAAuB,CAACK,KAAK,CAAC;EACzC;EACA,IAAI2H,MAAM,GAAGrI,eAAe,CAACU,KAAK,CAAC8C,OAAO,EAAE,CAAC;EAC7C;EACA,IAAI8E,WAAW,GAAG9I,2BAA2B,CAACkB,KAAK,CAAC8C,OAAO,EAAE,CAAC;EAC9D,OAAO;IACHuD,OAAO;IACPE,EAAE;IACFG,IAAI;IACJC,gBAAgB;IAChBC,SAAS;IACTC,SAAS;IACTa,IAAI;IACJC,MAAM;IACNC,WAAW;IACXX,SAAS;IACTC,WAAW;IACXW,eAAe,EAAE;MACbC,IAAI,EAAEtB,aAAa;MACnBD,EAAE,EAAEE;IACR;EACJ,CAAC;AACL;AACAzI,OAAO,CAACa,gBAAgB,GAAGA,gBAAgB;AAC3C,SAASD,gBAAgB,CAACmJ,EAAE,EAAE;EAC1B,OAAO;IACH5E,KAAK,EAAE4E,EAAE,CAAChH,iBAAiB,CAAC,CAAC,CAAC;IAC9BqC,IAAI,EAAE2E,EAAE,CAAChH,iBAAiB,CAAC,CAAC,CAAC;IAC7BiH,WAAW,EAAED,EAAE,CAAChH,iBAAiB,CAAC,CAAC;EACvC,CAAC;AACL;AACA/C,OAAO,CAACY,gBAAgB,GAAGA,gBAAgB;AAC3C,SAASD,gBAAgB,CAACoJ,EAAE,EAAE;EAC1B,OAAO;IACHE,IAAI,EAAErJ,gBAAgB,CAACmJ,EAAE,CAAC;IAC1BG,QAAQ,EAAEH,EAAE,CAAC7H,cAAc,CAAC,EAAE,CAAC;IAC/BiI,UAAU,EAAEJ,EAAE,CAACxH,OAAO,EAAE,GAAGwH,EAAE,CAAC1H,SAAS,EAAE,GAAG;EAChD,CAAC;AACL;AACArC,OAAO,CAACW,gBAAgB,GAAGA,gBAAgB;AAC3C,SAASD,iBAAiB,CAACqJ,EAAE,EAAE;EAC3B,IAAIA,EAAE,CAACxH,OAAO,EAAE,EAAE;IACd,OAAO;MAAEwB,IAAI,EAAE,QAAQ;MAAEqG,KAAK,EAAE5I,cAAc,CAACuI,EAAE;IAAE,CAAC;EACxD,CAAC,MACI,IAAIA,EAAE,CAACxH,OAAO,EAAE,EAAE;IACnB,OAAO;MAAEwB,IAAI,EAAE,QAAQ;MAAEsG,SAAS,EAAEN,EAAE,CAAC9E,UAAU,CAAC,EAAE;IAAE,CAAC;EAC3D,CAAC,MACI;IACD,OAAO;MAAElB,IAAI,EAAE;IAAS,CAAC;EAC7B;AACJ;AACA/D,OAAO,CAACU,iBAAiB,GAAGA,iBAAiB;AAC7C,SAASD,mBAAmB,CAACsJ,EAAE,EAAE;EAC7B,OAAO;IAAEO,WAAW,EAAEP,EAAE,CAAClG,QAAQ,CAAC,EAAE,CAAC;IAAE0G,OAAO,EAAE5I,uBAAuB,CAACoI,EAAE,CAAC;IAAEK,KAAK,EAAE1J,iBAAiB,CAACqJ,EAAE;EAAE,CAAC;AAC/G;AACA/J,OAAO,CAACS,mBAAmB,GAAGA,mBAAmB;AACjD,SAASD,YAAY,CAACuJ,EAAE,EAAE;EACtB,IAAIA,EAAE,CAACxH,OAAO,EAAE,EAAE;IACd,OAAO;MACH8F,OAAO,EAAE0B,EAAE,CAACvG,WAAW,EAAE;MACzBgH,WAAW,EAAE7J,gBAAgB,CAACoJ,EAAE,CAAC;MACjCU,OAAO,EAAEhK,mBAAmB,CAACsJ,EAAE;IACnC,CAAC;EACL,CAAC,MACI;IACD,OAAO,IAAI;EACf;AACJ;AACA/J,OAAO,CAACQ,YAAY,GAAGA,YAAY;AACnC,SAASD,eAAe,CAACwJ,EAAE,EAAE;EACzB,IAAIA,EAAE,CAAC7H,cAAc,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;IAC5B,MAAMC,KAAK,CAAC,cAAc,CAAC;EAC/B;EACA,IAAIuI,eAAe,GAAGX,EAAE,CAAC7H,cAAc,CAAC,CAAC,CAAC;EAC1C,IAAIyI,WAAW,GAAGZ,EAAE,CAACa,aAAa,CAAC,EAAE,CAAC;EACtC,IAAIC,WAAW,GAAGd,EAAE,CAAClG,QAAQ,CAAC,EAAE,CAAC;EACjC,OAAO;IACH6G,eAAe;IACfC,WAAW;IACXE;EACJ,CAAC;AACL;AACA7K,OAAO,CAACO,eAAe,GAAGA,eAAe;AACzC,SAASD,iBAAiB,CAACyJ,EAAE,EAAE;EAC3B,IAAIe,WAAW,GAAGf,EAAE,CAACtH,QAAQ,EAAE;EAC/B,IAAI4F,OAAO,GAAG,IAAI;EAClB,IAAI,CAACyC,WAAW,CAACpI,QAAQ,EAAE;IACvB2F,OAAO,GAAGyC,WAAW,CAACjI,UAAU,EAAE,CAACW,WAAW,EAAE;EACpD;EACA,OAAO;IACH6E,OAAO;IACP0C,aAAa,EAAEhB,EAAE,CAAC9E,UAAU,CAAC,EAAE,CAAC;IAChCqF,WAAW,EAAEP,EAAE,CAAClG,QAAQ,CAAC,EAAE;EAC/B,CAAC;AACL;AACA7D,OAAO,CAACM,iBAAiB,GAAGA,iBAAiB;AAC7C,SAASD,qBAAqB,CAAC0J,EAAE,EAAE;EAC/B,OAAO;IACH1F,UAAU,EAAE0F,EAAE,CAAC7H,cAAc,CAAC,CAAC,CAAC;IAChCqI,OAAO,EAAE5I,uBAAuB,CAACoI,EAAE;EACvC,CAAC;AACL;AACA/J,OAAO,CAACK,qBAAqB,GAAGA,qBAAqB;AACrD,SAASD,kBAAkB,CAAC2J,EAAE,EAAE;EAC5B,IAAI,CAACA,EAAE,CAACxH,OAAO,EAAE,EAAE;IACf,OAAO,IAAIS,GAAG,EAAE;EACpB;EACA,OAAO,CAAC,CAAC,EAAEjB,WAAW,CAACa,SAAS,EAAEmH,EAAE,CAACjF,OAAO,EAAE,EAAE,GAAG,EAAGkG,GAAG,IAAK;IAC1D,IAAIC,gBAAgB,GAAG5K,qBAAqB,CAAC2K,GAAG,CAAC;IACjD,IAAIE,YAAY,GAAG5K,iBAAiB,CAAC0K,GAAG,CAAC;IACzC,OAAO;MACHC,gBAAgB;MAChBC;IACJ,CAAC;EACL,CAAC,CAAC;AACN;AACAlL,OAAO,CAACI,kBAAkB,GAAGA,kBAAkB;AAC/C,SAASD,0BAA0B,CAAC4J,EAAE,EAAE;EACpC;EACA,IAAIA,EAAE,CAAC7H,cAAc,CAAC,EAAE,CAAC,KAAK,MAAM,EAAE;IAClC,MAAMC,KAAK,CAAC,cAAc,CAAC;EAC/B;EACA;EACA,IAAI4H,EAAE,CAACxH,OAAO,EAAE,EAAE;IACdwH,EAAE,CAACtH,QAAQ,EAAE;EACjB;EACA;EACA,IAAI0I,aAAa,GAAG,IAAItJ,GAAG,CAACyG,OAAO,CAAC,CAAC,CAAC,EAAEyB,EAAE,CAAC9E,UAAU,CAAC,EAAE,CAAC,CAAC;EAC1D,IAAImG,MAAM,GAAGrB,EAAE,CAACtH,QAAQ,EAAE;EAC1B;EACA,MAAM4I,aAAa,GAAG1J,uBAAuB,CAACoI,EAAE,CAAC;EACjD,OAAO;IACHqB,MAAM;IACND,aAAa;IACbE;EACJ,CAAC;AACL;AACArL,OAAO,CAACG,0BAA0B,GAAGA,0BAA0B;AAC/D,SAASD,sBAAsB,CAAC6J,EAAE,EAAE;EAChC,IAAIA,EAAE,CAAC7H,cAAc,CAAC,EAAE,CAAC,KAAK,UAAU,EAAE;IACtC,MAAMC,KAAK,CAAC,cAAc,CAAC;EAC/B;EACA,IAAImJ,QAAQ,GAAGvB,EAAE,CAACa,aAAa,CAAC,EAAE,CAAC;EACnC,IAAIW,OAAO,GAAGhL,eAAe,CAACwJ,EAAE,CAAC;EACjC,IAAIyB,KAAK,GAAGzB,EAAE,CAAC7H,cAAc,CAAC,EAAE,CAAC;EACjC,IAAIuJ,SAAS,GAAG1B,EAAE,CAAC7H,cAAc,CAAC,EAAE,CAAC;EACrC,IAAIwJ,QAAQ,GAAG3B,EAAE,CAAC7H,cAAc,CAAC,EAAE,CAAC;EACpC,IAAIyJ,KAAK,GAAG5B,EAAE,CAAClG,QAAQ,CAAC,EAAE,CAAC;EAC3B,IAAI+H,WAAW,GAAG7B,EAAE,CAAC7H,cAAc,CAAC,EAAE,CAAC;EACvC;EACA6H,EAAE,CAACtH,QAAQ,EAAE;EACb,IAAIoJ,WAAW,GAAG9B,EAAE,CAACxH,OAAO,EAAE;EAC9B;EACA,IAAIuJ,QAAQ;EACZ,IAAIC,YAAY,GAAGhC,EAAE,CAACtH,QAAQ,EAAE;EAChC,IAAIsJ,YAAY,CAACrJ,QAAQ,EAAE;IACvBoJ,QAAQ,GAAG,IAAI9I,GAAG,EAAE;EACxB,CAAC,MACI;IACD8I,QAAQ,GAAG1L,kBAAkB,CAAC2L,YAAY,CAAClJ,UAAU,EAAE,CAAC;EAC5D;EACA;EACAkH,EAAE,CAACtH,QAAQ,EAAE;EACb;EACA,IAAIuJ,YAAY,GAAGjC,EAAE,CAACxH,OAAO,EAAE;EAC/B,IAAI0J,MAAM,GAAG,IAAI;EACjB,IAAID,YAAY,EAAE;IACd,IAAIE,IAAI,GAAGnC,EAAE,CAACtH,QAAQ,EAAE;IACxB,IAAI,CAACyJ,IAAI,CAACxJ,QAAQ,EAAE;MAChBuJ,MAAM,GAAG9L,0BAA0B,CAAC+L,IAAI,CAACrJ,UAAU,EAAE,CAAC;IAC1D;EACJ;EACA;EACA,OAAO;IACHyI,QAAQ;IACRC,OAAO;IACPC,KAAK;IACLC,SAAS;IACTC,QAAQ;IACRC,KAAK;IACLC,WAAW;IACXC,WAAW;IACXC,QAAQ;IACRG;EACJ,CAAC;AACL;AACAjM,OAAO,CAACE,sBAAsB,GAAGA,sBAAsB"},"metadata":{},"sourceType":"script"}