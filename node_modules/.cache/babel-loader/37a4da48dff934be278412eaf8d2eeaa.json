{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFunctorComposition = exports.let = exports.bindTo = exports.flap = exports.map = void 0;\n/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nvar function_1 = require(\"./function\");\nfunction map(F, G) {\n  return function (f) {\n    return function (fa) {\n      return F.map(fa, function (ga) {\n        return G.map(ga, f);\n      });\n    };\n  };\n}\nexports.map = map;\nfunction flap(F) {\n  return function (a) {\n    return function (fab) {\n      return F.map(fab, function (f) {\n        return f(a);\n      });\n    };\n  };\n}\nexports.flap = flap;\nfunction bindTo(F) {\n  return function (name) {\n    return function (fa) {\n      return F.map(fa, function (a) {\n        var _a;\n        return _a = {}, _a[name] = a, _a;\n      });\n    };\n  };\n}\nexports.bindTo = bindTo;\nfunction let_(F) {\n  return function (name, f) {\n    return function (fa) {\n      return F.map(fa, function (a) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));\n      });\n    };\n  };\n}\nexports.let = let_;\n/** @deprecated */\nfunction getFunctorComposition(F, G) {\n  var _map = map(F, G);\n  return {\n    map: function map(fga, f) {\n      return (0, function_1.pipe)(fga, _map(f));\n    }\n  };\n}\nexports.getFunctorComposition = getFunctorComposition;","map":{"version":3,"names":["Object","defineProperty","exports","value","getFunctorComposition","let","bindTo","flap","map","function_1","require","F","G","f","fa","ga","a","fab","name","_a","let_","assign","_map","fga","pipe"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/fp-ts/lib/Functor.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getFunctorComposition = exports.let = exports.bindTo = exports.flap = exports.map = void 0;\n/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nvar function_1 = require(\"./function\");\nfunction map(F, G) {\n    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };\n}\nexports.map = map;\nfunction flap(F) {\n    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };\n}\nexports.flap = flap;\nfunction bindTo(F) {\n    return function (name) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return (_a = {}, _a[name] = a, _a);\n    }); }; };\n}\nexports.bindTo = bindTo;\nfunction let_(F) {\n    return function (name, f) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));\n    }); }; };\n}\nexports.let = let_;\n/** @deprecated */\nfunction getFunctorComposition(F, G) {\n    var _map = map(F, G);\n    return {\n        map: function (fga, f) { return (0, function_1.pipe)(fga, _map(f)); }\n    };\n}\nexports.getFunctorComposition = getFunctorComposition;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,qBAAqB,GAAGF,OAAO,CAACG,GAAG,GAAGH,OAAO,CAACI,MAAM,GAAGJ,OAAO,CAACK,IAAI,GAAGL,OAAO,CAACM,GAAG,GAAG,KAAK,CAAC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,UAAU,GAAGC,OAAO,CAAC,YAAY,CAAC;AACtC,SAASF,GAAG,CAACG,CAAC,EAAEC,CAAC,EAAE;EACf,OAAO,UAAUC,CAAC,EAAE;IAAE,OAAO,UAAUC,EAAE,EAAE;MAAE,OAAOH,CAAC,CAACH,GAAG,CAACM,EAAE,EAAE,UAAUC,EAAE,EAAE;QAAE,OAAOH,CAAC,CAACJ,GAAG,CAACO,EAAE,EAAEF,CAAC,CAAC;MAAE,CAAC,CAAC;IAAE,CAAC;EAAE,CAAC;AAC/G;AACAX,OAAO,CAACM,GAAG,GAAGA,GAAG;AACjB,SAASD,IAAI,CAACI,CAAC,EAAE;EACb,OAAO,UAAUK,CAAC,EAAE;IAAE,OAAO,UAAUC,GAAG,EAAE;MAAE,OAAON,CAAC,CAACH,GAAG,CAACS,GAAG,EAAE,UAAUJ,CAAC,EAAE;QAAE,OAAOA,CAAC,CAACG,CAAC,CAAC;MAAE,CAAC,CAAC;IAAE,CAAC;EAAE,CAAC;AACxG;AACAd,OAAO,CAACK,IAAI,GAAGA,IAAI;AACnB,SAASD,MAAM,CAACK,CAAC,EAAE;EACf,OAAO,UAAUO,IAAI,EAAE;IAAE,OAAO,UAAUJ,EAAE,EAAE;MAAE,OAAOH,CAAC,CAACH,GAAG,CAACM,EAAE,EAAE,UAAUE,CAAC,EAAE;QAC1E,IAAIG,EAAE;QACN,OAAQA,EAAE,GAAG,CAAC,CAAC,EAAEA,EAAE,CAACD,IAAI,CAAC,GAAGF,CAAC,EAAEG,EAAE;MACrC,CAAC,CAAC;IAAE,CAAC;EAAE,CAAC;AACZ;AACAjB,OAAO,CAACI,MAAM,GAAGA,MAAM;AACvB,SAASc,IAAI,CAACT,CAAC,EAAE;EACb,OAAO,UAAUO,IAAI,EAAEL,CAAC,EAAE;IAAE,OAAO,UAAUC,EAAE,EAAE;MAAE,OAAOH,CAAC,CAACH,GAAG,CAACM,EAAE,EAAE,UAAUE,CAAC,EAAE;QAC7E,IAAIG,EAAE;QACN,OAAOnB,MAAM,CAACqB,MAAM,CAAC,CAAC,CAAC,EAAEL,CAAC,GAAGG,EAAE,GAAG,CAAC,CAAC,EAAEA,EAAE,CAACD,IAAI,CAAC,GAAGL,CAAC,CAACG,CAAC,CAAC,EAAEG,EAAE,EAAE;MAC/D,CAAC,CAAC;IAAE,CAAC;EAAE,CAAC;AACZ;AACAjB,OAAO,CAACG,GAAG,GAAGe,IAAI;AAClB;AACA,SAAShB,qBAAqB,CAACO,CAAC,EAAEC,CAAC,EAAE;EACjC,IAAIU,IAAI,GAAGd,GAAG,CAACG,CAAC,EAAEC,CAAC,CAAC;EACpB,OAAO;IACHJ,GAAG,EAAE,aAAUe,GAAG,EAAEV,CAAC,EAAE;MAAE,OAAO,CAAC,CAAC,EAAEJ,UAAU,CAACe,IAAI,EAAED,GAAG,EAAED,IAAI,CAACT,CAAC,CAAC,CAAC;IAAE;EACxE,CAAC;AACL;AACAX,OAAO,CAACE,qBAAqB,GAAGA,qBAAqB"},"metadata":{},"sourceType":"script"}