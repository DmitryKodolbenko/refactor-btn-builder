{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mnemonicNew = exports.mnemonicValidate = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicToSeed = exports.mnemonicToEntropy = void 0;\nvar tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nvar getSecureRandom_1 = require(\"../primitives/getSecureRandom\");\nvar hmac_sha512_1 = require(\"../primitives/hmac_sha512\");\nvar pbkdf2_sha512_1 = require(\"../primitives/pbkdf2_sha512\");\nvar wordlist_1 = require(\"./wordlist\");\nvar PBKDF_ITERATIONS = 100000;\nfunction isPasswordNeeded(_x) {\n  return _isPasswordNeeded.apply(this, arguments);\n}\nfunction _isPasswordNeeded() {\n  _isPasswordNeeded = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(mnemonicArray) {\n    var passlessEntropy;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return mnemonicToEntropy(mnemonicArray);\n          case 2:\n            passlessEntropy = _context.sent;\n            _context.next = 5;\n            return isPasswordSeed(passlessEntropy);\n          case 5:\n            _context.t0 = _context.sent;\n            if (!_context.t0) {\n              _context.next = 10;\n              break;\n            }\n            _context.next = 9;\n            return isBasicSeed(passlessEntropy);\n          case 9:\n            _context.t0 = !_context.sent;\n          case 10:\n            return _context.abrupt(\"return\", _context.t0);\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _isPasswordNeeded.apply(this, arguments);\n}\nfunction normalizeMnemonic(src) {\n  return src.map(function (v) {\n    return v.toLowerCase().trim();\n  });\n}\nfunction isBasicSeed(_x2) {\n  return _isBasicSeed.apply(this, arguments);\n}\nfunction _isBasicSeed() {\n  _isBasicSeed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(entropy) {\n    var seed;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, 'TON seed version', Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);\n          case 2:\n            seed = _context2.sent;\n            return _context2.abrupt(\"return\", seed[0] == 0);\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _isBasicSeed.apply(this, arguments);\n}\nfunction isPasswordSeed(_x3) {\n  return _isPasswordSeed.apply(this, arguments);\n}\nfunction _isPasswordSeed() {\n  _isPasswordSeed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(entropy) {\n    var seed;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, 'TON fast seed version', 1, 64);\n          case 2:\n            seed = _context3.sent;\n            return _context3.abrupt(\"return\", seed[0] == 1);\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _isPasswordSeed.apply(this, arguments);\n}\nfunction mnemonicToEntropy(_x4, _x5) {\n  return _mnemonicToEntropy.apply(this, arguments);\n}\nfunction _mnemonicToEntropy() {\n  _mnemonicToEntropy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(mnemonicArray, password) {\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(' '), password && password.length > 0 ? password : '');\n          case 2:\n            return _context4.abrupt(\"return\", _context4.sent);\n          case 3:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _mnemonicToEntropy.apply(this, arguments);\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nfunction mnemonicToSeed(_x6, _x7, _x8) {\n  return _mnemonicToSeed.apply(this, arguments);\n}\nfunction _mnemonicToSeed() {\n  _mnemonicToSeed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(mnemonicArray, seed, password) {\n    var entropy, res;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return mnemonicToEntropy(mnemonicArray, password);\n          case 2:\n            entropy = _context5.sent;\n            _context5.next = 5;\n            return (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);\n          case 5:\n            res = _context5.sent;\n            return _context5.abrupt(\"return\", res.slice(0, 32));\n          case 7:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _mnemonicToSeed.apply(this, arguments);\n}\nexports.mnemonicToSeed = mnemonicToSeed;\n/**\n * Extract private key from mnemonic\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns Key Pair\n */\nfunction mnemonicToPrivateKey(_x9, _x10) {\n  return _mnemonicToPrivateKey.apply(this, arguments);\n}\nfunction _mnemonicToPrivateKey() {\n  _mnemonicToPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(mnemonicArray, password) {\n    var seed, keyPair;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L64\n            // td::Ed25519::PrivateKey Mnemonic::to_private_key() const {\n            //   return td::Ed25519::PrivateKey(td::SecureString(as_slice(to_seed()).substr(0, td::Ed25519::PrivateKey::LENGTH)));\n            // }\n            mnemonicArray = normalizeMnemonic(mnemonicArray);\n            _context6.next = 3;\n            return mnemonicToSeed(mnemonicArray, 'TON default seed', password);\n          case 3:\n            seed = _context6.sent;\n            keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed);\n            return _context6.abrupt(\"return\", {\n              publicKey: Buffer.from(keyPair.publicKey),\n              secretKey: Buffer.from(keyPair.secretKey)\n            });\n          case 6:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _mnemonicToPrivateKey.apply(this, arguments);\n}\nexports.mnemonicToPrivateKey = mnemonicToPrivateKey;\n/**\n * Convert mnemonic to wallet key pair\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns Key Pair\n */\nfunction mnemonicToWalletKey(_x11, _x12) {\n  return _mnemonicToWalletKey.apply(this, arguments);\n}\nfunction _mnemonicToWalletKey() {\n  _mnemonicToWalletKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(mnemonicArray, password) {\n    var seedPk, seedSecret, keyPair;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return mnemonicToPrivateKey(mnemonicArray, password);\n          case 2:\n            seedPk = _context7.sent;\n            seedSecret = seedPk.secretKey.slice(0, 32);\n            keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);\n            return _context7.abrupt(\"return\", {\n              publicKey: Buffer.from(keyPair.publicKey),\n              secretKey: Buffer.from(keyPair.secretKey)\n            });\n          case 6:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _mnemonicToWalletKey.apply(this, arguments);\n}\nexports.mnemonicToWalletKey = mnemonicToWalletKey;\n/**\n * Validate Mnemonic\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns true for valid mnemonic\n */\nfunction mnemonicValidate(_x13, _x14) {\n  return _mnemonicValidate.apply(this, arguments);\n}\nfunction _mnemonicValidate() {\n  _mnemonicValidate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(mnemonicArray, password) {\n    var _iterator, _step, word;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            // Normalize\n            mnemonicArray = normalizeMnemonic(mnemonicArray);\n            // Validate mnemonic words\n            _iterator = _createForOfIteratorHelper(mnemonicArray);\n            _context8.prev = 2;\n            _iterator.s();\n          case 4:\n            if ((_step = _iterator.n()).done) {\n              _context8.next = 10;\n              break;\n            }\n            word = _step.value;\n            if (!(wordlist_1.wordlist.indexOf(word) < 0)) {\n              _context8.next = 8;\n              break;\n            }\n            return _context8.abrupt(\"return\", false);\n          case 8:\n            _context8.next = 4;\n            break;\n          case 10:\n            _context8.next = 15;\n            break;\n          case 12:\n            _context8.prev = 12;\n            _context8.t0 = _context8[\"catch\"](2);\n            _iterator.e(_context8.t0);\n          case 15:\n            _context8.prev = 15;\n            _iterator.f();\n            return _context8.finish(15);\n          case 18:\n            if (!(password && password.length > 0)) {\n              _context8.next = 23;\n              break;\n            }\n            _context8.next = 21;\n            return isPasswordNeeded(mnemonicArray);\n          case 21:\n            if (_context8.sent) {\n              _context8.next = 23;\n              break;\n            }\n            return _context8.abrupt(\"return\", false);\n          case 23:\n            _context8.t1 = isBasicSeed;\n            _context8.next = 26;\n            return mnemonicToEntropy(mnemonicArray, password);\n          case 26:\n            _context8.t2 = _context8.sent;\n            _context8.next = 29;\n            return (0, _context8.t1)(_context8.t2);\n          case 29:\n            return _context8.abrupt(\"return\", _context8.sent);\n          case 30:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, null, [[2, 12, 15, 18]]);\n  }));\n  return _mnemonicValidate.apply(this, arguments);\n}\nexports.mnemonicValidate = mnemonicValidate;\n/**\n * Generate new Mnemonic\n * @param wordsCount number of words to generate\n * @param password mnemonic password\n * @returns\n */\nfunction mnemonicNew() {\n  return _mnemonicNew.apply(this, arguments);\n}\nfunction _mnemonicNew() {\n  _mnemonicNew = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n    var wordsCount,\n      password,\n      mnemonicArray,\n      i,\n      ind,\n      _args9 = arguments;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            wordsCount = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : 24;\n            password = _args9.length > 1 ? _args9[1] : undefined;\n            // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L159\n            mnemonicArray = [];\n          case 3:\n            if (!true) {\n              _context9.next = 30;\n              break;\n            }\n            // Regenerate new mnemonics\n            mnemonicArray = [];\n            i = 0;\n          case 6:\n            if (!(i < wordsCount)) {\n              _context9.next = 14;\n              break;\n            }\n            _context9.next = 9;\n            return (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);\n          case 9:\n            ind = _context9.sent;\n            mnemonicArray.push(wordlist_1.wordlist[ind]);\n          case 11:\n            i++;\n            _context9.next = 6;\n            break;\n          case 14:\n            if (!(password && password.length > 0)) {\n              _context9.next = 19;\n              break;\n            }\n            _context9.next = 17;\n            return isPasswordNeeded(mnemonicArray);\n          case 17:\n            if (_context9.sent) {\n              _context9.next = 19;\n              break;\n            }\n            return _context9.abrupt(\"continue\", 3);\n          case 19:\n            _context9.t0 = isBasicSeed;\n            _context9.next = 22;\n            return mnemonicToEntropy(mnemonicArray, password);\n          case 22:\n            _context9.t1 = _context9.sent;\n            _context9.next = 25;\n            return (0, _context9.t0)(_context9.t1);\n          case 25:\n            if (_context9.sent) {\n              _context9.next = 27;\n              break;\n            }\n            return _context9.abrupt(\"continue\", 3);\n          case 27:\n            return _context9.abrupt(\"break\", 30);\n          case 30:\n            return _context9.abrupt(\"return\", mnemonicArray);\n          case 31:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _mnemonicNew.apply(this, arguments);\n}\nexports.mnemonicNew = mnemonicNew;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","mnemonicNew","mnemonicValidate","mnemonicToWalletKey","mnemonicToPrivateKey","mnemonicToSeed","mnemonicToEntropy","tweetnacl_1","require","getSecureRandom_1","hmac_sha512_1","pbkdf2_sha512_1","wordlist_1","PBKDF_ITERATIONS","isPasswordNeeded","mnemonicArray","passlessEntropy","isPasswordSeed","isBasicSeed","normalizeMnemonic","src","map","v","toLowerCase","trim","entropy","pbkdf2_sha512","Math","max","floor","seed","password","hmac_sha512","join","length","res","slice","keyPair","default","sign","fromSeed","publicKey","Buffer","from","secretKey","seedPk","seedSecret","word","wordlist","indexOf","wordsCount","i","getSecureRandomNumber","ind","push"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/node_modules/ton-crypto/dist/mnemonic/mnemonic.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mnemonicNew = exports.mnemonicValidate = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicToSeed = exports.mnemonicToEntropy = void 0;\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst getSecureRandom_1 = require(\"../primitives/getSecureRandom\");\nconst hmac_sha512_1 = require(\"../primitives/hmac_sha512\");\nconst pbkdf2_sha512_1 = require(\"../primitives/pbkdf2_sha512\");\nconst wordlist_1 = require(\"./wordlist\");\nconst PBKDF_ITERATIONS = 100000;\nasync function isPasswordNeeded(mnemonicArray) {\n    const passlessEntropy = await mnemonicToEntropy(mnemonicArray);\n    return (await isPasswordSeed(passlessEntropy)) && !(await isBasicSeed(passlessEntropy));\n}\nfunction normalizeMnemonic(src) {\n    return src.map((v) => v.toLowerCase().trim());\n}\nasync function isBasicSeed(entropy) {\n    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L68\n    // bool Mnemonic::is_basic_seed() {\n    //   td::SecureString hash(64);\n    //   td::pbkdf2_sha512(as_slice(to_entropy()), \"TON seed version\", td::max(1, PBKDF_ITERATIONS / 256),\n    //                     hash.as_mutable_slice());\n    //   return hash.as_slice()[0] == 0;\n    // }\n    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, 'TON seed version', Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);\n    return seed[0] == 0;\n}\nasync function isPasswordSeed(entropy) {\n    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L75\n    // bool Mnemonic::is_password_seed() {\n    //   td::SecureString hash(64);\n    //   td::pbkdf2_sha512(as_slice(to_entropy()), \"TON fast seed version\", 1, hash.as_mutable_slice());\n    //   return hash.as_slice()[0] == 1;\n    // }\n    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, 'TON fast seed version', 1, 64);\n    return seed[0] == 1;\n}\nasync function mnemonicToEntropy(mnemonicArray, password) {\n    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L52\n    // td::SecureString Mnemonic::to_entropy() const {\n    //   td::SecureString res(64);\n    //   td::hmac_sha512(join(words_), password_, res.as_mutable_slice());\n    //   return res;\n    // }\n    return await (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(' '), password && password.length > 0 ? password : '');\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nasync function mnemonicToSeed(mnemonicArray, seed, password) {\n    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L58\n    // td::SecureString Mnemonic::to_seed() const {\n    //   td::SecureString hash(64);\n    //   td::pbkdf2_sha512(as_slice(to_entropy()), \"TON default seed\", PBKDF_ITERATIONS, hash.as_mutable_slice());\n    //   return hash;\n    // }\n    const entropy = await mnemonicToEntropy(mnemonicArray, password);\n    const res = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);\n    return res.slice(0, 32);\n}\nexports.mnemonicToSeed = mnemonicToSeed;\n/**\n * Extract private key from mnemonic\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns Key Pair\n */\nasync function mnemonicToPrivateKey(mnemonicArray, password) {\n    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L64\n    // td::Ed25519::PrivateKey Mnemonic::to_private_key() const {\n    //   return td::Ed25519::PrivateKey(td::SecureString(as_slice(to_seed()).substr(0, td::Ed25519::PrivateKey::LENGTH)));\n    // }\n    mnemonicArray = normalizeMnemonic(mnemonicArray);\n    const seed = (await mnemonicToSeed(mnemonicArray, 'TON default seed', password));\n    let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed);\n    return {\n        publicKey: Buffer.from(keyPair.publicKey),\n        secretKey: Buffer.from(keyPair.secretKey)\n    };\n}\nexports.mnemonicToPrivateKey = mnemonicToPrivateKey;\n/**\n * Convert mnemonic to wallet key pair\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns Key Pair\n */\nasync function mnemonicToWalletKey(mnemonicArray, password) {\n    let seedPk = await mnemonicToPrivateKey(mnemonicArray, password);\n    let seedSecret = seedPk.secretKey.slice(0, 32);\n    const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);\n    return {\n        publicKey: Buffer.from(keyPair.publicKey),\n        secretKey: Buffer.from(keyPair.secretKey)\n    };\n}\nexports.mnemonicToWalletKey = mnemonicToWalletKey;\n/**\n * Validate Mnemonic\n * @param mnemonicArray mnemonic array\n * @param password mnemonic password\n * @returns true for valid mnemonic\n */\nasync function mnemonicValidate(mnemonicArray, password) {\n    // Normalize\n    mnemonicArray = normalizeMnemonic(mnemonicArray);\n    // Validate mnemonic words\n    for (let word of mnemonicArray) {\n        if (wordlist_1.wordlist.indexOf(word) < 0) {\n            return false;\n        }\n    }\n    // Check password\n    if (password && password.length > 0) {\n        if (!await isPasswordNeeded(mnemonicArray)) {\n            return false;\n        }\n    }\n    // Validate seed\n    return await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password));\n}\nexports.mnemonicValidate = mnemonicValidate;\n/**\n * Generate new Mnemonic\n * @param wordsCount number of words to generate\n * @param password mnemonic password\n * @returns\n */\nasync function mnemonicNew(wordsCount = 24, password) {\n    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L159\n    let mnemonicArray = [];\n    while (true) {\n        // Regenerate new mnemonics\n        mnemonicArray = [];\n        for (let i = 0; i < wordsCount; i++) {\n            let ind = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);\n            mnemonicArray.push(wordlist_1.wordlist[ind]);\n        }\n        // Chek password conformance\n        if (password && password.length > 0) {\n            if (!await isPasswordNeeded(mnemonicArray)) {\n                continue;\n            }\n        }\n        // Check if basic seed correct\n        if (!(await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password)))) {\n            continue;\n        }\n        break;\n    }\n    return mnemonicArray;\n}\nexports.mnemonicNew = mnemonicNew;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}