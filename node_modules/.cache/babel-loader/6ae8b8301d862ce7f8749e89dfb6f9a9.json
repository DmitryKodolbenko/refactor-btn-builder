{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseStack = exports.serializeStack = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst Builder_1 = require(\"../boc/Builder\");\nconst Cell_1 = require(\"../boc/Cell\");\nconst INT64_MIN = new bn_js_1.default('-9223372036854775808');\nconst INT64_MAX = new bn_js_1.default('9223372036854775807');\n// vm_stk_null#00 = VmStackValue;\n// vm_stk_tinyint#01 value:int64 = VmStackValue;\n// vm_stk_int#0201_ value:int257 = VmStackValue;\n// vm_stk_nan#02ff = VmStackValue;\n// vm_stk_cell#03 cell:^Cell = VmStackValue;\n//_ cell:^Cell st_bits:(## 10) end_bits:(## 10) { st_bits <= end_bits }\n//   st_ref:(#<= 4) end_ref:(#<= 4) { st_ref <= end_ref } = VmCellSlice;\n// vm_stk_slice#04 _:VmCellSlice = VmStackValue;\n// vm_stk_builder#05 cell:^Cell = VmStackValue;\n// vm_stk_cont#06 cont:VmCont = VmStackValue;\n// vm_tupref_nil$_ = VmTupleRef 0;\n// vm_tupref_single$_ entry:^VmStackValue = VmTupleRef 1;\n// vm_tupref_any$_ {n:#} ref:^(VmTuple (n + 2)) = VmTupleRef (n + 2);\n// vm_tuple_nil$_ = VmTuple 0;\n// vm_tuple_tcons$_ {n:#} head:(VmTupleRef n) tail:^VmStackValue = VmTuple (n + 1);\n// vm_stk_tuple#07 len:(## 16) data:(VmTuple len) = VmStackValue;\nfunction serializeStackItem(src, builder) {\n  if (src.type === 'null') {\n    builder.storeUint8(0x00);\n  } else if (src.type === 'int') {\n    if (src.value.lte(INT64_MAX) && src.value.gte(INT64_MIN)) {\n      builder.storeUint8(0x01);\n      builder.storeInt(src.value, 64);\n    } else {\n      builder.storeUint(0x0100, 15);\n      builder.storeInt(src.value, 257);\n    }\n  } else if (src.type === 'nan') {\n    builder.storeInt(0x02ff, 16);\n  } else if (src.type === 'cell') {\n    builder.storeUint8(0x03);\n    builder.storeRef(src.cell);\n  } else if (src.type === 'slice') {\n    builder.storeUint8(0x04);\n    builder.storeUint(0, 10);\n    builder.storeUint(src.cell.bits.cursor, 10);\n    builder.storeUint(0, 3);\n    builder.storeUint(src.cell.refs.length, 3);\n    builder.storeRef(src.cell);\n  } else if (src.type === 'builder') {\n    builder.storeUint8(0x05);\n    builder.storeRef(src.cell);\n  } else if (src.type === 'tuple') {\n    let head = null;\n    let tail = null;\n    for (let i = 0; i < src.items.length; i++) {\n      // Swap\n      let s = head;\n      head = tail;\n      tail = s;\n      if (i > 1) {\n        head = (0, Builder_1.beginCell)().storeRef(tail).storeRef(head).endCell();\n      }\n      let bc = (0, Builder_1.beginCell)();\n      serializeStackItem(src.items[i], bc);\n      tail = bc.endCell();\n    }\n    builder.storeUint8(0x07);\n    builder.storeUint(src.items.length, 16);\n    if (head) {\n      builder.storeRef(head);\n    }\n    if (tail) {\n      builder.storeRef(tail);\n    }\n  } else {\n    throw Error('Invalid value');\n  }\n}\nfunction parseStackItem(cs) {\n  let kind = cs.readUintNumber(8);\n  if (kind === 0) {\n    return {\n      type: 'null'\n    };\n  } else if (kind === 1) {\n    return {\n      type: 'int',\n      value: cs.readInt(64)\n    };\n  } else if (kind === 2) {\n    if (cs.readUintNumber(7) === 0) {\n      return {\n        type: 'int',\n        value: cs.readInt(257)\n      };\n    } else {\n      cs.readBit(); // must eq 1\n      return {\n        type: 'nan'\n      };\n    }\n  } else if (kind === 3) {\n    return {\n      type: 'cell',\n      cell: cs.readCell()\n    };\n  } else if (kind === 4) {\n    let startBits = cs.readUintNumber(10);\n    let endBits = cs.readUintNumber(10);\n    let startRefs = cs.readUintNumber(3);\n    let endRefs = cs.readUintNumber(3);\n    // Copy to new cell\n    let rs = cs.readCell().beginParse();\n    rs.skip(startBits);\n    let dt = rs.readBitString(endBits - startBits);\n    let cell = new Cell_1.Cell('ordinary', dt);\n    // Copy refs if exist\n    if (startRefs < endRefs) {\n      for (let i = 0; i < startRefs; i++) {\n        cs.readCell();\n      }\n      for (let i = 0; i < endRefs - startRefs; i++) {\n        cell.refs.push(cs.readCell());\n      }\n    }\n    return {\n      type: 'slice',\n      cell\n    };\n  } else if (kind === 5) {\n    return {\n      type: 'builder',\n      cell: cs.readCell()\n    };\n  } else if (kind === 7) {\n    let length = cs.readUintNumber(16);\n    let items = [];\n    if (length > 1) {\n      let head = cs.readRef();\n      let tail = cs.readRef();\n      items.unshift(parseStackItem(tail));\n      for (let i = 0; i < length - 2; i++) {\n        let ohead = head;\n        head = ohead.readRef();\n        tail = ohead.readRef();\n        items.unshift(parseStackItem(tail));\n      }\n      items.unshift(parseStackItem(head));\n    } else if (length === 1) {\n      items.push(parseStackItem(cs.readRef()));\n    }\n    return {\n      type: 'tuple',\n      items\n    };\n  } else {\n    throw Error('Unsupported stack item');\n  }\n}\n//\n// Stack parsing\n// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/block.tlb#L783\n//\n// vm_stack#_ depth:(## 24) stack:(VmStackList depth) = VmStack;\n// vm_stk_cons#_ {n:#} rest:^(VmStackList n) tos:VmStackValue = VmStackList (n + 1);\n// vm_stk_nil#_ = VmStackList 0;\n//\nfunction serializeStackTail(src, builder) {\n  if (src.length > 0) {\n    // rest:^(VmStackList n)\n    let tail = (0, Builder_1.beginCell)();\n    serializeStackTail(src.slice(0, src.length - 1), tail);\n    builder.storeRef(tail.endCell());\n    // tos\n    serializeStackItem(src[src.length - 1], builder);\n  }\n}\nfunction serializeStack(src) {\n  let builder = (0, Builder_1.beginCell)();\n  builder.storeUint(src.length, 24);\n  let r = [...src];\n  serializeStackTail(r, builder);\n  return builder.endCell();\n}\nexports.serializeStack = serializeStack;\nfunction parseStack(src) {\n  let res = [];\n  let cs = src.beginParse();\n  let size = cs.readUintNumber(24);\n  for (let i = 0; i < size; i++) {\n    let next = cs.readRef();\n    res.unshift(parseStackItem(cs));\n    cs = next;\n  }\n  return res;\n}\nexports.parseStack = parseStack;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","parseStack","serializeStack","bn_js_1","require","Builder_1","Cell_1","INT64_MIN","default","INT64_MAX","serializeStackItem","src","builder","type","storeUint8","lte","gte","storeInt","storeUint","storeRef","cell","bits","cursor","refs","length","head","tail","i","items","s","beginCell","endCell","bc","Error","parseStackItem","cs","kind","readUintNumber","readInt","readBit","readCell","startBits","endBits","startRefs","endRefs","rs","beginParse","skip","dt","readBitString","Cell","push","readRef","unshift","ohead","serializeStackTail","slice","r","res","size","next"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/block/stack.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseStack = exports.serializeStack = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst Builder_1 = require(\"../boc/Builder\");\nconst Cell_1 = require(\"../boc/Cell\");\nconst INT64_MIN = new bn_js_1.default('-9223372036854775808');\nconst INT64_MAX = new bn_js_1.default('9223372036854775807');\n// vm_stk_null#00 = VmStackValue;\n// vm_stk_tinyint#01 value:int64 = VmStackValue;\n// vm_stk_int#0201_ value:int257 = VmStackValue;\n// vm_stk_nan#02ff = VmStackValue;\n// vm_stk_cell#03 cell:^Cell = VmStackValue;\n//_ cell:^Cell st_bits:(## 10) end_bits:(## 10) { st_bits <= end_bits }\n//   st_ref:(#<= 4) end_ref:(#<= 4) { st_ref <= end_ref } = VmCellSlice;\n// vm_stk_slice#04 _:VmCellSlice = VmStackValue;\n// vm_stk_builder#05 cell:^Cell = VmStackValue;\n// vm_stk_cont#06 cont:VmCont = VmStackValue;\n// vm_tupref_nil$_ = VmTupleRef 0;\n// vm_tupref_single$_ entry:^VmStackValue = VmTupleRef 1;\n// vm_tupref_any$_ {n:#} ref:^(VmTuple (n + 2)) = VmTupleRef (n + 2);\n// vm_tuple_nil$_ = VmTuple 0;\n// vm_tuple_tcons$_ {n:#} head:(VmTupleRef n) tail:^VmStackValue = VmTuple (n + 1);\n// vm_stk_tuple#07 len:(## 16) data:(VmTuple len) = VmStackValue;\nfunction serializeStackItem(src, builder) {\n    if (src.type === 'null') {\n        builder.storeUint8(0x00);\n    }\n    else if (src.type === 'int') {\n        if (src.value.lte(INT64_MAX) && src.value.gte(INT64_MIN)) {\n            builder.storeUint8(0x01);\n            builder.storeInt(src.value, 64);\n        }\n        else {\n            builder.storeUint(0x0100, 15);\n            builder.storeInt(src.value, 257);\n        }\n    }\n    else if (src.type === 'nan') {\n        builder.storeInt(0x02ff, 16);\n    }\n    else if (src.type === 'cell') {\n        builder.storeUint8(0x03);\n        builder.storeRef(src.cell);\n    }\n    else if (src.type === 'slice') {\n        builder.storeUint8(0x04);\n        builder.storeUint(0, 10);\n        builder.storeUint(src.cell.bits.cursor, 10);\n        builder.storeUint(0, 3);\n        builder.storeUint(src.cell.refs.length, 3);\n        builder.storeRef(src.cell);\n    }\n    else if (src.type === 'builder') {\n        builder.storeUint8(0x05);\n        builder.storeRef(src.cell);\n    }\n    else if (src.type === 'tuple') {\n        let head = null;\n        let tail = null;\n        for (let i = 0; i < src.items.length; i++) {\n            // Swap\n            let s = head;\n            head = tail;\n            tail = s;\n            if (i > 1) {\n                head = (0, Builder_1.beginCell)()\n                    .storeRef(tail)\n                    .storeRef(head)\n                    .endCell();\n            }\n            let bc = (0, Builder_1.beginCell)();\n            serializeStackItem(src.items[i], bc);\n            tail = bc.endCell();\n        }\n        builder.storeUint8(0x07);\n        builder.storeUint(src.items.length, 16);\n        if (head) {\n            builder.storeRef(head);\n        }\n        if (tail) {\n            builder.storeRef(tail);\n        }\n    }\n    else {\n        throw Error('Invalid value');\n    }\n}\nfunction parseStackItem(cs) {\n    let kind = cs.readUintNumber(8);\n    if (kind === 0) {\n        return { type: 'null' };\n    }\n    else if (kind === 1) {\n        return { type: 'int', value: cs.readInt(64) };\n    }\n    else if (kind === 2) {\n        if (cs.readUintNumber(7) === 0) {\n            return { type: 'int', value: cs.readInt(257) };\n        }\n        else {\n            cs.readBit(); // must eq 1\n            return { type: 'nan' };\n        }\n    }\n    else if (kind === 3) {\n        return { type: 'cell', cell: cs.readCell() };\n    }\n    else if (kind === 4) {\n        let startBits = cs.readUintNumber(10);\n        let endBits = cs.readUintNumber(10);\n        let startRefs = cs.readUintNumber(3);\n        let endRefs = cs.readUintNumber(3);\n        // Copy to new cell\n        let rs = cs.readCell().beginParse();\n        rs.skip(startBits);\n        let dt = rs.readBitString(endBits - startBits);\n        let cell = new Cell_1.Cell('ordinary', dt);\n        // Copy refs if exist\n        if (startRefs < endRefs) {\n            for (let i = 0; i < startRefs; i++) {\n                cs.readCell();\n            }\n            for (let i = 0; i < endRefs - startRefs; i++) {\n                cell.refs.push(cs.readCell());\n            }\n        }\n        return { type: 'slice', cell };\n    }\n    else if (kind === 5) {\n        return { type: 'builder', cell: cs.readCell() };\n    }\n    else if (kind === 7) {\n        let length = cs.readUintNumber(16);\n        let items = [];\n        if (length > 1) {\n            let head = cs.readRef();\n            let tail = cs.readRef();\n            items.unshift(parseStackItem(tail));\n            for (let i = 0; i < length - 2; i++) {\n                let ohead = head;\n                head = ohead.readRef();\n                tail = ohead.readRef();\n                items.unshift(parseStackItem(tail));\n            }\n            items.unshift(parseStackItem(head));\n        }\n        else if (length === 1) {\n            items.push(parseStackItem(cs.readRef()));\n        }\n        return { type: 'tuple', items };\n    }\n    else {\n        throw Error('Unsupported stack item');\n    }\n}\n//\n// Stack parsing\n// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/block.tlb#L783\n//\n// vm_stack#_ depth:(## 24) stack:(VmStackList depth) = VmStack;\n// vm_stk_cons#_ {n:#} rest:^(VmStackList n) tos:VmStackValue = VmStackList (n + 1);\n// vm_stk_nil#_ = VmStackList 0;\n//\nfunction serializeStackTail(src, builder) {\n    if (src.length > 0) {\n        // rest:^(VmStackList n)\n        let tail = (0, Builder_1.beginCell)();\n        serializeStackTail(src.slice(0, src.length - 1), tail);\n        builder.storeRef(tail.endCell());\n        // tos\n        serializeStackItem(src[src.length - 1], builder);\n    }\n}\nfunction serializeStack(src) {\n    let builder = (0, Builder_1.beginCell)();\n    builder.storeUint(src.length, 24);\n    let r = [...src];\n    serializeStackTail(r, builder);\n    return builder.endCell();\n}\nexports.serializeStack = serializeStack;\nfunction parseStack(src) {\n    let res = [];\n    let cs = src.beginParse();\n    let size = cs.readUintNumber(24);\n    for (let i = 0; i < size; i++) {\n        let next = cs.readRef();\n        res.unshift(parseStackItem(cs));\n        cs = next;\n    }\n    return res;\n}\nexports.parseStack = parseStack;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,UAAU,GAAGF,OAAO,CAACG,cAAc,GAAG,KAAK,CAAC;AACpD,MAAMC,OAAO,GAAGT,eAAe,CAACU,OAAO,CAAC,OAAO,CAAC,CAAC;AACjD,MAAMC,SAAS,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC3C,MAAME,MAAM,GAAGF,OAAO,CAAC,aAAa,CAAC;AACrC,MAAMG,SAAS,GAAG,IAAIJ,OAAO,CAACK,OAAO,CAAC,sBAAsB,CAAC;AAC7D,MAAMC,SAAS,GAAG,IAAIN,OAAO,CAACK,OAAO,CAAC,qBAAqB,CAAC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,kBAAkB,CAACC,GAAG,EAAEC,OAAO,EAAE;EACtC,IAAID,GAAG,CAACE,IAAI,KAAK,MAAM,EAAE;IACrBD,OAAO,CAACE,UAAU,CAAC,IAAI,CAAC;EAC5B,CAAC,MACI,IAAIH,GAAG,CAACE,IAAI,KAAK,KAAK,EAAE;IACzB,IAAIF,GAAG,CAACX,KAAK,CAACe,GAAG,CAACN,SAAS,CAAC,IAAIE,GAAG,CAACX,KAAK,CAACgB,GAAG,CAACT,SAAS,CAAC,EAAE;MACtDK,OAAO,CAACE,UAAU,CAAC,IAAI,CAAC;MACxBF,OAAO,CAACK,QAAQ,CAACN,GAAG,CAACX,KAAK,EAAE,EAAE,CAAC;IACnC,CAAC,MACI;MACDY,OAAO,CAACM,SAAS,CAAC,MAAM,EAAE,EAAE,CAAC;MAC7BN,OAAO,CAACK,QAAQ,CAACN,GAAG,CAACX,KAAK,EAAE,GAAG,CAAC;IACpC;EACJ,CAAC,MACI,IAAIW,GAAG,CAACE,IAAI,KAAK,KAAK,EAAE;IACzBD,OAAO,CAACK,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC;EAChC,CAAC,MACI,IAAIN,GAAG,CAACE,IAAI,KAAK,MAAM,EAAE;IAC1BD,OAAO,CAACE,UAAU,CAAC,IAAI,CAAC;IACxBF,OAAO,CAACO,QAAQ,CAACR,GAAG,CAACS,IAAI,CAAC;EAC9B,CAAC,MACI,IAAIT,GAAG,CAACE,IAAI,KAAK,OAAO,EAAE;IAC3BD,OAAO,CAACE,UAAU,CAAC,IAAI,CAAC;IACxBF,OAAO,CAACM,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC;IACxBN,OAAO,CAACM,SAAS,CAACP,GAAG,CAACS,IAAI,CAACC,IAAI,CAACC,MAAM,EAAE,EAAE,CAAC;IAC3CV,OAAO,CAACM,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;IACvBN,OAAO,CAACM,SAAS,CAACP,GAAG,CAACS,IAAI,CAACG,IAAI,CAACC,MAAM,EAAE,CAAC,CAAC;IAC1CZ,OAAO,CAACO,QAAQ,CAACR,GAAG,CAACS,IAAI,CAAC;EAC9B,CAAC,MACI,IAAIT,GAAG,CAACE,IAAI,KAAK,SAAS,EAAE;IAC7BD,OAAO,CAACE,UAAU,CAAC,IAAI,CAAC;IACxBF,OAAO,CAACO,QAAQ,CAACR,GAAG,CAACS,IAAI,CAAC;EAC9B,CAAC,MACI,IAAIT,GAAG,CAACE,IAAI,KAAK,OAAO,EAAE;IAC3B,IAAIY,IAAI,GAAG,IAAI;IACf,IAAIC,IAAI,GAAG,IAAI;IACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,GAAG,CAACiB,KAAK,CAACJ,MAAM,EAAEG,CAAC,EAAE,EAAE;MACvC;MACA,IAAIE,CAAC,GAAGJ,IAAI;MACZA,IAAI,GAAGC,IAAI;MACXA,IAAI,GAAGG,CAAC;MACR,IAAIF,CAAC,GAAG,CAAC,EAAE;QACPF,IAAI,GAAG,CAAC,CAAC,EAAEpB,SAAS,CAACyB,SAAS,GAAG,CAC5BX,QAAQ,CAACO,IAAI,CAAC,CACdP,QAAQ,CAACM,IAAI,CAAC,CACdM,OAAO,EAAE;MAClB;MACA,IAAIC,EAAE,GAAG,CAAC,CAAC,EAAE3B,SAAS,CAACyB,SAAS,GAAG;MACnCpB,kBAAkB,CAACC,GAAG,CAACiB,KAAK,CAACD,CAAC,CAAC,EAAEK,EAAE,CAAC;MACpCN,IAAI,GAAGM,EAAE,CAACD,OAAO,EAAE;IACvB;IACAnB,OAAO,CAACE,UAAU,CAAC,IAAI,CAAC;IACxBF,OAAO,CAACM,SAAS,CAACP,GAAG,CAACiB,KAAK,CAACJ,MAAM,EAAE,EAAE,CAAC;IACvC,IAAIC,IAAI,EAAE;MACNb,OAAO,CAACO,QAAQ,CAACM,IAAI,CAAC;IAC1B;IACA,IAAIC,IAAI,EAAE;MACNd,OAAO,CAACO,QAAQ,CAACO,IAAI,CAAC;IAC1B;EACJ,CAAC,MACI;IACD,MAAMO,KAAK,CAAC,eAAe,CAAC;EAChC;AACJ;AACA,SAASC,cAAc,CAACC,EAAE,EAAE;EACxB,IAAIC,IAAI,GAAGD,EAAE,CAACE,cAAc,CAAC,CAAC,CAAC;EAC/B,IAAID,IAAI,KAAK,CAAC,EAAE;IACZ,OAAO;MAAEvB,IAAI,EAAE;IAAO,CAAC;EAC3B,CAAC,MACI,IAAIuB,IAAI,KAAK,CAAC,EAAE;IACjB,OAAO;MAAEvB,IAAI,EAAE,KAAK;MAAEb,KAAK,EAAEmC,EAAE,CAACG,OAAO,CAAC,EAAE;IAAE,CAAC;EACjD,CAAC,MACI,IAAIF,IAAI,KAAK,CAAC,EAAE;IACjB,IAAID,EAAE,CAACE,cAAc,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;MAC5B,OAAO;QAAExB,IAAI,EAAE,KAAK;QAAEb,KAAK,EAAEmC,EAAE,CAACG,OAAO,CAAC,GAAG;MAAE,CAAC;IAClD,CAAC,MACI;MACDH,EAAE,CAACI,OAAO,EAAE,CAAC,CAAC;MACd,OAAO;QAAE1B,IAAI,EAAE;MAAM,CAAC;IAC1B;EACJ,CAAC,MACI,IAAIuB,IAAI,KAAK,CAAC,EAAE;IACjB,OAAO;MAAEvB,IAAI,EAAE,MAAM;MAAEO,IAAI,EAAEe,EAAE,CAACK,QAAQ;IAAG,CAAC;EAChD,CAAC,MACI,IAAIJ,IAAI,KAAK,CAAC,EAAE;IACjB,IAAIK,SAAS,GAAGN,EAAE,CAACE,cAAc,CAAC,EAAE,CAAC;IACrC,IAAIK,OAAO,GAAGP,EAAE,CAACE,cAAc,CAAC,EAAE,CAAC;IACnC,IAAIM,SAAS,GAAGR,EAAE,CAACE,cAAc,CAAC,CAAC,CAAC;IACpC,IAAIO,OAAO,GAAGT,EAAE,CAACE,cAAc,CAAC,CAAC,CAAC;IAClC;IACA,IAAIQ,EAAE,GAAGV,EAAE,CAACK,QAAQ,EAAE,CAACM,UAAU,EAAE;IACnCD,EAAE,CAACE,IAAI,CAACN,SAAS,CAAC;IAClB,IAAIO,EAAE,GAAGH,EAAE,CAACI,aAAa,CAACP,OAAO,GAAGD,SAAS,CAAC;IAC9C,IAAIrB,IAAI,GAAG,IAAId,MAAM,CAAC4C,IAAI,CAAC,UAAU,EAAEF,EAAE,CAAC;IAC1C;IACA,IAAIL,SAAS,GAAGC,OAAO,EAAE;MACrB,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgB,SAAS,EAAEhB,CAAC,EAAE,EAAE;QAChCQ,EAAE,CAACK,QAAQ,EAAE;MACjB;MACA,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,OAAO,GAAGD,SAAS,EAAEhB,CAAC,EAAE,EAAE;QAC1CP,IAAI,CAACG,IAAI,CAAC4B,IAAI,CAAChB,EAAE,CAACK,QAAQ,EAAE,CAAC;MACjC;IACJ;IACA,OAAO;MAAE3B,IAAI,EAAE,OAAO;MAAEO;IAAK,CAAC;EAClC,CAAC,MACI,IAAIgB,IAAI,KAAK,CAAC,EAAE;IACjB,OAAO;MAAEvB,IAAI,EAAE,SAAS;MAAEO,IAAI,EAAEe,EAAE,CAACK,QAAQ;IAAG,CAAC;EACnD,CAAC,MACI,IAAIJ,IAAI,KAAK,CAAC,EAAE;IACjB,IAAIZ,MAAM,GAAGW,EAAE,CAACE,cAAc,CAAC,EAAE,CAAC;IAClC,IAAIT,KAAK,GAAG,EAAE;IACd,IAAIJ,MAAM,GAAG,CAAC,EAAE;MACZ,IAAIC,IAAI,GAAGU,EAAE,CAACiB,OAAO,EAAE;MACvB,IAAI1B,IAAI,GAAGS,EAAE,CAACiB,OAAO,EAAE;MACvBxB,KAAK,CAACyB,OAAO,CAACnB,cAAc,CAACR,IAAI,CAAC,CAAC;MACnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,GAAG,CAAC,EAAEG,CAAC,EAAE,EAAE;QACjC,IAAI2B,KAAK,GAAG7B,IAAI;QAChBA,IAAI,GAAG6B,KAAK,CAACF,OAAO,EAAE;QACtB1B,IAAI,GAAG4B,KAAK,CAACF,OAAO,EAAE;QACtBxB,KAAK,CAACyB,OAAO,CAACnB,cAAc,CAACR,IAAI,CAAC,CAAC;MACvC;MACAE,KAAK,CAACyB,OAAO,CAACnB,cAAc,CAACT,IAAI,CAAC,CAAC;IACvC,CAAC,MACI,IAAID,MAAM,KAAK,CAAC,EAAE;MACnBI,KAAK,CAACuB,IAAI,CAACjB,cAAc,CAACC,EAAE,CAACiB,OAAO,EAAE,CAAC,CAAC;IAC5C;IACA,OAAO;MAAEvC,IAAI,EAAE,OAAO;MAAEe;IAAM,CAAC;EACnC,CAAC,MACI;IACD,MAAMK,KAAK,CAAC,wBAAwB,CAAC;EACzC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASsB,kBAAkB,CAAC5C,GAAG,EAAEC,OAAO,EAAE;EACtC,IAAID,GAAG,CAACa,MAAM,GAAG,CAAC,EAAE;IAChB;IACA,IAAIE,IAAI,GAAG,CAAC,CAAC,EAAErB,SAAS,CAACyB,SAAS,GAAG;IACrCyB,kBAAkB,CAAC5C,GAAG,CAAC6C,KAAK,CAAC,CAAC,EAAE7C,GAAG,CAACa,MAAM,GAAG,CAAC,CAAC,EAAEE,IAAI,CAAC;IACtDd,OAAO,CAACO,QAAQ,CAACO,IAAI,CAACK,OAAO,EAAE,CAAC;IAChC;IACArB,kBAAkB,CAACC,GAAG,CAACA,GAAG,CAACa,MAAM,GAAG,CAAC,CAAC,EAAEZ,OAAO,CAAC;EACpD;AACJ;AACA,SAASV,cAAc,CAACS,GAAG,EAAE;EACzB,IAAIC,OAAO,GAAG,CAAC,CAAC,EAAEP,SAAS,CAACyB,SAAS,GAAG;EACxClB,OAAO,CAACM,SAAS,CAACP,GAAG,CAACa,MAAM,EAAE,EAAE,CAAC;EACjC,IAAIiC,CAAC,GAAG,CAAC,GAAG9C,GAAG,CAAC;EAChB4C,kBAAkB,CAACE,CAAC,EAAE7C,OAAO,CAAC;EAC9B,OAAOA,OAAO,CAACmB,OAAO,EAAE;AAC5B;AACAhC,OAAO,CAACG,cAAc,GAAGA,cAAc;AACvC,SAASD,UAAU,CAACU,GAAG,EAAE;EACrB,IAAI+C,GAAG,GAAG,EAAE;EACZ,IAAIvB,EAAE,GAAGxB,GAAG,CAACmC,UAAU,EAAE;EACzB,IAAIa,IAAI,GAAGxB,EAAE,CAACE,cAAc,CAAC,EAAE,CAAC;EAChC,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgC,IAAI,EAAEhC,CAAC,EAAE,EAAE;IAC3B,IAAIiC,IAAI,GAAGzB,EAAE,CAACiB,OAAO,EAAE;IACvBM,GAAG,CAACL,OAAO,CAACnB,cAAc,CAACC,EAAE,CAAC,CAAC;IAC/BA,EAAE,GAAGyB,IAAI;EACb;EACA,OAAOF,GAAG;AACd;AACA3D,OAAO,CAACE,UAAU,GAAGA,UAAU"},"metadata":{},"sourceType":"script"}