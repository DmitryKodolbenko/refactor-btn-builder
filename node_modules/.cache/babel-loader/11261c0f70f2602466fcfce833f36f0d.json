{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concat = void 0;\nconst xstream_1 = require(\"xstream\");\n/**\n * An implementation of concat that buffers all source stream events\n *\n * Marble diagram:\n *\n * ```text\n * --1--2---3---4-|\n * -a--b-c--d-|\n * --------X---------Y---------Z-\n *           concat\n * --1--2---3---4-abcdXY-------Z-\n * ```\n *\n * This is inspired by RxJS's concat as documented at http://rxmarbles.com/#concat and behaves\n * differently than xstream's concat as discussed in https://github.com/staltz/xstream/issues/170.\n *\n */\nfunction concat() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  const subscriptions = new Array();\n  const queues = new Array(); // one queue per stream\n  const completedStreams = new Set();\n  let activeStreamIndex = 0;\n  function reset() {\n    while (subscriptions.length > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const subscription = subscriptions.shift();\n      subscription.unsubscribe();\n    }\n    queues.length = 0;\n    completedStreams.clear();\n    activeStreamIndex = 0;\n  }\n  const producer = {\n    start: listener => {\n      streams.forEach(_ => queues.push([]));\n      function emitAllQueuesEvents(streamIndex) {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const element = queues[streamIndex].shift();\n          if (element === undefined) {\n            return;\n          }\n          listener.next(element);\n        }\n      }\n      function isDone() {\n        return activeStreamIndex >= streams.length;\n      }\n      if (isDone()) {\n        listener.complete();\n        return;\n      }\n      streams.forEach((stream, index) => {\n        subscriptions.push(stream.subscribe({\n          next: value => {\n            if (index === activeStreamIndex) {\n              listener.next(value);\n            } else {\n              queues[index].push(value);\n            }\n          },\n          complete: () => {\n            completedStreams.add(index);\n            while (completedStreams.has(activeStreamIndex)) {\n              // this stream completed: emit all and move on\n              emitAllQueuesEvents(activeStreamIndex);\n              activeStreamIndex++;\n            }\n            if (isDone()) {\n              listener.complete();\n            } else {\n              // now active stream can have some events queued but did not yet complete\n              emitAllQueuesEvents(activeStreamIndex);\n            }\n          },\n          error: error => {\n            listener.error(error);\n            reset();\n          }\n        }));\n      });\n    },\n    stop: () => {\n      reset();\n    }\n  };\n  return xstream_1.Stream.create(producer);\n}\nexports.concat = concat;","map":{"version":3,"sources":["../src/concat.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA;;;;;;;;;;;;;;;;AAgBG;AACH,SAAgB,MAAM,GAAgC;EAAA,kCAAzB,OAAyB;IAAzB,OAAyB;EAAA;EACpD,MAAM,aAAa,GAAG,IAAI,KAAK,EAAgB;EAC/C,MAAM,MAAM,GAAG,IAAI,KAAK,EAAO,CAAC,CAAC;EACjC,MAAM,gBAAgB,GAAG,IAAI,GAAG,EAAU;EAC1C,IAAI,iBAAiB,GAAG,CAAC;EAEzB,SAAS,KAAK,GAAA;IACZ,OAAO,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;MAC/B;MACA,MAAM,YAAY,GAAG,aAAa,CAAC,KAAK,EAAG;MAC3C,YAAY,CAAC,WAAW,EAAE;IAC3B;IAED,MAAM,CAAC,MAAM,GAAG,CAAC;IACjB,gBAAgB,CAAC,KAAK,EAAE;IACxB,iBAAiB,GAAG,CAAC;EACvB;EAEA,MAAM,QAAQ,GAAgB;IAC5B,KAAK,EAAG,QAAQ,IAAI;MAClB,OAAO,CAAC,OAAO,CAAE,CAAC,IAAK,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;MAEvC,SAAS,mBAAmB,CAAC,WAAmB,EAAA;QAC9C;QACA,OAAO,IAAI,EAAE;UACX,MAAM,OAAO,GAAG,MAAM,CAAC,WAAW,CAAC,CAAC,KAAK,EAAE;UAC3C,IAAI,OAAO,KAAK,SAAS,EAAE;YACzB;UACD;UACD,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC;QACvB;MACH;MAEA,SAAS,MAAM,GAAA;QACb,OAAO,iBAAiB,IAAI,OAAO,CAAC,MAAM;MAC5C;MAEA,IAAI,MAAM,EAAE,EAAE;QACZ,QAAQ,CAAC,QAAQ,EAAE;QACnB;MACD;MAED,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,KAAK,KAAI;QAChC,aAAa,CAAC,IAAI,CAChB,MAAM,CAAC,SAAS,CAAC;UACf,IAAI,EAAG,KAAK,IAAI;YACd,IAAI,KAAK,KAAK,iBAAiB,EAAE;cAC/B,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;aACrB,MAAM;cACL,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;YAC1B;UACH,CAAC;UACD,QAAQ,EAAE,MAAK;YACb,gBAAgB,CAAC,GAAG,CAAC,KAAK,CAAC;YAE3B,OAAO,gBAAgB,CAAC,GAAG,CAAC,iBAAiB,CAAC,EAAE;cAC9C;cACA,mBAAmB,CAAC,iBAAiB,CAAC;cACtC,iBAAiB,EAAE;YACpB;YAED,IAAI,MAAM,EAAE,EAAE;cACZ,QAAQ,CAAC,QAAQ,EAAE;aACpB,MAAM;cACL;cACA,mBAAmB,CAAC,iBAAiB,CAAC;YACvC;UACH,CAAC;UACD,KAAK,EAAG,KAAK,IAAI;YACf,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC;YACrB,KAAK,EAAE;UACT;SACD,CAAC,CACH;MACH,CAAC,CAAC;IACJ,CAAC;IACD,IAAI,EAAE,MAAK;MACT,KAAK,EAAE;IACT;GACD;EAED,OAAO,SAAA,CAAA,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC;AAChC;AAlFA,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.concat = void 0;\nconst xstream_1 = require(\"xstream\");\n/**\n * An implementation of concat that buffers all source stream events\n *\n * Marble diagram:\n *\n * ```text\n * --1--2---3---4-|\n * -a--b-c--d-|\n * --------X---------Y---------Z-\n *           concat\n * --1--2---3---4-abcdXY-------Z-\n * ```\n *\n * This is inspired by RxJS's concat as documented at http://rxmarbles.com/#concat and behaves\n * differently than xstream's concat as discussed in https://github.com/staltz/xstream/issues/170.\n *\n */\nfunction concat(...streams) {\n    const subscriptions = new Array();\n    const queues = new Array(); // one queue per stream\n    const completedStreams = new Set();\n    let activeStreamIndex = 0;\n    function reset() {\n        while (subscriptions.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const subscription = subscriptions.shift();\n            subscription.unsubscribe();\n        }\n        queues.length = 0;\n        completedStreams.clear();\n        activeStreamIndex = 0;\n    }\n    const producer = {\n        start: (listener) => {\n            streams.forEach((_) => queues.push([]));\n            function emitAllQueuesEvents(streamIndex) {\n                // eslint-disable-next-line no-constant-condition\n                while (true) {\n                    const element = queues[streamIndex].shift();\n                    if (element === undefined) {\n                        return;\n                    }\n                    listener.next(element);\n                }\n            }\n            function isDone() {\n                return activeStreamIndex >= streams.length;\n            }\n            if (isDone()) {\n                listener.complete();\n                return;\n            }\n            streams.forEach((stream, index) => {\n                subscriptions.push(stream.subscribe({\n                    next: (value) => {\n                        if (index === activeStreamIndex) {\n                            listener.next(value);\n                        }\n                        else {\n                            queues[index].push(value);\n                        }\n                    },\n                    complete: () => {\n                        completedStreams.add(index);\n                        while (completedStreams.has(activeStreamIndex)) {\n                            // this stream completed: emit all and move on\n                            emitAllQueuesEvents(activeStreamIndex);\n                            activeStreamIndex++;\n                        }\n                        if (isDone()) {\n                            listener.complete();\n                        }\n                        else {\n                            // now active stream can have some events queued but did not yet complete\n                            emitAllQueuesEvents(activeStreamIndex);\n                        }\n                    },\n                    error: (error) => {\n                        listener.error(error);\n                        reset();\n                    },\n                }));\n            });\n        },\n        stop: () => {\n            reset();\n        },\n    };\n    return xstream_1.Stream.create(producer);\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map"]},"metadata":{},"sourceType":"script"}