{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebsocketClient = void 0;\nconst json_rpc_1 = require(\"@cosmjs/json-rpc\");\nconst socket_1 = require(\"@cosmjs/socket\");\nconst stream_1 = require(\"@cosmjs/stream\");\nconst xstream_1 = require(\"xstream\");\nconst rpcclient_1 = require(\"./rpcclient\");\nfunction defaultErrorHandler(error) {\n  throw error;\n}\nfunction toJsonRpcResponse(message) {\n  // this should never happen, but I want an alert if it does\n  if (message.type !== \"message\") {\n    throw new Error(`Unexcepted message type on websocket: ${message.type}`);\n  }\n  const jsonRpcEvent = (0, json_rpc_1.parseJsonRpcResponse)(JSON.parse(message.data));\n  return jsonRpcEvent;\n}\nclass RpcEventProducer {\n  constructor(request, socket) {\n    this.running = false;\n    this.subscriptions = [];\n    this.request = request;\n    this.socket = socket;\n  }\n  /**\n   * Implementation of Producer.start\n   */\n  start(listener) {\n    if (this.running) {\n      throw Error(\"Already started. Please stop first before restarting.\");\n    }\n    this.running = true;\n    this.connectToClient(listener);\n    this.socket.queueRequest(JSON.stringify(this.request));\n  }\n  /**\n   * Implementation of Producer.stop\n   *\n   * Called by the stream when the stream's last listener stopped listening\n   * or when the producer completed.\n   */\n  stop() {\n    this.running = false;\n    // Tell the server we are done in order to save resources. We cannot wait for the result.\n    // This may fail when socket connection is not open, thus ignore errors in queueRequest\n    const endRequest = {\n      ...this.request,\n      method: \"unsubscribe\"\n    };\n    try {\n      this.socket.queueRequest(JSON.stringify(endRequest));\n    } catch (error) {\n      if (error instanceof Error && error.message.match(/socket has disconnected/i)) {\n        // ignore\n      } else {\n        throw error;\n      }\n    }\n  }\n  connectToClient(listener) {\n    const responseStream = this.socket.events.map(toJsonRpcResponse);\n    // this should unsubscribe itself, so doesn't need to be removed explicitly\n    const idSubscription = responseStream.filter(response => response.id === this.request.id).subscribe({\n      next: response => {\n        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {\n          this.closeSubscriptions();\n          listener.error(JSON.stringify(response.error));\n        }\n        idSubscription.unsubscribe();\n      }\n    });\n    // this will fire on a response (success or error)\n    // Tendermint adds an \"#event\" suffix for events that follow a previous subscription\n    // https://github.com/tendermint/tendermint/blob/v0.23.0/rpc/core/events.go#L107\n    const idEventSubscription = responseStream.filter(response => response.id === this.request.id).subscribe({\n      next: response => {\n        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {\n          this.closeSubscriptions();\n          listener.error(JSON.stringify(response.error));\n        } else {\n          listener.next(response.result);\n        }\n      }\n    });\n    // this will fire in case the websocket disconnects cleanly\n    const nonResponseSubscription = responseStream.subscribe({\n      error: error => {\n        this.closeSubscriptions();\n        listener.error(error);\n      },\n      complete: () => {\n        this.closeSubscriptions();\n        listener.complete();\n      }\n    });\n    this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);\n  }\n  closeSubscriptions() {\n    for (const subscription of this.subscriptions) {\n      subscription.unsubscribe();\n    }\n    // clear unused subscriptions\n    this.subscriptions = [];\n  }\n}\nclass WebsocketClient {\n  constructor(baseUrl) {\n    let onError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultErrorHandler;\n    // Lazily create streams and use the same stream when listening to the same query twice.\n    //\n    // Creating streams is cheap since producer is not started as long as nobody listens to events. Thus this\n    // map is never cleared and there is no need to do so. But unsubscribe all the subscriptions!\n    this.subscriptionStreams = new Map();\n    // accept host.name:port and assume ws protocol\n    // make sure we don't end up with ...//websocket\n    const path = baseUrl.endsWith(\"/\") ? \"websocket\" : \"/websocket\";\n    const cleanBaseUrl = (0, rpcclient_1.hasProtocol)(baseUrl) ? baseUrl : \"ws://\" + baseUrl;\n    this.url = cleanBaseUrl + path;\n    this.socket = new socket_1.ReconnectingSocket(this.url);\n    const errorSubscription = this.socket.events.subscribe({\n      error: error => {\n        onError(error);\n        errorSubscription.unsubscribe();\n      }\n    });\n    this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);\n    this.socket.connect();\n  }\n  async execute(request) {\n    const pendingResponse = this.responseForRequestId(request.id);\n    this.socket.queueRequest(JSON.stringify(request));\n    const response = await pendingResponse;\n    if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {\n      throw new Error(JSON.stringify(response.error));\n    }\n    return response;\n  }\n  listen(request) {\n    if (request.method !== \"subscribe\") {\n      throw new Error(`Request method must be \"subscribe\" to start event listening`);\n    }\n    const query = request.params.query;\n    if (typeof query !== \"string\") {\n      throw new Error(\"request.params.query must be a string\");\n    }\n    if (!this.subscriptionStreams.has(query)) {\n      const producer = new RpcEventProducer(request, this.socket);\n      const stream = xstream_1.Stream.create(producer);\n      this.subscriptionStreams.set(query, stream);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.subscriptionStreams.get(query).filter(response => response.query !== undefined);\n  }\n  /**\n   * Resolves as soon as websocket is connected. execute() queues requests automatically,\n   * so this should be required for testing purposes only.\n   */\n  async connected() {\n    await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);\n  }\n  disconnect() {\n    this.socket.disconnect();\n  }\n  async responseForRequestId(id) {\n    return (0, stream_1.firstEvent)(this.jsonRpcResponseStream.filter(r => r.id === id));\n  }\n}\nexports.WebsocketClient = WebsocketClient;","map":{"version":3,"sources":["../../src/rpcclients/websocketclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebsocketClient = void 0;\nconst json_rpc_1 = require(\"@cosmjs/json-rpc\");\nconst socket_1 = require(\"@cosmjs/socket\");\nconst stream_1 = require(\"@cosmjs/stream\");\nconst xstream_1 = require(\"xstream\");\nconst rpcclient_1 = require(\"./rpcclient\");\nfunction defaultErrorHandler(error) {\n    throw error;\n}\nfunction toJsonRpcResponse(message) {\n    // this should never happen, but I want an alert if it does\n    if (message.type !== \"message\") {\n        throw new Error(`Unexcepted message type on websocket: ${message.type}`);\n    }\n    const jsonRpcEvent = (0, json_rpc_1.parseJsonRpcResponse)(JSON.parse(message.data));\n    return jsonRpcEvent;\n}\nclass RpcEventProducer {\n    constructor(request, socket) {\n        this.running = false;\n        this.subscriptions = [];\n        this.request = request;\n        this.socket = socket;\n    }\n    /**\n     * Implementation of Producer.start\n     */\n    start(listener) {\n        if (this.running) {\n            throw Error(\"Already started. Please stop first before restarting.\");\n        }\n        this.running = true;\n        this.connectToClient(listener);\n        this.socket.queueRequest(JSON.stringify(this.request));\n    }\n    /**\n     * Implementation of Producer.stop\n     *\n     * Called by the stream when the stream's last listener stopped listening\n     * or when the producer completed.\n     */\n    stop() {\n        this.running = false;\n        // Tell the server we are done in order to save resources. We cannot wait for the result.\n        // This may fail when socket connection is not open, thus ignore errors in queueRequest\n        const endRequest = { ...this.request, method: \"unsubscribe\" };\n        try {\n            this.socket.queueRequest(JSON.stringify(endRequest));\n        }\n        catch (error) {\n            if (error instanceof Error && error.message.match(/socket has disconnected/i)) {\n                // ignore\n            }\n            else {\n                throw error;\n            }\n        }\n    }\n    connectToClient(listener) {\n        const responseStream = this.socket.events.map(toJsonRpcResponse);\n        // this should unsubscribe itself, so doesn't need to be removed explicitly\n        const idSubscription = responseStream\n            .filter((response) => response.id === this.request.id)\n            .subscribe({\n            next: (response) => {\n                if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {\n                    this.closeSubscriptions();\n                    listener.error(JSON.stringify(response.error));\n                }\n                idSubscription.unsubscribe();\n            },\n        });\n        // this will fire on a response (success or error)\n        // Tendermint adds an \"#event\" suffix for events that follow a previous subscription\n        // https://github.com/tendermint/tendermint/blob/v0.23.0/rpc/core/events.go#L107\n        const idEventSubscription = responseStream\n            .filter((response) => response.id === this.request.id)\n            .subscribe({\n            next: (response) => {\n                if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {\n                    this.closeSubscriptions();\n                    listener.error(JSON.stringify(response.error));\n                }\n                else {\n                    listener.next(response.result);\n                }\n            },\n        });\n        // this will fire in case the websocket disconnects cleanly\n        const nonResponseSubscription = responseStream.subscribe({\n            error: (error) => {\n                this.closeSubscriptions();\n                listener.error(error);\n            },\n            complete: () => {\n                this.closeSubscriptions();\n                listener.complete();\n            },\n        });\n        this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);\n    }\n    closeSubscriptions() {\n        for (const subscription of this.subscriptions) {\n            subscription.unsubscribe();\n        }\n        // clear unused subscriptions\n        this.subscriptions = [];\n    }\n}\nclass WebsocketClient {\n    constructor(baseUrl, onError = defaultErrorHandler) {\n        // Lazily create streams and use the same stream when listening to the same query twice.\n        //\n        // Creating streams is cheap since producer is not started as long as nobody listens to events. Thus this\n        // map is never cleared and there is no need to do so. But unsubscribe all the subscriptions!\n        this.subscriptionStreams = new Map();\n        // accept host.name:port and assume ws protocol\n        // make sure we don't end up with ...//websocket\n        const path = baseUrl.endsWith(\"/\") ? \"websocket\" : \"/websocket\";\n        const cleanBaseUrl = (0, rpcclient_1.hasProtocol)(baseUrl) ? baseUrl : \"ws://\" + baseUrl;\n        this.url = cleanBaseUrl + path;\n        this.socket = new socket_1.ReconnectingSocket(this.url);\n        const errorSubscription = this.socket.events.subscribe({\n            error: (error) => {\n                onError(error);\n                errorSubscription.unsubscribe();\n            },\n        });\n        this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);\n        this.socket.connect();\n    }\n    async execute(request) {\n        const pendingResponse = this.responseForRequestId(request.id);\n        this.socket.queueRequest(JSON.stringify(request));\n        const response = await pendingResponse;\n        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {\n            throw new Error(JSON.stringify(response.error));\n        }\n        return response;\n    }\n    listen(request) {\n        if (request.method !== \"subscribe\") {\n            throw new Error(`Request method must be \"subscribe\" to start event listening`);\n        }\n        const query = request.params.query;\n        if (typeof query !== \"string\") {\n            throw new Error(\"request.params.query must be a string\");\n        }\n        if (!this.subscriptionStreams.has(query)) {\n            const producer = new RpcEventProducer(request, this.socket);\n            const stream = xstream_1.Stream.create(producer);\n            this.subscriptionStreams.set(query, stream);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.subscriptionStreams.get(query).filter((response) => response.query !== undefined);\n    }\n    /**\n     * Resolves as soon as websocket is connected. execute() queues requests automatically,\n     * so this should be required for testing purposes only.\n     */\n    async connected() {\n        await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);\n    }\n    disconnect() {\n        this.socket.disconnect();\n    }\n    async responseForRequestId(id) {\n        return (0, stream_1.firstEvent)(this.jsonRpcResponseStream.filter((r) => r.id === id));\n    }\n}\nexports.WebsocketClient = WebsocketClient;\n//# sourceMappingURL=websocketclient.js.map"]},"metadata":{},"sourceType":"script"}