{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseDictRefs = exports.parseDictBitString = exports.parseDict = void 0;\nvar bn_js_1 = require(\"bn.js\");\nfunction doParse(prefix, slice, n, res, extractor) {\n  // Reading label\n  var lb0 = slice.readBit() ? 1 : 0;\n  var prefixLength = 0;\n  var pp = prefix;\n  if (lb0 === 0) {\n    // Short label detected\n    // Read \n    prefixLength = slice.readUnaryLength();\n    // Read prefix\n    for (var i = 0; i < prefixLength; i++) {\n      pp += slice.readBit() ? '1' : '0';\n    }\n  } else {\n    var lb1 = slice.readBit() ? 1 : 0;\n    if (lb1 === 0) {\n      // Long label detected\n      prefixLength = slice.readUintNumber(Math.ceil(Math.log2(n + 1)));\n      for (var _i = 0; _i < prefixLength; _i++) {\n        pp += slice.readBit() ? '1' : '0';\n      }\n    } else {\n      // Same label detected\n      var bit = slice.readBit() ? '1' : '0';\n      prefixLength = slice.readUintNumber(Math.ceil(Math.log2(n + 1)));\n      for (var _i2 = 0; _i2 < prefixLength; _i2++) {\n        pp += bit;\n      }\n    }\n  }\n  if (n - prefixLength === 0) {\n    res.set(new bn_js_1.BN(pp, 2).toString(10), extractor(slice));\n  } else {\n    var left = slice.readCell();\n    var right = slice.readCell();\n    // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'\n    if (!left.isExotic) {\n      doParse(pp + '0', left.beginParse(), n - prefixLength - 1, res, extractor);\n    }\n    if (!right.isExotic) {\n      doParse(pp + '1', right.beginParse(), n - prefixLength - 1, res, extractor);\n    }\n  }\n}\nfunction parseDict(slice, keySize, extractor) {\n  var res = new Map();\n  doParse('', slice, keySize, res, extractor);\n  return res;\n}\nexports.parseDict = parseDict;\nfunction parseDictBitString(slice, keySize) {\n  var res = new Map();\n  doParse('', slice, keySize, res, function (slice) {\n    return slice.readRemaining();\n  });\n  return res;\n}\nexports.parseDictBitString = parseDictBitString;\nfunction parseDictRefs(slice, keySize) {\n  var res = new Map();\n  doParse('', slice, keySize, res, function (slice) {\n    return slice.readRef();\n  });\n  return res;\n}\nexports.parseDictRefs = parseDictRefs;","map":{"version":3,"names":["Object","defineProperty","exports","value","parseDictRefs","parseDictBitString","parseDict","bn_js_1","require","doParse","prefix","slice","n","res","extractor","lb0","readBit","prefixLength","pp","readUnaryLength","i","lb1","readUintNumber","Math","ceil","log2","bit","set","BN","toString","left","readCell","right","isExotic","beginParse","keySize","Map","readRemaining","readRef"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/boc/dict/parseDict.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseDictRefs = exports.parseDictBitString = exports.parseDict = void 0;\nconst bn_js_1 = require(\"bn.js\");\nfunction doParse(prefix, slice, n, res, extractor) {\n    // Reading label\n    let lb0 = slice.readBit() ? 1 : 0;\n    let prefixLength = 0;\n    let pp = prefix;\n    if (lb0 === 0) {\n        // Short label detected\n        // Read \n        prefixLength = slice.readUnaryLength();\n        // Read prefix\n        for (let i = 0; i < prefixLength; i++) {\n            pp += slice.readBit() ? '1' : '0';\n        }\n    }\n    else {\n        let lb1 = slice.readBit() ? 1 : 0;\n        if (lb1 === 0) {\n            // Long label detected\n            prefixLength = slice.readUintNumber(Math.ceil(Math.log2(n + 1)));\n            for (let i = 0; i < prefixLength; i++) {\n                pp += slice.readBit() ? '1' : '0';\n            }\n        }\n        else {\n            // Same label detected\n            let bit = slice.readBit() ? '1' : '0';\n            prefixLength = slice.readUintNumber(Math.ceil(Math.log2(n + 1)));\n            for (let i = 0; i < prefixLength; i++) {\n                pp += bit;\n            }\n        }\n    }\n    if (n - prefixLength === 0) {\n        res.set(new bn_js_1.BN(pp, 2).toString(10), extractor(slice));\n    }\n    else {\n        let left = slice.readCell();\n        let right = slice.readCell();\n        // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'\n        if (!left.isExotic) {\n            doParse(pp + '0', left.beginParse(), n - prefixLength - 1, res, extractor);\n        }\n        if (!right.isExotic) {\n            doParse(pp + '1', right.beginParse(), n - prefixLength - 1, res, extractor);\n        }\n    }\n}\nfunction parseDict(slice, keySize, extractor) {\n    let res = new Map();\n    doParse('', slice, keySize, res, extractor);\n    return res;\n}\nexports.parseDict = parseDict;\nfunction parseDictBitString(slice, keySize) {\n    let res = new Map();\n    doParse('', slice, keySize, res, (slice) => slice.readRemaining());\n    return res;\n}\nexports.parseDictBitString = parseDictBitString;\nfunction parseDictRefs(slice, keySize) {\n    let res = new Map();\n    doParse('', slice, keySize, res, (slice) => slice.readRef());\n    return res;\n}\nexports.parseDictRefs = parseDictRefs;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}