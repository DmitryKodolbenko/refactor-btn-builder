{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doHash = exports.applyInner = exports.applyLeaf = void 0;\nconst ripemd160_1 = require(\"@noble/hashes/ripemd160\");\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst sha512_1 = require(\"@noble/hashes/sha512\");\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nfunction applyLeaf(leaf, key, value) {\n  if (key.length === 0) {\n    throw new Error(\"Missing key\");\n  }\n  if (value.length === 0) {\n    throw new Error(\"Missing value\");\n  }\n  const pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);\n  const pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);\n  const data = new Uint8Array([...ensureBytes(leaf.prefix), ...pkey, ...pvalue]);\n  return doHash(ensureHash(leaf.hash), data);\n}\nexports.applyLeaf = applyLeaf;\nfunction applyInner(inner, child) {\n  if (child.length === 0) {\n    throw new Error(\"Inner op needs child value\");\n  }\n  const preimage = new Uint8Array([...ensureBytes(inner.prefix), ...child, ...ensureBytes(inner.suffix)]);\n  return doHash(ensureHash(inner.hash), preimage);\n}\nexports.applyInner = applyInner;\nfunction ensure(maybe, value) {\n  return maybe === undefined || maybe === null ? value : maybe;\n}\nconst ensureHash = h => ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);\nconst ensureLength = l => ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);\nconst ensureBytes = b => ensure(b, new Uint8Array([]));\nfunction prepareLeafData(hashOp, lengthOp, data) {\n  const h = doHashOrNoop(hashOp, data);\n  return doLengthOp(lengthOp, h);\n}\n// doHashOrNoop will return the preimage untouched if hashOp == NONE,\n// otherwise, perform doHash\nfunction doHashOrNoop(hashOp, preimage) {\n  if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {\n    return preimage;\n  }\n  return doHash(hashOp, preimage);\n}\n// doHash will preform the specified hash on the preimage.\n// if hashOp == NONE, it will return an error (use doHashOrNoop if you want different behavior)\nfunction doHash(hashOp, preimage) {\n  switch (hashOp) {\n    case codecimpl_1.ics23.HashOp.SHA256:\n      return (0, sha256_1.sha256)(preimage);\n    case codecimpl_1.ics23.HashOp.SHA512:\n      return (0, sha512_1.sha512)(preimage);\n    case codecimpl_1.ics23.HashOp.RIPEMD160:\n      return (0, ripemd160_1.ripemd160)(preimage);\n    case codecimpl_1.ics23.HashOp.BITCOIN:\n      return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(preimage));\n    case codecimpl_1.ics23.HashOp.SHA512_256:\n      return (0, sha512_1.sha512_256)(preimage);\n  }\n  throw new Error(`Unsupported hashop: ${hashOp}`);\n}\nexports.doHash = doHash;\n// doLengthOp will calculate the proper prefix and return it prepended\n//   doLengthOp(op, data) -> length(data) || data\nfunction doLengthOp(lengthOp, data) {\n  switch (lengthOp) {\n    case codecimpl_1.ics23.LengthOp.NO_PREFIX:\n      return data;\n    case codecimpl_1.ics23.LengthOp.VAR_PROTO:\n      return new Uint8Array([...encodeVarintProto(data.length), ...data]);\n    case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:\n      if (data.length !== 32) {\n        throw new Error(`Length is ${data.length}, not 32 bytes`);\n      }\n      return data;\n    case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:\n      if (data.length !== 64) {\n        throw new Error(`Length is ${data.length}, not 64 bytes`);\n      }\n      return data;\n    case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:\n      return new Uint8Array([...encodeFixed32Le(data.length), ...data]);\n    // TODO\n    // case LengthOp_VAR_RLP:\n    // case LengthOp_FIXED32_BIG:\n    // case LengthOp_FIXED64_BIG:\n    // case LengthOp_FIXED64_LITTLE:\n  }\n\n  throw new Error(`Unsupported lengthop: ${lengthOp}`);\n}\nfunction encodeVarintProto(n) {\n  let enc = [];\n  let l = n;\n  while (l >= 128) {\n    const b = l % 128 + 128;\n    enc = [...enc, b];\n    l = l / 128;\n  }\n  enc = [...enc, l];\n  return new Uint8Array(enc);\n}\nfunction encodeFixed32Le(n) {\n  const enc = new Uint8Array(4);\n  let l = n;\n  for (let i = enc.length; i > 0; i--) {\n    enc[Math.abs(i - enc.length)] = l % 256;\n    l = Math.floor(l / 256);\n  }\n  return enc;\n}","map":{"version":3,"sources":["../src/ops.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.doHash = exports.applyInner = exports.applyLeaf = void 0;\nconst ripemd160_1 = require(\"@noble/hashes/ripemd160\");\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst sha512_1 = require(\"@noble/hashes/sha512\");\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nfunction applyLeaf(leaf, key, value) {\n    if (key.length === 0) {\n        throw new Error(\"Missing key\");\n    }\n    if (value.length === 0) {\n        throw new Error(\"Missing value\");\n    }\n    const pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);\n    const pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);\n    const data = new Uint8Array([\n        ...ensureBytes(leaf.prefix),\n        ...pkey,\n        ...pvalue,\n    ]);\n    return doHash(ensureHash(leaf.hash), data);\n}\nexports.applyLeaf = applyLeaf;\nfunction applyInner(inner, child) {\n    if (child.length === 0) {\n        throw new Error(\"Inner op needs child value\");\n    }\n    const preimage = new Uint8Array([\n        ...ensureBytes(inner.prefix),\n        ...child,\n        ...ensureBytes(inner.suffix),\n    ]);\n    return doHash(ensureHash(inner.hash), preimage);\n}\nexports.applyInner = applyInner;\nfunction ensure(maybe, value) {\n    return maybe === undefined || maybe === null ? value : maybe;\n}\nconst ensureHash = (h) => ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);\nconst ensureLength = (l) => ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);\nconst ensureBytes = (b) => ensure(b, new Uint8Array([]));\nfunction prepareLeafData(hashOp, lengthOp, data) {\n    const h = doHashOrNoop(hashOp, data);\n    return doLengthOp(lengthOp, h);\n}\n// doHashOrNoop will return the preimage untouched if hashOp == NONE,\n// otherwise, perform doHash\nfunction doHashOrNoop(hashOp, preimage) {\n    if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {\n        return preimage;\n    }\n    return doHash(hashOp, preimage);\n}\n// doHash will preform the specified hash on the preimage.\n// if hashOp == NONE, it will return an error (use doHashOrNoop if you want different behavior)\nfunction doHash(hashOp, preimage) {\n    switch (hashOp) {\n        case codecimpl_1.ics23.HashOp.SHA256:\n            return (0, sha256_1.sha256)(preimage);\n        case codecimpl_1.ics23.HashOp.SHA512:\n            return (0, sha512_1.sha512)(preimage);\n        case codecimpl_1.ics23.HashOp.RIPEMD160:\n            return (0, ripemd160_1.ripemd160)(preimage);\n        case codecimpl_1.ics23.HashOp.BITCOIN:\n            return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(preimage));\n        case codecimpl_1.ics23.HashOp.SHA512_256:\n            return (0, sha512_1.sha512_256)(preimage);\n    }\n    throw new Error(`Unsupported hashop: ${hashOp}`);\n}\nexports.doHash = doHash;\n// doLengthOp will calculate the proper prefix and return it prepended\n//   doLengthOp(op, data) -> length(data) || data\nfunction doLengthOp(lengthOp, data) {\n    switch (lengthOp) {\n        case codecimpl_1.ics23.LengthOp.NO_PREFIX:\n            return data;\n        case codecimpl_1.ics23.LengthOp.VAR_PROTO:\n            return new Uint8Array([...encodeVarintProto(data.length), ...data]);\n        case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:\n            if (data.length !== 32) {\n                throw new Error(`Length is ${data.length}, not 32 bytes`);\n            }\n            return data;\n        case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:\n            if (data.length !== 64) {\n                throw new Error(`Length is ${data.length}, not 64 bytes`);\n            }\n            return data;\n        case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:\n            return new Uint8Array([...encodeFixed32Le(data.length), ...data]);\n        // TODO\n        // case LengthOp_VAR_RLP:\n        // case LengthOp_FIXED32_BIG:\n        // case LengthOp_FIXED64_BIG:\n        // case LengthOp_FIXED64_LITTLE:\n    }\n    throw new Error(`Unsupported lengthop: ${lengthOp}`);\n}\nfunction encodeVarintProto(n) {\n    let enc = [];\n    let l = n;\n    while (l >= 128) {\n        const b = (l % 128) + 128;\n        enc = [...enc, b];\n        l = l / 128;\n    }\n    enc = [...enc, l];\n    return new Uint8Array(enc);\n}\nfunction encodeFixed32Le(n) {\n    const enc = new Uint8Array(4);\n    let l = n;\n    for (let i = enc.length; i > 0; i--) {\n        enc[Math.abs(i - enc.length)] = l % 256;\n        l = Math.floor(l / 256);\n    }\n    return enc;\n}\n//# sourceMappingURL=ops.js.map"]},"metadata":{},"sourceType":"script"}