{"ast":null,"code":"const {\n  base64ToBytes,\n  Address\n} = require(\"../../../utils\");\nconst {\n  Cell\n} = require(\"../../../boc\");\nconst SNAKE_DATA_PREFIX = 0x00;\nconst CHUNK_DATA_PREFIX = 0x01;\nconst ONCHAIN_CONTENT_PREFIX = 0x00;\nconst OFFCHAIN_CONTENT_PREFIX = 0x01;\n\n/**\n * @param uri   {string}\n * @returns {Uint8Array}\n */\nconst serializeUri = uri => {\n  return new TextEncoder().encode(encodeURI(uri));\n};\n\n/**\n * @param bytes {Uint8Array}\n * @return {string}\n */\nconst parseUri = bytes => {\n  return new TextDecoder().decode(bytes);\n};\n\n/**\n * @param uri {string}\n * @return {Cell}\n */\nconst createOffchainUriCell = uri => {\n  const cell = new Cell();\n  cell.bits.writeUint(OFFCHAIN_CONTENT_PREFIX, 8);\n  cell.bits.writeBytes(serializeUri(uri));\n  return cell;\n};\n\n/**\n * @param cell {Cell}\n * @returns {string}\n */\nconst parseOffchainUriCell = cell => {\n  let length = 0;\n  let c = cell;\n  while (c) {\n    length += c.bits.array.length;\n    c = c.refs[0];\n  }\n  const bytes = new Uint8Array(length);\n  length = 0;\n  c = cell;\n  while (c) {\n    bytes.set(c.bits.array, length);\n    length += c.bits.array.length;\n    c = c.refs[0];\n  }\n  return parseUri(bytes.slice(1)); // slice OFFCHAIN_CONTENT_PREFIX\n};\n\n/**\n * @param bs    {BitString}\n * @param cursor    {number}\n * @param bits  {number}\n * @return {BigInt}\n */\nconst readIntFromBitString = (bs, cursor, bits) => {\n  let n = BigInt(0);\n  for (let i = 0; i < bits; i++) {\n    n *= BigInt(2);\n    n += BigInt(bs.get(cursor + i));\n  }\n  return n;\n};\n\n/**\n * @param cell  {Cell}\n * @return {Address|null}\n */\nconst parseAddress = cell => {\n  let n = readIntFromBitString(cell.bits, 3, 8);\n  if (n > BigInt(127)) {\n    n = n - BigInt(256);\n  }\n  const hashPart = readIntFromBitString(cell.bits, 3 + 8, 256);\n  if (n.toString(10) + \":\" + hashPart.toString(16) === '0:0') return null;\n  const s = n.toString(10) + \":\" + hashPart.toString(16).padStart(64, '0');\n  return new Address(s);\n};\nmodule.exports = {\n  SNAKE_DATA_PREFIX,\n  CHUNK_DATA_PREFIX,\n  ONCHAIN_CONTENT_PREFIX,\n  OFFCHAIN_CONTENT_PREFIX,\n  parseAddress,\n  serializeUri,\n  parseUri,\n  createOffchainUriCell,\n  parseOffchainUriCell\n};","map":{"version":3,"names":["base64ToBytes","Address","require","Cell","SNAKE_DATA_PREFIX","CHUNK_DATA_PREFIX","ONCHAIN_CONTENT_PREFIX","OFFCHAIN_CONTENT_PREFIX","serializeUri","uri","TextEncoder","encode","encodeURI","parseUri","bytes","TextDecoder","decode","createOffchainUriCell","cell","bits","writeUint","writeBytes","parseOffchainUriCell","length","c","array","refs","Uint8Array","set","slice","readIntFromBitString","bs","cursor","n","BigInt","i","get","parseAddress","hashPart","toString","s","padStart","module","exports"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/tonweb/src/contract/token/nft/NftUtils.js"],"sourcesContent":["const {base64ToBytes, Address} = require(\"../../../utils\");\nconst {Cell} = require(\"../../../boc\");\n\nconst SNAKE_DATA_PREFIX = 0x00;\nconst CHUNK_DATA_PREFIX = 0x01;\nconst ONCHAIN_CONTENT_PREFIX = 0x00;\nconst OFFCHAIN_CONTENT_PREFIX = 0x01;\n\n/**\n * @param uri   {string}\n * @returns {Uint8Array}\n */\nconst serializeUri = (uri) => {\n    return new TextEncoder().encode(encodeURI(uri));\n}\n\n/**\n * @param bytes {Uint8Array}\n * @return {string}\n */\nconst parseUri = (bytes) => {\n    return new TextDecoder().decode(bytes);\n}\n\n/**\n * @param uri {string}\n * @return {Cell}\n */\nconst createOffchainUriCell = (uri) => {\n    const cell = new Cell();\n    cell.bits.writeUint(OFFCHAIN_CONTENT_PREFIX, 8);\n    cell.bits.writeBytes(serializeUri(uri));\n    return cell;\n}\n\n/**\n * @param cell {Cell}\n * @returns {string}\n */\nconst parseOffchainUriCell = (cell) => {\n    let length = 0;\n    let c = cell;\n    while (c) {\n        length += c.bits.array.length;\n        c = c.refs[0];\n    }\n\n    const bytes = new Uint8Array(length);\n    length = 0;\n    c = cell;\n    while (c) {\n        bytes.set(c.bits.array, length)\n        length += c.bits.array.length;\n        c = c.refs[0];\n    }\n    return parseUri(bytes.slice(1)); // slice OFFCHAIN_CONTENT_PREFIX\n}\n\n/**\n * @param bs    {BitString}\n * @param cursor    {number}\n * @param bits  {number}\n * @return {BigInt}\n */\nconst readIntFromBitString = (bs, cursor, bits) => {\n    let n = BigInt(0);\n    for (let i = 0; i < bits; i++) {\n        n *= BigInt(2);\n        n += BigInt(bs.get(cursor + i));\n    }\n    return n;\n}\n\n/**\n * @param cell  {Cell}\n * @return {Address|null}\n */\nconst parseAddress = cell => {\n    let n = readIntFromBitString(cell.bits, 3, 8);\n    if (n > BigInt(127)) {\n        n = n - BigInt(256);\n    }\n    const hashPart = readIntFromBitString(cell.bits, 3 + 8, 256);\n    if (n.toString(10) + \":\" + hashPart.toString(16) === '0:0') return null;\n    const s = n.toString(10) + \":\" + hashPart.toString(16).padStart(64, '0');\n    return new Address(s);\n};\n\n\nmodule.exports = {\n    SNAKE_DATA_PREFIX,\n    CHUNK_DATA_PREFIX,\n    ONCHAIN_CONTENT_PREFIX,\n    OFFCHAIN_CONTENT_PREFIX,\n    parseAddress,\n    serializeUri,\n    parseUri,\n    createOffchainUriCell,\n    parseOffchainUriCell\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}