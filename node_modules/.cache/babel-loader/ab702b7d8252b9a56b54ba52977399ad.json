{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _toConsumableArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectSecp256k1HdWallet = exports.extractKdfConfiguration = void 0;\nvar amino_1 = require(\"@cosmjs/amino\");\nvar crypto_1 = require(\"@cosmjs/crypto\");\nvar encoding_1 = require(\"@cosmjs/encoding\");\nvar utils_1 = require(\"@cosmjs/utils\");\nvar signing_1 = require(\"./signing\");\nvar wallet_1 = require(\"./wallet\");\nvar serializationTypeV1 = \"directsecp256k1hdwallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\nvar basicPasswordHashingOptions = {\n  algorithm: \"argon2id\",\n  params: {\n    outputLength: 32,\n    opsLimit: 24,\n    memLimitKib: 12 * 1024\n  }\n};\nfunction isDerivationJson(thing) {\n  if (!(0, utils_1.isNonNullObject)(thing)) return false;\n  if (typeof thing.hdPath !== \"string\") return false;\n  if (typeof thing.prefix !== \"string\") return false;\n  return true;\n}\nfunction extractKdfConfigurationV1(doc) {\n  return doc.kdf;\n}\nfunction extractKdfConfiguration(serialization) {\n  var root = JSON.parse(serialization);\n  if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n  switch (root.type) {\n    case serializationTypeV1:\n      return extractKdfConfigurationV1(root);\n    default:\n      throw new Error(\"Unsupported serialization type\");\n  }\n}\nexports.extractKdfConfiguration = extractKdfConfiguration;\nvar defaultOptions = {\n  bip39Password: \"\",\n  hdPaths: [(0, amino_1.makeCosmoshubPath)(0)],\n  prefix: \"cosmos\"\n};\n/** A wallet for protobuf based signing using SIGN_MODE_DIRECT */\nvar DirectSecp256k1HdWallet = /*#__PURE__*/function () {\n  function DirectSecp256k1HdWallet(mnemonic, options) {\n    _classCallCheck(this, DirectSecp256k1HdWallet);\n    var _a, _b;\n    var prefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : defaultOptions.prefix;\n    var hdPaths = (_b = options.hdPaths) !== null && _b !== void 0 ? _b : defaultOptions.hdPaths;\n    this.secret = mnemonic;\n    this.seed = options.seed;\n    this.accounts = hdPaths.map(function (hdPath) {\n      return {\n        hdPath: hdPath,\n        prefix: prefix\n      };\n    });\n  }\n  /**\n   * Restores a wallet from the given BIP39 mnemonic.\n   *\n   * @param mnemonic Any valid English mnemonic.\n   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n  _createClass(DirectSecp256k1HdWallet, [{\n    key: \"mnemonic\",\n    get: function get() {\n      return this.secret.toString();\n    }\n  }, {\n    key: \"getAccounts\",\n    value: function () {\n      var _getAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var accountsWithPrivkeys;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.getAccountsWithPrivkeys();\n              case 2:\n                accountsWithPrivkeys = _context.sent;\n                return _context.abrupt(\"return\", accountsWithPrivkeys.map(function (_ref) {\n                  var algo = _ref.algo,\n                    pubkey = _ref.pubkey,\n                    address = _ref.address;\n                  return {\n                    algo: algo,\n                    pubkey: pubkey,\n                    address: address\n                  };\n                }));\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function getAccounts() {\n        return _getAccounts.apply(this, arguments);\n      }\n      return getAccounts;\n    }()\n  }, {\n    key: \"signDirect\",\n    value: function () {\n      var _signDirect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(signerAddress, signDoc) {\n        var accounts, account, privkey, pubkey, signBytes, hashedMessage, signature, signatureBytes, stdSignature;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.getAccountsWithPrivkeys();\n              case 2:\n                accounts = _context2.sent;\n                account = accounts.find(function (_ref2) {\n                  var address = _ref2.address;\n                  return address === signerAddress;\n                });\n                if (!(account === undefined)) {\n                  _context2.next = 6;\n                  break;\n                }\n                throw new Error(\"Address \".concat(signerAddress, \" not found in wallet\"));\n              case 6:\n                privkey = account.privkey, pubkey = account.pubkey;\n                signBytes = (0, signing_1.makeSignBytes)(signDoc);\n                hashedMessage = (0, crypto_1.sha256)(signBytes);\n                _context2.next = 11;\n                return crypto_1.Secp256k1.createSignature(hashedMessage, privkey);\n              case 11:\n                signature = _context2.sent;\n                signatureBytes = new Uint8Array([].concat(_toConsumableArray(signature.r(32)), _toConsumableArray(signature.s(32))));\n                stdSignature = (0, amino_1.encodeSecp256k1Signature)(pubkey, signatureBytes);\n                return _context2.abrupt(\"return\", {\n                  signed: signDoc,\n                  signature: stdSignature\n                });\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function signDirect(_x, _x2) {\n        return _signDirect.apply(this, arguments);\n      }\n      return signDirect;\n    }()\n    /**\n     * Generates an encrypted serialization of this wallet.\n     *\n     * @param password The user provided password used to generate an encryption key via a KDF.\n     *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n     */\n  }, {\n    key: \"serialize\",\n    value: function () {\n      var _serialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(password) {\n        var kdfConfiguration, encryptionKey;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                kdfConfiguration = basicPasswordHashingOptions;\n                _context3.next = 3;\n                return (0, wallet_1.executeKdf)(password, kdfConfiguration);\n              case 3:\n                encryptionKey = _context3.sent;\n                return _context3.abrupt(\"return\", this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration));\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function serialize(_x3) {\n        return _serialize.apply(this, arguments);\n      }\n      return serialize;\n    }()\n    /**\n     * Generates an encrypted serialization of this wallet.\n     *\n     * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n     * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n     *\n     * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n     * is not the case, the wallet cannot be restored with the original password.\n     */\n  }, {\n    key: \"serializeWithEncryptionKey\",\n    value: function () {\n      var _serializeWithEncryptionKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(encryptionKey, kdfConfiguration) {\n        var dataToEncrypt, dataToEncryptRaw, encryptionConfiguration, encryptedData, out;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                dataToEncrypt = {\n                  mnemonic: this.mnemonic,\n                  accounts: this.accounts.map(function (_ref3) {\n                    var hdPath = _ref3.hdPath,\n                      prefix = _ref3.prefix;\n                    return {\n                      hdPath: (0, crypto_1.pathToString)(hdPath),\n                      prefix: prefix\n                    };\n                  })\n                };\n                dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));\n                encryptionConfiguration = {\n                  algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf\n                };\n                _context4.next = 5;\n                return (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n              case 5:\n                encryptedData = _context4.sent;\n                out = {\n                  type: serializationTypeV1,\n                  kdf: kdfConfiguration,\n                  encryption: encryptionConfiguration,\n                  data: (0, encoding_1.toBase64)(encryptedData)\n                };\n                return _context4.abrupt(\"return\", JSON.stringify(out));\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function serializeWithEncryptionKey(_x4, _x5) {\n        return _serializeWithEncryptionKey.apply(this, arguments);\n      }\n      return serializeWithEncryptionKey;\n    }()\n  }, {\n    key: \"getKeyPair\",\n    value: function () {\n      var _getKeyPair = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(hdPath) {\n        var _crypto_1$Slip10$deri, privkey, _yield$crypto_1$Secp, pubkey;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _crypto_1$Slip10$deri = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath), privkey = _crypto_1$Slip10$deri.privkey;\n                _context5.next = 3;\n                return crypto_1.Secp256k1.makeKeypair(privkey);\n              case 3:\n                _yield$crypto_1$Secp = _context5.sent;\n                pubkey = _yield$crypto_1$Secp.pubkey;\n                return _context5.abrupt(\"return\", {\n                  privkey: privkey,\n                  pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)\n                });\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function getKeyPair(_x6) {\n        return _getKeyPair.apply(this, arguments);\n      }\n      return getKeyPair;\n    }()\n  }, {\n    key: \"getAccountsWithPrivkeys\",\n    value: function () {\n      var _getAccountsWithPrivkeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var _this = this;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                return _context7.abrupt(\"return\", Promise.all(this.accounts.map( /*#__PURE__*/function () {\n                  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref4) {\n                    var hdPath, prefix, _yield$_this$getKeyPa, privkey, pubkey, address;\n                    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            hdPath = _ref4.hdPath, prefix = _ref4.prefix;\n                            _context6.next = 3;\n                            return _this.getKeyPair(hdPath);\n                          case 3:\n                            _yield$_this$getKeyPa = _context6.sent;\n                            privkey = _yield$_this$getKeyPa.privkey;\n                            pubkey = _yield$_this$getKeyPa.pubkey;\n                            address = (0, encoding_1.toBech32)(prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(pubkey));\n                            return _context6.abrupt(\"return\", {\n                              algo: \"secp256k1\",\n                              privkey: privkey,\n                              pubkey: pubkey,\n                              address: address\n                            });\n                          case 8:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6);\n                  }));\n                  return function (_x7) {\n                    return _ref5.apply(this, arguments);\n                  };\n                }())));\n              case 1:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function getAccountsWithPrivkeys() {\n        return _getAccountsWithPrivkeys.apply(this, arguments);\n      }\n      return getAccountsWithPrivkeys;\n    }()\n  }], [{\n    key: \"fromMnemonic\",\n    value: function () {\n      var _fromMnemonic = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(mnemonic) {\n        var options,\n          mnemonicChecked,\n          seed,\n          _args8 = arguments;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n                mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n                _context8.next = 4;\n                return crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n              case 4:\n                seed = _context8.sent;\n                return _context8.abrupt(\"return\", new DirectSecp256k1HdWallet(mnemonicChecked, _objectSpread(_objectSpread({}, options), {}, {\n                  seed: seed\n                })));\n              case 6:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n      function fromMnemonic(_x8) {\n        return _fromMnemonic.apply(this, arguments);\n      }\n      return fromMnemonic;\n    }()\n    /**\n     * Generates a new wallet with a BIP39 mnemonic of the given length.\n     *\n     * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n     * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n     */\n  }, {\n    key: \"generate\",\n    value: function () {\n      var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var length,\n          options,\n          entropyLength,\n          entropy,\n          mnemonic,\n          _args9 = arguments;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                length = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : 12;\n                options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};\n                entropyLength = 4 * Math.floor(11 * length / 33);\n                entropy = crypto_1.Random.getBytes(entropyLength);\n                mnemonic = crypto_1.Bip39.encode(entropy);\n                return _context9.abrupt(\"return\", DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options));\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n      function generate() {\n        return _generate.apply(this, arguments);\n      }\n      return generate;\n    }()\n    /**\n     * Restores a wallet from an encrypted serialization.\n     *\n     * @param password The user provided password used to generate an encryption key via a KDF.\n     *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n     */\n  }, {\n    key: \"deserialize\",\n    value: function () {\n      var _deserialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(serialization, password) {\n        var root;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                root = JSON.parse(serialization);\n                if ((0, utils_1.isNonNullObject)(root)) {\n                  _context10.next = 3;\n                  break;\n                }\n                throw new Error(\"Root document is not an object.\");\n              case 3:\n                _context10.t0 = root.type;\n                _context10.next = _context10.t0 === serializationTypeV1 ? 6 : 7;\n                break;\n              case 6:\n                return _context10.abrupt(\"return\", DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password));\n              case 7:\n                throw new Error(\"Unsupported serialization type\");\n              case 8:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n      function deserialize(_x9, _x10) {\n        return _deserialize.apply(this, arguments);\n      }\n      return deserialize;\n    }()\n    /**\n     * Restores a wallet from an encrypted serialization.\n     *\n     * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n     * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n     *\n     * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n     * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n     */\n  }, {\n    key: \"deserializeWithEncryptionKey\",\n    value: function () {\n      var _deserializeWithEncryptionKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(serialization, encryptionKey) {\n        var root, untypedRoot, decryptedBytes, decryptedDocument, mnemonic, accounts, firstPrefix, hdPaths;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                root = JSON.parse(serialization);\n                if ((0, utils_1.isNonNullObject)(root)) {\n                  _context11.next = 3;\n                  break;\n                }\n                throw new Error(\"Root document is not an object.\");\n              case 3:\n                untypedRoot = root;\n                _context11.t0 = untypedRoot.type;\n                _context11.next = _context11.t0 === serializationTypeV1 ? 7 : 22;\n                break;\n              case 7:\n                _context11.next = 9;\n                return (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n              case 9:\n                decryptedBytes = _context11.sent;\n                decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));\n                mnemonic = decryptedDocument.mnemonic, accounts = decryptedDocument.accounts;\n                (0, utils_1.assert)(typeof mnemonic === \"string\");\n                if (Array.isArray(accounts)) {\n                  _context11.next = 15;\n                  break;\n                }\n                throw new Error(\"Property 'accounts' is not an array\");\n              case 15:\n                if (accounts.every(function (account) {\n                  return isDerivationJson(account);\n                })) {\n                  _context11.next = 17;\n                  break;\n                }\n                throw new Error(\"Account is not in the correct format.\");\n              case 17:\n                firstPrefix = accounts[0].prefix;\n                if (accounts.every(function (_ref6) {\n                  var prefix = _ref6.prefix;\n                  return prefix === firstPrefix;\n                })) {\n                  _context11.next = 20;\n                  break;\n                }\n                throw new Error(\"Accounts do not all have the same prefix\");\n              case 20:\n                hdPaths = accounts.map(function (_ref7) {\n                  var hdPath = _ref7.hdPath;\n                  return (0, crypto_1.stringToPath)(hdPath);\n                });\n                return _context11.abrupt(\"return\", DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {\n                  hdPaths: hdPaths,\n                  prefix: firstPrefix\n                }));\n              case 22:\n                throw new Error(\"Unsupported serialization type\");\n              case 23:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }));\n      function deserializeWithEncryptionKey(_x11, _x12) {\n        return _deserializeWithEncryptionKey.apply(this, arguments);\n      }\n      return deserializeWithEncryptionKey;\n    }()\n  }, {\n    key: \"deserializeTypeV1\",\n    value: function () {\n      var _deserializeTypeV = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(serialization, password) {\n        var root, encryptionKey;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                root = JSON.parse(serialization);\n                if ((0, utils_1.isNonNullObject)(root)) {\n                  _context12.next = 3;\n                  break;\n                }\n                throw new Error(\"Root document is not an object.\");\n              case 3:\n                _context12.next = 5;\n                return (0, wallet_1.executeKdf)(password, root.kdf);\n              case 5:\n                encryptionKey = _context12.sent;\n                return _context12.abrupt(\"return\", DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey));\n              case 7:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12);\n      }));\n      function deserializeTypeV1(_x13, _x14) {\n        return _deserializeTypeV.apply(this, arguments);\n      }\n      return deserializeTypeV1;\n    }()\n  }]);\n  return DirectSecp256k1HdWallet;\n}();\nexports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;","map":{"version":3,"sources":["../src/directsecp256k1hdwallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DirectSecp256k1HdWallet = exports.extractKdfConfiguration = void 0;\nconst amino_1 = require(\"@cosmjs/amino\");\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst signing_1 = require(\"./signing\");\nconst wallet_1 = require(\"./wallet\");\nconst serializationTypeV1 = \"directsecp256k1hdwallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\nconst basicPasswordHashingOptions = {\n    algorithm: \"argon2id\",\n    params: {\n        outputLength: 32,\n        opsLimit: 24,\n        memLimitKib: 12 * 1024,\n    },\n};\nfunction isDerivationJson(thing) {\n    if (!(0, utils_1.isNonNullObject)(thing))\n        return false;\n    if (typeof thing.hdPath !== \"string\")\n        return false;\n    if (typeof thing.prefix !== \"string\")\n        return false;\n    return true;\n}\nfunction extractKdfConfigurationV1(doc) {\n    return doc.kdf;\n}\nfunction extractKdfConfiguration(serialization) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root))\n        throw new Error(\"Root document is not an object.\");\n    switch (root.type) {\n        case serializationTypeV1:\n            return extractKdfConfigurationV1(root);\n        default:\n            throw new Error(\"Unsupported serialization type\");\n    }\n}\nexports.extractKdfConfiguration = extractKdfConfiguration;\nconst defaultOptions = {\n    bip39Password: \"\",\n    hdPaths: [(0, amino_1.makeCosmoshubPath)(0)],\n    prefix: \"cosmos\",\n};\n/** A wallet for protobuf based signing using SIGN_MODE_DIRECT */\nclass DirectSecp256k1HdWallet {\n    constructor(mnemonic, options) {\n        var _a, _b;\n        const prefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : defaultOptions.prefix;\n        const hdPaths = (_b = options.hdPaths) !== null && _b !== void 0 ? _b : defaultOptions.hdPaths;\n        this.secret = mnemonic;\n        this.seed = options.seed;\n        this.accounts = hdPaths.map((hdPath) => ({\n            hdPath: hdPath,\n            prefix: prefix,\n        }));\n    }\n    /**\n     * Restores a wallet from the given BIP39 mnemonic.\n     *\n     * @param mnemonic Any valid English mnemonic.\n     * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n     */\n    static async fromMnemonic(mnemonic, options = {}) {\n        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n        return new DirectSecp256k1HdWallet(mnemonicChecked, {\n            ...options,\n            seed: seed,\n        });\n    }\n    /**\n     * Generates a new wallet with a BIP39 mnemonic of the given length.\n     *\n     * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n     * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n     */\n    static async generate(length = 12, options = {}) {\n        const entropyLength = 4 * Math.floor((11 * length) / 33);\n        const entropy = crypto_1.Random.getBytes(entropyLength);\n        const mnemonic = crypto_1.Bip39.encode(entropy);\n        return DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);\n    }\n    /**\n     * Restores a wallet from an encrypted serialization.\n     *\n     * @param password The user provided password used to generate an encryption key via a KDF.\n     *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n     */\n    static async deserialize(serialization, password) {\n        const root = JSON.parse(serialization);\n        if (!(0, utils_1.isNonNullObject)(root))\n            throw new Error(\"Root document is not an object.\");\n        switch (root.type) {\n            case serializationTypeV1:\n                return DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);\n            default:\n                throw new Error(\"Unsupported serialization type\");\n        }\n    }\n    /**\n     * Restores a wallet from an encrypted serialization.\n     *\n     * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n     * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n     *\n     * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n     * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n     */\n    static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n        const root = JSON.parse(serialization);\n        if (!(0, utils_1.isNonNullObject)(root))\n            throw new Error(\"Root document is not an object.\");\n        const untypedRoot = root;\n        switch (untypedRoot.type) {\n            case serializationTypeV1: {\n                const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n                const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));\n                const { mnemonic, accounts } = decryptedDocument;\n                (0, utils_1.assert)(typeof mnemonic === \"string\");\n                if (!Array.isArray(accounts))\n                    throw new Error(\"Property 'accounts' is not an array\");\n                if (!accounts.every((account) => isDerivationJson(account))) {\n                    throw new Error(\"Account is not in the correct format.\");\n                }\n                const firstPrefix = accounts[0].prefix;\n                if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {\n                    throw new Error(\"Accounts do not all have the same prefix\");\n                }\n                const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));\n                return DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {\n                    hdPaths: hdPaths,\n                    prefix: firstPrefix,\n                });\n            }\n            default:\n                throw new Error(\"Unsupported serialization type\");\n        }\n    }\n    static async deserializeTypeV1(serialization, password) {\n        const root = JSON.parse(serialization);\n        if (!(0, utils_1.isNonNullObject)(root))\n            throw new Error(\"Root document is not an object.\");\n        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);\n        return DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n    }\n    get mnemonic() {\n        return this.secret.toString();\n    }\n    async getAccounts() {\n        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();\n        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({\n            algo: algo,\n            pubkey: pubkey,\n            address: address,\n        }));\n    }\n    async signDirect(signerAddress, signDoc) {\n        const accounts = await this.getAccountsWithPrivkeys();\n        const account = accounts.find(({ address }) => address === signerAddress);\n        if (account === undefined) {\n            throw new Error(`Address ${signerAddress} not found in wallet`);\n        }\n        const { privkey, pubkey } = account;\n        const signBytes = (0, signing_1.makeSignBytes)(signDoc);\n        const hashedMessage = (0, crypto_1.sha256)(signBytes);\n        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);\n        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(pubkey, signatureBytes);\n        return {\n            signed: signDoc,\n            signature: stdSignature,\n        };\n    }\n    /**\n     * Generates an encrypted serialization of this wallet.\n     *\n     * @param password The user provided password used to generate an encryption key via a KDF.\n     *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n     */\n    async serialize(password) {\n        const kdfConfiguration = basicPasswordHashingOptions;\n        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);\n        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n    }\n    /**\n     * Generates an encrypted serialization of this wallet.\n     *\n     * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n     * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n     *\n     * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n     * is not the case, the wallet cannot be restored with the original password.\n     */\n    async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n        const dataToEncrypt = {\n            mnemonic: this.mnemonic,\n            accounts: this.accounts.map(({ hdPath, prefix }) => ({\n                hdPath: (0, crypto_1.pathToString)(hdPath),\n                prefix: prefix,\n            })),\n        };\n        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));\n        const encryptionConfiguration = {\n            algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf,\n        };\n        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n        const out = {\n            type: serializationTypeV1,\n            kdf: kdfConfiguration,\n            encryption: encryptionConfiguration,\n            data: (0, encoding_1.toBase64)(encryptedData),\n        };\n        return JSON.stringify(out);\n    }\n    async getKeyPair(hdPath) {\n        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);\n        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);\n        return {\n            privkey: privkey,\n            pubkey: crypto_1.Secp256k1.compressPubkey(pubkey),\n        };\n    }\n    async getAccountsWithPrivkeys() {\n        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {\n            const { privkey, pubkey } = await this.getKeyPair(hdPath);\n            const address = (0, encoding_1.toBech32)(prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(pubkey));\n            return {\n                algo: \"secp256k1\",\n                privkey: privkey,\n                pubkey: pubkey,\n                address: address,\n            };\n        }));\n    }\n}\nexports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;\n//# sourceMappingURL=directsecp256k1hdwallet.js.map"]},"metadata":{},"sourceType":"script"}