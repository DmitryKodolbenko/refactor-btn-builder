{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Responses = exports.decodeValidatorInfo = exports.decodeValidatorGenesis = exports.decodeValidatorUpdate = exports.decodeEvent = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst dates_1 = require(\"../../dates\");\nconst types_1 = require(\"../../types\");\nconst encodings_1 = require(\"../encodings\");\nconst hasher_1 = require(\"../hasher\");\nfunction decodeAbciInfo(data) {\n  return {\n    data: data.data,\n    lastBlockHeight: (0, encodings_1.may)(encodings_1.Integer.parse, data.last_block_height),\n    lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)\n  };\n}\nfunction decodeQueryProof(data) {\n  return {\n    ops: data.ops.map(op => ({\n      type: op.type,\n      key: (0, encoding_1.fromBase64)(op.key),\n      data: (0, encoding_1.fromBase64)(op.data)\n    }))\n  };\n}\nfunction decodeAbciQuery(data) {\n  return {\n    key: (0, encoding_1.fromBase64)((0, encodings_1.optional)(data.key, \"\")),\n    value: (0, encoding_1.fromBase64)((0, encodings_1.optional)(data.value, \"\")),\n    proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),\n    height: (0, encodings_1.may)(encodings_1.Integer.parse, data.height),\n    code: (0, encodings_1.may)(encodings_1.Integer.parse, data.code),\n    index: (0, encodings_1.may)(encodings_1.Integer.parse, data.index),\n    log: data.log\n  };\n}\nfunction decodeAttribute(attribute) {\n  return {\n    key: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(attribute.key)),\n    value: (0, encoding_1.fromBase64)((0, encodings_1.optional)(attribute.value, \"\"))\n  };\n}\nfunction decodeAttributes(attributes) {\n  return (0, encodings_1.assertArray)(attributes).map(decodeAttribute);\n}\nfunction decodeEvent(event) {\n  return {\n    type: event.type,\n    attributes: event.attributes ? decodeAttributes(event.attributes) : []\n  };\n}\nexports.decodeEvent = decodeEvent;\nfunction decodeEvents(events) {\n  return (0, encodings_1.assertArray)(events).map(decodeEvent);\n}\nfunction decodeTxData(data) {\n  return {\n    code: encodings_1.Integer.parse((0, encodings_1.assertNumber)((0, encodings_1.optional)(data.code, 0))),\n    codeSpace: data.codespace,\n    log: data.log,\n    data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),\n    events: data.events ? decodeEvents(data.events) : [],\n    gasWanted: encodings_1.Integer.parse((0, encodings_1.optional)(data.gas_wanted, \"0\")),\n    gasUsed: encodings_1.Integer.parse((0, encodings_1.optional)(data.gas_used, \"0\"))\n  };\n}\nfunction decodePubkey(data) {\n  if (\"Sum\" in data) {\n    // we don't need to check type because we're checking algorithm\n    const [[algorithm, value]] = Object.entries(data.Sum.value);\n    (0, utils_1.assert)(algorithm === \"ed25519\" || algorithm === \"secp256k1\", `unknown pubkey type: ${algorithm}`);\n    return {\n      algorithm,\n      data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value))\n    };\n  } else {\n    switch (data.type) {\n      // go-amino special code\n      case \"tendermint/PubKeyEd25519\":\n        return {\n          algorithm: \"ed25519\",\n          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))\n        };\n      case \"tendermint/PubKeySecp256k1\":\n        return {\n          algorithm: \"secp256k1\",\n          data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))\n        };\n      default:\n        throw new Error(`unknown pubkey type: ${data.type}`);\n    }\n  }\n}\n/**\n * Note: we do not parse block.time_iota_ms for now because of this CHANGELOG entry\n *\n * > Add time_iota_ms to block's consensus parameters (not exposed to the application)\n * https://github.com/tendermint/tendermint/blob/master/CHANGELOG.md#v0310\n */\nfunction decodeBlockParams(data) {\n  return {\n    maxBytes: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.max_bytes)),\n    maxGas: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.max_gas))\n  };\n}\nfunction decodeEvidenceParams(data) {\n  return {\n    maxAgeNumBlocks: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),\n    maxAgeDuration: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.max_age_duration))\n  };\n}\nfunction decodeConsensusParams(data) {\n  return {\n    block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),\n    evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))\n  };\n}\nfunction decodeValidatorUpdate(data) {\n  var _a;\n  return {\n    pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),\n    votingPower: encodings_1.Integer.parse((_a = data.power) !== null && _a !== void 0 ? _a : 0)\n  };\n}\nexports.decodeValidatorUpdate = decodeValidatorUpdate;\nfunction decodeBlockResults(data) {\n  return {\n    height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),\n    results: (data.txs_results || []).map(decodeTxData),\n    validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),\n    consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),\n    beginBlockEvents: decodeEvents(data.begin_block_events || []),\n    endBlockEvents: decodeEvents(data.end_block_events || [])\n  };\n}\nfunction decodeBlockId(data) {\n  return {\n    hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),\n    parts: {\n      total: (0, encodings_1.assertNotEmpty)(data.parts.total),\n      hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))\n    }\n  };\n}\nfunction decodeBlockVersion(data) {\n  var _a;\n  return {\n    block: encodings_1.Integer.parse(data.block),\n    app: encodings_1.Integer.parse((_a = data.app) !== null && _a !== void 0 ? _a : 0)\n  };\n}\nfunction decodeHeader(data) {\n  return {\n    version: decodeBlockVersion(data.version),\n    chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),\n    height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),\n    time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),\n    // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:\n    // { hash: '', parts: { total: 0, hash: '' } }\n    lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,\n    lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),\n    dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),\n    validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),\n    nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),\n    consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),\n    appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),\n    lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),\n    evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),\n    proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))\n  };\n}\nfunction decodeBlockMeta(data) {\n  return {\n    blockId: decodeBlockId(data.block_id),\n    blockSize: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.block_size)),\n    header: decodeHeader(data.header),\n    numTxs: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.num_txs))\n  };\n}\nfunction decodeBlockchain(data) {\n  return {\n    lastHeight: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.last_height)),\n    blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)\n  };\n}\nfunction decodeBroadcastTxSync(data) {\n  return {\n    ...decodeTxData(data),\n    hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash))\n  };\n}\nfunction decodeBroadcastTxCommit(data) {\n  return {\n    height: encodings_1.Integer.parse(data.height),\n    hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),\n    checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),\n    deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)\n  };\n}\nfunction decodeBlockIdFlag(blockIdFlag) {\n  (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);\n  return blockIdFlag;\n}\n/**\n * In some cases a timestamp is optional and set to the value 0 in Go.\n * This can lead to strings like \"0001-01-01T00:00:00Z\" (see https://github.com/cosmos/cosmjs/issues/704#issuecomment-797122415).\n * This decoder tries to clean up such encoding from the API and turn them\n * into undefined values.\n */\nfunction decodeOptionalTime(timestamp) {\n  const nonZeroTime = timestamp && !timestamp.startsWith(\"0001-01-01\");\n  return nonZeroTime ? (0, dates_1.fromRfc3339WithNanoseconds)(timestamp) : undefined;\n}\nfunction decodeCommitSignature(data) {\n  return {\n    blockIdFlag: decodeBlockIdFlag(data.block_id_flag),\n    validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : undefined,\n    timestamp: decodeOptionalTime(data.timestamp),\n    signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : undefined\n  };\n}\nfunction decodeCommit(data) {\n  return {\n    blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),\n    height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),\n    round: encodings_1.Integer.parse(data.round),\n    signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)\n  };\n}\nfunction decodeCommitResponse(data) {\n  return {\n    canonical: (0, encodings_1.assertBoolean)(data.canonical),\n    header: decodeHeader(data.signed_header.header),\n    commit: decodeCommit(data.signed_header.commit)\n  };\n}\nfunction decodeValidatorGenesis(data) {\n  return {\n    address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),\n    pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),\n    votingPower: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.power))\n  };\n}\nexports.decodeValidatorGenesis = decodeValidatorGenesis;\nfunction decodeGenesis(data) {\n  return {\n    genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),\n    chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),\n    consensusParams: decodeConsensusParams(data.consensus_params),\n    validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],\n    appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),\n    appState: data.app_state\n  };\n}\nfunction decodeValidatorInfo(data) {\n  return {\n    pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),\n    votingPower: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.voting_power)),\n    address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),\n    proposerPriority: data.proposer_priority ? encodings_1.Integer.parse(data.proposer_priority) : undefined\n  };\n}\nexports.decodeValidatorInfo = decodeValidatorInfo;\nfunction decodeNodeInfo(data) {\n  return {\n    id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),\n    listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),\n    network: (0, encodings_1.assertNotEmpty)(data.network),\n    version: (0, encodings_1.assertString)(data.version),\n    channels: (0, encodings_1.assertNotEmpty)(data.channels),\n    moniker: (0, encodings_1.assertNotEmpty)(data.moniker),\n    other: (0, encodings_1.dictionaryToStringMap)(data.other),\n    protocolVersion: {\n      app: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),\n      block: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),\n      p2p: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))\n    }\n  };\n}\nfunction decodeSyncInfo(data) {\n  return {\n    latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),\n    latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),\n    latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),\n    latestBlockHeight: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.latest_block_height)),\n    catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)\n  };\n}\nfunction decodeStatus(data) {\n  return {\n    nodeInfo: decodeNodeInfo(data.node_info),\n    syncInfo: decodeSyncInfo(data.sync_info),\n    validatorInfo: decodeValidatorInfo(data.validator_info)\n  };\n}\nfunction decodeTxProof(data) {\n  return {\n    data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),\n    rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),\n    proof: {\n      total: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.proof.total)),\n      index: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.proof.index)),\n      leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),\n      aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)\n    }\n  };\n}\nfunction decodeTxResponse(data) {\n  return {\n    tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),\n    result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),\n    height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),\n    index: encodings_1.Integer.parse((0, encodings_1.assertNumber)(data.index)),\n    hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),\n    proof: (0, encodings_1.may)(decodeTxProof, data.proof)\n  };\n}\nfunction decodeTxSearch(data) {\n  return {\n    totalCount: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total_count)),\n    txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)\n  };\n}\nfunction decodeTxEvent(data) {\n  const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));\n  return {\n    tx: tx,\n    hash: (0, hasher_1.hashTx)(tx),\n    result: decodeTxData(data.result),\n    height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),\n    index: (0, encodings_1.may)(encodings_1.Integer.parse, data.index)\n  };\n}\nfunction decodeValidators(data) {\n  return {\n    blockHeight: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.block_height)),\n    validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),\n    count: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.count)),\n    total: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total))\n  };\n}\nfunction decodeBlock(data) {\n  var _a, _b;\n  return {\n    header: decodeHeader((0, encodings_1.assertObject)(data.header)),\n    // For the block at height 1, last commit is not set. This is represented in an empty object like this:\n    // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }\n    lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,\n    txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],\n    // Lift up .evidence.evidence to just .evidence\n    // See https://github.com/tendermint/tendermint/issues/7697\n    evidence: (_b = (_a = data.evidence) === null || _a === void 0 ? void 0 : _a.evidence) !== null && _b !== void 0 ? _b : []\n  };\n}\nfunction decodeBlockResponse(data) {\n  return {\n    blockId: decodeBlockId(data.block_id),\n    block: decodeBlock(data.block)\n  };\n}\nfunction decodeBlockSearch(data) {\n  return {\n    totalCount: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total_count)),\n    blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)\n  };\n}\nfunction decodeNumUnconfirmedTxs(data) {\n  return {\n    total: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total)),\n    totalBytes: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total_bytes))\n  };\n}\nclass Responses {\n  static decodeAbciInfo(response) {\n    return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));\n  }\n  static decodeAbciQuery(response) {\n    return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));\n  }\n  static decodeBlock(response) {\n    return decodeBlockResponse(response.result);\n  }\n  static decodeBlockResults(response) {\n    return decodeBlockResults(response.result);\n  }\n  static decodeBlockSearch(response) {\n    return decodeBlockSearch(response.result);\n  }\n  static decodeBlockchain(response) {\n    return decodeBlockchain(response.result);\n  }\n  static decodeBroadcastTxSync(response) {\n    return decodeBroadcastTxSync(response.result);\n  }\n  static decodeBroadcastTxAsync(response) {\n    return Responses.decodeBroadcastTxSync(response);\n  }\n  static decodeBroadcastTxCommit(response) {\n    return decodeBroadcastTxCommit(response.result);\n  }\n  static decodeCommit(response) {\n    return decodeCommitResponse(response.result);\n  }\n  static decodeGenesis(response) {\n    return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));\n  }\n  static decodeHealth() {\n    return null;\n  }\n  static decodeNumUnconfirmedTxs(response) {\n    return decodeNumUnconfirmedTxs(response.result);\n  }\n  static decodeStatus(response) {\n    return decodeStatus(response.result);\n  }\n  static decodeNewBlockEvent(event) {\n    return decodeBlock(event.data.value.block);\n  }\n  static decodeNewBlockHeaderEvent(event) {\n    return decodeHeader(event.data.value.header);\n  }\n  static decodeTxEvent(event) {\n    return decodeTxEvent(event.data.value.TxResult);\n  }\n  static decodeTx(response) {\n    return decodeTxResponse(response.result);\n  }\n  static decodeTxSearch(response) {\n    return decodeTxSearch(response.result);\n  }\n  static decodeValidators(response) {\n    return decodeValidators(response.result);\n  }\n}\nexports.Responses = Responses;","map":{"version":3,"sources":["../../../src/tendermint34/adaptor/responses.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Responses = exports.decodeValidatorInfo = exports.decodeValidatorGenesis = exports.decodeValidatorUpdate = exports.decodeEvent = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst dates_1 = require(\"../../dates\");\nconst types_1 = require(\"../../types\");\nconst encodings_1 = require(\"../encodings\");\nconst hasher_1 = require(\"../hasher\");\nfunction decodeAbciInfo(data) {\n    return {\n        data: data.data,\n        lastBlockHeight: (0, encodings_1.may)(encodings_1.Integer.parse, data.last_block_height),\n        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash),\n    };\n}\nfunction decodeQueryProof(data) {\n    return {\n        ops: data.ops.map((op) => ({\n            type: op.type,\n            key: (0, encoding_1.fromBase64)(op.key),\n            data: (0, encoding_1.fromBase64)(op.data),\n        })),\n    };\n}\nfunction decodeAbciQuery(data) {\n    return {\n        key: (0, encoding_1.fromBase64)((0, encodings_1.optional)(data.key, \"\")),\n        value: (0, encoding_1.fromBase64)((0, encodings_1.optional)(data.value, \"\")),\n        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),\n        height: (0, encodings_1.may)(encodings_1.Integer.parse, data.height),\n        code: (0, encodings_1.may)(encodings_1.Integer.parse, data.code),\n        index: (0, encodings_1.may)(encodings_1.Integer.parse, data.index),\n        log: data.log,\n    };\n}\nfunction decodeAttribute(attribute) {\n    return {\n        key: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(attribute.key)),\n        value: (0, encoding_1.fromBase64)((0, encodings_1.optional)(attribute.value, \"\")),\n    };\n}\nfunction decodeAttributes(attributes) {\n    return (0, encodings_1.assertArray)(attributes).map(decodeAttribute);\n}\nfunction decodeEvent(event) {\n    return {\n        type: event.type,\n        attributes: event.attributes ? decodeAttributes(event.attributes) : [],\n    };\n}\nexports.decodeEvent = decodeEvent;\nfunction decodeEvents(events) {\n    return (0, encodings_1.assertArray)(events).map(decodeEvent);\n}\nfunction decodeTxData(data) {\n    return {\n        code: encodings_1.Integer.parse((0, encodings_1.assertNumber)((0, encodings_1.optional)(data.code, 0))),\n        codeSpace: data.codespace,\n        log: data.log,\n        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),\n        events: data.events ? decodeEvents(data.events) : [],\n        gasWanted: encodings_1.Integer.parse((0, encodings_1.optional)(data.gas_wanted, \"0\")),\n        gasUsed: encodings_1.Integer.parse((0, encodings_1.optional)(data.gas_used, \"0\")),\n    };\n}\nfunction decodePubkey(data) {\n    if (\"Sum\" in data) {\n        // we don't need to check type because we're checking algorithm\n        const [[algorithm, value]] = Object.entries(data.Sum.value);\n        (0, utils_1.assert)(algorithm === \"ed25519\" || algorithm === \"secp256k1\", `unknown pubkey type: ${algorithm}`);\n        return {\n            algorithm,\n            data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(value)),\n        };\n    }\n    else {\n        switch (data.type) {\n            // go-amino special code\n            case \"tendermint/PubKeyEd25519\":\n                return {\n                    algorithm: \"ed25519\",\n                    data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value)),\n                };\n            case \"tendermint/PubKeySecp256k1\":\n                return {\n                    algorithm: \"secp256k1\",\n                    data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value)),\n                };\n            default:\n                throw new Error(`unknown pubkey type: ${data.type}`);\n        }\n    }\n}\n/**\n * Note: we do not parse block.time_iota_ms for now because of this CHANGELOG entry\n *\n * > Add time_iota_ms to block's consensus parameters (not exposed to the application)\n * https://github.com/tendermint/tendermint/blob/master/CHANGELOG.md#v0310\n */\nfunction decodeBlockParams(data) {\n    return {\n        maxBytes: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.max_bytes)),\n        maxGas: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.max_gas)),\n    };\n}\nfunction decodeEvidenceParams(data) {\n    return {\n        maxAgeNumBlocks: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),\n        maxAgeDuration: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.max_age_duration)),\n    };\n}\nfunction decodeConsensusParams(data) {\n    return {\n        block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),\n        evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence)),\n    };\n}\nfunction decodeValidatorUpdate(data) {\n    var _a;\n    return {\n        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),\n        votingPower: encodings_1.Integer.parse((_a = data.power) !== null && _a !== void 0 ? _a : 0),\n    };\n}\nexports.decodeValidatorUpdate = decodeValidatorUpdate;\nfunction decodeBlockResults(data) {\n    return {\n        height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),\n        results: (data.txs_results || []).map(decodeTxData),\n        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),\n        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),\n        beginBlockEvents: decodeEvents(data.begin_block_events || []),\n        endBlockEvents: decodeEvents(data.end_block_events || []),\n    };\n}\nfunction decodeBlockId(data) {\n    return {\n        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),\n        parts: {\n            total: (0, encodings_1.assertNotEmpty)(data.parts.total),\n            hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash)),\n        },\n    };\n}\nfunction decodeBlockVersion(data) {\n    var _a;\n    return {\n        block: encodings_1.Integer.parse(data.block),\n        app: encodings_1.Integer.parse((_a = data.app) !== null && _a !== void 0 ? _a : 0),\n    };\n}\nfunction decodeHeader(data) {\n    return {\n        version: decodeBlockVersion(data.version),\n        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),\n        height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),\n        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),\n        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:\n        // { hash: '', parts: { total: 0, hash: '' } }\n        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,\n        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),\n        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),\n        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),\n        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),\n        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),\n        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),\n        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),\n        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),\n        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address)),\n    };\n}\nfunction decodeBlockMeta(data) {\n    return {\n        blockId: decodeBlockId(data.block_id),\n        blockSize: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.block_size)),\n        header: decodeHeader(data.header),\n        numTxs: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.num_txs)),\n    };\n}\nfunction decodeBlockchain(data) {\n    return {\n        lastHeight: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.last_height)),\n        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta),\n    };\n}\nfunction decodeBroadcastTxSync(data) {\n    return {\n        ...decodeTxData(data),\n        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),\n    };\n}\nfunction decodeBroadcastTxCommit(data) {\n    return {\n        height: encodings_1.Integer.parse(data.height),\n        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),\n        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),\n        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx),\n    };\n}\nfunction decodeBlockIdFlag(blockIdFlag) {\n    (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);\n    return blockIdFlag;\n}\n/**\n * In some cases a timestamp is optional and set to the value 0 in Go.\n * This can lead to strings like \"0001-01-01T00:00:00Z\" (see https://github.com/cosmos/cosmjs/issues/704#issuecomment-797122415).\n * This decoder tries to clean up such encoding from the API and turn them\n * into undefined values.\n */\nfunction decodeOptionalTime(timestamp) {\n    const nonZeroTime = timestamp && !timestamp.startsWith(\"0001-01-01\");\n    return nonZeroTime ? (0, dates_1.fromRfc3339WithNanoseconds)(timestamp) : undefined;\n}\nfunction decodeCommitSignature(data) {\n    return {\n        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),\n        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : undefined,\n        timestamp: decodeOptionalTime(data.timestamp),\n        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : undefined,\n    };\n}\nfunction decodeCommit(data) {\n    return {\n        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),\n        height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),\n        round: encodings_1.Integer.parse(data.round),\n        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature),\n    };\n}\nfunction decodeCommitResponse(data) {\n    return {\n        canonical: (0, encodings_1.assertBoolean)(data.canonical),\n        header: decodeHeader(data.signed_header.header),\n        commit: decodeCommit(data.signed_header.commit),\n    };\n}\nfunction decodeValidatorGenesis(data) {\n    return {\n        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),\n        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),\n        votingPower: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.power)),\n    };\n}\nexports.decodeValidatorGenesis = decodeValidatorGenesis;\nfunction decodeGenesis(data) {\n    return {\n        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),\n        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),\n        consensusParams: decodeConsensusParams(data.consensus_params),\n        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],\n        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),\n        appState: data.app_state,\n    };\n}\nfunction decodeValidatorInfo(data) {\n    return {\n        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),\n        votingPower: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.voting_power)),\n        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),\n        proposerPriority: data.proposer_priority ? encodings_1.Integer.parse(data.proposer_priority) : undefined,\n    };\n}\nexports.decodeValidatorInfo = decodeValidatorInfo;\nfunction decodeNodeInfo(data) {\n    return {\n        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),\n        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),\n        network: (0, encodings_1.assertNotEmpty)(data.network),\n        version: (0, encodings_1.assertString)(data.version),\n        channels: (0, encodings_1.assertNotEmpty)(data.channels),\n        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),\n        other: (0, encodings_1.dictionaryToStringMap)(data.other),\n        protocolVersion: {\n            app: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),\n            block: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),\n            p2p: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p)),\n        },\n    };\n}\nfunction decodeSyncInfo(data) {\n    return {\n        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),\n        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),\n        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),\n        latestBlockHeight: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.latest_block_height)),\n        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up),\n    };\n}\nfunction decodeStatus(data) {\n    return {\n        nodeInfo: decodeNodeInfo(data.node_info),\n        syncInfo: decodeSyncInfo(data.sync_info),\n        validatorInfo: decodeValidatorInfo(data.validator_info),\n    };\n}\nfunction decodeTxProof(data) {\n    return {\n        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),\n        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),\n        proof: {\n            total: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.proof.total)),\n            index: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.proof.index)),\n            leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),\n            aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64),\n        },\n    };\n}\nfunction decodeTxResponse(data) {\n    return {\n        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),\n        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),\n        height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),\n        index: encodings_1.Integer.parse((0, encodings_1.assertNumber)(data.index)),\n        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),\n        proof: (0, encodings_1.may)(decodeTxProof, data.proof),\n    };\n}\nfunction decodeTxSearch(data) {\n    return {\n        totalCount: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total_count)),\n        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse),\n    };\n}\nfunction decodeTxEvent(data) {\n    const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));\n    return {\n        tx: tx,\n        hash: (0, hasher_1.hashTx)(tx),\n        result: decodeTxData(data.result),\n        height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),\n        index: (0, encodings_1.may)(encodings_1.Integer.parse, data.index),\n    };\n}\nfunction decodeValidators(data) {\n    return {\n        blockHeight: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.block_height)),\n        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorInfo),\n        count: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.count)),\n        total: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total)),\n    };\n}\nfunction decodeBlock(data) {\n    var _a, _b;\n    return {\n        header: decodeHeader((0, encodings_1.assertObject)(data.header)),\n        // For the block at height 1, last commit is not set. This is represented in an empty object like this:\n        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }\n        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,\n        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],\n        // Lift up .evidence.evidence to just .evidence\n        // See https://github.com/tendermint/tendermint/issues/7697\n        evidence: (_b = (_a = data.evidence) === null || _a === void 0 ? void 0 : _a.evidence) !== null && _b !== void 0 ? _b : [],\n    };\n}\nfunction decodeBlockResponse(data) {\n    return {\n        blockId: decodeBlockId(data.block_id),\n        block: decodeBlock(data.block),\n    };\n}\nfunction decodeBlockSearch(data) {\n    return {\n        totalCount: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total_count)),\n        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse),\n    };\n}\nfunction decodeNumUnconfirmedTxs(data) {\n    return {\n        total: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total)),\n        totalBytes: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total_bytes)),\n    };\n}\nclass Responses {\n    static decodeAbciInfo(response) {\n        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));\n    }\n    static decodeAbciQuery(response) {\n        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));\n    }\n    static decodeBlock(response) {\n        return decodeBlockResponse(response.result);\n    }\n    static decodeBlockResults(response) {\n        return decodeBlockResults(response.result);\n    }\n    static decodeBlockSearch(response) {\n        return decodeBlockSearch(response.result);\n    }\n    static decodeBlockchain(response) {\n        return decodeBlockchain(response.result);\n    }\n    static decodeBroadcastTxSync(response) {\n        return decodeBroadcastTxSync(response.result);\n    }\n    static decodeBroadcastTxAsync(response) {\n        return Responses.decodeBroadcastTxSync(response);\n    }\n    static decodeBroadcastTxCommit(response) {\n        return decodeBroadcastTxCommit(response.result);\n    }\n    static decodeCommit(response) {\n        return decodeCommitResponse(response.result);\n    }\n    static decodeGenesis(response) {\n        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));\n    }\n    static decodeHealth() {\n        return null;\n    }\n    static decodeNumUnconfirmedTxs(response) {\n        return decodeNumUnconfirmedTxs(response.result);\n    }\n    static decodeStatus(response) {\n        return decodeStatus(response.result);\n    }\n    static decodeNewBlockEvent(event) {\n        return decodeBlock(event.data.value.block);\n    }\n    static decodeNewBlockHeaderEvent(event) {\n        return decodeHeader(event.data.value.header);\n    }\n    static decodeTxEvent(event) {\n        return decodeTxEvent(event.data.value.TxResult);\n    }\n    static decodeTx(response) {\n        return decodeTxResponse(response.result);\n    }\n    static decodeTxSearch(response) {\n        return decodeTxSearch(response.result);\n    }\n    static decodeValidators(response) {\n        return decodeValidators(response.result);\n    }\n}\nexports.Responses = Responses;\n//# sourceMappingURL=responses.js.map"]},"metadata":{},"sourceType":"script"}