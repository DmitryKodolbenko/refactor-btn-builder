{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Fee = exports.ModeInfo_Multi = exports.ModeInfo_Single = exports.ModeInfo = exports.SignerInfo = exports.AuthInfo = exports.TxBody = exports.SignDoc = exports.TxRaw = exports.Tx = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst any_1 = require(\"../../../google/protobuf/any\");\nconst signing_1 = require(\"../../../cosmos/tx/signing/v1beta1/signing\");\nconst multisig_1 = require(\"../../../cosmos/crypto/multisig/v1beta1/multisig\");\nconst coin_1 = require(\"../../../cosmos/base/v1beta1/coin\");\nexports.protobufPackage = \"cosmos.tx.v1beta1\";\nconst baseTx = {};\nexports.Tx = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.body !== undefined) {\n      exports.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.authInfo !== undefined) {\n      exports.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.signatures) {\n      writer.uint32(26).bytes(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseTx);\n    message.signatures = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.body = exports.TxBody.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.authInfo = exports.AuthInfo.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    var _a;\n    const message = Object.assign({}, baseTx);\n    message.body = object.body !== undefined && object.body !== null ? exports.TxBody.fromJSON(object.body) : undefined;\n    message.authInfo = object.authInfo !== undefined && object.authInfo !== null ? exports.AuthInfo.fromJSON(object.authInfo) : undefined;\n    message.signatures = ((_a = object.signatures) !== null && _a !== void 0 ? _a : []).map(e => bytesFromBase64(e));\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.body !== undefined && (obj.body = message.body ? exports.TxBody.toJSON(message.body) : undefined);\n    message.authInfo !== undefined && (obj.authInfo = message.authInfo ? exports.AuthInfo.toJSON(message.authInfo) : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map(e => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _a;\n    const message = Object.assign({}, baseTx);\n    message.body = object.body !== undefined && object.body !== null ? exports.TxBody.fromPartial(object.body) : undefined;\n    message.authInfo = object.authInfo !== undefined && object.authInfo !== null ? exports.AuthInfo.fromPartial(object.authInfo) : undefined;\n    message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map(e => e)) || [];\n    return message;\n  }\n};\nconst baseTxRaw = {};\nexports.TxRaw = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.bodyBytes.length !== 0) {\n      writer.uint32(10).bytes(message.bodyBytes);\n    }\n    if (message.authInfoBytes.length !== 0) {\n      writer.uint32(18).bytes(message.authInfoBytes);\n    }\n    for (const v of message.signatures) {\n      writer.uint32(26).bytes(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseTxRaw);\n    message.signatures = [];\n    message.bodyBytes = new Uint8Array();\n    message.authInfoBytes = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bodyBytes = reader.bytes();\n          break;\n        case 2:\n          message.authInfoBytes = reader.bytes();\n          break;\n        case 3:\n          message.signatures.push(reader.bytes());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    var _a;\n    const message = Object.assign({}, baseTxRaw);\n    message.bodyBytes = object.bodyBytes !== undefined && object.bodyBytes !== null ? bytesFromBase64(object.bodyBytes) : new Uint8Array();\n    message.authInfoBytes = object.authInfoBytes !== undefined && object.authInfoBytes !== null ? bytesFromBase64(object.authInfoBytes) : new Uint8Array();\n    message.signatures = ((_a = object.signatures) !== null && _a !== void 0 ? _a : []).map(e => bytesFromBase64(e));\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.bodyBytes !== undefined && (obj.bodyBytes = base64FromBytes(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));\n    message.authInfoBytes !== undefined && (obj.authInfoBytes = base64FromBytes(message.authInfoBytes !== undefined ? message.authInfoBytes : new Uint8Array()));\n    if (message.signatures) {\n      obj.signatures = message.signatures.map(e => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = Object.assign({}, baseTxRaw);\n    message.bodyBytes = (_a = object.bodyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n    message.authInfoBytes = (_b = object.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();\n    message.signatures = ((_c = object.signatures) === null || _c === void 0 ? void 0 : _c.map(e => e)) || [];\n    return message;\n  }\n};\nconst baseSignDoc = {\n  chainId: \"\",\n  accountNumber: long_1.default.UZERO\n};\nexports.SignDoc = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.bodyBytes.length !== 0) {\n      writer.uint32(10).bytes(message.bodyBytes);\n    }\n    if (message.authInfoBytes.length !== 0) {\n      writer.uint32(18).bytes(message.authInfoBytes);\n    }\n    if (message.chainId !== \"\") {\n      writer.uint32(26).string(message.chainId);\n    }\n    if (!message.accountNumber.isZero()) {\n      writer.uint32(32).uint64(message.accountNumber);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSignDoc);\n    message.bodyBytes = new Uint8Array();\n    message.authInfoBytes = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bodyBytes = reader.bytes();\n          break;\n        case 2:\n          message.authInfoBytes = reader.bytes();\n          break;\n        case 3:\n          message.chainId = reader.string();\n          break;\n        case 4:\n          message.accountNumber = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseSignDoc);\n    message.bodyBytes = object.bodyBytes !== undefined && object.bodyBytes !== null ? bytesFromBase64(object.bodyBytes) : new Uint8Array();\n    message.authInfoBytes = object.authInfoBytes !== undefined && object.authInfoBytes !== null ? bytesFromBase64(object.authInfoBytes) : new Uint8Array();\n    message.chainId = object.chainId !== undefined && object.chainId !== null ? String(object.chainId) : \"\";\n    message.accountNumber = object.accountNumber !== undefined && object.accountNumber !== null ? long_1.default.fromString(object.accountNumber) : long_1.default.UZERO;\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.bodyBytes !== undefined && (obj.bodyBytes = base64FromBytes(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));\n    message.authInfoBytes !== undefined && (obj.authInfoBytes = base64FromBytes(message.authInfoBytes !== undefined ? message.authInfoBytes : new Uint8Array()));\n    message.chainId !== undefined && (obj.chainId = message.chainId);\n    message.accountNumber !== undefined && (obj.accountNumber = (message.accountNumber || long_1.default.UZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = Object.assign({}, baseSignDoc);\n    message.bodyBytes = (_a = object.bodyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n    message.authInfoBytes = (_b = object.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();\n    message.chainId = (_c = object.chainId) !== null && _c !== void 0 ? _c : \"\";\n    message.accountNumber = object.accountNumber !== undefined && object.accountNumber !== null ? long_1.default.fromValue(object.accountNumber) : long_1.default.UZERO;\n    return message;\n  }\n};\nconst baseTxBody = {\n  memo: \"\",\n  timeoutHeight: long_1.default.UZERO\n};\nexports.TxBody = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    for (const v of message.messages) {\n      any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.memo !== \"\") {\n      writer.uint32(18).string(message.memo);\n    }\n    if (!message.timeoutHeight.isZero()) {\n      writer.uint32(24).uint64(message.timeoutHeight);\n    }\n    for (const v of message.extensionOptions) {\n      any_1.Any.encode(v, writer.uint32(8186).fork()).ldelim();\n    }\n    for (const v of message.nonCriticalExtensionOptions) {\n      any_1.Any.encode(v, writer.uint32(16378).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseTxBody);\n    message.messages = [];\n    message.extensionOptions = [];\n    message.nonCriticalExtensionOptions = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.messages.push(any_1.Any.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.memo = reader.string();\n          break;\n        case 3:\n          message.timeoutHeight = reader.uint64();\n          break;\n        case 1023:\n          message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));\n          break;\n        case 2047:\n          message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    var _a, _b, _c;\n    const message = Object.assign({}, baseTxBody);\n    message.messages = ((_a = object.messages) !== null && _a !== void 0 ? _a : []).map(e => any_1.Any.fromJSON(e));\n    message.memo = object.memo !== undefined && object.memo !== null ? String(object.memo) : \"\";\n    message.timeoutHeight = object.timeoutHeight !== undefined && object.timeoutHeight !== null ? long_1.default.fromString(object.timeoutHeight) : long_1.default.UZERO;\n    message.extensionOptions = ((_b = object.extensionOptions) !== null && _b !== void 0 ? _b : []).map(e => any_1.Any.fromJSON(e));\n    message.nonCriticalExtensionOptions = ((_c = object.nonCriticalExtensionOptions) !== null && _c !== void 0 ? _c : []).map(e => any_1.Any.fromJSON(e));\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.messages) {\n      obj.messages = message.messages.map(e => e ? any_1.Any.toJSON(e) : undefined);\n    } else {\n      obj.messages = [];\n    }\n    message.memo !== undefined && (obj.memo = message.memo);\n    message.timeoutHeight !== undefined && (obj.timeoutHeight = (message.timeoutHeight || long_1.default.UZERO).toString());\n    if (message.extensionOptions) {\n      obj.extensionOptions = message.extensionOptions.map(e => e ? any_1.Any.toJSON(e) : undefined);\n    } else {\n      obj.extensionOptions = [];\n    }\n    if (message.nonCriticalExtensionOptions) {\n      obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map(e => e ? any_1.Any.toJSON(e) : undefined);\n    } else {\n      obj.nonCriticalExtensionOptions = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = Object.assign({}, baseTxBody);\n    message.messages = ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map(e => any_1.Any.fromPartial(e))) || [];\n    message.memo = (_b = object.memo) !== null && _b !== void 0 ? _b : \"\";\n    message.timeoutHeight = object.timeoutHeight !== undefined && object.timeoutHeight !== null ? long_1.default.fromValue(object.timeoutHeight) : long_1.default.UZERO;\n    message.extensionOptions = ((_c = object.extensionOptions) === null || _c === void 0 ? void 0 : _c.map(e => any_1.Any.fromPartial(e))) || [];\n    message.nonCriticalExtensionOptions = ((_d = object.nonCriticalExtensionOptions) === null || _d === void 0 ? void 0 : _d.map(e => any_1.Any.fromPartial(e))) || [];\n    return message;\n  }\n};\nconst baseAuthInfo = {};\nexports.AuthInfo = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    for (const v of message.signerInfos) {\n      exports.SignerInfo.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.fee !== undefined) {\n      exports.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseAuthInfo);\n    message.signerInfos = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signerInfos.push(exports.SignerInfo.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.fee = exports.Fee.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    var _a;\n    const message = Object.assign({}, baseAuthInfo);\n    message.signerInfos = ((_a = object.signerInfos) !== null && _a !== void 0 ? _a : []).map(e => exports.SignerInfo.fromJSON(e));\n    message.fee = object.fee !== undefined && object.fee !== null ? exports.Fee.fromJSON(object.fee) : undefined;\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.signerInfos) {\n      obj.signerInfos = message.signerInfos.map(e => e ? exports.SignerInfo.toJSON(e) : undefined);\n    } else {\n      obj.signerInfos = [];\n    }\n    message.fee !== undefined && (obj.fee = message.fee ? exports.Fee.toJSON(message.fee) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    var _a;\n    const message = Object.assign({}, baseAuthInfo);\n    message.signerInfos = ((_a = object.signerInfos) === null || _a === void 0 ? void 0 : _a.map(e => exports.SignerInfo.fromPartial(e))) || [];\n    message.fee = object.fee !== undefined && object.fee !== null ? exports.Fee.fromPartial(object.fee) : undefined;\n    return message;\n  }\n};\nconst baseSignerInfo = {\n  sequence: long_1.default.UZERO\n};\nexports.SignerInfo = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.publicKey !== undefined) {\n      any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.modeInfo !== undefined) {\n      exports.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSignerInfo);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.publicKey = any_1.Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.modeInfo = exports.ModeInfo.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.sequence = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseSignerInfo);\n    message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? any_1.Any.fromJSON(object.publicKey) : undefined;\n    message.modeInfo = object.modeInfo !== undefined && object.modeInfo !== null ? exports.ModeInfo.fromJSON(object.modeInfo) : undefined;\n    message.sequence = object.sequence !== undefined && object.sequence !== null ? long_1.default.fromString(object.sequence) : long_1.default.UZERO;\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.publicKey !== undefined && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);\n    message.modeInfo !== undefined && (obj.modeInfo = message.modeInfo ? exports.ModeInfo.toJSON(message.modeInfo) : undefined);\n    message.sequence !== undefined && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseSignerInfo);\n    message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? any_1.Any.fromPartial(object.publicKey) : undefined;\n    message.modeInfo = object.modeInfo !== undefined && object.modeInfo !== null ? exports.ModeInfo.fromPartial(object.modeInfo) : undefined;\n    message.sequence = object.sequence !== undefined && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;\n    return message;\n  }\n};\nconst baseModeInfo = {};\nexports.ModeInfo = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.single !== undefined) {\n      exports.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.multi !== undefined) {\n      exports.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseModeInfo);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.single = exports.ModeInfo_Single.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.multi = exports.ModeInfo_Multi.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseModeInfo);\n    message.single = object.single !== undefined && object.single !== null ? exports.ModeInfo_Single.fromJSON(object.single) : undefined;\n    message.multi = object.multi !== undefined && object.multi !== null ? exports.ModeInfo_Multi.fromJSON(object.multi) : undefined;\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.single !== undefined && (obj.single = message.single ? exports.ModeInfo_Single.toJSON(message.single) : undefined);\n    message.multi !== undefined && (obj.multi = message.multi ? exports.ModeInfo_Multi.toJSON(message.multi) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseModeInfo);\n    message.single = object.single !== undefined && object.single !== null ? exports.ModeInfo_Single.fromPartial(object.single) : undefined;\n    message.multi = object.multi !== undefined && object.multi !== null ? exports.ModeInfo_Multi.fromPartial(object.multi) : undefined;\n    return message;\n  }\n};\nconst baseModeInfo_Single = {\n  mode: 0\n};\nexports.ModeInfo_Single = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseModeInfo_Single);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.mode = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseModeInfo_Single);\n    message.mode = object.mode !== undefined && object.mode !== null ? signing_1.signModeFromJSON(object.mode) : 0;\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.mode !== undefined && (obj.mode = signing_1.signModeToJSON(message.mode));\n    return obj;\n  },\n  fromPartial(object) {\n    var _a;\n    const message = Object.assign({}, baseModeInfo_Single);\n    message.mode = (_a = object.mode) !== null && _a !== void 0 ? _a : 0;\n    return message;\n  }\n};\nconst baseModeInfo_Multi = {};\nexports.ModeInfo_Multi = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.bitarray !== undefined) {\n      multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.modeInfos) {\n      exports.ModeInfo.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseModeInfo_Multi);\n    message.modeInfos = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.modeInfos.push(exports.ModeInfo.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    var _a;\n    const message = Object.assign({}, baseModeInfo_Multi);\n    message.bitarray = object.bitarray !== undefined && object.bitarray !== null ? multisig_1.CompactBitArray.fromJSON(object.bitarray) : undefined;\n    message.modeInfos = ((_a = object.modeInfos) !== null && _a !== void 0 ? _a : []).map(e => exports.ModeInfo.fromJSON(e));\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.bitarray !== undefined && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : undefined);\n    if (message.modeInfos) {\n      obj.modeInfos = message.modeInfos.map(e => e ? exports.ModeInfo.toJSON(e) : undefined);\n    } else {\n      obj.modeInfos = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _a;\n    const message = Object.assign({}, baseModeInfo_Multi);\n    message.bitarray = object.bitarray !== undefined && object.bitarray !== null ? multisig_1.CompactBitArray.fromPartial(object.bitarray) : undefined;\n    message.modeInfos = ((_a = object.modeInfos) === null || _a === void 0 ? void 0 : _a.map(e => exports.ModeInfo.fromPartial(e))) || [];\n    return message;\n  }\n};\nconst baseFee = {\n  gasLimit: long_1.default.UZERO,\n  payer: \"\",\n  granter: \"\"\n};\nexports.Fee = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    for (const v of message.amount) {\n      coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.gasLimit.isZero()) {\n      writer.uint32(16).uint64(message.gasLimit);\n    }\n    if (message.payer !== \"\") {\n      writer.uint32(26).string(message.payer);\n    }\n    if (message.granter !== \"\") {\n      writer.uint32(34).string(message.granter);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseFee);\n    message.amount = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.gasLimit = reader.uint64();\n          break;\n        case 3:\n          message.payer = reader.string();\n          break;\n        case 4:\n          message.granter = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    var _a;\n    const message = Object.assign({}, baseFee);\n    message.amount = ((_a = object.amount) !== null && _a !== void 0 ? _a : []).map(e => coin_1.Coin.fromJSON(e));\n    message.gasLimit = object.gasLimit !== undefined && object.gasLimit !== null ? long_1.default.fromString(object.gasLimit) : long_1.default.UZERO;\n    message.payer = object.payer !== undefined && object.payer !== null ? String(object.payer) : \"\";\n    message.granter = object.granter !== undefined && object.granter !== null ? String(object.granter) : \"\";\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.amount) {\n      obj.amount = message.amount.map(e => e ? coin_1.Coin.toJSON(e) : undefined);\n    } else {\n      obj.amount = [];\n    }\n    message.gasLimit !== undefined && (obj.gasLimit = (message.gasLimit || long_1.default.UZERO).toString());\n    message.payer !== undefined && (obj.payer = message.payer);\n    message.granter !== undefined && (obj.granter = message.granter);\n    return obj;\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = Object.assign({}, baseFee);\n    message.amount = ((_a = object.amount) === null || _a === void 0 ? void 0 : _a.map(e => coin_1.Coin.fromPartial(e))) || [];\n    message.gasLimit = object.gasLimit !== undefined && object.gasLimit !== null ? long_1.default.fromValue(object.gasLimit) : long_1.default.UZERO;\n    message.payer = (_b = object.payer) !== null && _b !== void 0 ? _b : \"\";\n    message.granter = (_c = object.granter) !== null && _c !== void 0 ? _c : \"\";\n    return message;\n  }\n};\nvar globalThis = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || (b64 => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\nconst btoa = globalThis.btoa || (bin => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n  const bin = [];\n  for (const byte of arr) {\n    bin.push(String.fromCharCode(byte));\n  }\n  return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}","map":{"version":3,"sources":["../../../../src/cosmos/tx/v1beta1/tx.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA;AACA,MAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,oBAAA,CAAA,CAAA;AACA,MAAA,KAAA,GAAA,OAAA,CAAA,8BAAA,CAAA;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,4CAAA,CAAA;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,kDAAA,CAAA;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;AAEa,OAAA,CAAA,eAAe,GAAG,mBAAmB;AA6MlD,MAAM,MAAM,GAAW,CAAA,CAAE;AAEZ,OAAA,CAAA,EAAE,GAAG;EAChB,MAAM,CAAC,OAAW,EAA0C;IAAA,IAAxC,MAAA,uEAAqB,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,MAAM,EAAE;IAC1D,IAAI,OAAO,CAAC,IAAI,KAAK,SAAS,EAAE;MAC9B,OAAA,CAAA,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IAC/D;IACD,IAAI,OAAO,CAAC,QAAQ,KAAK,SAAS,EAAE;MAClC,OAAA,CAAA,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IACrE;IACD,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,UAAU,EAAE;MAClC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAE,CAAC;IAC5B;IACD,OAAO,MAAM;EACf,CAAC;EAED,MAAM,CAAC,KAA8B,EAAE,MAAe,EAAA;IACpD,MAAM,MAAM,GAAG,KAAK,YAAY,SAAA,CAAA,OAAG,CAAC,MAAM,GAAG,KAAK,GAAG,IAAI,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,KAAK,CAAC;IAC1E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM;IACjE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,MAAM,CAAQ;IACnC,OAAO,CAAC,UAAU,GAAG,EAAE;IACvB,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;MACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE;MAC3B,QAAQ,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJ,OAAO,CAAC,IAAI,GAAG,OAAA,CAAA,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC;UACrD;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,QAAQ,GAAG,OAAA,CAAA,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC;UAC3D;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;UACvC;QACF;UACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC;UACxB;MAAM;IAEX;IACD,OAAO,OAAO;EAChB,CAAC;EAED,QAAQ,CAAC,MAAW,EAAA;;IAClB,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,MAAM,CAAQ;IACnC,OAAO,CAAC,IAAI,GACV,MAAM,CAAC,IAAI,KAAK,SAAS,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,GAAG,OAAA,CAAA,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,SAAS;IAC9F,OAAO,CAAC,QAAQ,GACd,MAAM,CAAC,QAAQ,KAAK,SAAS,IAAI,MAAM,CAAC,QAAQ,KAAK,IAAI,GACrD,OAAA,CAAA,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,GAClC,SAAS;IACf,OAAO,CAAC,UAAU,GAAG,CAAC,CAAA,EAAA,GAAA,MAAM,CAAC,UAAU,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE,EAAE,GAAG,CAAE,CAAM,IAAK,eAAe,CAAC,CAAC,CAAC,CAAC;IAClF,OAAO,OAAO;EAChB,CAAC;EAED,MAAM,CAAC,OAAW,EAAA;IAChB,MAAM,GAAG,GAAQ,CAAA,CAAE;IACnB,OAAO,CAAC,IAAI,KAAK,SAAS,KAAK,GAAG,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,GAAG,OAAA,CAAA,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC;IACjG,OAAO,CAAC,QAAQ,KAAK,SAAS,KAC3B,GAAG,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,GAAG,OAAA,CAAA,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC;IACnF,IAAI,OAAO,CAAC,UAAU,EAAE;MACtB,GAAG,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,GAAG,CAAE,CAAC,IAAK,eAAe,CAAC,CAAC,KAAK,SAAS,GAAG,CAAC,GAAG,IAAI,UAAU,EAAE,CAAC,CAAC;KACxG,MAAM;MACL,GAAG,CAAC,UAAU,GAAG,EAAE;IACpB;IACD,OAAO,GAAG;EACZ,CAAC;EAED,WAAW,CAAsC,MAAS,EAAA;;IACxD,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,MAAM,CAAQ;IACnC,OAAO,CAAC,IAAI,GACV,MAAM,CAAC,IAAI,KAAK,SAAS,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,GAAG,OAAA,CAAA,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,SAAS;IACjG,OAAO,CAAC,QAAQ,GACd,MAAM,CAAC,QAAQ,KAAK,SAAS,IAAI,MAAM,CAAC,QAAQ,KAAK,IAAI,GACrD,OAAA,CAAA,QAAQ,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,GACrC,SAAS;IACf,OAAO,CAAC,UAAU,GAAG,CAAA,CAAA,EAAA,GAAA,MAAM,CAAC,UAAU,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,GAAG,CAAE,CAAC,IAAK,CAAC,CAAC,KAAI,EAAE;IAC3D,OAAO,OAAO;EAChB;CACD;AAED,MAAM,SAAS,GAAW,CAAA,CAAE;AAEf,OAAA,CAAA,KAAK,GAAG;EACnB,MAAM,CAAC,OAAc,EAA0C;IAAA,IAAxC,MAAA,uEAAqB,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,MAAM,EAAE;IAC7D,IAAI,OAAO,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;MAClC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC;IAC3C;IACD,IAAI,OAAO,CAAC,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE;MACtC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC;IAC/C;IACD,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,UAAU,EAAE;MAClC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAE,CAAC;IAC5B;IACD,OAAO,MAAM;EACf,CAAC;EAED,MAAM,CAAC,KAA8B,EAAE,MAAe,EAAA;IACpD,MAAM,MAAM,GAAG,KAAK,YAAY,SAAA,CAAA,OAAG,CAAC,MAAM,GAAG,KAAK,GAAG,IAAI,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,KAAK,CAAC;IAC1E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM;IACjE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,SAAS,CAAW;IACzC,OAAO,CAAC,UAAU,GAAG,EAAE;IACvB,OAAO,CAAC,SAAS,GAAG,IAAI,UAAU,EAAE;IACpC,OAAO,CAAC,aAAa,GAAG,IAAI,UAAU,EAAE;IACxC,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;MACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE;MAC3B,QAAQ,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJ,OAAO,CAAC,SAAS,GAAG,MAAM,CAAC,KAAK,EAAE;UAClC;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,aAAa,GAAG,MAAM,CAAC,KAAK,EAAE;UACtC;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;UACvC;QACF;UACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC;UACxB;MAAM;IAEX;IACD,OAAO,OAAO;EAChB,CAAC;EAED,QAAQ,CAAC,MAAW,EAAA;;IAClB,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,SAAS,CAAW;IACzC,OAAO,CAAC,SAAS,GACf,MAAM,CAAC,SAAS,KAAK,SAAS,IAAI,MAAM,CAAC,SAAS,KAAK,IAAI,GACvD,eAAe,CAAC,MAAM,CAAC,SAAS,CAAC,GACjC,IAAI,UAAU,EAAE;IACtB,OAAO,CAAC,aAAa,GACnB,MAAM,CAAC,aAAa,KAAK,SAAS,IAAI,MAAM,CAAC,aAAa,KAAK,IAAI,GAC/D,eAAe,CAAC,MAAM,CAAC,aAAa,CAAC,GACrC,IAAI,UAAU,EAAE;IACtB,OAAO,CAAC,UAAU,GAAG,CAAC,CAAA,EAAA,GAAA,MAAM,CAAC,UAAU,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE,EAAE,GAAG,CAAE,CAAM,IAAK,eAAe,CAAC,CAAC,CAAC,CAAC;IAClF,OAAO,OAAO;EAChB,CAAC;EAED,MAAM,CAAC,OAAc,EAAA;IACnB,MAAM,GAAG,GAAQ,CAAA,CAAE;IACnB,OAAO,CAAC,SAAS,KAAK,SAAS,KAC5B,GAAG,CAAC,SAAS,GAAG,eAAe,CAC9B,OAAO,CAAC,SAAS,KAAK,SAAS,GAAG,OAAO,CAAC,SAAS,GAAG,IAAI,UAAU,EAAE,CACvE,CAAC;IACJ,OAAO,CAAC,aAAa,KAAK,SAAS,KAChC,GAAG,CAAC,aAAa,GAAG,eAAe,CAClC,OAAO,CAAC,aAAa,KAAK,SAAS,GAAG,OAAO,CAAC,aAAa,GAAG,IAAI,UAAU,EAAE,CAC/E,CAAC;IACJ,IAAI,OAAO,CAAC,UAAU,EAAE;MACtB,GAAG,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,GAAG,CAAE,CAAC,IAAK,eAAe,CAAC,CAAC,KAAK,SAAS,GAAG,CAAC,GAAG,IAAI,UAAU,EAAE,CAAC,CAAC;KACxG,MAAM;MACL,GAAG,CAAC,UAAU,GAAG,EAAE;IACpB;IACD,OAAO,GAAG;EACZ,CAAC;EAED,WAAW,CAAyC,MAAS,EAAA;;IAC3D,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,SAAS,CAAW;IACzC,OAAO,CAAC,SAAS,GAAG,CAAA,EAAA,GAAA,MAAM,CAAC,SAAS,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAAI,UAAU,EAAE;IACxD,OAAO,CAAC,aAAa,GAAG,CAAA,EAAA,GAAA,MAAM,CAAC,aAAa,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAAI,UAAU,EAAE;IAChE,OAAO,CAAC,UAAU,GAAG,CAAA,CAAA,EAAA,GAAA,MAAM,CAAC,UAAU,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,GAAG,CAAE,CAAC,IAAK,CAAC,CAAC,KAAI,EAAE;IAC3D,OAAO,OAAO;EAChB;CACD;AAED,MAAM,WAAW,GAAW;EAAE,OAAO,EAAE,EAAE;EAAE,aAAa,EAAE,MAAA,CAAA,OAAI,CAAC;AAAK,CAAE;AAEzD,OAAA,CAAA,OAAO,GAAG;EACrB,MAAM,CAAC,OAAgB,EAA0C;IAAA,IAAxC,MAAA,uEAAqB,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,MAAM,EAAE;IAC/D,IAAI,OAAO,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;MAClC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC;IAC3C;IACD,IAAI,OAAO,CAAC,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE;MACtC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC;IAC/C;IACD,IAAI,OAAO,CAAC,OAAO,KAAK,EAAE,EAAE;MAC1B,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC;IAC1C;IACD,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,MAAM,EAAE,EAAE;MACnC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC;IAChD;IACD,OAAO,MAAM;EACf,CAAC;EAED,MAAM,CAAC,KAA8B,EAAE,MAAe,EAAA;IACpD,MAAM,MAAM,GAAG,KAAK,YAAY,SAAA,CAAA,OAAG,CAAC,MAAM,GAAG,KAAK,GAAG,IAAI,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,KAAK,CAAC;IAC1E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM;IACjE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,WAAW,CAAa;IAC7C,OAAO,CAAC,SAAS,GAAG,IAAI,UAAU,EAAE;IACpC,OAAO,CAAC,aAAa,GAAG,IAAI,UAAU,EAAE;IACxC,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;MACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE;MAC3B,QAAQ,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJ,OAAO,CAAC,SAAS,GAAG,MAAM,CAAC,KAAK,EAAE;UAClC;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,aAAa,GAAG,MAAM,CAAC,KAAK,EAAE;UACtC;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,EAAE;UACjC;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,aAAa,GAAG,MAAM,CAAC,MAAM,EAAU;UAC/C;QACF;UACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC;UACxB;MAAM;IAEX;IACD,OAAO,OAAO;EAChB,CAAC;EAED,QAAQ,CAAC,MAAW,EAAA;IAClB,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,WAAW,CAAa;IAC7C,OAAO,CAAC,SAAS,GACf,MAAM,CAAC,SAAS,KAAK,SAAS,IAAI,MAAM,CAAC,SAAS,KAAK,IAAI,GACvD,eAAe,CAAC,MAAM,CAAC,SAAS,CAAC,GACjC,IAAI,UAAU,EAAE;IACtB,OAAO,CAAC,aAAa,GACnB,MAAM,CAAC,aAAa,KAAK,SAAS,IAAI,MAAM,CAAC,aAAa,KAAK,IAAI,GAC/D,eAAe,CAAC,MAAM,CAAC,aAAa,CAAC,GACrC,IAAI,UAAU,EAAE;IACtB,OAAO,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,KAAK,SAAS,IAAI,MAAM,CAAC,OAAO,KAAK,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE;IACvG,OAAO,CAAC,aAAa,GACnB,MAAM,CAAC,aAAa,KAAK,SAAS,IAAI,MAAM,CAAC,aAAa,KAAK,IAAI,GAC/D,MAAA,CAAA,OAAI,CAAC,UAAU,CAAC,MAAM,CAAC,aAAa,CAAC,GACrC,MAAA,CAAA,OAAI,CAAC,KAAK;IAChB,OAAO,OAAO;EAChB,CAAC;EAED,MAAM,CAAC,OAAgB,EAAA;IACrB,MAAM,GAAG,GAAQ,CAAA,CAAE;IACnB,OAAO,CAAC,SAAS,KAAK,SAAS,KAC5B,GAAG,CAAC,SAAS,GAAG,eAAe,CAC9B,OAAO,CAAC,SAAS,KAAK,SAAS,GAAG,OAAO,CAAC,SAAS,GAAG,IAAI,UAAU,EAAE,CACvE,CAAC;IACJ,OAAO,CAAC,aAAa,KAAK,SAAS,KAChC,GAAG,CAAC,aAAa,GAAG,eAAe,CAClC,OAAO,CAAC,aAAa,KAAK,SAAS,GAAG,OAAO,CAAC,aAAa,GAAG,IAAI,UAAU,EAAE,CAC/E,CAAC;IACJ,OAAO,CAAC,OAAO,KAAK,SAAS,KAAK,GAAG,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAChE,OAAO,CAAC,aAAa,KAAK,SAAS,KAChC,GAAG,CAAC,aAAa,GAAG,CAAC,OAAO,CAAC,aAAa,IAAI,MAAA,CAAA,OAAI,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAC;IACxE,OAAO,GAAG;EACZ,CAAC;EAED,WAAW,CAA2C,MAAS,EAAA;;IAC7D,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,WAAW,CAAa;IAC7C,OAAO,CAAC,SAAS,GAAG,CAAA,EAAA,GAAA,MAAM,CAAC,SAAS,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAAI,UAAU,EAAE;IACxD,OAAO,CAAC,aAAa,GAAG,CAAA,EAAA,GAAA,MAAM,CAAC,aAAa,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAAI,UAAU,EAAE;IAChE,OAAO,CAAC,OAAO,GAAG,CAAA,EAAA,GAAA,MAAM,CAAC,OAAO,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE;IACtC,OAAO,CAAC,aAAa,GACnB,MAAM,CAAC,aAAa,KAAK,SAAS,IAAI,MAAM,CAAC,aAAa,KAAK,IAAI,GAC/D,MAAA,CAAA,OAAI,CAAC,SAAS,CAAC,MAAM,CAAC,aAAa,CAAC,GACpC,MAAA,CAAA,OAAI,CAAC,KAAK;IAChB,OAAO,OAAO;EAChB;CACD;AAED,MAAM,UAAU,GAAW;EAAE,IAAI,EAAE,EAAE;EAAE,aAAa,EAAE,MAAA,CAAA,OAAI,CAAC;AAAK,CAAE;AAErD,OAAA,CAAA,MAAM,GAAG;EACpB,MAAM,CAAC,OAAe,EAA0C;IAAA,IAAxC,MAAA,uEAAqB,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,MAAM,EAAE;IAC9D,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,QAAQ,EAAE;MAChC,KAAA,CAAA,GAAG,CAAC,MAAM,CAAC,CAAE,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IAClD;IACD,IAAI,OAAO,CAAC,IAAI,KAAK,EAAE,EAAE;MACvB,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC;IACvC;IACD,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,MAAM,EAAE,EAAE;MACnC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC;IAChD;IACD,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,gBAAgB,EAAE;MACxC,KAAA,CAAA,GAAG,CAAC,MAAM,CAAC,CAAE,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IACpD;IACD,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,2BAA2B,EAAE;MACnD,KAAA,CAAA,GAAG,CAAC,MAAM,CAAC,CAAE,EAAE,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IACrD;IACD,OAAO,MAAM;EACf,CAAC;EAED,MAAM,CAAC,KAA8B,EAAE,MAAe,EAAA;IACpD,MAAM,MAAM,GAAG,KAAK,YAAY,SAAA,CAAA,OAAG,CAAC,MAAM,GAAG,KAAK,GAAG,IAAI,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,KAAK,CAAC;IAC1E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM;IACjE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,UAAU,CAAY;IAC3C,OAAO,CAAC,QAAQ,GAAG,EAAE;IACrB,OAAO,CAAC,gBAAgB,GAAG,EAAE;IAC7B,OAAO,CAAC,2BAA2B,GAAG,EAAE;IACxC,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;MACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE;MAC3B,QAAQ,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJ,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAA,CAAA,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;UAC1D;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,IAAI,GAAG,MAAM,CAAC,MAAM,EAAE;UAC9B;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,aAAa,GAAG,MAAM,CAAC,MAAM,EAAU;UAC/C;QACF,KAAK,IAAI;UACP,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,KAAA,CAAA,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;UAClE;QACF,KAAK,IAAI;UACP,OAAO,CAAC,2BAA2B,CAAC,IAAI,CAAC,KAAA,CAAA,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;UAC7E;QACF;UACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC;UACxB;MAAM;IAEX;IACD,OAAO,OAAO;EAChB,CAAC;EAED,QAAQ,CAAC,MAAW,EAAA;;IAClB,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,UAAU,CAAY;IAC3C,OAAO,CAAC,QAAQ,GAAG,CAAC,CAAA,EAAA,GAAA,MAAM,CAAC,QAAQ,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE,EAAE,GAAG,CAAE,CAAM,IAAK,KAAA,CAAA,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IAC3E,OAAO,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,KAAK,SAAS,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE;IAC3F,OAAO,CAAC,aAAa,GACnB,MAAM,CAAC,aAAa,KAAK,SAAS,IAAI,MAAM,CAAC,aAAa,KAAK,IAAI,GAC/D,MAAA,CAAA,OAAI,CAAC,UAAU,CAAC,MAAM,CAAC,aAAa,CAAC,GACrC,MAAA,CAAA,OAAI,CAAC,KAAK;IAChB,OAAO,CAAC,gBAAgB,GAAG,CAAC,CAAA,EAAA,GAAA,MAAM,CAAC,gBAAgB,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE,EAAE,GAAG,CAAE,CAAM,IAAK,KAAA,CAAA,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IAC3F,OAAO,CAAC,2BAA2B,GAAG,CAAC,CAAA,EAAA,GAAA,MAAM,CAAC,2BAA2B,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE,EAAE,GAAG,CAAE,CAAM,IAC1F,KAAA,CAAA,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAChB;IACD,OAAO,OAAO;EAChB,CAAC;EAED,MAAM,CAAC,OAAe,EAAA;IACpB,MAAM,GAAG,GAAQ,CAAA,CAAE;IACnB,IAAI,OAAO,CAAC,QAAQ,EAAE;MACpB,GAAG,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAE,CAAC,IAAM,CAAC,GAAG,KAAA,CAAA,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,SAAU,CAAC;KAC5E,MAAM;MACL,GAAG,CAAC,QAAQ,GAAG,EAAE;IAClB;IACD,OAAO,CAAC,IAAI,KAAK,SAAS,KAAK,GAAG,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;IACvD,OAAO,CAAC,aAAa,KAAK,SAAS,KAChC,GAAG,CAAC,aAAa,GAAG,CAAC,OAAO,CAAC,aAAa,IAAI,MAAA,CAAA,OAAI,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAC;IACxE,IAAI,OAAO,CAAC,gBAAgB,EAAE;MAC5B,GAAG,CAAC,gBAAgB,GAAG,OAAO,CAAC,gBAAgB,CAAC,GAAG,CAAE,CAAC,IAAM,CAAC,GAAG,KAAA,CAAA,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,SAAU,CAAC;KAC5F,MAAM;MACL,GAAG,CAAC,gBAAgB,GAAG,EAAE;IAC1B;IACD,IAAI,OAAO,CAAC,2BAA2B,EAAE;MACvC,GAAG,CAAC,2BAA2B,GAAG,OAAO,CAAC,2BAA2B,CAAC,GAAG,CAAE,CAAC,IAC1E,CAAC,GAAG,KAAA,CAAA,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,SAAS,CAC9B;KACF,MAAM;MACL,GAAG,CAAC,2BAA2B,GAAG,EAAE;IACrC;IACD,OAAO,GAAG;EACZ,CAAC;EAED,WAAW,CAA0C,MAAS,EAAA;;IAC5D,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,UAAU,CAAY;IAC3C,OAAO,CAAC,QAAQ,GAAG,CAAA,CAAA,EAAA,GAAA,MAAM,CAAC,QAAQ,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,GAAG,CAAE,CAAC,IAAK,KAAA,CAAA,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,KAAI,EAAE;IACxE,OAAO,CAAC,IAAI,GAAG,CAAA,EAAA,GAAA,MAAM,CAAC,IAAI,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE;IAChC,OAAO,CAAC,aAAa,GACnB,MAAM,CAAC,aAAa,KAAK,SAAS,IAAI,MAAM,CAAC,aAAa,KAAK,IAAI,GAC/D,MAAA,CAAA,OAAI,CAAC,SAAS,CAAC,MAAM,CAAC,aAAa,CAAC,GACpC,MAAA,CAAA,OAAI,CAAC,KAAK;IAChB,OAAO,CAAC,gBAAgB,GAAG,CAAA,CAAA,EAAA,GAAA,MAAM,CAAC,gBAAgB,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,GAAG,CAAE,CAAC,IAAK,KAAA,CAAA,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,KAAI,EAAE;IACxF,OAAO,CAAC,2BAA2B,GACjC,CAAA,CAAA,EAAA,GAAA,MAAM,CAAC,2BAA2B,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,GAAG,CAAE,CAAC,IAAK,KAAA,CAAA,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,KAAI,EAAE;IAC1E,OAAO,OAAO;EAChB;CACD;AAED,MAAM,YAAY,GAAW,CAAA,CAAE;AAElB,OAAA,CAAA,QAAQ,GAAG;EACtB,MAAM,CAAC,OAAiB,EAA0C;IAAA,IAAxC,MAAA,uEAAqB,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,MAAM,EAAE;IAChE,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,WAAW,EAAE;MACnC,OAAA,CAAA,UAAU,CAAC,MAAM,CAAC,CAAE,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IACzD;IACD,IAAI,OAAO,CAAC,GAAG,KAAK,SAAS,EAAE;MAC7B,OAAA,CAAA,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IAC3D;IACD,OAAO,MAAM;EACf,CAAC;EAED,MAAM,CAAC,KAA8B,EAAE,MAAe,EAAA;IACpD,MAAM,MAAM,GAAG,KAAK,YAAY,SAAA,CAAA,OAAG,CAAC,MAAM,GAAG,KAAK,GAAG,IAAI,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,KAAK,CAAC;IAC1E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM;IACjE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,YAAY,CAAc;IAC/C,OAAO,CAAC,WAAW,GAAG,EAAE;IACxB,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;MACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE;MAC3B,QAAQ,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJ,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,OAAA,CAAA,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;UACpE;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,GAAG,GAAG,OAAA,CAAA,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC;UACjD;QACF;UACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC;UACxB;MAAM;IAEX;IACD,OAAO,OAAO;EAChB,CAAC;EAED,QAAQ,CAAC,MAAW,EAAA;;IAClB,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,YAAY,CAAc;IAC/C,OAAO,CAAC,WAAW,GAAG,CAAC,CAAA,EAAA,GAAA,MAAM,CAAC,WAAW,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE,EAAE,GAAG,CAAE,CAAM,IAAK,OAAA,CAAA,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IACxF,OAAO,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,KAAK,SAAS,IAAI,MAAM,CAAC,GAAG,KAAK,IAAI,GAAG,OAAA,CAAA,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,SAAS;IACpG,OAAO,OAAO;EAChB,CAAC;EAED,MAAM,CAAC,OAAiB,EAAA;IACtB,MAAM,GAAG,GAAQ,CAAA,CAAE;IACnB,IAAI,OAAO,CAAC,WAAW,EAAE;MACvB,GAAG,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC,GAAG,CAAE,CAAC,IAAM,CAAC,GAAG,OAAA,CAAA,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,SAAU,CAAC;KACzF,MAAM;MACL,GAAG,CAAC,WAAW,GAAG,EAAE;IACrB;IACD,OAAO,CAAC,GAAG,KAAK,SAAS,KAAK,GAAG,CAAC,GAAG,GAAG,OAAO,CAAC,GAAG,GAAG,OAAA,CAAA,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC;IAC1F,OAAO,GAAG;EACZ,CAAC;EAED,WAAW,CAA4C,MAAS,EAAA;;IAC9D,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,YAAY,CAAc;IAC/C,OAAO,CAAC,WAAW,GAAG,CAAA,CAAA,EAAA,GAAA,MAAM,CAAC,WAAW,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,GAAG,CAAE,CAAC,IAAK,OAAA,CAAA,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,KAAI,EAAE;IACrF,OAAO,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,KAAK,SAAS,IAAI,MAAM,CAAC,GAAG,KAAK,IAAI,GAAG,OAAA,CAAA,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,SAAS;IACvG,OAAO,OAAO;EAChB;CACD;AAED,MAAM,cAAc,GAAW;EAAE,QAAQ,EAAE,MAAA,CAAA,OAAI,CAAC;AAAK,CAAE;AAE1C,OAAA,CAAA,UAAU,GAAG;EACxB,MAAM,CAAC,OAAmB,EAA0C;IAAA,IAAxC,MAAA,uEAAqB,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,MAAM,EAAE;IAClE,IAAI,OAAO,CAAC,SAAS,KAAK,SAAS,EAAE;MACnC,KAAA,CAAA,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IACjE;IACD,IAAI,OAAO,CAAC,QAAQ,KAAK,SAAS,EAAE;MAClC,OAAA,CAAA,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IACrE;IACD,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE;MAC9B,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;IAC3C;IACD,OAAO,MAAM;EACf,CAAC;EAED,MAAM,CAAC,KAA8B,EAAE,MAAe,EAAA;IACpD,MAAM,MAAM,GAAG,KAAK,YAAY,SAAA,CAAA,OAAG,CAAC,MAAM,GAAG,KAAK,GAAG,IAAI,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,KAAK,CAAC;IAC1E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM;IACjE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,cAAc,CAAgB;IACnD,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;MACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE;MAC3B,QAAQ,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJ,OAAO,CAAC,SAAS,GAAG,KAAA,CAAA,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC;UACvD;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,QAAQ,GAAG,OAAA,CAAA,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC;UAC3D;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,QAAQ,GAAG,MAAM,CAAC,MAAM,EAAU;UAC1C;QACF;UACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC;UACxB;MAAM;IAEX;IACD,OAAO,OAAO;EAChB,CAAC;EAED,QAAQ,CAAC,MAAW,EAAA;IAClB,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,cAAc,CAAgB;IACnD,OAAO,CAAC,SAAS,GACf,MAAM,CAAC,SAAS,KAAK,SAAS,IAAI,MAAM,CAAC,SAAS,KAAK,IAAI,GACvD,KAAA,CAAA,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,GAC9B,SAAS;IACf,OAAO,CAAC,QAAQ,GACd,MAAM,CAAC,QAAQ,KAAK,SAAS,IAAI,MAAM,CAAC,QAAQ,KAAK,IAAI,GACrD,OAAA,CAAA,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,GAClC,SAAS;IACf,OAAO,CAAC,QAAQ,GACd,MAAM,CAAC,QAAQ,KAAK,SAAS,IAAI,MAAM,CAAC,QAAQ,KAAK,IAAI,GACrD,MAAA,CAAA,OAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,GAChC,MAAA,CAAA,OAAI,CAAC,KAAK;IAChB,OAAO,OAAO;EAChB,CAAC;EAED,MAAM,CAAC,OAAmB,EAAA;IACxB,MAAM,GAAG,GAAQ,CAAA,CAAE;IACnB,OAAO,CAAC,SAAS,KAAK,SAAS,KAC5B,GAAG,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,GAAG,KAAA,CAAA,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC;IACjF,OAAO,CAAC,QAAQ,KAAK,SAAS,KAC3B,GAAG,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,GAAG,OAAA,CAAA,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC;IACnF,OAAO,CAAC,QAAQ,KAAK,SAAS,KAAK,GAAG,CAAC,QAAQ,GAAG,CAAC,OAAO,CAAC,QAAQ,IAAI,MAAA,CAAA,OAAI,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAC;IAC9F,OAAO,GAAG;EACZ,CAAC;EAED,WAAW,CAA8C,MAAS,EAAA;IAChE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,cAAc,CAAgB;IACnD,OAAO,CAAC,SAAS,GACf,MAAM,CAAC,SAAS,KAAK,SAAS,IAAI,MAAM,CAAC,SAAS,KAAK,IAAI,GACvD,KAAA,CAAA,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,GACjC,SAAS;IACf,OAAO,CAAC,QAAQ,GACd,MAAM,CAAC,QAAQ,KAAK,SAAS,IAAI,MAAM,CAAC,QAAQ,KAAK,IAAI,GACrD,OAAA,CAAA,QAAQ,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,GACrC,SAAS;IACf,OAAO,CAAC,QAAQ,GACd,MAAM,CAAC,QAAQ,KAAK,SAAS,IAAI,MAAM,CAAC,QAAQ,KAAK,IAAI,GACrD,MAAA,CAAA,OAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,GAC/B,MAAA,CAAA,OAAI,CAAC,KAAK;IAChB,OAAO,OAAO;EAChB;CACD;AAED,MAAM,YAAY,GAAW,CAAA,CAAE;AAElB,OAAA,CAAA,QAAQ,GAAG;EACtB,MAAM,CAAC,OAAiB,EAA0C;IAAA,IAAxC,MAAA,uEAAqB,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,MAAM,EAAE;IAChE,IAAI,OAAO,CAAC,MAAM,KAAK,SAAS,EAAE;MAChC,OAAA,CAAA,eAAe,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IAC1E;IACD,IAAI,OAAO,CAAC,KAAK,KAAK,SAAS,EAAE;MAC/B,OAAA,CAAA,cAAc,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IACxE;IACD,OAAO,MAAM;EACf,CAAC;EAED,MAAM,CAAC,KAA8B,EAAE,MAAe,EAAA;IACpD,MAAM,MAAM,GAAG,KAAK,YAAY,SAAA,CAAA,OAAG,CAAC,MAAM,GAAG,KAAK,GAAG,IAAI,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,KAAK,CAAC;IAC1E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM;IACjE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,YAAY,CAAc;IAC/C,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;MACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE;MAC3B,QAAQ,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJ,OAAO,CAAC,MAAM,GAAG,OAAA,CAAA,eAAe,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC;UAChE;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,KAAK,GAAG,OAAA,CAAA,cAAc,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC;UAC9D;QACF;UACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC;UACxB;MAAM;IAEX;IACD,OAAO,OAAO;EAChB,CAAC;EAED,QAAQ,CAAC,MAAW,EAAA;IAClB,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,YAAY,CAAc;IAC/C,OAAO,CAAC,MAAM,GACZ,MAAM,CAAC,MAAM,KAAK,SAAS,IAAI,MAAM,CAAC,MAAM,KAAK,IAAI,GACjD,OAAA,CAAA,eAAe,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,GACvC,SAAS;IACf,OAAO,CAAC,KAAK,GACX,MAAM,CAAC,KAAK,KAAK,SAAS,IAAI,MAAM,CAAC,KAAK,KAAK,IAAI,GAAG,OAAA,CAAA,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,SAAS;IACzG,OAAO,OAAO;EAChB,CAAC;EAED,MAAM,CAAC,OAAiB,EAAA;IACtB,MAAM,GAAG,GAAQ,CAAA,CAAE;IACnB,OAAO,CAAC,MAAM,KAAK,SAAS,KACzB,GAAG,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,GAAG,OAAA,CAAA,eAAe,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,SAAS,CAAC;IACpF,OAAO,CAAC,KAAK,KAAK,SAAS,KACxB,GAAG,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,GAAG,OAAA,CAAA,cAAc,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC;IAChF,OAAO,GAAG;EACZ,CAAC;EAED,WAAW,CAA4C,MAAS,EAAA;IAC9D,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,YAAY,CAAc;IAC/C,OAAO,CAAC,MAAM,GACZ,MAAM,CAAC,MAAM,KAAK,SAAS,IAAI,MAAM,CAAC,MAAM,KAAK,IAAI,GACjD,OAAA,CAAA,eAAe,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,GAC1C,SAAS;IACf,OAAO,CAAC,KAAK,GACX,MAAM,CAAC,KAAK,KAAK,SAAS,IAAI,MAAM,CAAC,KAAK,KAAK,IAAI,GAC/C,OAAA,CAAA,cAAc,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,GACxC,SAAS;IACf,OAAO,OAAO;EAChB;CACD;AAED,MAAM,mBAAmB,GAAW;EAAE,IAAI,EAAE;AAAC,CAAE;AAElC,OAAA,CAAA,eAAe,GAAG;EAC7B,MAAM,CAAC,OAAwB,EAA0C;IAAA,IAAxC,MAAA,uEAAqB,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,MAAM,EAAE;IACvE,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE;MACtB,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;IACrC;IACD,OAAO,MAAM;EACf,CAAC;EAED,MAAM,CAAC,KAA8B,EAAE,MAAe,EAAA;IACpD,MAAM,MAAM,GAAG,KAAK,YAAY,SAAA,CAAA,OAAG,CAAC,MAAM,GAAG,KAAK,GAAG,IAAI,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,KAAK,CAAC;IAC1E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM;IACjE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,mBAAmB,CAAqB;IAC7D,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;MACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE;MAC3B,QAAQ,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJ,OAAO,CAAC,IAAI,GAAG,MAAM,CAAC,KAAK,EAAS;UACpC;QACF;UACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC;UACxB;MAAM;IAEX;IACD,OAAO,OAAO;EAChB,CAAC;EAED,QAAQ,CAAC,MAAW,EAAA;IAClB,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,mBAAmB,CAAqB;IAC7D,OAAO,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,KAAK,SAAS,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,GAAG,SAAA,CAAA,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC;IACpG,OAAO,OAAO;EAChB,CAAC;EAED,MAAM,CAAC,OAAwB,EAAA;IAC7B,MAAM,GAAG,GAAQ,CAAA,CAAE;IACnB,OAAO,CAAC,IAAI,KAAK,SAAS,KAAK,GAAG,CAAC,IAAI,GAAG,SAAA,CAAA,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IACvE,OAAO,GAAG;EACZ,CAAC;EAED,WAAW,CAAmD,MAAS,EAAA;;IACrE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,mBAAmB,CAAqB;IAC7D,OAAO,CAAC,IAAI,GAAG,CAAA,EAAA,GAAA,MAAM,CAAC,IAAI,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,CAAC;IAC/B,OAAO,OAAO;EAChB;CACD;AAED,MAAM,kBAAkB,GAAW,CAAA,CAAE;AAExB,OAAA,CAAA,cAAc,GAAG;EAC5B,MAAM,CAAC,OAAuB,EAA0C;IAAA,IAAxC,MAAA,uEAAqB,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,MAAM,EAAE;IACtE,IAAI,OAAO,CAAC,QAAQ,KAAK,SAAS,EAAE;MAClC,UAAA,CAAA,eAAe,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IAC5E;IACD,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,SAAS,EAAE;MACjC,OAAA,CAAA,QAAQ,CAAC,MAAM,CAAC,CAAE,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IACvD;IACD,OAAO,MAAM;EACf,CAAC;EAED,MAAM,CAAC,KAA8B,EAAE,MAAe,EAAA;IACpD,MAAM,MAAM,GAAG,KAAK,YAAY,SAAA,CAAA,OAAG,CAAC,MAAM,GAAG,KAAK,GAAG,IAAI,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,KAAK,CAAC;IAC1E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM;IACjE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,kBAAkB,CAAoB;IAC3D,OAAO,CAAC,SAAS,GAAG,EAAE;IACtB,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;MACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE;MAC3B,QAAQ,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJ,OAAO,CAAC,QAAQ,GAAG,UAAA,CAAA,eAAe,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC;UAClE;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,OAAA,CAAA,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;UAChE;QACF;UACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC;UACxB;MAAM;IAEX;IACD,OAAO,OAAO;EAChB,CAAC;EAED,QAAQ,CAAC,MAAW,EAAA;;IAClB,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,kBAAkB,CAAoB;IAC3D,OAAO,CAAC,QAAQ,GACd,MAAM,CAAC,QAAQ,KAAK,SAAS,IAAI,MAAM,CAAC,QAAQ,KAAK,IAAI,GACrD,UAAA,CAAA,eAAe,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,GACzC,SAAS;IACf,OAAO,CAAC,SAAS,GAAG,CAAC,CAAA,EAAA,GAAA,MAAM,CAAC,SAAS,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE,EAAE,GAAG,CAAE,CAAM,IAAK,OAAA,CAAA,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IAClF,OAAO,OAAO;EAChB,CAAC;EAED,MAAM,CAAC,OAAuB,EAAA;IAC5B,MAAM,GAAG,GAAQ,CAAA,CAAE;IACnB,OAAO,CAAC,QAAQ,KAAK,SAAS,KAC3B,GAAG,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,GAAG,UAAA,CAAA,eAAe,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC;IAC1F,IAAI,OAAO,CAAC,SAAS,EAAE;MACrB,GAAG,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC,GAAG,CAAE,CAAC,IAAM,CAAC,GAAG,OAAA,CAAA,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,SAAU,CAAC;KACnF,MAAM;MACL,GAAG,CAAC,SAAS,GAAG,EAAE;IACnB;IACD,OAAO,GAAG;EACZ,CAAC;EAED,WAAW,CAAkD,MAAS,EAAA;;IACpE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,kBAAkB,CAAoB;IAC3D,OAAO,CAAC,QAAQ,GACd,MAAM,CAAC,QAAQ,KAAK,SAAS,IAAI,MAAM,CAAC,QAAQ,KAAK,IAAI,GACrD,UAAA,CAAA,eAAe,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,GAC5C,SAAS;IACf,OAAO,CAAC,SAAS,GAAG,CAAA,CAAA,EAAA,GAAA,MAAM,CAAC,SAAS,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,GAAG,CAAE,CAAC,IAAK,OAAA,CAAA,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,KAAI,EAAE;IAC/E,OAAO,OAAO;EAChB;CACD;AAED,MAAM,OAAO,GAAW;EAAE,QAAQ,EAAE,MAAA,CAAA,OAAI,CAAC,KAAK;EAAE,KAAK,EAAE,EAAE;EAAE,OAAO,EAAE;AAAE,CAAE;AAE3D,OAAA,CAAA,GAAG,GAAG;EACjB,MAAM,CAAC,OAAY,EAA0C;IAAA,IAAxC,MAAA,uEAAqB,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,MAAM,EAAE;IAC3D,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,MAAM,EAAE;MAC9B,MAAA,CAAA,IAAI,CAAC,MAAM,CAAC,CAAE,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE;IACnD;IACD,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE;MAC9B,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;IAC3C;IACD,IAAI,OAAO,CAAC,KAAK,KAAK,EAAE,EAAE;MACxB,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;IACxC;IACD,IAAI,OAAO,CAAC,OAAO,KAAK,EAAE,EAAE;MAC1B,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC;IAC1C;IACD,OAAO,MAAM;EACf,CAAC;EAED,MAAM,CAAC,KAA8B,EAAE,MAAe,EAAA;IACpD,MAAM,MAAM,GAAG,KAAK,YAAY,SAAA,CAAA,OAAG,CAAC,MAAM,GAAG,KAAK,GAAG,IAAI,SAAA,CAAA,OAAG,CAAC,MAAM,CAAC,KAAK,CAAC;IAC1E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM;IACjE,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,OAAO,CAAS;IACrC,OAAO,CAAC,MAAM,GAAG,EAAE;IACnB,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;MACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE;MAC3B,QAAQ,GAAG,KAAK,CAAC;QACf,KAAK,CAAC;UACJ,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,MAAA,CAAA,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;UACzD;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,QAAQ,GAAG,MAAM,CAAC,MAAM,EAAU;UAC1C;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,KAAK,GAAG,MAAM,CAAC,MAAM,EAAE;UAC/B;QACF,KAAK,CAAC;UACJ,OAAO,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,EAAE;UACjC;QACF;UACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC;UACxB;MAAM;IAEX;IACD,OAAO,OAAO;EAChB,CAAC;EAED,QAAQ,CAAC,MAAW,EAAA;;IAClB,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,OAAO,CAAS;IACrC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAA,EAAA,GAAA,MAAM,CAAC,MAAM,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE,EAAE,GAAG,CAAE,CAAM,IAAK,MAAA,CAAA,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IACxE,OAAO,CAAC,QAAQ,GACd,MAAM,CAAC,QAAQ,KAAK,SAAS,IAAI,MAAM,CAAC,QAAQ,KAAK,IAAI,GACrD,MAAA,CAAA,OAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,GAChC,MAAA,CAAA,OAAI,CAAC,KAAK;IAChB,OAAO,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,KAAK,SAAS,IAAI,MAAM,CAAC,KAAK,KAAK,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE;IAC/F,OAAO,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,KAAK,SAAS,IAAI,MAAM,CAAC,OAAO,KAAK,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE;IACvG,OAAO,OAAO;EAChB,CAAC;EAED,MAAM,CAAC,OAAY,EAAA;IACjB,MAAM,GAAG,GAAQ,CAAA,CAAE;IACnB,IAAI,OAAO,CAAC,MAAM,EAAE;MAClB,GAAG,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,GAAG,CAAE,CAAC,IAAM,CAAC,GAAG,MAAA,CAAA,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,SAAU,CAAC;KACzE,MAAM;MACL,GAAG,CAAC,MAAM,GAAG,EAAE;IAChB;IACD,OAAO,CAAC,QAAQ,KAAK,SAAS,KAAK,GAAG,CAAC,QAAQ,GAAG,CAAC,OAAO,CAAC,QAAQ,IAAI,MAAA,CAAA,OAAI,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAC;IAC9F,OAAO,CAAC,KAAK,KAAK,SAAS,KAAK,GAAG,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;IAC1D,OAAO,CAAC,OAAO,KAAK,SAAS,KAAK,GAAG,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAChE,OAAO,GAAG;EACZ,CAAC;EAED,WAAW,CAAuC,MAAS,EAAA;;IACzD,MAAM,OAAO,GAAG,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,OAAO,CAAS;IACrC,OAAO,CAAC,MAAM,GAAG,CAAA,CAAA,EAAA,GAAA,MAAM,CAAC,MAAM,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,GAAG,CAAE,CAAC,IAAK,MAAA,CAAA,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,KAAI,EAAE;IACrE,OAAO,CAAC,QAAQ,GACd,MAAM,CAAC,QAAQ,KAAK,SAAS,IAAI,MAAM,CAAC,QAAQ,KAAK,IAAI,GACrD,MAAA,CAAA,OAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,GAC/B,MAAA,CAAA,OAAI,CAAC,KAAK;IAChB,OAAO,CAAC,KAAK,GAAG,CAAA,EAAA,GAAA,MAAM,CAAC,KAAK,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE;IAClC,OAAO,CAAC,OAAO,GAAG,CAAA,EAAA,GAAA,MAAM,CAAC,OAAO,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE;IACtC,OAAO,OAAO;EAChB;CACD;AAKD,IAAI,UAAU,GAAQ,CAAC,MAAK;EAC1B,IAAI,OAAO,UAAU,KAAK,WAAW,EAAE,OAAO,UAAU;EACxD,IAAI,OAAO,IAAI,KAAK,WAAW,EAAE,OAAO,IAAI;EAC5C,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE,OAAO,MAAM;EAChD,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE,OAAO,MAAM;EAChD,MAAM,gCAAgC;AACxC,CAAC,GAAG;AAEJ,MAAM,IAAI,GACR,UAAU,CAAC,IAAI,KAAM,GAAG,IAAK,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AACxF,SAAS,eAAe,CAAC,GAAW,EAAA;EAClC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;EACrB,MAAM,GAAG,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC;EACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;IACnC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC;EAC3B;EACD,OAAO,GAAG;AACZ;AAEA,MAAM,IAAI,GACR,UAAU,CAAC,IAAI,KAAM,GAAG,IAAK,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AACxF,SAAS,eAAe,CAAC,GAAe,EAAA;EACtC,MAAM,GAAG,GAAa,EAAE;EACxB,KAAK,MAAM,IAAI,IAAI,GAAG,EAAE;IACtB,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;EACpC;EACD,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AAC3B;AAqBA,IAAI,SAAA,CAAA,OAAG,CAAC,IAAI,CAAC,IAAI,KAAK,MAAA,CAAA,OAAI,EAAE;EAC1B,SAAA,CAAA,OAAG,CAAC,IAAI,CAAC,IAAI,GAAG,MAAA,CAAA,OAAW;EAC3B,SAAA,CAAA,OAAG,CAAC,SAAS,EAAE;AAChB","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Fee = exports.ModeInfo_Multi = exports.ModeInfo_Single = exports.ModeInfo = exports.SignerInfo = exports.AuthInfo = exports.TxBody = exports.SignDoc = exports.TxRaw = exports.Tx = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst any_1 = require(\"../../../google/protobuf/any\");\nconst signing_1 = require(\"../../../cosmos/tx/signing/v1beta1/signing\");\nconst multisig_1 = require(\"../../../cosmos/crypto/multisig/v1beta1/multisig\");\nconst coin_1 = require(\"../../../cosmos/base/v1beta1/coin\");\nexports.protobufPackage = \"cosmos.tx.v1beta1\";\nconst baseTx = {};\nexports.Tx = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.body !== undefined) {\n            exports.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.authInfo !== undefined) {\n            exports.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();\n        }\n        for (const v of message.signatures) {\n            writer.uint32(26).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseTx);\n        message.signatures = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.body = exports.TxBody.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.authInfo = exports.AuthInfo.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.signatures.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        var _a;\n        const message = Object.assign({}, baseTx);\n        message.body =\n            object.body !== undefined && object.body !== null ? exports.TxBody.fromJSON(object.body) : undefined;\n        message.authInfo =\n            object.authInfo !== undefined && object.authInfo !== null\n                ? exports.AuthInfo.fromJSON(object.authInfo)\n                : undefined;\n        message.signatures = ((_a = object.signatures) !== null && _a !== void 0 ? _a : []).map((e) => bytesFromBase64(e));\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.body !== undefined && (obj.body = message.body ? exports.TxBody.toJSON(message.body) : undefined);\n        message.authInfo !== undefined &&\n            (obj.authInfo = message.authInfo ? exports.AuthInfo.toJSON(message.authInfo) : undefined);\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = Object.assign({}, baseTx);\n        message.body =\n            object.body !== undefined && object.body !== null ? exports.TxBody.fromPartial(object.body) : undefined;\n        message.authInfo =\n            object.authInfo !== undefined && object.authInfo !== null\n                ? exports.AuthInfo.fromPartial(object.authInfo)\n                : undefined;\n        message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nconst baseTxRaw = {};\nexports.TxRaw = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.bodyBytes.length !== 0) {\n            writer.uint32(10).bytes(message.bodyBytes);\n        }\n        if (message.authInfoBytes.length !== 0) {\n            writer.uint32(18).bytes(message.authInfoBytes);\n        }\n        for (const v of message.signatures) {\n            writer.uint32(26).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseTxRaw);\n        message.signatures = [];\n        message.bodyBytes = new Uint8Array();\n        message.authInfoBytes = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bodyBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.authInfoBytes = reader.bytes();\n                    break;\n                case 3:\n                    message.signatures.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        var _a;\n        const message = Object.assign({}, baseTxRaw);\n        message.bodyBytes =\n            object.bodyBytes !== undefined && object.bodyBytes !== null\n                ? bytesFromBase64(object.bodyBytes)\n                : new Uint8Array();\n        message.authInfoBytes =\n            object.authInfoBytes !== undefined && object.authInfoBytes !== null\n                ? bytesFromBase64(object.authInfoBytes)\n                : new Uint8Array();\n        message.signatures = ((_a = object.signatures) !== null && _a !== void 0 ? _a : []).map((e) => bytesFromBase64(e));\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bodyBytes !== undefined &&\n            (obj.bodyBytes = base64FromBytes(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));\n        message.authInfoBytes !== undefined &&\n            (obj.authInfoBytes = base64FromBytes(message.authInfoBytes !== undefined ? message.authInfoBytes : new Uint8Array()));\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = Object.assign({}, baseTxRaw);\n        message.bodyBytes = (_a = object.bodyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.authInfoBytes = (_b = object.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.signatures = ((_c = object.signatures) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];\n        return message;\n    },\n};\nconst baseSignDoc = { chainId: \"\", accountNumber: long_1.default.UZERO };\nexports.SignDoc = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.bodyBytes.length !== 0) {\n            writer.uint32(10).bytes(message.bodyBytes);\n        }\n        if (message.authInfoBytes.length !== 0) {\n            writer.uint32(18).bytes(message.authInfoBytes);\n        }\n        if (message.chainId !== \"\") {\n            writer.uint32(26).string(message.chainId);\n        }\n        if (!message.accountNumber.isZero()) {\n            writer.uint32(32).uint64(message.accountNumber);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseSignDoc);\n        message.bodyBytes = new Uint8Array();\n        message.authInfoBytes = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bodyBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.authInfoBytes = reader.bytes();\n                    break;\n                case 3:\n                    message.chainId = reader.string();\n                    break;\n                case 4:\n                    message.accountNumber = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseSignDoc);\n        message.bodyBytes =\n            object.bodyBytes !== undefined && object.bodyBytes !== null\n                ? bytesFromBase64(object.bodyBytes)\n                : new Uint8Array();\n        message.authInfoBytes =\n            object.authInfoBytes !== undefined && object.authInfoBytes !== null\n                ? bytesFromBase64(object.authInfoBytes)\n                : new Uint8Array();\n        message.chainId = object.chainId !== undefined && object.chainId !== null ? String(object.chainId) : \"\";\n        message.accountNumber =\n            object.accountNumber !== undefined && object.accountNumber !== null\n                ? long_1.default.fromString(object.accountNumber)\n                : long_1.default.UZERO;\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bodyBytes !== undefined &&\n            (obj.bodyBytes = base64FromBytes(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));\n        message.authInfoBytes !== undefined &&\n            (obj.authInfoBytes = base64FromBytes(message.authInfoBytes !== undefined ? message.authInfoBytes : new Uint8Array()));\n        message.chainId !== undefined && (obj.chainId = message.chainId);\n        message.accountNumber !== undefined &&\n            (obj.accountNumber = (message.accountNumber || long_1.default.UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = Object.assign({}, baseSignDoc);\n        message.bodyBytes = (_a = object.bodyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.authInfoBytes = (_b = object.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.chainId = (_c = object.chainId) !== null && _c !== void 0 ? _c : \"\";\n        message.accountNumber =\n            object.accountNumber !== undefined && object.accountNumber !== null\n                ? long_1.default.fromValue(object.accountNumber)\n                : long_1.default.UZERO;\n        return message;\n    },\n};\nconst baseTxBody = { memo: \"\", timeoutHeight: long_1.default.UZERO };\nexports.TxBody = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.messages) {\n            any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.memo !== \"\") {\n            writer.uint32(18).string(message.memo);\n        }\n        if (!message.timeoutHeight.isZero()) {\n            writer.uint32(24).uint64(message.timeoutHeight);\n        }\n        for (const v of message.extensionOptions) {\n            any_1.Any.encode(v, writer.uint32(8186).fork()).ldelim();\n        }\n        for (const v of message.nonCriticalExtensionOptions) {\n            any_1.Any.encode(v, writer.uint32(16378).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseTxBody);\n        message.messages = [];\n        message.extensionOptions = [];\n        message.nonCriticalExtensionOptions = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messages.push(any_1.Any.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.memo = reader.string();\n                    break;\n                case 3:\n                    message.timeoutHeight = reader.uint64();\n                    break;\n                case 1023:\n                    message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));\n                    break;\n                case 2047:\n                    message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        var _a, _b, _c;\n        const message = Object.assign({}, baseTxBody);\n        message.messages = ((_a = object.messages) !== null && _a !== void 0 ? _a : []).map((e) => any_1.Any.fromJSON(e));\n        message.memo = object.memo !== undefined && object.memo !== null ? String(object.memo) : \"\";\n        message.timeoutHeight =\n            object.timeoutHeight !== undefined && object.timeoutHeight !== null\n                ? long_1.default.fromString(object.timeoutHeight)\n                : long_1.default.UZERO;\n        message.extensionOptions = ((_b = object.extensionOptions) !== null && _b !== void 0 ? _b : []).map((e) => any_1.Any.fromJSON(e));\n        message.nonCriticalExtensionOptions = ((_c = object.nonCriticalExtensionOptions) !== null && _c !== void 0 ? _c : []).map((e) => any_1.Any.fromJSON(e));\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.messages) {\n            obj.messages = message.messages.map((e) => (e ? any_1.Any.toJSON(e) : undefined));\n        }\n        else {\n            obj.messages = [];\n        }\n        message.memo !== undefined && (obj.memo = message.memo);\n        message.timeoutHeight !== undefined &&\n            (obj.timeoutHeight = (message.timeoutHeight || long_1.default.UZERO).toString());\n        if (message.extensionOptions) {\n            obj.extensionOptions = message.extensionOptions.map((e) => (e ? any_1.Any.toJSON(e) : undefined));\n        }\n        else {\n            obj.extensionOptions = [];\n        }\n        if (message.nonCriticalExtensionOptions) {\n            obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map((e) => e ? any_1.Any.toJSON(e) : undefined);\n        }\n        else {\n            obj.nonCriticalExtensionOptions = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = Object.assign({}, baseTxBody);\n        message.messages = ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e) => any_1.Any.fromPartial(e))) || [];\n        message.memo = (_b = object.memo) !== null && _b !== void 0 ? _b : \"\";\n        message.timeoutHeight =\n            object.timeoutHeight !== undefined && object.timeoutHeight !== null\n                ? long_1.default.fromValue(object.timeoutHeight)\n                : long_1.default.UZERO;\n        message.extensionOptions = ((_c = object.extensionOptions) === null || _c === void 0 ? void 0 : _c.map((e) => any_1.Any.fromPartial(e))) || [];\n        message.nonCriticalExtensionOptions =\n            ((_d = object.nonCriticalExtensionOptions) === null || _d === void 0 ? void 0 : _d.map((e) => any_1.Any.fromPartial(e))) || [];\n        return message;\n    },\n};\nconst baseAuthInfo = {};\nexports.AuthInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.signerInfos) {\n            exports.SignerInfo.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.fee !== undefined) {\n            exports.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseAuthInfo);\n        message.signerInfos = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signerInfos.push(exports.SignerInfo.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.fee = exports.Fee.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        var _a;\n        const message = Object.assign({}, baseAuthInfo);\n        message.signerInfos = ((_a = object.signerInfos) !== null && _a !== void 0 ? _a : []).map((e) => exports.SignerInfo.fromJSON(e));\n        message.fee = object.fee !== undefined && object.fee !== null ? exports.Fee.fromJSON(object.fee) : undefined;\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.signerInfos) {\n            obj.signerInfos = message.signerInfos.map((e) => (e ? exports.SignerInfo.toJSON(e) : undefined));\n        }\n        else {\n            obj.signerInfos = [];\n        }\n        message.fee !== undefined && (obj.fee = message.fee ? exports.Fee.toJSON(message.fee) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = Object.assign({}, baseAuthInfo);\n        message.signerInfos = ((_a = object.signerInfos) === null || _a === void 0 ? void 0 : _a.map((e) => exports.SignerInfo.fromPartial(e))) || [];\n        message.fee = object.fee !== undefined && object.fee !== null ? exports.Fee.fromPartial(object.fee) : undefined;\n        return message;\n    },\n};\nconst baseSignerInfo = { sequence: long_1.default.UZERO };\nexports.SignerInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.publicKey !== undefined) {\n            any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.modeInfo !== undefined) {\n            exports.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();\n        }\n        if (!message.sequence.isZero()) {\n            writer.uint32(24).uint64(message.sequence);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseSignerInfo);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.publicKey = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.modeInfo = exports.ModeInfo.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.sequence = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseSignerInfo);\n        message.publicKey =\n            object.publicKey !== undefined && object.publicKey !== null\n                ? any_1.Any.fromJSON(object.publicKey)\n                : undefined;\n        message.modeInfo =\n            object.modeInfo !== undefined && object.modeInfo !== null\n                ? exports.ModeInfo.fromJSON(object.modeInfo)\n                : undefined;\n        message.sequence =\n            object.sequence !== undefined && object.sequence !== null\n                ? long_1.default.fromString(object.sequence)\n                : long_1.default.UZERO;\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.publicKey !== undefined &&\n            (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);\n        message.modeInfo !== undefined &&\n            (obj.modeInfo = message.modeInfo ? exports.ModeInfo.toJSON(message.modeInfo) : undefined);\n        message.sequence !== undefined && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseSignerInfo);\n        message.publicKey =\n            object.publicKey !== undefined && object.publicKey !== null\n                ? any_1.Any.fromPartial(object.publicKey)\n                : undefined;\n        message.modeInfo =\n            object.modeInfo !== undefined && object.modeInfo !== null\n                ? exports.ModeInfo.fromPartial(object.modeInfo)\n                : undefined;\n        message.sequence =\n            object.sequence !== undefined && object.sequence !== null\n                ? long_1.default.fromValue(object.sequence)\n                : long_1.default.UZERO;\n        return message;\n    },\n};\nconst baseModeInfo = {};\nexports.ModeInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.single !== undefined) {\n            exports.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.multi !== undefined) {\n            exports.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseModeInfo);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.single = exports.ModeInfo_Single.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.multi = exports.ModeInfo_Multi.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseModeInfo);\n        message.single =\n            object.single !== undefined && object.single !== null\n                ? exports.ModeInfo_Single.fromJSON(object.single)\n                : undefined;\n        message.multi =\n            object.multi !== undefined && object.multi !== null ? exports.ModeInfo_Multi.fromJSON(object.multi) : undefined;\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.single !== undefined &&\n            (obj.single = message.single ? exports.ModeInfo_Single.toJSON(message.single) : undefined);\n        message.multi !== undefined &&\n            (obj.multi = message.multi ? exports.ModeInfo_Multi.toJSON(message.multi) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseModeInfo);\n        message.single =\n            object.single !== undefined && object.single !== null\n                ? exports.ModeInfo_Single.fromPartial(object.single)\n                : undefined;\n        message.multi =\n            object.multi !== undefined && object.multi !== null\n                ? exports.ModeInfo_Multi.fromPartial(object.multi)\n                : undefined;\n        return message;\n    },\n};\nconst baseModeInfo_Single = { mode: 0 };\nexports.ModeInfo_Single = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.mode !== 0) {\n            writer.uint32(8).int32(message.mode);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseModeInfo_Single);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.mode = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseModeInfo_Single);\n        message.mode = object.mode !== undefined && object.mode !== null ? signing_1.signModeFromJSON(object.mode) : 0;\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.mode !== undefined && (obj.mode = signing_1.signModeToJSON(message.mode));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = Object.assign({}, baseModeInfo_Single);\n        message.mode = (_a = object.mode) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nconst baseModeInfo_Multi = {};\nexports.ModeInfo_Multi = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.bitarray !== undefined) {\n            multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.modeInfos) {\n            exports.ModeInfo.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseModeInfo_Multi);\n        message.modeInfos = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.modeInfos.push(exports.ModeInfo.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        var _a;\n        const message = Object.assign({}, baseModeInfo_Multi);\n        message.bitarray =\n            object.bitarray !== undefined && object.bitarray !== null\n                ? multisig_1.CompactBitArray.fromJSON(object.bitarray)\n                : undefined;\n        message.modeInfos = ((_a = object.modeInfos) !== null && _a !== void 0 ? _a : []).map((e) => exports.ModeInfo.fromJSON(e));\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bitarray !== undefined &&\n            (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : undefined);\n        if (message.modeInfos) {\n            obj.modeInfos = message.modeInfos.map((e) => (e ? exports.ModeInfo.toJSON(e) : undefined));\n        }\n        else {\n            obj.modeInfos = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = Object.assign({}, baseModeInfo_Multi);\n        message.bitarray =\n            object.bitarray !== undefined && object.bitarray !== null\n                ? multisig_1.CompactBitArray.fromPartial(object.bitarray)\n                : undefined;\n        message.modeInfos = ((_a = object.modeInfos) === null || _a === void 0 ? void 0 : _a.map((e) => exports.ModeInfo.fromPartial(e))) || [];\n        return message;\n    },\n};\nconst baseFee = { gasLimit: long_1.default.UZERO, payer: \"\", granter: \"\" };\nexports.Fee = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.amount) {\n            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (!message.gasLimit.isZero()) {\n            writer.uint32(16).uint64(message.gasLimit);\n        }\n        if (message.payer !== \"\") {\n            writer.uint32(26).string(message.payer);\n        }\n        if (message.granter !== \"\") {\n            writer.uint32(34).string(message.granter);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseFee);\n        message.amount = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.gasLimit = reader.uint64();\n                    break;\n                case 3:\n                    message.payer = reader.string();\n                    break;\n                case 4:\n                    message.granter = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        var _a;\n        const message = Object.assign({}, baseFee);\n        message.amount = ((_a = object.amount) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.Coin.fromJSON(e));\n        message.gasLimit =\n            object.gasLimit !== undefined && object.gasLimit !== null\n                ? long_1.default.fromString(object.gasLimit)\n                : long_1.default.UZERO;\n        message.payer = object.payer !== undefined && object.payer !== null ? String(object.payer) : \"\";\n        message.granter = object.granter !== undefined && object.granter !== null ? String(object.granter) : \"\";\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.amount) {\n            obj.amount = message.amount.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.amount = [];\n        }\n        message.gasLimit !== undefined && (obj.gasLimit = (message.gasLimit || long_1.default.UZERO).toString());\n        message.payer !== undefined && (obj.payer = message.payer);\n        message.granter !== undefined && (obj.granter = message.granter);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = Object.assign({}, baseFee);\n        message.amount = ((_a = object.amount) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        message.gasLimit =\n            object.gasLimit !== undefined && object.gasLimit !== null\n                ? long_1.default.fromValue(object.gasLimit)\n                : long_1.default.UZERO;\n        message.payer = (_b = object.payer) !== null && _b !== void 0 ? _b : \"\";\n        message.granter = (_c = object.granter) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\n//# sourceMappingURL=tx.js.map"]},"metadata":{},"sourceType":"script"}