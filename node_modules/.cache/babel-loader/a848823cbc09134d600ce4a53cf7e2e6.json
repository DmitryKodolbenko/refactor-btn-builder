{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AminoTypes = void 0;\nfunction isAminoConverter(converter) {\n  return typeof converter[1] !== \"string\";\n}\n/**\n * A map from Stargate message types as used in the messages's `Any` type\n * to Amino types.\n */\nclass AminoTypes {\n  constructor(types) {\n    this.register = types;\n  }\n  toAmino(_ref) {\n    let {\n      typeUrl,\n      value\n    } = _ref;\n    const converter = this.register[typeUrl];\n    if (converter === \"not_supported_by_chain\") {\n      throw new Error(`The message type '${typeUrl}' cannot be signed using the Amino JSON sign mode because this is not supported by chain.`);\n    }\n    if (!converter) {\n      throw new Error(`Type URL '${typeUrl}' does not exist in the Amino message type register. ` + \"If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. \" + \"If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.\");\n    }\n    return {\n      type: converter.aminoType,\n      value: converter.toAmino(value)\n    };\n  }\n  fromAmino(_ref2) {\n    let {\n      type,\n      value\n    } = _ref2;\n    const matches = Object.entries(this.register).filter(isAminoConverter).filter(_ref3 => {\n      let [_typeUrl, {\n        aminoType\n      }] = _ref3;\n      return aminoType === type;\n    });\n    switch (matches.length) {\n      case 0:\n        {\n          throw new Error(`Amino type identifier '${type}' does not exist in the Amino message type register. ` + \"If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. \" + \"If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.\");\n        }\n      case 1:\n        {\n          const [typeUrl, converter] = matches[0];\n          return {\n            typeUrl: typeUrl,\n            value: converter.fromAmino(value)\n          };\n        }\n      default:\n        throw new Error(`Multiple types are registered with Amino type identifier '${type}': '` + matches.map(_ref4 => {\n          let [key, _value] = _ref4;\n          return key;\n        }).sort().join(\"', '\") + \"'. Thus fromAmino cannot be performed.\");\n    }\n  }\n}\nexports.AminoTypes = AminoTypes;","map":{"version":3,"sources":["../src/aminotypes.ts"],"names":[],"mappings":";;;;;;AAaA,SAAS,gBAAgB,CACvB,SAA8D,EAAA;EAE9D,OAAO,OAAO,SAAS,CAAC,CAAC,CAAC,KAAK,QAAQ;AACzC;AAEA;;;AAGG;AACH,MAAa,UAAU,CAAA;EAOrB,WAAA,CAAmB,KAAsB,EAAA;IACvC,IAAI,CAAC,QAAQ,GAAG,KAAK;EACvB;EAEO,OAAO,OAAiC;IAAA,IAAhC;MAAE,OAAO;MAAE;IAAK,CAAgB;IAC7C,MAAM,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC;IACxC,IAAI,SAAS,KAAK,wBAAwB,EAAE;MAC1C,MAAM,IAAI,KAAK,CACb,qBAAqB,OAAO,2FAA2F,CACxH;IACF;IACD,IAAI,CAAC,SAAS,EAAE;MACd,MAAM,IAAI,KAAK,CACb,aAAa,OAAO,uDAAuD,GACzE,+GAA+G,GAC/G,gIAAgI,CACnI;IACF;IACD,OAAO;MACL,IAAI,EAAE,SAAS,CAAC,SAAS;MACzB,KAAK,EAAE,SAAS,CAAC,OAAO,CAAC,KAAK;KAC/B;EACH;EAEO,SAAS,QAA0B;IAAA,IAAzB;MAAE,IAAI;MAAE;IAAK,CAAY;IACxC,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAC1C,MAAM,CAAC,gBAAgB,CAAC,CACxB,MAAM,CAAC;MAAA,IAAC,CAAC,QAAQ,EAAE;QAAE;MAAS,CAAE,CAAC;MAAA,OAAK,SAAS,KAAK,IAAI;IAAA,EAAC;IAE5D,QAAQ,OAAO,CAAC,MAAM;MACpB,KAAK,CAAC;QAAE;UACN,MAAM,IAAI,KAAK,CACb,0BAA0B,IAAI,uDAAuD,GACnF,+GAA+G,GAC/G,gIAAgI,CACnI;QACF;MACD,KAAK,CAAC;QAAE;UACN,MAAM,CAAC,OAAO,EAAE,SAAS,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;UACvC,OAAO;YACL,OAAO,EAAE,OAAO;YAChB,KAAK,EAAE,SAAS,CAAC,SAAS,CAAC,KAAK;WACjC;QACF;MACD;QACE,MAAM,IAAI,KAAK,CACb,6DAA6D,IAAI,MAAM,GACrE,OAAO,CACJ,GAAG,CAAC;UAAA,IAAC,CAAC,GAAG,EAAE,MAAM,CAAC;UAAA,OAAK,GAAG;QAAA,EAAC,CAC3B,IAAI,EAAE,CACN,IAAI,CAAC,MAAM,CAAC,GACf,wCAAwC,CAC3C;IAAC;EAER;AACD;AA9DD,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AminoTypes = void 0;\nfunction isAminoConverter(converter) {\n    return typeof converter[1] !== \"string\";\n}\n/**\n * A map from Stargate message types as used in the messages's `Any` type\n * to Amino types.\n */\nclass AminoTypes {\n    constructor(types) {\n        this.register = types;\n    }\n    toAmino({ typeUrl, value }) {\n        const converter = this.register[typeUrl];\n        if (converter === \"not_supported_by_chain\") {\n            throw new Error(`The message type '${typeUrl}' cannot be signed using the Amino JSON sign mode because this is not supported by chain.`);\n        }\n        if (!converter) {\n            throw new Error(`Type URL '${typeUrl}' does not exist in the Amino message type register. ` +\n                \"If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. \" +\n                \"If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.\");\n        }\n        return {\n            type: converter.aminoType,\n            value: converter.toAmino(value),\n        };\n    }\n    fromAmino({ type, value }) {\n        const matches = Object.entries(this.register)\n            .filter(isAminoConverter)\n            .filter(([_typeUrl, { aminoType }]) => aminoType === type);\n        switch (matches.length) {\n            case 0: {\n                throw new Error(`Amino type identifier '${type}' does not exist in the Amino message type register. ` +\n                    \"If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. \" +\n                    \"If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.\");\n            }\n            case 1: {\n                const [typeUrl, converter] = matches[0];\n                return {\n                    typeUrl: typeUrl,\n                    value: converter.fromAmino(value),\n                };\n            }\n            default:\n                throw new Error(`Multiple types are registered with Amino type identifier '${type}': '` +\n                    matches\n                        .map(([key, _value]) => key)\n                        .sort()\n                        .join(\"', '\") +\n                    \"'. Thus fromAmino cannot be performed.\");\n        }\n    }\n}\nexports.AminoTypes = AminoTypes;\n//# sourceMappingURL=aminotypes.js.map"]},"metadata":{},"sourceType":"script"}