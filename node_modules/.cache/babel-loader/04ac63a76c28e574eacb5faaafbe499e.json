{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\n/**\n * Storage for storing block numbers that we have already processed.\n * Used by `BlockSubscription`.\n *\n * Dumb in-memory implementation.\n */\nvar InMemoryBlockStorage = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * @param logFunction?   {(text: string) => void}\n   */\n  function InMemoryBlockStorage(logFunction) {\n    _classCallCheck(this, InMemoryBlockStorage);\n    this.masterchainBlocks = {}; // mcBlockNumber {number} -> isProcessed {boolean}\n    this.shardchainBlocks = {}; // workchain {number} + shardId {string} + shardBlockNumber {number} -> isProcessed {boolean}\n    this.logFunction = logFunction;\n  }\n\n  /**\n   * @private\n   * Insert new UNprocessed shardchain block numbers\n   * Block number (workchain + shardId + shardBlockNumber) should be IGNORED if it is already in the storage\n   * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n   */\n  _createClass(InMemoryBlockStorage, [{\n    key: \"insertShardBlocks\",\n    value: function () {\n      var _insertShardBlocks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(shardBlockNumbers) {\n        var _iterator, _step, _step$value, workchain, shardId, shardBlockNumber;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _iterator = _createForOfIteratorHelper(shardBlockNumbers);\n                _context.prev = 1;\n                _iterator.s();\n              case 3:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 11;\n                  break;\n                }\n                _step$value = _step.value, workchain = _step$value.workchain, shardId = _step$value.shardId, shardBlockNumber = _step$value.shardBlockNumber;\n                if (!(this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] !== undefined)) {\n                  _context.next = 7;\n                  break;\n                }\n                return _context.abrupt(\"continue\", 9);\n              case 7:\n                if (this.logFunction) {\n                  this.logFunction('insert shard ' + workchain + ' ' + shardId + ' ' + shardBlockNumber);\n                }\n                // INSERT INTO shardchainBlocks VALUES (workchain, shardId, shardBlockNumber, FALSE);\n                this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] = false;\n              case 9:\n                _context.next = 3;\n                break;\n              case 11:\n                _context.next = 16;\n                break;\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](1);\n                _iterator.e(_context.t0);\n              case 16:\n                _context.prev = 16;\n                _iterator.f();\n                return _context.finish(16);\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 13, 16, 19]]);\n      }));\n      function insertShardBlocks(_x) {\n        return _insertShardBlocks.apply(this, arguments);\n      }\n      return insertShardBlocks;\n    }()\n    /**\n     * Insert new processed masterchain block number & new UNprocessed shardchains blocks numbers\n     * Must be in single DB transaction\n     * @param   mcBlockNumber {number}\n     * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n     */\n  }, {\n    key: \"insertBlocks\",\n    value: function () {\n      var _insertBlocks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(mcBlockNumber, shardBlockNumbers) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.logFunction) {\n                  this.logFunction('mc processed ' + mcBlockNumber);\n                }\n                // INSERT INTO masterchainBlocks VALUES (blockNumber, TRUE);\n                if (!(this.masterchainBlocks[mcBlockNumber] !== undefined)) {\n                  _context2.next = 3;\n                  break;\n                }\n                throw new Error('mc already exists ' + mcBlockNumber);\n              case 3:\n                this.masterchainBlocks[mcBlockNumber] = true;\n                _context2.next = 6;\n                return this.insertShardBlocks(shardBlockNumbers);\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function insertBlocks(_x2, _x3) {\n        return _insertBlocks.apply(this, arguments);\n      }\n      return insertBlocks;\n    }()\n    /**\n     * Get last processed masterchain block number\n     * @return {Promise<number | undefined>}\n     */\n  }, {\n    key: \"getLastMasterchainBlockNumber\",\n    value: function () {\n      var _getLastMasterchainBlockNumber = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var blockNumbers;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // SELECT MAX(blockNumber) FROM masterchainBlocks\n                blockNumbers = Object.keys(this.masterchainBlocks).map(function (x) {\n                  return Number(x);\n                }).sort(function (a, b) {\n                  return b - a;\n                });\n                return _context3.abrupt(\"return\", blockNumbers[0]);\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function getLastMasterchainBlockNumber() {\n        return _getLastMasterchainBlockNumber.apply(this, arguments);\n      }\n      return getLastMasterchainBlockNumber;\n    }()\n    /**\n     * Set that this shardchain block number processed & insert new UNprocessed shardchains blocks numbers\n     * Must be in single DB transaction\n     * @param   workchain {number}\n     * @param   shardId {string}\n     * @param   shardBlockNumber    {number}\n     * @param   prevShardBlocks    {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n     */\n  }, {\n    key: \"setBlockProcessed\",\n    value: function () {\n      var _setBlockProcessed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(workchain, shardId, shardBlockNumber, prevShardBlocks) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this.logFunction) {\n                  this.logFunction('shard processed ' + workchain + ' ' + shardId + ' ' + shardBlockNumber);\n                }\n                // UPDATE shardchainBlocks SET processed = TRUE WHERE workchain = ? AND shardId = ? AND shardBlockNumber = ?\n                if (!(this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] === undefined)) {\n                  _context4.next = 3;\n                  break;\n                }\n                throw new Error('shard not exists ' + workchain + '_' + shardId + '_' + shardBlockNumber);\n              case 3:\n                this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] = true;\n                _context4.next = 6;\n                return this.insertShardBlocks(prevShardBlocks);\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function setBlockProcessed(_x4, _x5, _x6, _x7) {\n        return _setBlockProcessed.apply(this, arguments);\n      }\n      return setBlockProcessed;\n    }()\n    /**\n     * Get any unprocesed shard block number (order is not important)\n     * @return {Promise<{workchain: number, shardId: string, shardBlockNumber: number}>}\n     */\n  }, {\n    key: \"getUnprocessedShardBlock\",\n    value: function () {\n      var _getUnprocessedShardBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var key, arr;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.t0 = _regeneratorRuntime().keys(this.shardchainBlocks);\n              case 1:\n                if ((_context5.t1 = _context5.t0()).done) {\n                  _context5.next = 8;\n                  break;\n                }\n                key = _context5.t1.value;\n                if (!(this.shardchainBlocks[key] === false)) {\n                  _context5.next = 6;\n                  break;\n                }\n                arr = key.split('_');\n                return _context5.abrupt(\"return\", {\n                  workchain: Number(arr[0]),\n                  shardId: arr[1],\n                  shardBlockNumber: Number(arr[2])\n                });\n              case 6:\n                _context5.next = 1;\n                break;\n              case 8:\n                return _context5.abrupt(\"return\", undefined);\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function getUnprocessedShardBlock() {\n        return _getUnprocessedShardBlock.apply(this, arguments);\n      }\n      return getUnprocessedShardBlock;\n    }()\n  }]);\n  return InMemoryBlockStorage;\n}();\nmodule.exports = {\n  InMemoryBlockStorage: InMemoryBlockStorage\n};","map":{"version":3,"names":["InMemoryBlockStorage","logFunction","masterchainBlocks","shardchainBlocks","shardBlockNumbers","workchain","shardId","shardBlockNumber","undefined","mcBlockNumber","Error","insertShardBlocks","blockNumbers","Object","keys","map","x","Number","sort","a","b","prevShardBlocks","key","arr","split","module","exports"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/tonweb/src/providers/blockSubscription/InMemoryBlockStorage.js"],"sourcesContent":["/**\n * Storage for storing block numbers that we have already processed.\n * Used by `BlockSubscription`.\n *\n * Dumb in-memory implementation.\n */\nclass InMemoryBlockStorage {\n\n    /**\n     * @param logFunction?   {(text: string) => void}\n     */\n    constructor(logFunction) {\n        this.masterchainBlocks = {}; // mcBlockNumber {number} -> isProcessed {boolean}\n        this.shardchainBlocks = {}; // workchain {number} + shardId {string} + shardBlockNumber {number} -> isProcessed {boolean}\n        this.logFunction = logFunction;\n    }\n\n    /**\n     * @private\n     * Insert new UNprocessed shardchain block numbers\n     * Block number (workchain + shardId + shardBlockNumber) should be IGNORED if it is already in the storage\n     * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n     */\n    async insertShardBlocks(shardBlockNumbers) {\n        for (const {workchain, shardId, shardBlockNumber} of shardBlockNumbers) {\n            if (this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] !== undefined) continue;\n            if (this.logFunction) {\n                this.logFunction('insert shard ' + workchain + ' ' + shardId + ' ' + shardBlockNumber);\n            }\n            // INSERT INTO shardchainBlocks VALUES (workchain, shardId, shardBlockNumber, FALSE);\n            this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] = false;\n        }\n    }\n\n    /**\n     * Insert new processed masterchain block number & new UNprocessed shardchains blocks numbers\n     * Must be in single DB transaction\n     * @param   mcBlockNumber {number}\n     * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n     */\n    async insertBlocks(mcBlockNumber, shardBlockNumbers) {\n        if (this.logFunction) {\n            this.logFunction('mc processed ' + mcBlockNumber);\n        }\n        // INSERT INTO masterchainBlocks VALUES (blockNumber, TRUE);\n        if (this.masterchainBlocks[mcBlockNumber] !== undefined) throw new Error('mc already exists ' + mcBlockNumber);\n        this.masterchainBlocks[mcBlockNumber] = true;\n\n        await this.insertShardBlocks(shardBlockNumbers);\n    }\n\n    /**\n     * Get last processed masterchain block number\n     * @return {Promise<number | undefined>}\n     */\n    async getLastMasterchainBlockNumber() {\n        // SELECT MAX(blockNumber) FROM masterchainBlocks\n        const blockNumbers = Object.keys(this.masterchainBlocks)\n            .map(x => Number(x))\n            .sort((a, b) => b - a);\n        return blockNumbers[0];\n    }\n\n    /**\n     * Set that this shardchain block number processed & insert new UNprocessed shardchains blocks numbers\n     * Must be in single DB transaction\n     * @param   workchain {number}\n     * @param   shardId {string}\n     * @param   shardBlockNumber    {number}\n     * @param   prevShardBlocks    {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n     */\n    async setBlockProcessed(workchain, shardId, shardBlockNumber, prevShardBlocks) {\n        if (this.logFunction) {\n            this.logFunction('shard processed ' + workchain + ' ' + shardId + ' ' + shardBlockNumber);\n        }\n        // UPDATE shardchainBlocks SET processed = TRUE WHERE workchain = ? AND shardId = ? AND shardBlockNumber = ?\n        if (this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] === undefined) throw new Error('shard not exists ' + workchain + '_' + shardId + '_' + shardBlockNumber);\n        this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] = true;\n\n        await this.insertShardBlocks(prevShardBlocks);\n    }\n\n    /**\n     * Get any unprocesed shard block number (order is not important)\n     * @return {Promise<{workchain: number, shardId: string, shardBlockNumber: number}>}\n     */\n    async getUnprocessedShardBlock() {\n        // SELECT workchain, shardId, shardBlockNumber from sharchainBlocks WHERE processed = FALSE LIMIT 1\n        for (let key in this.shardchainBlocks) {\n            if (this.shardchainBlocks[key] === false) {\n                const arr = key.split('_');\n                return {\n                    workchain: Number(arr[0]),\n                    shardId: arr[1],\n                    shardBlockNumber: Number(arr[2]),\n                }\n            }\n        }\n        return undefined;\n    }\n\n}\n\nmodule.exports = {InMemoryBlockStorage};"],"mappings":"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"},"metadata":{},"sourceType":"script"}