{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decrypt = exports.encrypt = exports.supportedAlgorithms = exports.executeKdf = exports.cosmjsSalt = void 0;\nvar crypto_1 = require(\"@cosmjs/crypto\");\nvar encoding_1 = require(\"@cosmjs/encoding\");\n/**\n * A fixed salt is chosen to archive a deterministic password to key derivation.\n * This reduces the scope of a potential rainbow attack to all CosmJS users.\n * Must be 16 bytes due to implementation limitations.\n */\nexports.cosmjsSalt = (0, encoding_1.toAscii)(\"The CosmJS salt.\");\nfunction executeKdf(_x, _x2) {\n  return _executeKdf.apply(this, arguments);\n}\nfunction _executeKdf() {\n  _executeKdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(password, configuration) {\n    var options;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.t0 = configuration.algorithm;\n            _context.next = _context.t0 === \"argon2id\" ? 3 : 7;\n            break;\n          case 3:\n            options = configuration.params;\n            if ((0, crypto_1.isArgon2idOptions)(options)) {\n              _context.next = 6;\n              break;\n            }\n            throw new Error(\"Invalid format of argon2id params\");\n          case 6:\n            return _context.abrupt(\"return\", crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options));\n          case 7:\n            throw new Error(\"Unsupported KDF algorithm\");\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _executeKdf.apply(this, arguments);\n}\nexports.executeKdf = executeKdf;\nexports.supportedAlgorithms = {\n  xchacha20poly1305Ietf: \"xchacha20poly1305-ietf\"\n};\nfunction encrypt(_x3, _x4, _x5) {\n  return _encrypt.apply(this, arguments);\n}\nfunction _encrypt() {\n  _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(plaintext, encryptionKey, config) {\n    var nonce;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.t0 = config.algorithm;\n            _context2.next = _context2.t0 === exports.supportedAlgorithms.xchacha20poly1305Ietf ? 3 : 14;\n            break;\n          case 3:\n            nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength); // Prepend fixed-length nonce to ciphertext as suggested in the example from https://github.com/jedisct1/libsodium.js#api\n            _context2.t1 = Uint8Array;\n            _context2.t2 = [];\n            _context2.t3 = _toConsumableArray(nonce);\n            _context2.t4 = _toConsumableArray;\n            _context2.next = 10;\n            return crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce);\n          case 10:\n            _context2.t5 = _context2.sent;\n            _context2.t6 = (0, _context2.t4)(_context2.t5);\n            _context2.t7 = _context2.t2.concat.call(_context2.t2, _context2.t3, _context2.t6);\n            return _context2.abrupt(\"return\", new _context2.t1(_context2.t7));\n          case 14:\n            throw new Error(\"Unsupported encryption algorithm: '\".concat(config.algorithm, \"'\"));\n          case 15:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _encrypt.apply(this, arguments);\n}\nexports.encrypt = encrypt;\nfunction decrypt(_x6, _x7, _x8) {\n  return _decrypt.apply(this, arguments);\n}\nfunction _decrypt() {\n  _decrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(ciphertext, encryptionKey, config) {\n    var nonce;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.t0 = config.algorithm;\n            _context3.next = _context3.t0 === exports.supportedAlgorithms.xchacha20poly1305Ietf ? 3 : 5;\n            break;\n          case 3:\n            nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);\n            return _context3.abrupt(\"return\", crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce));\n          case 5:\n            throw new Error(\"Unsupported encryption algorithm: '\".concat(config.algorithm, \"'\"));\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _decrypt.apply(this, arguments);\n}\nexports.decrypt = decrypt;","map":{"version":3,"sources":["../src/wallet.ts"],"names":[],"mappings":";;;;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;AAOA,IAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAEA;;;;AAIG;AACU,OAAA,CAAA,UAAU,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,OAAO,EAAC,kBAAkB,CAAC;AAAC,SAWhC,UAAU;EAAA;AAAA;AAAA;EAAA,yEAAzB,iBAA0B,QAAgB,EAAE,aAA+B;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,cACxE,aAAa,CAAC,SAAS;YAAA,gCACxB,UAAU;YAAA;UAAA;YACP,OAAO,GAAG,aAAa,CAAC,MAAM;YAAA,IAC/B,CAAA,CAAA,EAAA,QAAA,CAAA,iBAAiB,EAAC,OAAO,CAAC;cAAA;cAAA;YAAA;YAAA,MAAQ,IAAI,KAAK,CAAC,mCAAmC,CAAC;UAAA;YAAA,iCAC9E,QAAA,CAAA,QAAQ,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAA,CAAA,UAAU,EAAE,OAAO,CAAC;UAAA;YAAA,MAGhD,IAAI,KAAK,CAAC,2BAA2B,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAEjD;EAAA;AAAA;AAVD,OAAA,CAAA,UAAA,GAAA,UAAA;AAyBa,OAAA,CAAA,mBAAmB,GAAG;EACjC,qBAAqB,EAAE;CACxB;AAAC,SAEoB,OAAO;EAAA;AAAA;AAAA;EAAA,sEAAtB,kBACL,SAAqB,EACrB,aAAyB,EACzB,MAA+B;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,eAEvB,MAAM,CAAC,SAAS;YAAA,kCACjB,OAAA,CAAA,mBAAmB,CAAC,qBAAqB;YAAA;UAAA;YACtC,KAAK,GAAG,QAAA,CAAA,MAAM,CAAC,QAAQ,CAAC,QAAA,CAAA,oBAAoB,CAAC,EACnD;YAAA,eACW,UAAU;YAAA;YAAA,kCAChB,KAAK;YAAA;YAAA;YAAA,OACE,QAAA,CAAA,qBAAqB,CAAC,OAAO,CAAC,SAAS,EAAE,aAAa,EAAE,KAAK,CAAC;UAAA;YAAA;YAAA;YAAA;YAAA;UAAA;YAAA,MAIpE,IAAI,KAAK,8CAAuC,MAAM,CAAC,SAAS,OAAI;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAE/E;EAAA;AAAA;AAjBD,OAAA,CAAA,OAAA,GAAA,OAAA;AAiBC,SAEqB,OAAO;EAAA;AAAA;AAAA;EAAA,sEAAtB,kBACL,UAAsB,EACtB,aAAyB,EACzB,MAA+B;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,eAEvB,MAAM,CAAC,SAAS;YAAA,kCACjB,OAAA,CAAA,mBAAmB,CAAC,qBAAqB;YAAA;UAAA;YACtC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,QAAA,CAAA,oBAAoB,CAAC;YAAA,kCAChD,QAAA,CAAA,qBAAqB,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,QAAA,CAAA,oBAAoB,CAAC,EAAE,aAAa,EAAE,KAAK,CAAC;UAAA;YAAA,MAG5F,IAAI,KAAK,8CAAuC,MAAM,CAAC,SAAS,OAAI;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAE/E;EAAA;AAAA;AAbD,OAAA,CAAA,OAAA,GAAA,OAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decrypt = exports.encrypt = exports.supportedAlgorithms = exports.executeKdf = exports.cosmjsSalt = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\n/**\n * A fixed salt is chosen to archive a deterministic password to key derivation.\n * This reduces the scope of a potential rainbow attack to all CosmJS users.\n * Must be 16 bytes due to implementation limitations.\n */\nexports.cosmjsSalt = (0, encoding_1.toAscii)(\"The CosmJS salt.\");\nasync function executeKdf(password, configuration) {\n    switch (configuration.algorithm) {\n        case \"argon2id\": {\n            const options = configuration.params;\n            if (!(0, crypto_1.isArgon2idOptions)(options))\n                throw new Error(\"Invalid format of argon2id params\");\n            return crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);\n        }\n        default:\n            throw new Error(\"Unsupported KDF algorithm\");\n    }\n}\nexports.executeKdf = executeKdf;\nexports.supportedAlgorithms = {\n    xchacha20poly1305Ietf: \"xchacha20poly1305-ietf\",\n};\nasync function encrypt(plaintext, encryptionKey, config) {\n    switch (config.algorithm) {\n        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {\n            const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);\n            // Prepend fixed-length nonce to ciphertext as suggested in the example from https://github.com/jedisct1/libsodium.js#api\n            return new Uint8Array([\n                ...nonce,\n                ...(await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)),\n            ]);\n        }\n        default:\n            throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);\n    }\n}\nexports.encrypt = encrypt;\nasync function decrypt(ciphertext, encryptionKey, config) {\n    switch (config.algorithm) {\n        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {\n            const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);\n            return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);\n        }\n        default:\n            throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);\n    }\n}\nexports.decrypt = decrypt;\n//# sourceMappingURL=wallet.js.map"]},"metadata":{},"sourceType":"script"}