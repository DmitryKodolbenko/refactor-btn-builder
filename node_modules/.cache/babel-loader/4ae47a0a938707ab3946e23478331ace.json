{"ast":null,"code":"const {\n  Contract\n} = require(\"../index.js\");\nconst {\n  Cell\n} = require(\"../../boc\");\nconst {\n  nacl,\n  stringToBytes,\n  Address,\n  BN\n} = require(\"../../utils\");\n\n/**\n * Abstract standard wallet class\n */\nclass WalletContract extends Contract {\n  /**\n   * @param provider    {HttpProvider}\n   * @param options?    {{code: Uint8Array, publicKey?: Uint8Array, address?: Address | string, wc?: number}}\n   */\n  constructor(provider, options) {\n    if (!options.publicKey && !options.address) throw new Error('WalletContract required publicKey or address in options');\n    super(provider, options);\n    this.methods = {\n      /**\n       * @param   params {{secretKey: Uint8Array, toAddress: Address | string, amount: BN | number, seqno: number, payload: string | Uint8Array | Cell, sendMode: number, stateInit?: Cell}}\n       */\n      transfer: params => Contract.createMethod(provider, this.createTransferMessage(params.secretKey, params.toAddress, params.amount, params.seqno, params.payload, params.sendMode, !Boolean(params.secretKey), params.stateInit)),\n      seqno: () => {\n        return {\n          /**\n           * @return {Promise<number>}\n           */\n          call: async () => {\n            const address = await this.getAddress();\n            let n = null;\n            try {\n              n = (await provider.call2(address.toString(), 'seqno')).toNumber();\n            } catch (e) {}\n            return n;\n          }\n        };\n      }\n    };\n\n    /**\n     * @param secretKey {Uint8Array}\n     */\n    this.deploy = secretKey => Contract.createMethod(provider, this.createInitExternalMessage(secretKey));\n  }\n  getName() {\n    throw new Error('override me');\n  }\n\n  /**\n   * @override\n   * @protected\n   * @return {Cell} cell contains wallet data\n   */\n  createDataCell() {\n    // 4 byte seqno, 32 byte publicKey\n    const cell = new Cell();\n    cell.bits.writeUint(0, 32); // seqno\n    cell.bits.writeBytes(this.options.publicKey);\n    return cell;\n  }\n\n  /**\n   * @protected\n   * @param   seqno?   {number}\n   * @return {Cell}\n   */\n  createSigningMessage(seqno) {\n    seqno = seqno || 0;\n    const cell = new Cell();\n    cell.bits.writeUint(seqno, 32);\n    return cell;\n  }\n\n  /**\n   * External message for initialization\n   * @param secretKey  {Uint8Array} nacl.KeyPair.secretKey\n   * @return {{address: Address, message: Cell, body: Cell, sateInit: Cell, code: Cell, data: Cell}}\n   */\n  async createInitExternalMessage(secretKey) {\n    if (!this.options.publicKey) {\n      const keyPair = nacl.sign.keyPair.fromSecretKey(secretKey);\n      this.options.publicKey = keyPair.publicKey;\n    }\n    const {\n      stateInit,\n      address,\n      code,\n      data\n    } = await this.createStateInit();\n    const signingMessage = this.createSigningMessage();\n    const signature = nacl.sign.detached(await signingMessage.hash(), secretKey);\n    const body = new Cell();\n    body.bits.writeBytes(signature);\n    body.writeCell(signingMessage);\n    const header = Contract.createExternalMessageHeader(address);\n    const externalMessage = Contract.createCommonMsgInfo(header, stateInit, body);\n    return {\n      address: address,\n      message: externalMessage,\n      body,\n      signingMessage,\n      stateInit,\n      code,\n      data\n    };\n  }\n\n  /**\n   * @protected\n   * @param signingMessage {Cell}\n   * @param secretKey {Uint8Array}  nacl.KeyPair.secretKey\n   * @param seqno {number}\n   * @param dummySignature?    {boolean}\n   * @return {Promise<{address: Address, signature: Uint8Array, message: Cell, cell: Cell, body: Cell, resultMessage: Cell}>}\n   */\n  async createExternalMessage(signingMessage, secretKey, seqno) {\n    let dummySignature = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const signature = dummySignature ? new Uint8Array(64) : nacl.sign.detached(await signingMessage.hash(), secretKey);\n    const body = new Cell();\n    body.bits.writeBytes(signature);\n    body.writeCell(signingMessage);\n    let stateInit = null,\n      code = null,\n      data = null;\n    if (seqno === 0) {\n      if (!this.options.publicKey) {\n        const keyPair = nacl.sign.keyPair.fromSecretKey(secretKey);\n        this.options.publicKey = keyPair.publicKey;\n      }\n      const deploy = await this.createStateInit();\n      stateInit = deploy.stateInit;\n      code = deploy.code;\n      data = deploy.data;\n    }\n    const selfAddress = await this.getAddress();\n    const header = Contract.createExternalMessageHeader(selfAddress);\n    const resultMessage = Contract.createCommonMsgInfo(header, stateInit, body);\n    return {\n      address: selfAddress,\n      message: resultMessage,\n      // old wallet_send_generate_external_message\n\n      body: body,\n      signature: signature,\n      signingMessage: signingMessage,\n      stateInit,\n      code,\n      data\n    };\n  }\n\n  /**\n   * @param secretKey {Uint8Array}  nacl.KeyPair.secretKey\n   * @param address   {Address | string}\n   * @param amount    {BN | number} in nanograms\n   * @param seqno {number}\n   * @param payload?   {string | Uint8Array | Cell}\n   * @param sendMode?  {number}\n   * @param dummySignature?    {boolean}\n   * @param stateInit? {Cell}\n   * @return {Promise<{address: Address, signature: Uint8Array, message: Cell, cell: Cell, body: Cell, resultMessage: Cell}>}\n   */\n  async createTransferMessage(secretKey, address, amount, seqno) {\n    let payload = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    let sendMode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 3;\n    let dummySignature = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    let stateInit = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    let payloadCell = new Cell();\n    if (payload) {\n      if (payload.refs) {\n        // is Cell\n        payloadCell = payload;\n      } else if (typeof payload === 'string') {\n        if (payload.length > 0) {\n          payloadCell.bits.writeUint(0, 32);\n          const payloadBytes = new TextEncoder().encode(payload);\n          payloadCell.bits.writeBytes(payloadBytes);\n        }\n      } else {\n        payloadCell.bits.writeBytes(payload);\n      }\n    }\n    const orderHeader = Contract.createInternalMessageHeader(new Address(address), new BN(amount));\n    const order = Contract.createCommonMsgInfo(orderHeader, stateInit, payloadCell);\n    const signingMessage = this.createSigningMessage(seqno);\n    signingMessage.bits.writeUint8(sendMode);\n    signingMessage.refs.push(order);\n    return this.createExternalMessage(signingMessage, secretKey, seqno, dummySignature);\n  }\n}\nmodule.exports = {\n  WalletContract\n};","map":{"version":3,"names":["Contract","require","Cell","nacl","stringToBytes","Address","BN","WalletContract","constructor","provider","options","publicKey","address","Error","methods","transfer","params","createMethod","createTransferMessage","secretKey","toAddress","amount","seqno","payload","sendMode","Boolean","stateInit","call","getAddress","n","call2","toString","toNumber","e","deploy","createInitExternalMessage","getName","createDataCell","cell","bits","writeUint","writeBytes","createSigningMessage","keyPair","sign","fromSecretKey","code","data","createStateInit","signingMessage","signature","detached","hash","body","writeCell","header","createExternalMessageHeader","externalMessage","createCommonMsgInfo","message","createExternalMessage","dummySignature","Uint8Array","selfAddress","resultMessage","payloadCell","refs","length","payloadBytes","TextEncoder","encode","orderHeader","createInternalMessageHeader","order","writeUint8","push","module","exports"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/tonweb/src/contract/wallet/WalletContract.js"],"sourcesContent":["const {Contract} = require(\"../index.js\");\nconst {Cell} = require(\"../../boc\");\nconst {nacl, stringToBytes, Address, BN} = require(\"../../utils\");\n\n/**\n * Abstract standard wallet class\n */\nclass WalletContract extends Contract {\n    /**\n     * @param provider    {HttpProvider}\n     * @param options?    {{code: Uint8Array, publicKey?: Uint8Array, address?: Address | string, wc?: number}}\n     */\n    constructor(provider, options) {\n        if (!options.publicKey && !options.address) throw new Error('WalletContract required publicKey or address in options')\n        super(provider, options);\n\n        this.methods = {\n            /**\n             * @param   params {{secretKey: Uint8Array, toAddress: Address | string, amount: BN | number, seqno: number, payload: string | Uint8Array | Cell, sendMode: number, stateInit?: Cell}}\n             */\n            transfer: (params) => Contract.createMethod(provider, this.createTransferMessage(params.secretKey, params.toAddress, params.amount, params.seqno, params.payload, params.sendMode, !Boolean(params.secretKey), params.stateInit)),\n\n            seqno: () => {\n                return {\n                    /**\n                     * @return {Promise<number>}\n                     */\n                    call: async () => {\n                        const address = await this.getAddress();\n                        let n = null;\n                        try {\n                            n = (await provider.call2(address.toString(), 'seqno')).toNumber();\n                        } catch (e) {\n                        }\n                        return n;\n                    }\n                }\n            }\n        }\n\n        /**\n         * @param secretKey {Uint8Array}\n         */\n        this.deploy = (secretKey) => Contract.createMethod(provider, this.createInitExternalMessage(secretKey));\n    }\n\n    getName() {\n        throw new Error('override me');\n    }\n\n    /**\n     * @override\n     * @protected\n     * @return {Cell} cell contains wallet data\n     */\n    createDataCell() {\n        // 4 byte seqno, 32 byte publicKey\n        const cell = new Cell();\n        cell.bits.writeUint(0, 32); // seqno\n        cell.bits.writeBytes(this.options.publicKey);\n        return cell;\n    }\n\n    /**\n     * @protected\n     * @param   seqno?   {number}\n     * @return {Cell}\n     */\n    createSigningMessage(seqno) {\n        seqno = seqno || 0;\n        const cell = new Cell();\n        cell.bits.writeUint(seqno, 32);\n        return cell;\n    }\n\n    /**\n     * External message for initialization\n     * @param secretKey  {Uint8Array} nacl.KeyPair.secretKey\n     * @return {{address: Address, message: Cell, body: Cell, sateInit: Cell, code: Cell, data: Cell}}\n     */\n    async createInitExternalMessage(secretKey) {\n        if (!this.options.publicKey) {\n            const keyPair = nacl.sign.keyPair.fromSecretKey(secretKey)\n            this.options.publicKey = keyPair.publicKey;\n        }\n        const {stateInit, address, code, data} = await this.createStateInit();\n\n        const signingMessage = this.createSigningMessage();\n        const signature = nacl.sign.detached(await signingMessage.hash(), secretKey);\n\n        const body = new Cell();\n        body.bits.writeBytes(signature);\n        body.writeCell(signingMessage);\n\n        const header = Contract.createExternalMessageHeader(address);\n        const externalMessage = Contract.createCommonMsgInfo(header, stateInit, body);\n\n        return {\n            address: address,\n            message: externalMessage,\n\n            body,\n            signingMessage,\n            stateInit,\n            code,\n            data,\n        };\n    }\n\n    /**\n     * @protected\n     * @param signingMessage {Cell}\n     * @param secretKey {Uint8Array}  nacl.KeyPair.secretKey\n     * @param seqno {number}\n     * @param dummySignature?    {boolean}\n     * @return {Promise<{address: Address, signature: Uint8Array, message: Cell, cell: Cell, body: Cell, resultMessage: Cell}>}\n     */\n    async createExternalMessage(\n        signingMessage,\n        secretKey,\n        seqno,\n        dummySignature = false\n    ) {\n        const signature = dummySignature ? new Uint8Array(64) : nacl.sign.detached(await signingMessage.hash(), secretKey);\n\n        const body = new Cell();\n        body.bits.writeBytes(signature);\n        body.writeCell(signingMessage);\n\n        let stateInit = null, code = null, data = null;\n\n        if (seqno === 0) {\n            if (!this.options.publicKey) {\n                const keyPair = nacl.sign.keyPair.fromSecretKey(secretKey)\n                this.options.publicKey = keyPair.publicKey;\n            }\n            const deploy = await this.createStateInit();\n            stateInit = deploy.stateInit;\n            code = deploy.code;\n            data = deploy.data;\n        }\n\n        const selfAddress = await this.getAddress();\n        const header = Contract.createExternalMessageHeader(selfAddress);\n        const resultMessage = Contract.createCommonMsgInfo(header, stateInit, body);\n\n        return {\n            address: selfAddress,\n            message: resultMessage, // old wallet_send_generate_external_message\n\n            body: body,\n            signature: signature,\n            signingMessage: signingMessage,\n\n            stateInit,\n            code,\n            data,\n        };\n    }\n\n    /**\n     * @param secretKey {Uint8Array}  nacl.KeyPair.secretKey\n     * @param address   {Address | string}\n     * @param amount    {BN | number} in nanograms\n     * @param seqno {number}\n     * @param payload?   {string | Uint8Array | Cell}\n     * @param sendMode?  {number}\n     * @param dummySignature?    {boolean}\n     * @param stateInit? {Cell}\n     * @return {Promise<{address: Address, signature: Uint8Array, message: Cell, cell: Cell, body: Cell, resultMessage: Cell}>}\n     */\n    async createTransferMessage(\n        secretKey,\n        address,\n        amount,\n        seqno,\n        payload = \"\",\n        sendMode = 3,\n        dummySignature = false,\n        stateInit = null\n    ) {\n        let payloadCell = new Cell();\n        if (payload) {\n            if (payload.refs) { // is Cell\n                payloadCell = payload;\n            } else if (typeof payload === 'string') {\n                if (payload.length > 0) {\n                    payloadCell.bits.writeUint(0, 32);\n                    const payloadBytes = new TextEncoder().encode(payload);\n                    payloadCell.bits.writeBytes(payloadBytes);\n                }\n            } else {\n                payloadCell.bits.writeBytes(payload)\n            }\n        }\n\n        const orderHeader = Contract.createInternalMessageHeader(new Address(address), new BN(amount));\n        const order = Contract.createCommonMsgInfo(orderHeader, stateInit, payloadCell);\n        const signingMessage = this.createSigningMessage(seqno);\n        signingMessage.bits.writeUint8(sendMode);\n        signingMessage.refs.push(order);\n\n        return this.createExternalMessage(signingMessage, secretKey, seqno, dummySignature);\n    }\n}\n\nmodule.exports = {WalletContract};"],"mappings":"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"},"metadata":{},"sourceType":"script"}