{"ast":null,"code":"import { eqStrict } from './Eq';\nimport { constant, constTrue, pipe } from './function';\n// -------------------------------------------------------------------------------------\n// defaults\n// -------------------------------------------------------------------------------------\n/**\n * @category defaults\n * @since 2.10.0\n */\nexport var equalsDefault = function equalsDefault(compare) {\n  return function (first, second) {\n    return first === second || compare(first, second) === 0;\n  };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromCompare = function fromCompare(_compare) {\n  return {\n    equals: equalsDefault(_compare),\n    compare: function compare(first, second) {\n      return first === second ? 0 : _compare(first, second);\n    }\n  };\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Given a tuple of `Ord`s returns an `Ord` for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Ord'\n * import * as B from 'fp-ts/boolean'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n *\n * const O = tuple(S.Ord, N.Ord, B.Ord)\n * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)\n *\n * @since 2.10.0\n */\nexport var tuple = function tuple() {\n  var ords = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    ords[_i] = arguments[_i];\n  }\n  return fromCompare(function (first, second) {\n    var i = 0;\n    for (; i < ords.length - 1; i++) {\n      var r = ords[i].compare(first[i], second[i]);\n      if (r !== 0) {\n        return r;\n      }\n    }\n    return ords[i].compare(first[i], second[i]);\n  });\n};\n/**\n * @since 2.10.0\n */\nexport var reverse = function reverse(O) {\n  return fromCompare(function (first, second) {\n    return O.compare(second, first);\n  });\n};\n/* istanbul ignore next */\nvar contramap_ = function contramap_(fa, f) {\n  return pipe(fa, contramap(f));\n};\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Ord<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for ordering (meaning we have an `Ord<X>`)\n *\n * For example, given the following `User` type, there are lots of possible choices for `X`,\n * but let's say we want to sort a list of users by `lastName`.\n *\n * If we have a way of comparing `lastName`s for ordering (`ordLastName: Ord<string>`) and we know how to go from `User -> string`,\n * using `contramap` we can do this\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import { contramap, Ord } from 'fp-ts/Ord'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * interface User {\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const ordLastName: Ord<string> = S.Ord\n *\n * const ordByLastName: Ord<User> = pipe(\n *   ordLastName,\n *   contramap((user) => user.lastName)\n * )\n *\n * assert.deepStrictEqual(\n *   RA.sort(ordByLastName)([\n *     { firstName: 'a', lastName: 'd' },\n *     { firstName: 'c', lastName: 'b' }\n *   ]),\n *   [\n *     { firstName: 'c', lastName: 'b' },\n *     { firstName: 'a', lastName: 'd' }\n *   ]\n * )\n *\n * @since 2.0.0\n */\nexport var contramap = function contramap(f) {\n  return function (fa) {\n    return fromCompare(function (first, second) {\n      return fa.compare(f(first), f(second));\n    });\n  };\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Ord';\n/**\n * A typical use case for the `Semigroup` instance of `Ord` is merging two or more orderings.\n *\n * For example the following snippet builds an `Ord` for a type `User` which\n * sorts by `created` date descending, and **then** `lastName`\n *\n * @example\n * import * as D from 'fp-ts/Date'\n * import { pipe } from 'fp-ts/function'\n * import { contramap, getSemigroup, Ord, reverse } from 'fp-ts/Ord'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * interface User {\n *   readonly id: string\n *   readonly lastName: string\n *   readonly created: Date\n * }\n *\n * const ordByLastName: Ord<User> = pipe(\n *   S.Ord,\n *   contramap((user) => user.lastName)\n * )\n *\n * const ordByCreated: Ord<User> = pipe(\n *   D.Ord,\n *   contramap((user) => user.created)\n * )\n *\n * const ordUserByCreatedDescThenLastName = getSemigroup<User>().concat(\n *   reverse(ordByCreated),\n *   ordByLastName\n * )\n *\n * assert.deepStrictEqual(\n *   RA.sort(ordUserByCreatedDescThenLastName)([\n *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) },\n *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) }\n *   ]),\n *   [\n *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) },\n *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) }\n *   ]\n * )\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function getSemigroup() {\n  return {\n    concat: function concat(first, second) {\n      return fromCompare(function (a, b) {\n        var ox = first.compare(a, b);\n        return ox !== 0 ? ox : second.compare(a, b);\n      });\n    }\n  };\n};\n/**\n * Returns a `Monoid` such that:\n *\n * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`\n * - its `empty` value is an `Ord` that always considers compared elements equal\n *\n * @example\n * import { sort } from 'fp-ts/Array'\n * import { contramap, reverse, getMonoid } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as B from 'fp-ts/boolean'\n * import { pipe } from 'fp-ts/function'\n * import { concatAll } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * interface User {\n *   readonly id: number\n *   readonly name: string\n *   readonly age: number\n *   readonly rememberMe: boolean\n * }\n *\n * const byName = pipe(\n *   S.Ord,\n *   contramap((p: User) => p.name)\n * )\n *\n * const byAge = pipe(\n *   N.Ord,\n *   contramap((p: User) => p.age)\n * )\n *\n * const byRememberMe = pipe(\n *   B.Ord,\n *   contramap((p: User) => p.rememberMe)\n * )\n *\n * const M = getMonoid<User>()\n *\n * const users: Array<User> = [\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }\n * ]\n *\n * // sort by name, then by age, then by `rememberMe`\n * const O1 = concatAll(M)([byName, byAge, byRememberMe])\n * assert.deepStrictEqual(sort(O1)(users), [\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * // now `rememberMe = true` first, then by name, then by age\n * const O2 = concatAll(M)([reverse(byRememberMe), byName, byAge])\n * assert.deepStrictEqual(sort(O2)(users), [\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * @category instances\n * @since 2.4.0\n */\nexport var getMonoid = function getMonoid() {\n  return {\n    concat: getSemigroup().concat,\n    empty: fromCompare(function () {\n      return 0;\n    })\n  };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n  URI: URI,\n  contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var trivial = {\n  equals: constTrue,\n  compare: /*#__PURE__*/constant(0)\n};\n/**\n * @since 2.11.0\n */\nexport var equals = function equals(O) {\n  return function (second) {\n    return function (first) {\n      return first === second || O.compare(first, second) === 0;\n    };\n  };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly less than_ another\n *\n * @since 2.0.0\n */\nexport var lt = function lt(O) {\n  return function (first, second) {\n    return O.compare(first, second) === -1;\n  };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly greater than_ another\n *\n * @since 2.0.0\n */\nexport var gt = function gt(O) {\n  return function (first, second) {\n    return O.compare(first, second) === 1;\n  };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly less than_ another\n *\n * @since 2.0.0\n */\nexport var leq = function leq(O) {\n  return function (first, second) {\n    return O.compare(first, second) !== 1;\n  };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly greater than_ another\n *\n * @since 2.0.0\n */\nexport var geq = function geq(O) {\n  return function (first, second) {\n    return O.compare(first, second) !== -1;\n  };\n};\n// TODO: curry in v3\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nexport var min = function min(O) {\n  return function (first, second) {\n    return first === second || O.compare(first, second) < 1 ? first : second;\n  };\n};\n// TODO: curry in v3\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nexport var max = function max(O) {\n  return function (first, second) {\n    return first === second || O.compare(first, second) > -1 ? first : second;\n  };\n};\n/**\n * Clamp a value between a minimum and a maximum\n *\n * @since 2.0.0\n */\nexport var clamp = function clamp(O) {\n  var minO = min(O);\n  var maxO = max(O);\n  return function (low, hi) {\n    return function (a) {\n      return maxO(minO(a, hi), low);\n    };\n  };\n};\n/**\n * Test whether a value is between a minimum and a maximum (inclusive)\n *\n * @since 2.0.0\n */\nexport var between = function between(O) {\n  var ltO = lt(O);\n  var gtO = gt(O);\n  return function (low, hi) {\n    return function (a) {\n      return ltO(a, low) || gtO(a, hi) ? false : true;\n    };\n  };\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleOrd = tuple;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualOrd = reverse;\n/**\n * Use [`Contravariant`](#contravariant) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ord = Contravariant;\n// default compare for primitive types\nfunction compare(first, second) {\n  return first < second ? -1 : first > second ? 1 : 0;\n}\nvar strictOrd = {\n  equals: eqStrict.equals,\n  compare: compare\n};\n/**\n * Use [`Ord`](./boolean.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordBoolean = strictOrd;\n/**\n * Use [`Ord`](./string.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordString = strictOrd;\n/**\n * Use [`Ord`](./number.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordNumber = strictOrd;\n/**\n * Use [`Ord`](./Date.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordDate = /*#__PURE__*/pipe(ordNumber, /*#__PURE__*/\ncontramap(function (date) {\n  return date.valueOf();\n}));","map":{"version":3,"names":["eqStrict","constant","constTrue","pipe","equalsDefault","compare","first","second","fromCompare","equals","tuple","ords","_i","arguments","length","i","r","reverse","O","contramap_","fa","f","contramap","URI","getSemigroup","concat","a","b","ox","getMonoid","empty","Contravariant","trivial","lt","gt","leq","geq","min","max","clamp","minO","maxO","low","hi","between","ltO","gtO","getTupleOrd","getDualOrd","ord","strictOrd","ordBoolean","ordString","ordNumber","ordDate","date","valueOf"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/fp-ts/es6/Ord.js"],"sourcesContent":["import { eqStrict } from './Eq';\nimport { constant, constTrue, pipe } from './function';\n// -------------------------------------------------------------------------------------\n// defaults\n// -------------------------------------------------------------------------------------\n/**\n * @category defaults\n * @since 2.10.0\n */\nexport var equalsDefault = function (compare) {\n    return function (first, second) {\n        return first === second || compare(first, second) === 0;\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromCompare = function (compare) { return ({\n    equals: equalsDefault(compare),\n    compare: function (first, second) { return (first === second ? 0 : compare(first, second)); }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Given a tuple of `Ord`s returns an `Ord` for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Ord'\n * import * as B from 'fp-ts/boolean'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n *\n * const O = tuple(S.Ord, N.Ord, B.Ord)\n * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var ords = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        ords[_i] = arguments[_i];\n    }\n    return fromCompare(function (first, second) {\n        var i = 0;\n        for (; i < ords.length - 1; i++) {\n            var r = ords[i].compare(first[i], second[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return ords[i].compare(first[i], second[i]);\n    });\n};\n/**\n * @since 2.10.0\n */\nexport var reverse = function (O) { return fromCompare(function (first, second) { return O.compare(second, first); }); };\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return pipe(fa, contramap(f)); };\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Ord<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for ordering (meaning we have an `Ord<X>`)\n *\n * For example, given the following `User` type, there are lots of possible choices for `X`,\n * but let's say we want to sort a list of users by `lastName`.\n *\n * If we have a way of comparing `lastName`s for ordering (`ordLastName: Ord<string>`) and we know how to go from `User -> string`,\n * using `contramap` we can do this\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import { contramap, Ord } from 'fp-ts/Ord'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * interface User {\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const ordLastName: Ord<string> = S.Ord\n *\n * const ordByLastName: Ord<User> = pipe(\n *   ordLastName,\n *   contramap((user) => user.lastName)\n * )\n *\n * assert.deepStrictEqual(\n *   RA.sort(ordByLastName)([\n *     { firstName: 'a', lastName: 'd' },\n *     { firstName: 'c', lastName: 'b' }\n *   ]),\n *   [\n *     { firstName: 'c', lastName: 'b' },\n *     { firstName: 'a', lastName: 'd' }\n *   ]\n * )\n *\n * @since 2.0.0\n */\nexport var contramap = function (f) { return function (fa) {\n    return fromCompare(function (first, second) { return fa.compare(f(first), f(second)); });\n}; };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Ord';\n/**\n * A typical use case for the `Semigroup` instance of `Ord` is merging two or more orderings.\n *\n * For example the following snippet builds an `Ord` for a type `User` which\n * sorts by `created` date descending, and **then** `lastName`\n *\n * @example\n * import * as D from 'fp-ts/Date'\n * import { pipe } from 'fp-ts/function'\n * import { contramap, getSemigroup, Ord, reverse } from 'fp-ts/Ord'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * interface User {\n *   readonly id: string\n *   readonly lastName: string\n *   readonly created: Date\n * }\n *\n * const ordByLastName: Ord<User> = pipe(\n *   S.Ord,\n *   contramap((user) => user.lastName)\n * )\n *\n * const ordByCreated: Ord<User> = pipe(\n *   D.Ord,\n *   contramap((user) => user.created)\n * )\n *\n * const ordUserByCreatedDescThenLastName = getSemigroup<User>().concat(\n *   reverse(ordByCreated),\n *   ordByLastName\n * )\n *\n * assert.deepStrictEqual(\n *   RA.sort(ordUserByCreatedDescThenLastName)([\n *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) },\n *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) }\n *   ]),\n *   [\n *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) },\n *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) }\n *   ]\n * )\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) {\n        return fromCompare(function (a, b) {\n            var ox = first.compare(a, b);\n            return ox !== 0 ? ox : second.compare(a, b);\n        });\n    }\n}); };\n/**\n * Returns a `Monoid` such that:\n *\n * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`\n * - its `empty` value is an `Ord` that always considers compared elements equal\n *\n * @example\n * import { sort } from 'fp-ts/Array'\n * import { contramap, reverse, getMonoid } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as B from 'fp-ts/boolean'\n * import { pipe } from 'fp-ts/function'\n * import { concatAll } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * interface User {\n *   readonly id: number\n *   readonly name: string\n *   readonly age: number\n *   readonly rememberMe: boolean\n * }\n *\n * const byName = pipe(\n *   S.Ord,\n *   contramap((p: User) => p.name)\n * )\n *\n * const byAge = pipe(\n *   N.Ord,\n *   contramap((p: User) => p.age)\n * )\n *\n * const byRememberMe = pipe(\n *   B.Ord,\n *   contramap((p: User) => p.rememberMe)\n * )\n *\n * const M = getMonoid<User>()\n *\n * const users: Array<User> = [\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }\n * ]\n *\n * // sort by name, then by age, then by `rememberMe`\n * const O1 = concatAll(M)([byName, byAge, byRememberMe])\n * assert.deepStrictEqual(sort(O1)(users), [\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * // now `rememberMe = true` first, then by name, then by age\n * const O2 = concatAll(M)([reverse(byRememberMe), byName, byAge])\n * assert.deepStrictEqual(sort(O2)(users), [\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * @category instances\n * @since 2.4.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: fromCompare(function () { return 0; })\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var trivial = {\n    equals: constTrue,\n    compare: /*#__PURE__*/ constant(0)\n};\n/**\n * @since 2.11.0\n */\nexport var equals = function (O) {\n    return function (second) {\n        return function (first) {\n            return first === second || O.compare(first, second) === 0;\n        };\n    };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly less than_ another\n *\n * @since 2.0.0\n */\nexport var lt = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) === -1;\n    };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly greater than_ another\n *\n * @since 2.0.0\n */\nexport var gt = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) === 1;\n    };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly less than_ another\n *\n * @since 2.0.0\n */\nexport var leq = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) !== 1;\n    };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly greater than_ another\n *\n * @since 2.0.0\n */\nexport var geq = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) !== -1;\n    };\n};\n// TODO: curry in v3\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nexport var min = function (O) {\n    return function (first, second) {\n        return first === second || O.compare(first, second) < 1 ? first : second;\n    };\n};\n// TODO: curry in v3\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nexport var max = function (O) {\n    return function (first, second) {\n        return first === second || O.compare(first, second) > -1 ? first : second;\n    };\n};\n/**\n * Clamp a value between a minimum and a maximum\n *\n * @since 2.0.0\n */\nexport var clamp = function (O) {\n    var minO = min(O);\n    var maxO = max(O);\n    return function (low, hi) { return function (a) { return maxO(minO(a, hi), low); }; };\n};\n/**\n * Test whether a value is between a minimum and a maximum (inclusive)\n *\n * @since 2.0.0\n */\nexport var between = function (O) {\n    var ltO = lt(O);\n    var gtO = gt(O);\n    return function (low, hi) { return function (a) { return ltO(a, low) || gtO(a, hi) ? false : true; }; };\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleOrd = tuple;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualOrd = reverse;\n/**\n * Use [`Contravariant`](#contravariant) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ord = Contravariant;\n// default compare for primitive types\nfunction compare(first, second) {\n    return first < second ? -1 : first > second ? 1 : 0;\n}\nvar strictOrd = {\n    equals: eqStrict.equals,\n    compare: compare\n};\n/**\n * Use [`Ord`](./boolean.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordBoolean = strictOrd;\n/**\n * Use [`Ord`](./string.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordString = strictOrd;\n/**\n * Use [`Ord`](./number.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordNumber = strictOrd;\n/**\n * Use [`Ord`](./Date.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordDate = /*#__PURE__*/ pipe(ordNumber, \n/*#__PURE__*/\ncontramap(function (date) { return date.valueOf(); }));\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,MAAM;AAC/B,SAASC,QAAQ,EAAEC,SAAS,EAAEC,IAAI,QAAQ,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,aAAa,GAAG,SAAhBA,aAAa,CAAaC,OAAO,EAAE;EAC1C,OAAO,UAAUC,KAAK,EAAEC,MAAM,EAAE;IAC5B,OAAOD,KAAK,KAAKC,MAAM,IAAIF,OAAO,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK,CAAC;EAC3D,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,WAAW,GAAG,SAAdA,WAAW,CAAaH,QAAO,EAAE;EAAE,OAAQ;IAClDI,MAAM,EAAEL,aAAa,CAACC,QAAO,CAAC;IAC9BA,OAAO,EAAE,iBAAUC,KAAK,EAAEC,MAAM,EAAE;MAAE,OAAQD,KAAK,KAAKC,MAAM,GAAG,CAAC,GAAGF,QAAO,CAACC,KAAK,EAAEC,MAAM,CAAC;IAAG;EAChG,CAAC;AAAG,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIG,KAAK,GAAG,SAARA,KAAK,GAAe;EAC3B,IAAIC,IAAI,GAAG,EAAE;EACb,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;IAC1CD,IAAI,CAACC,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;EAC5B;EACA,OAAOJ,WAAW,CAAC,UAAUF,KAAK,EAAEC,MAAM,EAAE;IACxC,IAAIQ,CAAC,GAAG,CAAC;IACT,OAAOA,CAAC,GAAGJ,IAAI,CAACG,MAAM,GAAG,CAAC,EAAEC,CAAC,EAAE,EAAE;MAC7B,IAAIC,CAAC,GAAGL,IAAI,CAACI,CAAC,CAAC,CAACV,OAAO,CAACC,KAAK,CAACS,CAAC,CAAC,EAAER,MAAM,CAACQ,CAAC,CAAC,CAAC;MAC5C,IAAIC,CAAC,KAAK,CAAC,EAAE;QACT,OAAOA,CAAC;MACZ;IACJ;IACA,OAAOL,IAAI,CAACI,CAAC,CAAC,CAACV,OAAO,CAACC,KAAK,CAACS,CAAC,CAAC,EAAER,MAAM,CAACQ,CAAC,CAAC,CAAC;EAC/C,CAAC,CAAC;AACN,CAAC;AACD;AACA;AACA;AACA,OAAO,IAAIE,OAAO,GAAG,SAAVA,OAAO,CAAaC,CAAC,EAAE;EAAE,OAAOV,WAAW,CAAC,UAAUF,KAAK,EAAEC,MAAM,EAAE;IAAE,OAAOW,CAAC,CAACb,OAAO,CAACE,MAAM,EAAED,KAAK,CAAC;EAAE,CAAC,CAAC;AAAE,CAAC;AACxH;AACA,IAAIa,UAAU,GAAG,SAAbA,UAAU,CAAaC,EAAE,EAAEC,CAAC,EAAE;EAAE,OAAOlB,IAAI,CAACiB,EAAE,EAAEE,SAAS,CAACD,CAAC,CAAC,CAAC;AAAE,CAAC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,SAAS,GAAG,SAAZA,SAAS,CAAaD,CAAC,EAAE;EAAE,OAAO,UAAUD,EAAE,EAAE;IACvD,OAAOZ,WAAW,CAAC,UAAUF,KAAK,EAAEC,MAAM,EAAE;MAAE,OAAOa,EAAE,CAACf,OAAO,CAACgB,CAAC,CAACf,KAAK,CAAC,EAAEe,CAAC,CAACd,MAAM,CAAC,CAAC;IAAE,CAAC,CAAC;EAC5F,CAAC;AAAE,CAAC;AACJ;AACA;AACA;AACA;AACA,OAAO,IAAIgB,GAAG,GAAG,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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"},"metadata":{},"sourceType":"module"}