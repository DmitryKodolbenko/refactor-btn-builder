{"ast":null,"code":"/**\n * ```ts\n * interface Separated<E, A> {\n *    readonly left: E\n *    readonly right: A\n * }\n * ```\n *\n * Represents a result of separating a whole into two parts.\n *\n * @since 2.10.0\n */\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var separated = function separated(left, right) {\n  return {\n    left: left,\n    right: right\n  };\n};\nvar _map = function _map(fa, f) {\n  return pipe(fa, map(f));\n};\nvar _mapLeft = function _mapLeft(fa, f) {\n  return pipe(fa, mapLeft(f));\n};\nvar _bimap = function _bimap(fa, g, f) {\n  return pipe(fa, bimap(g, f));\n};\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var map = function map(f) {\n  return function (fa) {\n    return separated(left(fa), f(right(fa)));\n  };\n};\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var mapLeft = function mapLeft(f) {\n  return function (fa) {\n    return separated(f(left(fa)), right(fa));\n  };\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var bimap = function bimap(f, g) {\n  return function (fa) {\n    return separated(f(left(fa)), g(right(fa)));\n  };\n};\n/**\n * @category type lambdas\n * @since 2.10.0\n */\nexport var URI = 'Separated';\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Bifunctor = {\n  URI: URI,\n  mapLeft: _mapLeft,\n  bimap: _bimap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Functor = {\n  URI: URI,\n  map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/flap_(Functor);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nexport var left = function left(s) {\n  return s.left;\n};\n/**\n * @since 2.10.0\n */\nexport var right = function right(s) {\n  return s.right;\n};","map":{"version":3,"names":["pipe","flap","flap_","separated","left","right","_map","fa","f","map","_mapLeft","mapLeft","_bimap","g","bimap","URI","Bifunctor","Functor","s"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/fp-ts/es6/Separated.js"],"sourcesContent":["/**\n * ```ts\n * interface Separated<E, A> {\n *    readonly left: E\n *    readonly right: A\n * }\n * ```\n *\n * Represents a result of separating a whole into two parts.\n *\n * @since 2.10.0\n */\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var separated = function (left, right) { return ({ left: left, right: right }); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\nvar _bimap = function (fa, g, f) { return pipe(fa, bimap(g, f)); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var map = function (f) {\n    return function (fa) {\n        return separated(left(fa), f(right(fa)));\n    };\n};\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var mapLeft = function (f) {\n    return function (fa) {\n        return separated(f(left(fa)), right(fa));\n    };\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var bimap = function (f, g) {\n    return function (fa) {\n        return separated(f(left(fa)), g(right(fa)));\n    };\n};\n/**\n * @category type lambdas\n * @since 2.10.0\n */\nexport var URI = 'Separated';\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    mapLeft: _mapLeft,\n    bimap: _bimap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nexport var left = function (s) { return s.left; };\n/**\n * @since 2.10.0\n */\nexport var right = function (s) { return s.right; };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,IAAI,QAAQ,YAAY;AACjC,SAASC,IAAI,IAAIC,KAAK,QAAQ,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,SAAS,GAAG,SAAZA,SAAS,CAAaC,IAAI,EAAEC,KAAK,EAAE;EAAE,OAAQ;IAAED,IAAI,EAAEA,IAAI;IAAEC,KAAK,EAAEA;EAAM,CAAC;AAAG,CAAC;AACxF,IAAIC,IAAI,GAAG,SAAPA,IAAI,CAAaC,EAAE,EAAEC,CAAC,EAAE;EAAE,OAAOR,IAAI,CAACO,EAAE,EAAEE,GAAG,CAACD,CAAC,CAAC,CAAC;AAAE,CAAC;AACxD,IAAIE,QAAQ,GAAG,SAAXA,QAAQ,CAAaH,EAAE,EAAEC,CAAC,EAAE;EAAE,OAAOR,IAAI,CAACO,EAAE,EAAEI,OAAO,CAACH,CAAC,CAAC,CAAC;AAAE,CAAC;AAChE,IAAII,MAAM,GAAG,SAATA,MAAM,CAAaL,EAAE,EAAEM,CAAC,EAAEL,CAAC,EAAE;EAAE,OAAOR,IAAI,CAACO,EAAE,EAAEO,KAAK,CAACD,CAAC,EAAEL,CAAC,CAAC,CAAC;AAAE,CAAC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,GAAG,GAAG,SAANA,GAAG,CAAaD,CAAC,EAAE;EAC1B,OAAO,UAAUD,EAAE,EAAE;IACjB,OAAOJ,SAAS,CAACC,IAAI,CAACG,EAAE,CAAC,EAAEC,CAAC,CAACH,KAAK,CAACE,EAAE,CAAC,CAAC,CAAC;EAC5C,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAII,OAAO,GAAG,SAAVA,OAAO,CAAaH,CAAC,EAAE;EAC9B,OAAO,UAAUD,EAAE,EAAE;IACjB,OAAOJ,SAAS,CAACK,CAAC,CAACJ,IAAI,CAACG,EAAE,CAAC,CAAC,EAAEF,KAAK,CAACE,EAAE,CAAC,CAAC;EAC5C,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIO,KAAK,GAAG,SAARA,KAAK,CAAaN,CAAC,EAAEK,CAAC,EAAE;EAC/B,OAAO,UAAUN,EAAE,EAAE;IACjB,OAAOJ,SAAS,CAACK,CAAC,CAACJ,IAAI,CAACG,EAAE,CAAC,CAAC,EAAEM,CAAC,CAACR,KAAK,CAACE,EAAE,CAAC,CAAC,CAAC;EAC/C,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,IAAIQ,GAAG,GAAG,WAAW;AAC5B;AACA;AACA;AACA;AACA,OAAO,IAAIC,SAAS,GAAG;EACnBD,GAAG,EAAEA,GAAG;EACRJ,OAAO,EAAED,QAAQ;EACjBI,KAAK,EAAEF;AACX,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,IAAIK,OAAO,GAAG;EACjBF,GAAG,EAAEA,GAAG;EACRN,GAAG,EAAEH;AACT,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,IAAIL,IAAI,GAAG,aAAcC,KAAK,CAACe,OAAO,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIb,IAAI,GAAG,SAAPA,IAAI,CAAac,CAAC,EAAE;EAAE,OAAOA,CAAC,CAACd,IAAI;AAAE,CAAC;AACjD;AACA;AACA;AACA,OAAO,IAAIC,KAAK,GAAG,SAARA,KAAK,CAAaa,CAAC,EAAE;EAAE,OAAOA,CAAC,CAACb,KAAK;AAAE,CAAC"},"metadata":{},"sourceType":"module"}