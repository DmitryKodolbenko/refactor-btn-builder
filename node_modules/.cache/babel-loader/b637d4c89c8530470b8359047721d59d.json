{"ast":null,"code":"// NOTE: \"mc\" means masterchain, \"shards\" means shardchains\n\nconst MC_INTERVAL = 10 * 1000;\nconst SHARDS_INTERVAL = 1 * 1000;\nconst parseShardBlockNumber = x => {\n  return {\n    workchain: x.workchain,\n    shardId: x.shard,\n    shardBlockNumber: x.seqno\n  };\n};\nclass BlockSubscription {\n  /**\n   * @param provider  {TonWeb.HttpProvider}\n   * @param storage   persistent storage for storing block numbers that we have already processed.\n   * @param onBlock {(blockHeader: BlockHeader) => Promise<void>} callback which is called for of each block.\n   *                                                       callback may throw an error, in this case the block processing will be interrupted and block will not be saved in the storage as processed.\n   *                                                       shardchain blocks are processed OUT of chronological order.\n   *                                                       masterchain blocks are processed in chronological order.\n   *                                                       for masterchain workchain === -1 and shardId === '-9223372036854775808'\n   * @param options? {startMcBlockNumber:? number, mcInterval?: number, shardsInterval?: number} start masterchain block number from which we start to process blocks.\n   *                                     if not specified, the subscription starts from the last block of the network at the time of launch.\n   */\n  constructor(provider, storage, onBlock, options) {\n    this.provider = provider;\n    this.storage = storage;\n    this.onBlock = onBlock;\n    this.startMcBlockNumber = options ? options.startMcBlockNumber : undefined;\n    this.mcInterval = (options ? options.mcInterval : undefined) || MC_INTERVAL;\n    this.shardsInterval = (options ? options.shardsInterval : undefined) || SHARDS_INTERVAL;\n  }\n  async start() {\n    this.stop();\n    if (!this.startMcBlockNumber) {\n      this.startMcBlockNumber = (await this.provider.getMasterchainInfo()).last.seqno;\n      if (!this.startMcBlockNumber) throw new Error('Cannot get start mc block number from provider');\n    }\n    const startMcBlockHeader = await this.provider.getMasterchainBlockHeader(this.startMcBlockNumber);\n    this.startLT = startMcBlockHeader.end_lt;\n    if (!this.startLT) throw new Error('Cannot get startLT from provider');\n\n    // MASTERCHAIN\n\n    let isMcProcessing = false;\n    const mcTick = async () => {\n      if (isMcProcessing) return;\n      isMcProcessing = true;\n      try {\n        const lastSavedMcBlock = (await this.storage.getLastMasterchainBlockNumber()) || this.startMcBlockNumber;\n        if (!lastSavedMcBlock) throw new Error('no init masterchain block in storage');\n        const lastMcBlock = (await this.provider.getMasterchainInfo()).last.seqno;\n        if (!lastMcBlock) throw new Error('invalid last masterchain block from provider');\n        for (let i = lastSavedMcBlock + 1; i < lastMcBlock; i++) {\n          const blockShards = await this.provider.getBlockShards(i);\n          const blockHeader = await this.provider.getMasterchainBlockHeader(i);\n          await this.onBlock(blockHeader, blockShards);\n          await this.storage.insertBlocks(i, blockShards.shards.map(parseShardBlockNumber));\n        }\n      } catch (e) {\n        console.error(e);\n      }\n      isMcProcessing = false;\n    };\n    this.mcIntervalId = setInterval(() => mcTick(), this.mcInterval);\n    mcTick();\n\n    // SHARDCHAINS\n\n    let isShardsProcessing = false;\n    const shardsTick = async () => {\n      if (isShardsProcessing) return;\n      isShardsProcessing = true;\n      try {\n        const shardBlock = await this.storage.getUnprocessedShardBlock();\n        if (shardBlock) {\n          const {\n            workchain,\n            shardId,\n            shardBlockNumber\n          } = shardBlock;\n          const blockHeader = await this.provider.getBlockHeader(workchain, shardId, shardBlockNumber);\n          if (blockHeader.end_lt < this.startLT) {\n            await this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, []);\n          } else {\n            await this.onBlock(blockHeader);\n            const prevBlocks = blockHeader.prev_blocks.map(parseShardBlockNumber);\n            await this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, prevBlocks);\n          }\n        }\n      } catch (e) {\n        console.log(e);\n      }\n      isShardsProcessing = false;\n    };\n    this.shardsIntervalId = setInterval(() => shardsTick(), this.shardsInterval);\n  }\n  stop() {\n    clearInterval(this.mcIntervalId);\n    clearInterval(this.shardsIntervalId);\n  }\n}\nmodule.exports = {\n  BlockSubscription\n};","map":{"version":3,"names":["MC_INTERVAL","SHARDS_INTERVAL","parseShardBlockNumber","x","workchain","shardId","shard","shardBlockNumber","seqno","BlockSubscription","constructor","provider","storage","onBlock","options","startMcBlockNumber","undefined","mcInterval","shardsInterval","start","stop","getMasterchainInfo","last","Error","startMcBlockHeader","getMasterchainBlockHeader","startLT","end_lt","isMcProcessing","mcTick","lastSavedMcBlock","getLastMasterchainBlockNumber","lastMcBlock","i","blockShards","getBlockShards","blockHeader","insertBlocks","shards","map","e","console","error","mcIntervalId","setInterval","isShardsProcessing","shardsTick","shardBlock","getUnprocessedShardBlock","getBlockHeader","setBlockProcessed","prevBlocks","prev_blocks","log","shardsIntervalId","clearInterval","module","exports"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/tonweb/src/providers/blockSubscription/BlockSubscription.js"],"sourcesContent":["// NOTE: \"mc\" means masterchain, \"shards\" means shardchains\n\nconst MC_INTERVAL = 10 * 1000;\nconst SHARDS_INTERVAL = 1 * 1000;\n\nconst parseShardBlockNumber = x => {\n    return {\n        workchain: x.workchain,\n        shardId: x.shard,\n        shardBlockNumber: x.seqno\n    }\n}\n\nclass BlockSubscription {\n\n    /**\n     * @param provider  {TonWeb.HttpProvider}\n     * @param storage   persistent storage for storing block numbers that we have already processed.\n     * @param onBlock {(blockHeader: BlockHeader) => Promise<void>} callback which is called for of each block.\n     *                                                       callback may throw an error, in this case the block processing will be interrupted and block will not be saved in the storage as processed.\n     *                                                       shardchain blocks are processed OUT of chronological order.\n     *                                                       masterchain blocks are processed in chronological order.\n     *                                                       for masterchain workchain === -1 and shardId === '-9223372036854775808'\n     * @param options? {startMcBlockNumber:? number, mcInterval?: number, shardsInterval?: number} start masterchain block number from which we start to process blocks.\n     *                                     if not specified, the subscription starts from the last block of the network at the time of launch.\n     */\n    constructor(provider, storage, onBlock, options) {\n        this.provider = provider;\n        this.storage = storage;\n        this.onBlock = onBlock;\n        this.startMcBlockNumber = options ? options.startMcBlockNumber : undefined;\n        this.mcInterval = (options ? options.mcInterval : undefined) || MC_INTERVAL;\n        this.shardsInterval = (options ? options.shardsInterval : undefined) || SHARDS_INTERVAL;\n    }\n\n    async start() {\n        this.stop();\n\n        if (!this.startMcBlockNumber) {\n            this.startMcBlockNumber = (await this.provider.getMasterchainInfo()).last.seqno;\n            if (!this.startMcBlockNumber) throw new Error('Cannot get start mc block number from provider');\n        }\n        const startMcBlockHeader = await this.provider.getMasterchainBlockHeader(this.startMcBlockNumber);\n        this.startLT = startMcBlockHeader.end_lt;\n        if (!this.startLT) throw new Error('Cannot get startLT from provider');\n\n        // MASTERCHAIN\n\n        let isMcProcessing = false;\n\n        const mcTick = async () => {\n            if (isMcProcessing) return;\n\n            isMcProcessing = true;\n\n            try {\n                const lastSavedMcBlock = await this.storage.getLastMasterchainBlockNumber() || this.startMcBlockNumber;\n                if (!lastSavedMcBlock) throw new Error('no init masterchain block in storage');\n                const lastMcBlock = (await this.provider.getMasterchainInfo()).last.seqno;\n                if (!lastMcBlock) throw new Error('invalid last masterchain block from provider');\n\n                for (let i = lastSavedMcBlock + 1; i < lastMcBlock; i++) {\n                    const blockShards = await this.provider.getBlockShards(i);\n                    const blockHeader = await this.provider.getMasterchainBlockHeader(i);\n                    await this.onBlock(blockHeader, blockShards);\n                    await this.storage.insertBlocks(i, blockShards.shards.map(parseShardBlockNumber));\n                }\n            } catch (e) {\n                console.error(e);\n            }\n\n            isMcProcessing = false;\n        }\n\n        this.mcIntervalId = setInterval(() => mcTick(), this.mcInterval);\n        mcTick();\n\n        // SHARDCHAINS\n\n        let isShardsProcessing = false;\n\n        const shardsTick = async () => {\n            if (isShardsProcessing) return;\n\n            isShardsProcessing = true;\n            try {\n                const shardBlock = await this.storage.getUnprocessedShardBlock();\n                if (shardBlock) {\n                    const {workchain, shardId, shardBlockNumber} = shardBlock;\n                    const blockHeader = await this.provider.getBlockHeader(workchain, shardId, shardBlockNumber);\n                    if (blockHeader.end_lt < this.startLT) {\n                        await this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, []);\n                    } else {\n                        await this.onBlock(blockHeader);\n                        const prevBlocks = blockHeader.prev_blocks.map(parseShardBlockNumber);\n                        await this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, prevBlocks);\n                    }\n                }\n            } catch (e) {\n                console.log(e);\n            }\n            isShardsProcessing = false;\n        }\n\n        this.shardsIntervalId = setInterval(() => shardsTick(), this.shardsInterval);\n    }\n\n    stop() {\n        clearInterval(this.mcIntervalId);\n        clearInterval(this.shardsIntervalId);\n    }\n}\n\nmodule.exports = {BlockSubscription};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}