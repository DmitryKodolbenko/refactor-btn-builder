{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.beginDict = exports.DictBuilder = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst Builder_1 = require(\"./Builder\");\nconst serializeDict_1 = require(\"./dict/serializeDict\");\nclass DictBuilder {\n  constructor(keySize) {\n    this.items = new Map();\n    this.ended = false;\n    this.storeCell = (index, value) => {\n      if (this.ended) {\n        throw Error('Already ended');\n      }\n      let key;\n      if (typeof index === 'number') {\n        key = index.toString(10);\n      } else if (bn_js_1.default.isBN(index)) {\n        key = index.toString(10);\n      } else if (Buffer.isBuffer(index)) {\n        key = new bn_js_1.default(index.toString('hex'), 'hex').toString(10);\n      } else {\n        throw Error('Invalid index type');\n      }\n      if (this.items.has(key)) {\n        throw Error('Item ' + index + ' already exist');\n      }\n      this.items.set(key, value);\n    };\n    this.storeRef = (index, value) => {\n      if (this.ended) {\n        throw Error('Already ended');\n      }\n      this.storeCell(index, (0, Builder_1.beginCell)().storeRef(value).endCell());\n    };\n    this.endDict = () => {\n      if (this.ended) {\n        throw Error('Already ended');\n      }\n      this.ended = true;\n      if (this.items.size === 0) {\n        return null;\n      }\n      return (0, serializeDict_1.serializeDict)(this.items, this.keySize, (src, dst) => dst.writeCell(src));\n    };\n    this.endCell = () => {\n      if (this.ended) {\n        throw Error('Already ended');\n      }\n      if (this.items.size === 0) {\n        throw Error('Dict is empty');\n      }\n      return this.endDict();\n    };\n    this.keySize = keySize;\n  }\n}\nexports.DictBuilder = DictBuilder;\nfunction beginDict(keyLength) {\n  return new DictBuilder(keyLength);\n}\nexports.beginDict = beginDict;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","beginDict","DictBuilder","bn_js_1","require","Builder_1","serializeDict_1","constructor","keySize","items","Map","ended","storeCell","index","Error","key","toString","default","isBN","Buffer","isBuffer","has","set","storeRef","beginCell","endCell","endDict","size","serializeDict","src","dst","writeCell","keyLength"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/boc/DictBuilder.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.beginDict = exports.DictBuilder = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst Builder_1 = require(\"./Builder\");\nconst serializeDict_1 = require(\"./dict/serializeDict\");\nclass DictBuilder {\n    constructor(keySize) {\n        this.items = new Map();\n        this.ended = false;\n        this.storeCell = (index, value) => {\n            if (this.ended) {\n                throw Error('Already ended');\n            }\n            let key;\n            if (typeof index === 'number') {\n                key = index.toString(10);\n            }\n            else if (bn_js_1.default.isBN(index)) {\n                key = index.toString(10);\n            }\n            else if (Buffer.isBuffer(index)) {\n                key = new bn_js_1.default(index.toString('hex'), 'hex').toString(10);\n            }\n            else {\n                throw Error('Invalid index type');\n            }\n            if (this.items.has(key)) {\n                throw Error('Item ' + index + ' already exist');\n            }\n            this.items.set(key, value);\n        };\n        this.storeRef = (index, value) => {\n            if (this.ended) {\n                throw Error('Already ended');\n            }\n            this.storeCell(index, (0, Builder_1.beginCell)()\n                .storeRef(value)\n                .endCell());\n        };\n        this.endDict = () => {\n            if (this.ended) {\n                throw Error('Already ended');\n            }\n            this.ended = true;\n            if (this.items.size === 0) {\n                return null;\n            }\n            return (0, serializeDict_1.serializeDict)(this.items, this.keySize, (src, dst) => dst.writeCell(src));\n        };\n        this.endCell = () => {\n            if (this.ended) {\n                throw Error('Already ended');\n            }\n            if (this.items.size === 0) {\n                throw Error('Dict is empty');\n            }\n            return this.endDict();\n        };\n        this.keySize = keySize;\n    }\n}\nexports.DictBuilder = DictBuilder;\nfunction beginDict(keyLength) {\n    return new DictBuilder(keyLength);\n}\nexports.beginDict = beginDict;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}