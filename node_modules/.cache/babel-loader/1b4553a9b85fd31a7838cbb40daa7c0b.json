{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SignatureDescriptor_Data_Multi = exports.SignatureDescriptor_Data_Single = exports.SignatureDescriptor_Data = exports.SignatureDescriptor = exports.SignatureDescriptors = exports.signModeToJSON = exports.signModeFromJSON = exports.SignMode = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst any_1 = require(\"../../../../google/protobuf/any\");\nconst multisig_1 = require(\"../../../../cosmos/crypto/multisig/v1beta1/multisig\");\nexports.protobufPackage = \"cosmos.tx.signing.v1beta1\";\n/** SignMode represents a signing mode with its own security guarantees. */\nvar SignMode;\n(function (SignMode) {\n  /**\n   * SIGN_MODE_UNSPECIFIED - SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\n   * rejected\n   */\n  SignMode[SignMode[\"SIGN_MODE_UNSPECIFIED\"] = 0] = \"SIGN_MODE_UNSPECIFIED\";\n  /**\n   * SIGN_MODE_DIRECT - SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\n   * verified with raw bytes from Tx\n   */\n  SignMode[SignMode[\"SIGN_MODE_DIRECT\"] = 1] = \"SIGN_MODE_DIRECT\";\n  /**\n   * SIGN_MODE_TEXTUAL - SIGN_MODE_TEXTUAL is a future signing mode that will verify some\n   * human-readable textual representation on top of the binary representation\n   * from SIGN_MODE_DIRECT\n   */\n  SignMode[SignMode[\"SIGN_MODE_TEXTUAL\"] = 2] = \"SIGN_MODE_TEXTUAL\";\n  /**\n   * SIGN_MODE_LEGACY_AMINO_JSON - SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\n   * Amino JSON and will be removed in the future\n   */\n  SignMode[SignMode[\"SIGN_MODE_LEGACY_AMINO_JSON\"] = 127] = \"SIGN_MODE_LEGACY_AMINO_JSON\";\n  SignMode[SignMode[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(SignMode = exports.SignMode || (exports.SignMode = {}));\nfunction signModeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"SIGN_MODE_UNSPECIFIED\":\n      return SignMode.SIGN_MODE_UNSPECIFIED;\n    case 1:\n    case \"SIGN_MODE_DIRECT\":\n      return SignMode.SIGN_MODE_DIRECT;\n    case 2:\n    case \"SIGN_MODE_TEXTUAL\":\n      return SignMode.SIGN_MODE_TEXTUAL;\n    case 127:\n    case \"SIGN_MODE_LEGACY_AMINO_JSON\":\n      return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return SignMode.UNRECOGNIZED;\n  }\n}\nexports.signModeFromJSON = signModeFromJSON;\nfunction signModeToJSON(object) {\n  switch (object) {\n    case SignMode.SIGN_MODE_UNSPECIFIED:\n      return \"SIGN_MODE_UNSPECIFIED\";\n    case SignMode.SIGN_MODE_DIRECT:\n      return \"SIGN_MODE_DIRECT\";\n    case SignMode.SIGN_MODE_TEXTUAL:\n      return \"SIGN_MODE_TEXTUAL\";\n    case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:\n      return \"SIGN_MODE_LEGACY_AMINO_JSON\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\nexports.signModeToJSON = signModeToJSON;\nconst baseSignatureDescriptors = {};\nexports.SignatureDescriptors = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    for (const v of message.signatures) {\n      exports.SignatureDescriptor.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSignatureDescriptors);\n    message.signatures = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.signatures.push(exports.SignatureDescriptor.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    var _a;\n    const message = Object.assign({}, baseSignatureDescriptors);\n    message.signatures = ((_a = object.signatures) !== null && _a !== void 0 ? _a : []).map(e => exports.SignatureDescriptor.fromJSON(e));\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.signatures) {\n      obj.signatures = message.signatures.map(e => e ? exports.SignatureDescriptor.toJSON(e) : undefined);\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _a;\n    const message = Object.assign({}, baseSignatureDescriptors);\n    message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map(e => exports.SignatureDescriptor.fromPartial(e))) || [];\n    return message;\n  }\n};\nconst baseSignatureDescriptor = {\n  sequence: long_1.default.UZERO\n};\nexports.SignatureDescriptor = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.publicKey !== undefined) {\n      any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.data !== undefined) {\n      exports.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.sequence.isZero()) {\n      writer.uint32(24).uint64(message.sequence);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSignatureDescriptor);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.publicKey = any_1.Any.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.data = exports.SignatureDescriptor_Data.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.sequence = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseSignatureDescriptor);\n    message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? any_1.Any.fromJSON(object.publicKey) : undefined;\n    message.data = object.data !== undefined && object.data !== null ? exports.SignatureDescriptor_Data.fromJSON(object.data) : undefined;\n    message.sequence = object.sequence !== undefined && object.sequence !== null ? long_1.default.fromString(object.sequence) : long_1.default.UZERO;\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.publicKey !== undefined && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);\n    message.data !== undefined && (obj.data = message.data ? exports.SignatureDescriptor_Data.toJSON(message.data) : undefined);\n    message.sequence !== undefined && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseSignatureDescriptor);\n    message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? any_1.Any.fromPartial(object.publicKey) : undefined;\n    message.data = object.data !== undefined && object.data !== null ? exports.SignatureDescriptor_Data.fromPartial(object.data) : undefined;\n    message.sequence = object.sequence !== undefined && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;\n    return message;\n  }\n};\nconst baseSignatureDescriptor_Data = {};\nexports.SignatureDescriptor_Data = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.single !== undefined) {\n      exports.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.multi !== undefined) {\n      exports.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSignatureDescriptor_Data);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.single = exports.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.multi = exports.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseSignatureDescriptor_Data);\n    message.single = object.single !== undefined && object.single !== null ? exports.SignatureDescriptor_Data_Single.fromJSON(object.single) : undefined;\n    message.multi = object.multi !== undefined && object.multi !== null ? exports.SignatureDescriptor_Data_Multi.fromJSON(object.multi) : undefined;\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.single !== undefined && (obj.single = message.single ? exports.SignatureDescriptor_Data_Single.toJSON(message.single) : undefined);\n    message.multi !== undefined && (obj.multi = message.multi ? exports.SignatureDescriptor_Data_Multi.toJSON(message.multi) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseSignatureDescriptor_Data);\n    message.single = object.single !== undefined && object.single !== null ? exports.SignatureDescriptor_Data_Single.fromPartial(object.single) : undefined;\n    message.multi = object.multi !== undefined && object.multi !== null ? exports.SignatureDescriptor_Data_Multi.fromPartial(object.multi) : undefined;\n    return message;\n  }\n};\nconst baseSignatureDescriptor_Data_Single = {\n  mode: 0\n};\nexports.SignatureDescriptor_Data_Single = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    if (message.signature.length !== 0) {\n      writer.uint32(18).bytes(message.signature);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSignatureDescriptor_Data_Single);\n    message.signature = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.mode = reader.int32();\n          break;\n        case 2:\n          message.signature = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseSignatureDescriptor_Data_Single);\n    message.mode = object.mode !== undefined && object.mode !== null ? signModeFromJSON(object.mode) : 0;\n    message.signature = object.signature !== undefined && object.signature !== null ? bytesFromBase64(object.signature) : new Uint8Array();\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));\n    message.signature !== undefined && (obj.signature = base64FromBytes(message.signature !== undefined ? message.signature : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = Object.assign({}, baseSignatureDescriptor_Data_Single);\n    message.mode = (_a = object.mode) !== null && _a !== void 0 ? _a : 0;\n    message.signature = (_b = object.signature) !== null && _b !== void 0 ? _b : new Uint8Array();\n    return message;\n  }\n};\nconst baseSignatureDescriptor_Data_Multi = {};\nexports.SignatureDescriptor_Data_Multi = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    if (message.bitarray !== undefined) {\n      multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.signatures) {\n      exports.SignatureDescriptor_Data.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSignatureDescriptor_Data_Multi);\n    message.signatures = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.signatures.push(exports.SignatureDescriptor_Data.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    var _a;\n    const message = Object.assign({}, baseSignatureDescriptor_Data_Multi);\n    message.bitarray = object.bitarray !== undefined && object.bitarray !== null ? multisig_1.CompactBitArray.fromJSON(object.bitarray) : undefined;\n    message.signatures = ((_a = object.signatures) !== null && _a !== void 0 ? _a : []).map(e => exports.SignatureDescriptor_Data.fromJSON(e));\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.bitarray !== undefined && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : undefined);\n    if (message.signatures) {\n      obj.signatures = message.signatures.map(e => e ? exports.SignatureDescriptor_Data.toJSON(e) : undefined);\n    } else {\n      obj.signatures = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    var _a;\n    const message = Object.assign({}, baseSignatureDescriptor_Data_Multi);\n    message.bitarray = object.bitarray !== undefined && object.bitarray !== null ? multisig_1.CompactBitArray.fromPartial(object.bitarray) : undefined;\n    message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map(e => exports.SignatureDescriptor_Data.fromPartial(e))) || [];\n    return message;\n  }\n};\nvar globalThis = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || (b64 => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\nconst btoa = globalThis.btoa || (bin => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n  const bin = [];\n  for (const byte of arr) {\n    bin.push(String.fromCharCode(byte));\n  }\n  return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}","map":{"version":3,"sources":["../../../../../src/cosmos/tx/signing/v1beta1/signing.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SignatureDescriptor_Data_Multi = exports.SignatureDescriptor_Data_Single = exports.SignatureDescriptor_Data = exports.SignatureDescriptor = exports.SignatureDescriptors = exports.signModeToJSON = exports.signModeFromJSON = exports.SignMode = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst any_1 = require(\"../../../../google/protobuf/any\");\nconst multisig_1 = require(\"../../../../cosmos/crypto/multisig/v1beta1/multisig\");\nexports.protobufPackage = \"cosmos.tx.signing.v1beta1\";\n/** SignMode represents a signing mode with its own security guarantees. */\nvar SignMode;\n(function (SignMode) {\n    /**\n     * SIGN_MODE_UNSPECIFIED - SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\n     * rejected\n     */\n    SignMode[SignMode[\"SIGN_MODE_UNSPECIFIED\"] = 0] = \"SIGN_MODE_UNSPECIFIED\";\n    /**\n     * SIGN_MODE_DIRECT - SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\n     * verified with raw bytes from Tx\n     */\n    SignMode[SignMode[\"SIGN_MODE_DIRECT\"] = 1] = \"SIGN_MODE_DIRECT\";\n    /**\n     * SIGN_MODE_TEXTUAL - SIGN_MODE_TEXTUAL is a future signing mode that will verify some\n     * human-readable textual representation on top of the binary representation\n     * from SIGN_MODE_DIRECT\n     */\n    SignMode[SignMode[\"SIGN_MODE_TEXTUAL\"] = 2] = \"SIGN_MODE_TEXTUAL\";\n    /**\n     * SIGN_MODE_LEGACY_AMINO_JSON - SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\n     * Amino JSON and will be removed in the future\n     */\n    SignMode[SignMode[\"SIGN_MODE_LEGACY_AMINO_JSON\"] = 127] = \"SIGN_MODE_LEGACY_AMINO_JSON\";\n    SignMode[SignMode[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(SignMode = exports.SignMode || (exports.SignMode = {}));\nfunction signModeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"SIGN_MODE_UNSPECIFIED\":\n            return SignMode.SIGN_MODE_UNSPECIFIED;\n        case 1:\n        case \"SIGN_MODE_DIRECT\":\n            return SignMode.SIGN_MODE_DIRECT;\n        case 2:\n        case \"SIGN_MODE_TEXTUAL\":\n            return SignMode.SIGN_MODE_TEXTUAL;\n        case 127:\n        case \"SIGN_MODE_LEGACY_AMINO_JSON\":\n            return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return SignMode.UNRECOGNIZED;\n    }\n}\nexports.signModeFromJSON = signModeFromJSON;\nfunction signModeToJSON(object) {\n    switch (object) {\n        case SignMode.SIGN_MODE_UNSPECIFIED:\n            return \"SIGN_MODE_UNSPECIFIED\";\n        case SignMode.SIGN_MODE_DIRECT:\n            return \"SIGN_MODE_DIRECT\";\n        case SignMode.SIGN_MODE_TEXTUAL:\n            return \"SIGN_MODE_TEXTUAL\";\n        case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:\n            return \"SIGN_MODE_LEGACY_AMINO_JSON\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexports.signModeToJSON = signModeToJSON;\nconst baseSignatureDescriptors = {};\nexports.SignatureDescriptors = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.signatures) {\n            exports.SignatureDescriptor.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseSignatureDescriptors);\n        message.signatures = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signatures.push(exports.SignatureDescriptor.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        var _a;\n        const message = Object.assign({}, baseSignatureDescriptors);\n        message.signatures = ((_a = object.signatures) !== null && _a !== void 0 ? _a : []).map((e) => exports.SignatureDescriptor.fromJSON(e));\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => (e ? exports.SignatureDescriptor.toJSON(e) : undefined));\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = Object.assign({}, baseSignatureDescriptors);\n        message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => exports.SignatureDescriptor.fromPartial(e))) || [];\n        return message;\n    },\n};\nconst baseSignatureDescriptor = { sequence: long_1.default.UZERO };\nexports.SignatureDescriptor = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.publicKey !== undefined) {\n            any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.data !== undefined) {\n            exports.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();\n        }\n        if (!message.sequence.isZero()) {\n            writer.uint32(24).uint64(message.sequence);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseSignatureDescriptor);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.publicKey = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.data = exports.SignatureDescriptor_Data.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.sequence = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseSignatureDescriptor);\n        message.publicKey =\n            object.publicKey !== undefined && object.publicKey !== null\n                ? any_1.Any.fromJSON(object.publicKey)\n                : undefined;\n        message.data =\n            object.data !== undefined && object.data !== null\n                ? exports.SignatureDescriptor_Data.fromJSON(object.data)\n                : undefined;\n        message.sequence =\n            object.sequence !== undefined && object.sequence !== null\n                ? long_1.default.fromString(object.sequence)\n                : long_1.default.UZERO;\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.publicKey !== undefined &&\n            (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : undefined);\n        message.data !== undefined &&\n            (obj.data = message.data ? exports.SignatureDescriptor_Data.toJSON(message.data) : undefined);\n        message.sequence !== undefined && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseSignatureDescriptor);\n        message.publicKey =\n            object.publicKey !== undefined && object.publicKey !== null\n                ? any_1.Any.fromPartial(object.publicKey)\n                : undefined;\n        message.data =\n            object.data !== undefined && object.data !== null\n                ? exports.SignatureDescriptor_Data.fromPartial(object.data)\n                : undefined;\n        message.sequence =\n            object.sequence !== undefined && object.sequence !== null\n                ? long_1.default.fromValue(object.sequence)\n                : long_1.default.UZERO;\n        return message;\n    },\n};\nconst baseSignatureDescriptor_Data = {};\nexports.SignatureDescriptor_Data = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.single !== undefined) {\n            exports.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.multi !== undefined) {\n            exports.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseSignatureDescriptor_Data);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.single = exports.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.multi = exports.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseSignatureDescriptor_Data);\n        message.single =\n            object.single !== undefined && object.single !== null\n                ? exports.SignatureDescriptor_Data_Single.fromJSON(object.single)\n                : undefined;\n        message.multi =\n            object.multi !== undefined && object.multi !== null\n                ? exports.SignatureDescriptor_Data_Multi.fromJSON(object.multi)\n                : undefined;\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.single !== undefined &&\n            (obj.single = message.single ? exports.SignatureDescriptor_Data_Single.toJSON(message.single) : undefined);\n        message.multi !== undefined &&\n            (obj.multi = message.multi ? exports.SignatureDescriptor_Data_Multi.toJSON(message.multi) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseSignatureDescriptor_Data);\n        message.single =\n            object.single !== undefined && object.single !== null\n                ? exports.SignatureDescriptor_Data_Single.fromPartial(object.single)\n                : undefined;\n        message.multi =\n            object.multi !== undefined && object.multi !== null\n                ? exports.SignatureDescriptor_Data_Multi.fromPartial(object.multi)\n                : undefined;\n        return message;\n    },\n};\nconst baseSignatureDescriptor_Data_Single = { mode: 0 };\nexports.SignatureDescriptor_Data_Single = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.mode !== 0) {\n            writer.uint32(8).int32(message.mode);\n        }\n        if (message.signature.length !== 0) {\n            writer.uint32(18).bytes(message.signature);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseSignatureDescriptor_Data_Single);\n        message.signature = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.mode = reader.int32();\n                    break;\n                case 2:\n                    message.signature = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseSignatureDescriptor_Data_Single);\n        message.mode = object.mode !== undefined && object.mode !== null ? signModeFromJSON(object.mode) : 0;\n        message.signature =\n            object.signature !== undefined && object.signature !== null\n                ? bytesFromBase64(object.signature)\n                : new Uint8Array();\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));\n        message.signature !== undefined &&\n            (obj.signature = base64FromBytes(message.signature !== undefined ? message.signature : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = Object.assign({}, baseSignatureDescriptor_Data_Single);\n        message.mode = (_a = object.mode) !== null && _a !== void 0 ? _a : 0;\n        message.signature = (_b = object.signature) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nconst baseSignatureDescriptor_Data_Multi = {};\nexports.SignatureDescriptor_Data_Multi = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.bitarray !== undefined) {\n            multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.signatures) {\n            exports.SignatureDescriptor_Data.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseSignatureDescriptor_Data_Multi);\n        message.signatures = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.signatures.push(exports.SignatureDescriptor_Data.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        var _a;\n        const message = Object.assign({}, baseSignatureDescriptor_Data_Multi);\n        message.bitarray =\n            object.bitarray !== undefined && object.bitarray !== null\n                ? multisig_1.CompactBitArray.fromJSON(object.bitarray)\n                : undefined;\n        message.signatures = ((_a = object.signatures) !== null && _a !== void 0 ? _a : []).map((e) => exports.SignatureDescriptor_Data.fromJSON(e));\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bitarray !== undefined &&\n            (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : undefined);\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => (e ? exports.SignatureDescriptor_Data.toJSON(e) : undefined));\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = Object.assign({}, baseSignatureDescriptor_Data_Multi);\n        message.bitarray =\n            object.bitarray !== undefined && object.bitarray !== null\n                ? multisig_1.CompactBitArray.fromPartial(object.bitarray)\n                : undefined;\n        message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => exports.SignatureDescriptor_Data.fromPartial(e))) || [];\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\n//# sourceMappingURL=signing.js.map"]},"metadata":{},"sourceType":"script"}