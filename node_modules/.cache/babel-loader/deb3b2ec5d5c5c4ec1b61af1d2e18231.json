{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpClient = exports.http = void 0;\nconst json_rpc_1 = require(\"@cosmjs/json-rpc\");\nconst axios_1 = __importDefault(require(\"axios\"));\nconst rpcclient_1 = require(\"./rpcclient\");\nfunction filterBadStatus(res) {\n  if (res.status >= 400) {\n    throw new Error(`Bad status on response: ${res.status}`);\n  }\n  return res;\n}\n/**\n * Helper to work around missing CORS support in Tendermint (https://github.com/tendermint/tendermint/pull/2800)\n *\n * For some reason, fetch does not complain about missing server-side CORS support.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nasync function http(method, url, headers, request) {\n  if (typeof fetch !== \"undefined\") {\n    const settings = {\n      method: method,\n      body: request ? JSON.stringify(request) : undefined,\n      headers: {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        \"Content-Type\": \"application/json\",\n        ...headers\n      }\n    };\n    return fetch(url, settings).then(filterBadStatus).then(res => res.json());\n  } else {\n    return axios_1.default.request({\n      url: url,\n      method: method,\n      data: request,\n      headers: headers\n    }).then(res => res.data);\n  }\n}\nexports.http = http;\nclass HttpClient {\n  constructor(endpoint) {\n    if (typeof endpoint === \"string\") {\n      // accept host.name:port and assume http protocol\n      this.url = (0, rpcclient_1.hasProtocol)(endpoint) ? endpoint : \"http://\" + endpoint;\n    } else {\n      this.url = endpoint.url;\n      this.headers = endpoint.headers;\n    }\n  }\n  disconnect() {\n    // nothing to be done\n  }\n  async execute(request) {\n    const response = (0, json_rpc_1.parseJsonRpcResponse)(await http(\"POST\", this.url, this.headers, request));\n    if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {\n      throw new Error(JSON.stringify(response.error));\n    }\n    return response;\n  }\n}\nexports.HttpClient = HttpClient;","map":{"version":3,"sources":["../../src/rpcclients/httpclient.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,MAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAMA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAMA,SAAS,eAAe,CAAC,GAAQ,EAAA;EAC/B,IAAI,GAAG,CAAC,MAAM,IAAI,GAAG,EAAE;IACrB,MAAM,IAAI,KAAK,CAAC,2BAA2B,GAAG,CAAC,MAAM,EAAE,CAAC;EACzD;EACD,OAAO,GAAG;AACZ;AAEA;;;;AAIG;AACH;AACO,eAAe,IAAI,CACxB,MAAc,EACd,GAAW,EACX,OAA2C,EAC3C,OAAa,EAAA;EAEb,IAAI,OAAO,KAAK,KAAK,WAAW,EAAE;IAChC,MAAM,QAAQ,GAAG;MACf,MAAM,EAAE,MAAM;MACd,IAAI,EAAE,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,SAAS;MACnD,OAAO,EAAE;QACP;QACA,cAAc,EAAE,kBAAkB;QAClC,GAAG;MACJ;KACF;IACD,OAAO,KAAK,CAAC,GAAG,EAAE,QAAQ,CAAC,CACxB,IAAI,CAAC,eAAe,CAAC,CACrB,IAAI,CAAE,GAAQ,IAAK,GAAG,CAAC,IAAI,EAAE,CAAC;GAClC,MAAM;IACL,OAAO,OAAA,CAAA,OAAK,CACT,OAAO,CAAC;MAAE,GAAG,EAAE,GAAG;MAAE,MAAM,EAAE,MAAM;MAAE,IAAI,EAAE,OAAO;MAAE,OAAO,EAAE;IAAO,CAAE,CAAC,CACtE,IAAI,CAAE,GAAG,IAAK,GAAG,CAAC,IAAI,CAAC;EAC3B;AACH;AAxBA,OAAA,CAAA,IAAA,GAAA,IAAA;AAwCA,MAAa,UAAU,CAAA;EAIrB,WAAA,CAAmB,QAA+B,EAAA;IAChD,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;MAChC;MACA,IAAI,CAAC,GAAG,GAAG,CAAA,CAAA,EAAA,WAAA,CAAA,WAAW,EAAC,QAAQ,CAAC,GAAG,QAAQ,GAAG,SAAS,GAAG,QAAQ;KACnE,MAAM;MACL,IAAI,CAAC,GAAG,GAAG,QAAQ,CAAC,GAAG;MACvB,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO;IAChC;EACH;EAEO,UAAU,GAAA;IACf;EAAA;EAGK,MAAM,OAAO,CAAC,OAAuB,EAAA;IAC1C,MAAM,QAAQ,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,oBAAoB,EAAC,MAAM,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IAC1F,IAAI,CAAA,CAAA,EAAA,UAAA,CAAA,sBAAsB,EAAC,QAAQ,CAAC,EAAE;MACpC,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IAChD;IACD,OAAO,QAAQ;EACjB;AACD;AAzBD,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpClient = exports.http = void 0;\nconst json_rpc_1 = require(\"@cosmjs/json-rpc\");\nconst axios_1 = __importDefault(require(\"axios\"));\nconst rpcclient_1 = require(\"./rpcclient\");\nfunction filterBadStatus(res) {\n    if (res.status >= 400) {\n        throw new Error(`Bad status on response: ${res.status}`);\n    }\n    return res;\n}\n/**\n * Helper to work around missing CORS support in Tendermint (https://github.com/tendermint/tendermint/pull/2800)\n *\n * For some reason, fetch does not complain about missing server-side CORS support.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nasync function http(method, url, headers, request) {\n    if (typeof fetch !== \"undefined\") {\n        const settings = {\n            method: method,\n            body: request ? JSON.stringify(request) : undefined,\n            headers: {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                \"Content-Type\": \"application/json\",\n                ...headers,\n            },\n        };\n        return fetch(url, settings)\n            .then(filterBadStatus)\n            .then((res) => res.json());\n    }\n    else {\n        return axios_1.default\n            .request({ url: url, method: method, data: request, headers: headers })\n            .then((res) => res.data);\n    }\n}\nexports.http = http;\nclass HttpClient {\n    constructor(endpoint) {\n        if (typeof endpoint === \"string\") {\n            // accept host.name:port and assume http protocol\n            this.url = (0, rpcclient_1.hasProtocol)(endpoint) ? endpoint : \"http://\" + endpoint;\n        }\n        else {\n            this.url = endpoint.url;\n            this.headers = endpoint.headers;\n        }\n    }\n    disconnect() {\n        // nothing to be done\n    }\n    async execute(request) {\n        const response = (0, json_rpc_1.parseJsonRpcResponse)(await http(\"POST\", this.url, this.headers, request));\n        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {\n            throw new Error(JSON.stringify(response.error));\n        }\n        return response;\n    }\n}\nexports.HttpClient = HttpClient;\n//# sourceMappingURL=httpclient.js.map"]},"metadata":{},"sourceType":"script"}