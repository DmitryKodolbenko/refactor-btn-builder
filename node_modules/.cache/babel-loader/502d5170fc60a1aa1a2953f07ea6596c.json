{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Secp256k1HdWallet = exports.extractKdfConfiguration = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst addresses_1 = require(\"./addresses\");\nconst paths_1 = require(\"./paths\");\nconst signature_1 = require(\"./signature\");\nconst signdoc_1 = require(\"./signdoc\");\nconst wallet_1 = require(\"./wallet\");\nconst serializationTypeV1 = \"secp256k1wallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\nconst basicPasswordHashingOptions = {\n  algorithm: \"argon2id\",\n  params: {\n    outputLength: 32,\n    opsLimit: 24,\n    memLimitKib: 12 * 1024\n  }\n};\nfunction isDerivationJson(thing) {\n  if (!(0, utils_1.isNonNullObject)(thing)) return false;\n  if (typeof thing.hdPath !== \"string\") return false;\n  if (typeof thing.prefix !== \"string\") return false;\n  return true;\n}\nfunction extractKdfConfigurationV1(doc) {\n  return doc.kdf;\n}\nfunction extractKdfConfiguration(serialization) {\n  const root = JSON.parse(serialization);\n  if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n  switch (root.type) {\n    case serializationTypeV1:\n      return extractKdfConfigurationV1(root);\n    default:\n      throw new Error(\"Unsupported serialization type\");\n  }\n}\nexports.extractKdfConfiguration = extractKdfConfiguration;\nconst defaultOptions = {\n  bip39Password: \"\",\n  hdPaths: [(0, paths_1.makeCosmoshubPath)(0)],\n  prefix: \"cosmos\"\n};\nclass Secp256k1HdWallet {\n  constructor(mnemonic, options) {\n    var _a, _b;\n    const hdPaths = (_a = options.hdPaths) !== null && _a !== void 0 ? _a : defaultOptions.hdPaths;\n    const prefix = (_b = options.prefix) !== null && _b !== void 0 ? _b : defaultOptions.prefix;\n    this.secret = mnemonic;\n    this.seed = options.seed;\n    this.accounts = hdPaths.map(hdPath => ({\n      hdPath: hdPath,\n      prefix\n    }));\n  }\n  /**\n   * Restores a wallet from the given BIP39 mnemonic.\n   *\n   * @param mnemonic Any valid English mnemonic.\n   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n  static async fromMnemonic(mnemonic) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n    const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n    return new Secp256k1HdWallet(mnemonicChecked, {\n      ...options,\n      seed: seed\n    });\n  }\n  /**\n   * Generates a new wallet with a BIP39 mnemonic of the given length.\n   *\n   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n  static async generate() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const entropyLength = 4 * Math.floor(11 * length / 33);\n    const entropy = crypto_1.Random.getBytes(entropyLength);\n    const mnemonic = crypto_1.Bip39.encode(entropy);\n    return Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n  static async deserialize(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n    switch (root.type) {\n      case serializationTypeV1:\n        return Secp256k1HdWallet.deserializeTypeV1(serialization, password);\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n   */\n  static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n    const untypedRoot = root;\n    switch (untypedRoot.type) {\n      case serializationTypeV1:\n        {\n          const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n          const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));\n          const {\n            mnemonic,\n            accounts\n          } = decryptedDocument;\n          (0, utils_1.assert)(typeof mnemonic === \"string\");\n          if (!Array.isArray(accounts)) throw new Error(\"Property 'accounts' is not an array\");\n          if (!accounts.every(account => isDerivationJson(account))) {\n            throw new Error(\"Account is not in the correct format.\");\n          }\n          const firstPrefix = accounts[0].prefix;\n          if (!accounts.every(_ref => {\n            let {\n              prefix\n            } = _ref;\n            return prefix === firstPrefix;\n          })) {\n            throw new Error(\"Accounts do not all have the same prefix\");\n          }\n          const hdPaths = accounts.map(_ref2 => {\n            let {\n              hdPath\n            } = _ref2;\n            return (0, crypto_1.stringToPath)(hdPath);\n          });\n          return Secp256k1HdWallet.fromMnemonic(mnemonic, {\n            hdPaths: hdPaths,\n            prefix: firstPrefix\n          });\n        }\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n  static async deserializeTypeV1(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n    const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);\n    return Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n  }\n  get mnemonic() {\n    return this.secret.toString();\n  }\n  async getAccounts() {\n    const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();\n    return accountsWithPrivkeys.map(_ref3 => {\n      let {\n        algo,\n        pubkey,\n        address\n      } = _ref3;\n      return {\n        algo: algo,\n        pubkey: pubkey,\n        address: address\n      };\n    });\n  }\n  async signAmino(signerAddress, signDoc) {\n    const accounts = await this.getAccountsWithPrivkeys();\n    const account = accounts.find(_ref4 => {\n      let {\n        address\n      } = _ref4;\n      return address === signerAddress;\n    });\n    if (account === undefined) {\n      throw new Error(`Address ${signerAddress} not found in wallet`);\n    }\n    const {\n      privkey,\n      pubkey\n    } = account;\n    const message = (0, crypto_1.sha256)((0, signdoc_1.serializeSignDoc)(signDoc));\n    const signature = await crypto_1.Secp256k1.createSignature(message, privkey);\n    const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n    return {\n      signed: signDoc,\n      signature: (0, signature_1.encodeSecp256k1Signature)(pubkey, signatureBytes)\n    };\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n  async serialize(password) {\n    const kdfConfiguration = basicPasswordHashingOptions;\n    const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);\n    return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n   * is not the case, the wallet cannot be restored with the original password.\n   */\n  async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n    const dataToEncrypt = {\n      mnemonic: this.mnemonic,\n      accounts: this.accounts.map(_ref5 => {\n        let {\n          hdPath,\n          prefix\n        } = _ref5;\n        return {\n          hdPath: (0, crypto_1.pathToString)(hdPath),\n          prefix: prefix\n        };\n      })\n    };\n    const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));\n    const encryptionConfiguration = {\n      algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf\n    };\n    const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n    const out = {\n      type: serializationTypeV1,\n      kdf: kdfConfiguration,\n      encryption: encryptionConfiguration,\n      data: (0, encoding_1.toBase64)(encryptedData)\n    };\n    return JSON.stringify(out);\n  }\n  async getKeyPair(hdPath) {\n    const {\n      privkey\n    } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);\n    const {\n      pubkey\n    } = await crypto_1.Secp256k1.makeKeypair(privkey);\n    return {\n      privkey: privkey,\n      pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)\n    };\n  }\n  async getAccountsWithPrivkeys() {\n    return Promise.all(this.accounts.map(async _ref6 => {\n      let {\n        hdPath,\n        prefix\n      } = _ref6;\n      const {\n        privkey,\n        pubkey\n      } = await this.getKeyPair(hdPath);\n      const address = (0, encoding_1.toBech32)(prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(pubkey));\n      return {\n        algo: \"secp256k1\",\n        privkey: privkey,\n        pubkey: pubkey,\n        address: address\n      };\n    }));\n  }\n}\nexports.Secp256k1HdWallet = Secp256k1HdWallet;","map":{"version":3,"sources":["../src/secp256k1hdwallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Secp256k1HdWallet = exports.extractKdfConfiguration = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst addresses_1 = require(\"./addresses\");\nconst paths_1 = require(\"./paths\");\nconst signature_1 = require(\"./signature\");\nconst signdoc_1 = require(\"./signdoc\");\nconst wallet_1 = require(\"./wallet\");\nconst serializationTypeV1 = \"secp256k1wallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\nconst basicPasswordHashingOptions = {\n    algorithm: \"argon2id\",\n    params: {\n        outputLength: 32,\n        opsLimit: 24,\n        memLimitKib: 12 * 1024,\n    },\n};\nfunction isDerivationJson(thing) {\n    if (!(0, utils_1.isNonNullObject)(thing))\n        return false;\n    if (typeof thing.hdPath !== \"string\")\n        return false;\n    if (typeof thing.prefix !== \"string\")\n        return false;\n    return true;\n}\nfunction extractKdfConfigurationV1(doc) {\n    return doc.kdf;\n}\nfunction extractKdfConfiguration(serialization) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root))\n        throw new Error(\"Root document is not an object.\");\n    switch (root.type) {\n        case serializationTypeV1:\n            return extractKdfConfigurationV1(root);\n        default:\n            throw new Error(\"Unsupported serialization type\");\n    }\n}\nexports.extractKdfConfiguration = extractKdfConfiguration;\nconst defaultOptions = {\n    bip39Password: \"\",\n    hdPaths: [(0, paths_1.makeCosmoshubPath)(0)],\n    prefix: \"cosmos\",\n};\nclass Secp256k1HdWallet {\n    constructor(mnemonic, options) {\n        var _a, _b;\n        const hdPaths = (_a = options.hdPaths) !== null && _a !== void 0 ? _a : defaultOptions.hdPaths;\n        const prefix = (_b = options.prefix) !== null && _b !== void 0 ? _b : defaultOptions.prefix;\n        this.secret = mnemonic;\n        this.seed = options.seed;\n        this.accounts = hdPaths.map((hdPath) => ({\n            hdPath: hdPath,\n            prefix,\n        }));\n    }\n    /**\n     * Restores a wallet from the given BIP39 mnemonic.\n     *\n     * @param mnemonic Any valid English mnemonic.\n     * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n     */\n    static async fromMnemonic(mnemonic, options = {}) {\n        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n        return new Secp256k1HdWallet(mnemonicChecked, {\n            ...options,\n            seed: seed,\n        });\n    }\n    /**\n     * Generates a new wallet with a BIP39 mnemonic of the given length.\n     *\n     * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n     * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n     */\n    static async generate(length = 12, options = {}) {\n        const entropyLength = 4 * Math.floor((11 * length) / 33);\n        const entropy = crypto_1.Random.getBytes(entropyLength);\n        const mnemonic = crypto_1.Bip39.encode(entropy);\n        return Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);\n    }\n    /**\n     * Restores a wallet from an encrypted serialization.\n     *\n     * @param password The user provided password used to generate an encryption key via a KDF.\n     *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n     */\n    static async deserialize(serialization, password) {\n        const root = JSON.parse(serialization);\n        if (!(0, utils_1.isNonNullObject)(root))\n            throw new Error(\"Root document is not an object.\");\n        switch (root.type) {\n            case serializationTypeV1:\n                return Secp256k1HdWallet.deserializeTypeV1(serialization, password);\n            default:\n                throw new Error(\"Unsupported serialization type\");\n        }\n    }\n    /**\n     * Restores a wallet from an encrypted serialization.\n     *\n     * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n     * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n     *\n     * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n     * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n     */\n    static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n        const root = JSON.parse(serialization);\n        if (!(0, utils_1.isNonNullObject)(root))\n            throw new Error(\"Root document is not an object.\");\n        const untypedRoot = root;\n        switch (untypedRoot.type) {\n            case serializationTypeV1: {\n                const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n                const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));\n                const { mnemonic, accounts } = decryptedDocument;\n                (0, utils_1.assert)(typeof mnemonic === \"string\");\n                if (!Array.isArray(accounts))\n                    throw new Error(\"Property 'accounts' is not an array\");\n                if (!accounts.every((account) => isDerivationJson(account))) {\n                    throw new Error(\"Account is not in the correct format.\");\n                }\n                const firstPrefix = accounts[0].prefix;\n                if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {\n                    throw new Error(\"Accounts do not all have the same prefix\");\n                }\n                const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));\n                return Secp256k1HdWallet.fromMnemonic(mnemonic, {\n                    hdPaths: hdPaths,\n                    prefix: firstPrefix,\n                });\n            }\n            default:\n                throw new Error(\"Unsupported serialization type\");\n        }\n    }\n    static async deserializeTypeV1(serialization, password) {\n        const root = JSON.parse(serialization);\n        if (!(0, utils_1.isNonNullObject)(root))\n            throw new Error(\"Root document is not an object.\");\n        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);\n        return Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n    }\n    get mnemonic() {\n        return this.secret.toString();\n    }\n    async getAccounts() {\n        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();\n        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({\n            algo: algo,\n            pubkey: pubkey,\n            address: address,\n        }));\n    }\n    async signAmino(signerAddress, signDoc) {\n        const accounts = await this.getAccountsWithPrivkeys();\n        const account = accounts.find(({ address }) => address === signerAddress);\n        if (account === undefined) {\n            throw new Error(`Address ${signerAddress} not found in wallet`);\n        }\n        const { privkey, pubkey } = account;\n        const message = (0, crypto_1.sha256)((0, signdoc_1.serializeSignDoc)(signDoc));\n        const signature = await crypto_1.Secp256k1.createSignature(message, privkey);\n        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n        return {\n            signed: signDoc,\n            signature: (0, signature_1.encodeSecp256k1Signature)(pubkey, signatureBytes),\n        };\n    }\n    /**\n     * Generates an encrypted serialization of this wallet.\n     *\n     * @param password The user provided password used to generate an encryption key via a KDF.\n     *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n     */\n    async serialize(password) {\n        const kdfConfiguration = basicPasswordHashingOptions;\n        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);\n        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n    }\n    /**\n     * Generates an encrypted serialization of this wallet.\n     *\n     * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n     * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n     *\n     * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n     * is not the case, the wallet cannot be restored with the original password.\n     */\n    async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n        const dataToEncrypt = {\n            mnemonic: this.mnemonic,\n            accounts: this.accounts.map(({ hdPath, prefix }) => ({\n                hdPath: (0, crypto_1.pathToString)(hdPath),\n                prefix: prefix,\n            })),\n        };\n        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));\n        const encryptionConfiguration = {\n            algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf,\n        };\n        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n        const out = {\n            type: serializationTypeV1,\n            kdf: kdfConfiguration,\n            encryption: encryptionConfiguration,\n            data: (0, encoding_1.toBase64)(encryptedData),\n        };\n        return JSON.stringify(out);\n    }\n    async getKeyPair(hdPath) {\n        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);\n        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);\n        return {\n            privkey: privkey,\n            pubkey: crypto_1.Secp256k1.compressPubkey(pubkey),\n        };\n    }\n    async getAccountsWithPrivkeys() {\n        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {\n            const { privkey, pubkey } = await this.getKeyPair(hdPath);\n            const address = (0, encoding_1.toBech32)(prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(pubkey));\n            return {\n                algo: \"secp256k1\",\n                privkey: privkey,\n                pubkey: pubkey,\n                address: address,\n            };\n        }));\n    }\n}\nexports.Secp256k1HdWallet = Secp256k1HdWallet;\n//# sourceMappingURL=secp256k1hdwallet.js.map"]},"metadata":{},"sourceType":"script"}