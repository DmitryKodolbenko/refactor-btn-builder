{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.firstEvent = exports.toListPromise = exports.fromListPromise = void 0;\nconst xstream_1 = require(\"xstream\");\n/**\n * Emits one event for each list element as soon as the promise resolves\n */\nfunction fromListPromise(promise) {\n  const producer = {\n    start: listener => {\n      // the code in `start` runs as soon as anyone listens to the stream\n      promise.then(iterable => {\n        for (const element of iterable) {\n          listener.next(element);\n        }\n        listener.complete();\n      }).catch(error => listener.error(error));\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    stop: () => {}\n  };\n  return xstream_1.Stream.create(producer);\n}\nexports.fromListPromise = fromListPromise;\n/**\n * Listens to stream and collects events. When `count` events are collected,\n * the promise resolves with an array of events.\n *\n * Rejects if stream completes before `count` events are collected.\n */\nasync function toListPromise(stream, count) {\n  return new Promise((resolve, reject) => {\n    if (count === 0) {\n      resolve([]);\n      return;\n    }\n    const events = new Array();\n    // take() unsubscribes from source stream automatically\n    stream.take(count).subscribe({\n      next: event => {\n        events.push(event);\n        if (events.length === count) {\n          resolve(events);\n        }\n      },\n      complete: () => {\n        reject(`Stream completed before all events could be collected. ` + `Collected ${events.length}, expected ${count}`);\n      },\n      error: error => reject(error)\n    });\n  });\n}\nexports.toListPromise = toListPromise;\n/**\n * Listens to stream, collects one event and revolves.\n *\n * Rejects if stream completes before one event was fired.\n */\nasync function firstEvent(stream) {\n  return (await toListPromise(stream, 1))[0];\n}\nexports.firstEvent = firstEvent;","map":{"version":3,"sources":["../src/promise.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA;;AAEG;AACH,SAAgB,eAAe,CAAI,OAA6B,EAAA;EAC9D,MAAM,QAAQ,GAAgB;IAC5B,KAAK,EAAG,QAAQ,IAAI;MAClB;MACA,OAAO,CACJ,IAAI,CAAE,QAAQ,IAAI;QACjB,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;UAC9B,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC;QACvB;QACD,QAAQ,CAAC,QAAQ,EAAE;MACrB,CAAC,CAAC,CACD,KAAK,CAAE,KAAK,IAAK,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;IAC5C,CAAC;IACD;IACA,IAAI,EAAE,MAAK,CAAE;GACd;EAED,OAAO,SAAA,CAAA,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC;AAChC;AAlBA,OAAA,CAAA,eAAA,GAAA,eAAA;AAoBA;;;;;AAKG;AACI,eAAe,aAAa,CAAI,MAAiB,EAAE,KAAa,EAAA;EACrE,OAAO,IAAI,OAAO,CAAe,CAAC,OAAO,EAAE,MAAM,KAAI;IACnD,IAAI,KAAK,KAAK,CAAC,EAAE;MACf,OAAO,CAAC,EAAE,CAAC;MACX;IACD;IAED,MAAM,MAAM,GAAG,IAAI,KAAK,EAAK;IAC7B;IACA,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC;MAC3B,IAAI,EAAG,KAAK,IAAI;QACd,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;QAElB,IAAI,MAAM,CAAC,MAAM,KAAK,KAAK,EAAE;UAC3B,OAAO,CAAC,MAAM,CAAC;QAChB;MACH,CAAC;MACD,QAAQ,EAAE,MAAK;QACb,MAAM,CACJ,yDAAyD,GACvD,aAAa,MAAM,CAAC,MAAM,cAAc,KAAK,EAAE,CAClD;MACH,CAAC;MACD,KAAK,EAAG,KAAK,IAAK,MAAM,CAAC,KAAK;KAC/B,CAAC;EACJ,CAAC,CAAC;AACJ;AA1BA,OAAA,CAAA,aAAA,GAAA,aAAA;AA4BA;;;;AAIG;AACI,eAAe,UAAU,CAAI,MAAiB,EAAA;EACnD,OAAO,CAAC,MAAM,aAAa,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;AAC5C;AAFA,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.firstEvent = exports.toListPromise = exports.fromListPromise = void 0;\nconst xstream_1 = require(\"xstream\");\n/**\n * Emits one event for each list element as soon as the promise resolves\n */\nfunction fromListPromise(promise) {\n    const producer = {\n        start: (listener) => {\n            // the code in `start` runs as soon as anyone listens to the stream\n            promise\n                .then((iterable) => {\n                for (const element of iterable) {\n                    listener.next(element);\n                }\n                listener.complete();\n            })\n                .catch((error) => listener.error(error));\n        },\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        stop: () => { },\n    };\n    return xstream_1.Stream.create(producer);\n}\nexports.fromListPromise = fromListPromise;\n/**\n * Listens to stream and collects events. When `count` events are collected,\n * the promise resolves with an array of events.\n *\n * Rejects if stream completes before `count` events are collected.\n */\nasync function toListPromise(stream, count) {\n    return new Promise((resolve, reject) => {\n        if (count === 0) {\n            resolve([]);\n            return;\n        }\n        const events = new Array();\n        // take() unsubscribes from source stream automatically\n        stream.take(count).subscribe({\n            next: (event) => {\n                events.push(event);\n                if (events.length === count) {\n                    resolve(events);\n                }\n            },\n            complete: () => {\n                reject(`Stream completed before all events could be collected. ` +\n                    `Collected ${events.length}, expected ${count}`);\n            },\n            error: (error) => reject(error),\n        });\n    });\n}\nexports.toListPromise = toListPromise;\n/**\n * Listens to stream, collects one event and revolves.\n *\n * Rejects if stream completes before one event was fired.\n */\nasync function firstEvent(stream) {\n    return (await toListPromise(stream, 1))[0];\n}\nexports.firstEvent = firstEvent;\n//# sourceMappingURL=promise.js.map"]},"metadata":{},"sourceType":"script"}