{"ast":null,"code":"import { waitFor } from '@near-wallet-selector/core';\nimport detectEthereumProvider from '@metamask/detect-provider';\nimport { ethers } from 'ethers';\nimport * as nearAPI from 'near-api-js';\nimport { generateSeedPhrase } from 'near-seed-phrase';\nimport BN from 'bn.js';\nimport isMobile from 'is-mobile';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nconst nethIcon = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABiCAYAAACmu3ZJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAEqVJREFUeJztnHtUVXWbx797n/uBIxcvwNG4CGqCikZKpIFKr5TayItm5qsD1Vuu0bIsXSOrSJmVjk6OC8fpNisTWWW6alLGZLQy31ReFRIjSxAvIAYCcr+c+9nP/MFIL3I4Z1/O4eb7WWv/wTl7P8+zn+/ev9/zuxwYIiLcQ1VVFT799FMcPXoU169fR21tLex2O2QyGQICAhAaGor58+dj2bJlCA8Pv/fyIU1paSlycnLw/fff4+rVq2hpacGoUaMwduxYLFiwAMuXL0dISIh4B/Q3mM1mSk9PJ41GQwBcHnK5nNatW0etra001Kmvr6fU1FRiWdZpTpRKJa1bt446OjpE+ekSpKGhgeLj43kJce8xbdo0qq+vd9vNDzRKSkooLCxMUE5iYmKoqqpKsC8QEVksFkpISBAlxt0jOjqaWlpa3J6M/qa6uprGjBkjKidTp06l9vZ2Qf5ARJSRkSFJjLvH/PnzyWazeSQx/QHHcZSUlCQpJ6tWrRLkE9XV1eTl5eUWQQDQunXrPJSevueDDz6QnA+5XE6XL1/m7RPvvvuu28S4e3z44YceTFPfUF5eTjqdzi352LBhA2+/mDNnjtsFUSgUdPLkSc9ly8PY7XaaPXu22/IxceJE3r6h1+vdLggA8vf3p7KyMg+mzXPs2rXLrbmQy+Vkt9t5+YZCofCIIHefjObmZg+nz72UlZWRVqt1ey7q6up4+YenxLh7zJs3j6xWq4fT6B7sdrvosZirg++YxOOCAKC1a9d6OJXuwRMFzoAUBAC9//77Hk6nNEpKSnhPGQ0JQeRyOX333XceTqs4bDYbxcbGevT+B5wgAMjPz4+uXLni4fQKZ+vWrR6/9wEpCACaMGECNTY2ejjF/Ll8+TKp1er7VxAAFB8fT2az2cOpdo3VaqXp06f3yT0PaEEA0AsvvODhdLtm8+bNfXa/A14QALR7924Pp7x3Ll68SEIHxUFBQQNTEJZlafv27fTggw9KEkQul9Px48c9nPqemM1mio6O5h2nSqWizz77jKxWK/n4+Aw8QYKCgoiI6MaNGzRy5EhJovj6+lJJSYkn89+Dt956i3d8/v7+9MMPP3RdK3buz6OC6PX6LgNnzpwhlUolSZSwsDC6c+eO2xPviAsXLvBuqsLCwnqsZQx4QYiIsrOzJQkCgB577DGPV14mk4kmTZrEK54ZM2ZQTU1NDxuDQhAiog0bNkgW5fnnn5ecdGfwjTE5ObnXXSODRhC73U6LFi2SLEpWVpakpPfG2bNnSSaTufS/du1ap/sCBo0gRERtbW00ZcoUSYLIZDI6cuSIqKT3htFopMjISKd+GYahTZs2ubQ1qAQhIqqoqKCAgABJouh0Orp06RLffLvktddec+pPrVbTgQMHeNkadIIQEeXn50uuvEJDQ3mvsjnjzJkzTpuq4cOH0+nTp3nbG5SCEBHl5ORIEgQAzZo1i0wmE+9k3UtHRwdFRET0aj88PFzw7POgFYSIKD09XbIoaWlpghL2t6xevbpXu3FxcaLewEEtCMdxtHTpUsmi7NixQ3DiTpw4QQzDOLS3ZMkSMhgMgm0SDXJBiIgMBoPkKW6WZSk3N5e3z/b2dgoPD3doa+3atby35Dhi0AtCRFRZWUmBgYGSRBFSeb3yyis9rpfL5W7ZUTkkBCEiOnfunOSVudDQUKqtrXXp694JT29vb8rLyxMcsyOGjCBERPv37++1Xed7zJw502XllZyc3C3WoqIiUfE6YkgJQuSenz6kpqY69dHS0kKZmZmUnp5Ot2/fFh2rI4acIBzH0bJlyySLsm3bNtExSGHICULUWXnNmDFDkiAsy9Lhw4clxSEGTwvCoh/QaDQ4fPgwxowZI9oGx3FYsWIFiouL3RhZ/9MvggBAUFAQcnNzodVqRdtob2/H/PnzUV1d7cbI+pd+EwQAHnroIeTk5IBhGNE2qqursWjRIhiNRjdG1n/0qyAAsHjxYrz99tuSbPz4449IS0sD9fwfCIOSPu/U74XjOFq+fLnkymvLli1ujcsRQ7LKcoTRaJS8A51hGN4LTWIZklWWI9RqNQ4fPowHHnhAtA0iwnPPPYfCwkI3Rta3DBhBACAwMBC5ubnw8vISbcNoNCI5ORlVVVVujKzvGFCCAMC0adOQk5MDlhUf2t3Ky2AwuDGyvmHACQIAKSkpyMzMlGTjwoULSE1NHZSV14Do1O+F4zhasWKF5MorMzPTrXF5ulNn/v8CQej1+j5po00mE+bMmYNz586JtsEwDA4ePIinn37aLTH9/PPPaG1tRWNjI5qamnD79m2cP38eBQUFTmcMqqqqoNfrefkYkG/IXWpqaig4OFjSW6LVaqmwsNDjsVZWVlJWVhbFxMQMzTfkLsXFxZg1axba29tF29Dr9SgoKMDo0aMFXWe2EGoa7GhotqPdQPj+5GmolDL4DtNghL8KD0aMxOTInqX65cuXsWvXLnzyySew2Wy835BBIQgA5ObmIiUlBRzHibYRExODU6dOOZ3Q5Djg8g0LisssKC23orrO5tKuzdIG1noTYXobVi6eirCQkV3flZWVISMjA1lZWQgKCnJpa9AIAgDbtm1Denq6JBspKSn44osvepTV7QYO354z4kyRCc1t4kXnOBu4jhIkzdRi+eJHBF8/IASpqanBzp07odFo8Prrr8PHx6fXc9PS0rBv3z7Rvvz8/FBQUICIiAgAgMVK+PqUAd+dM8JscW+JbG4txYtLg5AQF8H7mn4XpKioCE899VRXhZKcnIxDhw71er7ZbEZiYiLy8/MF+woNDUVeXh4mTpwIoLNpys5tR0OzXVzwPCCyQ8sV49/enAOtRuny/H4V5Ouvv8azzz7brbMOCAhATU2N0+vq6uoQGxuLiooK3r6io6Nx/PhxBAQEgAjY8M43aLZPQ1+NG4OGE9auGI5R/jKn5/XbSP29995DcnJyj8rpmWeecXntqFGjcOTIEeh0Ol6+goODkZeXh4CAABhNVrz4zyfQZBMvRvgYheBrbjcweOe/mnDtltXpeX0uCMdxeOONN/Dyyy/Dbu/eVISGhuKdd97hZWfSpEnYv38/ZDLnT5yvry/y8vKg1+s7xdh4CqSZIjr+SRFKJDyshr+P8NR1GAk7c1pwrbJ3UfpUEIPBgCVLlmDnzp09vmMYBnv27OH91APAwoULsX37dqfnZGdnIyoqCkTAK5tOQeUjXgylgsGfFniDYYG4aDXErDybLYT/2N/SazndZ4I0NDRg3rx5vXbYa9aswdy5cwXbfeONN/DSSy85/G7lypVYtGgRACD9X78BqcWLAQALHtN29QEjfGUYFyy86QI635Tdn7fCaOrZZvaJICUlJZg+fXqvlVF4eDi2bdsm2v7u3bsRHx/f7bOgoCBkZWUBAI58cwm1xsmi7QNAwHAZkmZqun320EQV1CpxGzTqGu3Yd6Stx+ceFyQ/Px/x8fEoLy93+D3LstizZ4+kRSmlUomvvvqqa2wBAJs2bYK/vz/MFjsOHLeAZeWi7QPAyoXeUMi7J1+lZBATqRJts/AXM4qvWLp95lFBcnJyMHfuXNTX1/d6zquvvoqEhATJvoYPH47c3Fz4+Phg9OjRSEtLAwD8y84TUHsHS7IdO0WFiWMdjyHCxygQOMJ5YeGM/XntsNl+b7o8IggRYfPmzUhLS4PFYun1vAkTJmDLli1u8xsZGYmDBw8iPT0dKpUKrW0mVDaFSrKpUTFYOs+71+8ZBoidrIbYBc76ZjvyfzJ3/e12QSwWC9LS0pCZmel0tU4mk2Hv3r3QaDS9niOGpKQkrFmzBgDwn3vPQ6n2k2Qv5XEv+Oqcp8lXxyKylzeID3lnDF1jIrcK0tTUhCeeeAI5OTkuz12/fj3i4uLc6b4Hv1aI36YKACF6OWY/zO+BiZ6ghLdWXDrrm+woLe9sSdwmSHl5OWbOnImTJ0+6PDcqKkrymrkrKqotUOtCRV/PMMCKBd68myK5jMH0SeI7+L8WdzZbbhGkoKAAcXFxKCkpcXmuXC7H3r17oVKJD54Pv15zvY7hjDnTNRgrcIokOFCOBwLFVXO/XLWAyA2CHDp0CHPmzEFtbS2v8zdu3Ijp06dLdeuS0grnc0bOGObN4o+J4srw2MkqyOXCxyatHRyq79jECdLW1oaOjg7s3LkTS5Ys4b3/KTo6GhkZGWJcCuZmtXhBliV5Q6vumdR2A4eCS2aUVdhwo8oKm71n0eKlYTFlnLgO/ma1DaLer7a2Nvj5+cFq5X/TCoUC2dnZUCrFVyN8aevg0GEUN5U7IVSBGZO7N6f1zXaUVVhhtXX2LWYrh9oGO6pq7RjhJ0NIoAxaze/P9qQIJcqrrGhqFbbyeLveLk4QAILEAICMjAxMnTpVrDtBNLSIW4KVy4CVC3Vdk4Y3q22ouN3ZFzFAj8lEO0eobbChrtEGH28WwYEK+PuwXWOT4381CJrib2iRIIgQpk2bho0bN/aFKwCAySzu7XhilhYj/WW4fMOC2no7ZDIGfHoDIqC5jUNzmxlaNQv9KBlGj5Rj7BgFrrtY/+gWt4k8L4hKpcK+ffugUIibGRWDxSpcEF8di8DhMpwuMkLGMpDJxE0aGkwcrlVy+O22DSP9WNysBmw8V4hNFvL85GJmZiYmT5Y20yoUuYjHrKWdw8lCEyzia4FudJgIv1yz8hYDAFQKxrNvSGxsLNavX+9JFw7RqMQ9Z9dvWXGrxoZJEUpEhisgY4W/JUSdRUVzGweizn6Hbz+iVjGee0NUKhX27NnjconVE7iae3KEUsHgqQQt1EoGRSVm/M9fDPitVtjg0mgiVNfZ0NTKQaNiMHGsUtCqot8w1nOCbN26FVFRUZ4y7xRfHSt44chsIfxyzYLMNX54cpYWBiOHE+eN+OasweXGOYuVUFNvR12jHYTOsndhgheq62wQstEycIQcMgCbBUXOg0cffRQfffSRpB/dSIFhgJ+vWNAocBzQ3MZBIWOw+HEvzJikxp1GO67fsuFqpRVmCzDKXwYZy6C+2Y4OI4HjgOZWDo0tHGx24IFAORJjNQjVK3D+khm364Xt91oYr4VMoVBslrJf9l60Wi2OHTuGESNGuM2mGOqb7Ci7KbyHvlppxbgQJUL1cjwyRY1xIQqUV9lQXmXDtVtWKOQMOA6oqbfjTpMdJgvBR8ciPkaNKeNVUCoYVFRbcbG093UgR6hVDJY/qQMbEBAgOGhnbN++HePGjXOrTTFERYibESAC9nzVinZD50MaOVaJzH/yx7NPegMEnC02oajEjMYWDgo5gxmTVVg02wv6kZ31UbuBw9liszMXDokcqwTLAqw7kzd79mysXr3abfakMC5YgRF+4gqKplYO2bm/b+CTyYDHH9Fgyyv+SHhYDSJgfIgCyXO9MDHs946bCDh1wSRqHPTIlM7pGnbhwoWigr4XLy8vfPzxx/3Wb9wLwwCPRouf4r9YasZfCrv/uw4fHYt/fEqHFQt1iItWQ63sXjj8VGrGnSbh+4S9tSyix3e+0ezy5cvh7d37mjFfduzYgfDwcMl23ElirAYqpbgRNwAcONbhsPRVOBi91TbYcemasH7jLn94RNM1Zc8GBgZKHrwlJSVh1apVkmx4Am8ti4SH1aKvt9oIH33Z5rIJslgJp4uMovYKe2kYzI39fZmYBYA333wTiYmJwq0BCAkJQXZ2tqT/6ONJ/mG2600Kzqius+HLbzucnpN/0SR6un/x493XXligc1n1yy+/FCxKeHg4vv32WwQGBooKpi/QqJjOCkkC3xcY8dMVx83RlQoLKmvELRdHBCsQH9P9De56dHx9fXHs2DFkZma67FNYlkVaWhoKCwsHRInrioejVD1uXAhEwN7DbT1G7M1tHH78VXiJCwBaDYMXF+t6TK0w5GDzVG1tLT7//HMcPXoUpaWlqK2thbe3N8aPH4/ExESkpqZi/PjxogLpLyxWwr/va3H5+wxnTAhVYH2qL85dMsFsIRw9ZRC8Kgh0LoS9+icfRIb3HCs5FGSo0mEkbPukmdcva3tjyR+84KNjkX/RhNJy4eIyDPDnlGFd444e399PggCdouz6rEXQSt7fIpMBM6JUOHfJLLiqksuA5/84DLGTex8f3XeCAJ0zux9/1YaiEnHtvxiGebFY9fQwPBjmfOX0vhQE6OyoT5w34r+/6xA11SGEyLFK/DlFBx8e5fd9K8hd6pvtOPC/HbhY6v63xVfHYuk8b8T20l844r4X5C7lVTYcPWVAcZlZ0KKSI0b4yZD0qAaPPaTu8SMfV/xdkHtoaeNw/pIZxWVmXL9lg9XGLz2j/GWIDFcidrIK44IVon4QCvxdEKdYrITfam1dy7NmC8FsJbAMA7WK6dw6NEKG0aPk8Bvmnlnu/wNWcf8As19BPQAAAABJRU5ErkJggg==`;\n\n/*eslint @typescript-eslint/no-use-before-define: 1*/\nconst {\n  Near,\n  Account,\n  KeyPair,\n  keyStores: {\n    BrowserLocalStorageKeyStore\n  },\n  transactions: {\n    addKey,\n    deleteKey,\n    functionCallAccessKey\n  },\n  utils: {\n    PublicKey,\n    format: {\n      parseNearAmount\n    }\n  }\n} = nearAPI;\nconst NETH_SITE_URL = \"https://neth.app\";\nconst PREV_NETH_SITE_URL = \"neardefi.github.io/neth\";\nconst NETWORK = {\n  testnet: {\n    FUNDING_ACCOUNT_ID: \"neth.testnet\",\n    MAP_ACCOUNT_ID: \"map.neth.testnet\",\n    ROOT_ACCOUNT_ID: \"testnet\"\n  },\n  mainnet: {\n    MAP_ACCOUNT_ID: \"nethmap.near\",\n    ROOT_ACCOUNT_ID: \"near\"\n  }\n};\nconst WS_STORAGE_NAMESPACE = \"near-wallet-selector:neth:\";\nconst REFRESH_MSG = `Please refresh the page and try again.`;\nconst TX_ARGS_ATTEMPT = \"__TX_ARGS_ATTEMPT\";\nconst ATTEMPT_SECRET_KEY = \"__ATTEMPT_SECRET_KEY\";\nconst ATTEMPT_ACCOUNT_ID = \"__ATTEMPT_ACCOUNT_ID\";\nconst ATTEMPT_ETH_ADDRESS = \"__ATTEMPT_ETH_ADDRESS\";\nconst APP_KEY_SECRET = \"__APP_KEY_SECRET\";\nconst APP_KEY_ACCOUNT_ID = \"__APP_KEY_ACCOUNT_ID\";\nconst defaultGas = \"200000000000000\";\nconst halfGas = \"50000000000000\"; /// this is the new account amount 0.21 for account name, keys, contract and 0.01 for mapping contract storage cost\n\nconst MIN_NEW_ACCOUNT = parseNearAmount(\"0.4\");\nconst MIN_NEW_ACCOUNT_THRESH = parseNearAmount(\"0.49\");\nconst MIN_NEW_ACCOUNT_ASK = parseNearAmount(\"0.5\");\nconst FUNDING_CHECK_TIMEOUT = 5000; /// lkmfawl\n\nconst attachedDepositMapping = parseNearAmount(\"0.05\"); /// Helpers\n\nconst defaultStorage = function () {\n  let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  return {\n    getItem: k => {\n      const v = localStorage.getItem(prefix + k);\n      if ((v === null || v === void 0 ? void 0 : v.charAt(0)) !== \"{\") {\n        return v;\n      }\n      try {\n        return JSON.parse(v);\n      } catch (e) {//   logger.log(e);\n      }\n    },\n    setItem: (k, v) => localStorage.setItem(prefix + k, typeof v === \"string\" ? v : JSON.stringify(v)),\n    removeItem: k => localStorage.removeItem(prefix + k)\n  };\n};\nconst defaultLogger = () => ({\n  // eslint-disable-next-line\n  log: args => console.log(...args)\n}); /// NEAR setup\n\nlet near, gas, keyStore, logger, storage, connection, networkId, contractAccount, accountSuffix;\nconst initConnection = _ref => {\n  let {\n    network,\n    gas: _gas = defaultGas,\n    logger: _logger = defaultLogger(),\n    storage: _storage = defaultStorage()\n  } = _ref;\n  gas = _gas;\n  logger = _logger;\n  storage = _storage;\n  keyStore = new BrowserLocalStorageKeyStore();\n  near = new Near(Object.assign(Object.assign({}, network), {\n    keyStore\n  }));\n  connection = near.connection;\n  networkId = network.networkId;\n  contractAccount = new Account(connection, networkId === \"mainnet\" ? \"near\" : networkId);\n  accountSuffix = networkId === \"mainnet\" ? \".near\" : \".\" + networkId;\n  const cover = document.createElement(\"div\");\n  cover.style.display = \"none\";\n  cover.style.width = \"100%\";\n  cover.style.height = \"100vh\";\n  cover.style.zIndex = \"999999\";\n  cover.style.position = \"fixed\";\n  cover.style.top = \"0\";\n  cover.style.background = \"rgba(0, 0, 0, 0.5)\";\n  document.body.appendChild(cover); /// recovery from unbundled TXs that haven't been broadcast yet\n\n  broadcastTXs();\n  return cover;\n};\nconst getConnection = () => {\n  return {\n    near,\n    connection,\n    keyStore,\n    networkId,\n    contractAccount,\n    accountSuffix\n  };\n}; /// helpers\n\nconst accountExists = function (accountId) {\n  let ethAddress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    try {\n      const account = new nearAPI.Account(connection, accountId);\n      yield account.state();\n      if (ethAddress) {\n        const mapAccountId = yield getNearMap(ethAddress);\n        if (mapAccountId) {\n          return true;\n        }\n      }\n      return true;\n    } catch (e) {\n      if (!/no such file|does not exist/.test(e.toString())) {\n        throw e;\n      }\n      return false;\n    }\n  });\n};\nconst buf2hex = buf => ethers.utils.hexlify(buf).substring(2);\nconst pub2hex = publicKey => ethers.utils.hexlify(PublicKey.fromString(publicKey).data).substring(2); /// account creation and connection flow\n\nconst handleCreate = (signer, ethAddress, newAccountId, fundingAccountCB, fundingErrorCB, postFundingCB) => __awaiter(void 0, void 0, void 0, function* () {\n  if (networkId === \"testnet\" && newAccountId.indexOf(\".near\") > -1 || networkId === \"mainnet\" && newAccountId.indexOf(\".testnet\") > -1) {\n    return alert(\"Invalid account name. You do not need to add any .near or .testnet. Please try again.\");\n  } /// get keypair from eth sig entropy for the near-eth account\n\n  const {\n    publicKey: fundingAccountPubKey,\n    secretKey: new_secret_key\n  } = yield keyPairFromEthSig(signer, fundingKeyPayload()); /// store attempt in localStorage so we can recover and retry / resume contract deployment\n\n  yield storage.setItem(ATTEMPT_ACCOUNT_ID, newAccountId);\n  yield storage.setItem(ATTEMPT_SECRET_KEY, new_secret_key);\n  yield storage.setItem(ATTEMPT_ETH_ADDRESS, ethAddress);\n  return yield createAccount({\n    signer,\n    newAccountId,\n    fundingAccountPubKey,\n    fundingAccountCB,\n    fundingErrorCB,\n    postFundingCB\n  });\n});\nconst createAccount = _ref2 => {\n  let {\n    signer,\n    newAccountId,\n    fundingAccountPubKey,\n    fundingAccountCB,\n    fundingErrorCB,\n    postFundingCB\n  } = _ref2;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    // const { publicKey, secretKey } = parseSeedPhrase(process.env.REACT_APP_FUNDING_SEED_PHRASE);\n    /// assumes implicit is funded, otherwise will warn and cycle here\n    const implicitAccountId = Buffer.from(PublicKey.from(fundingAccountPubKey).data).toString(\"hex\");\n    if (fundingAccountCB) {\n      fundingAccountCB(implicitAccountId);\n    } /// wait for implicit funding here and then continue to createAccount\n\n    const checkImplicitFunded = () => __awaiter(void 0, void 0, void 0, function* () {\n      logger.log(\"checking for funding of implicit account\", implicitAccountId);\n      const account = new Account(connection, implicitAccountId);\n      try {\n        const balance = yield account.getAccountBalance();\n        const {\n          available\n        } = balance;\n        const diff = new BN(available).sub(new BN(MIN_NEW_ACCOUNT_THRESH));\n        if (diff.lt(new BN(\"0\"))) {\n          // alert(`There is not enough NEAR (${formatNearAmount(MIN_NEW_ACCOUNT_ASK, 4)} minimum) to create a new account and deploy NETH contract. Please deposit more and try again.`)\n          if (fundingErrorCB) {\n            fundingErrorCB(implicitAccountId, diff.abs().toString());\n          }\n          yield new Promise(r => setTimeout(r, FUNDING_CHECK_TIMEOUT));\n          return yield checkImplicitFunded();\n        }\n      } catch (e) {\n        if (!/does not exist/gi.test(e.toString())) {\n          throw e;\n        }\n        logger.log(\"not funded, checking again\");\n        yield new Promise(r => setTimeout(r, FUNDING_CHECK_TIMEOUT));\n        return yield checkImplicitFunded();\n      }\n      return true;\n    }); /// if not funded properly, return and reload\n\n    if (!(yield checkImplicitFunded())) {\n      return window.location.reload();\n    }\n    logger.log(\"implicit account funded\", implicitAccountId);\n    if (postFundingCB) {\n      postFundingCB();\n    }\n    const {\n      account,\n      ethAddress\n    } = yield setupFromStorage(implicitAccountId); /// final checks, last chance to cancel funding if they fail\n\n    if (yield accountExists(newAccountId, ethAddress)) {\n      alert(`${newAccountId} already exists. Please try another.`);\n      return yield handleCancelFunding(implicitAccountId);\n    } /// create account now\n    /// get keypair from eth sig entropy for the near-eth account\n\n    const {\n      publicKey: new_public_key,\n      secretKey: new_secret_key\n    } = yield keyPairFromEthSig(signer, unlimitedKeyPayload(newAccountId, ethAddress));\n    yield storage.setItem(ATTEMPT_SECRET_KEY, new_secret_key); // remove any existing app key\n\n    yield storage.removeItem(APP_KEY_ACCOUNT_ID);\n    yield storage.removeItem(APP_KEY_SECRET);\n    try {\n      yield account.functionCall({\n        contractId: NETWORK[networkId].ROOT_ACCOUNT_ID,\n        methodName: \"create_account\",\n        args: {\n          new_account_id: newAccountId,\n          new_public_key\n        },\n        gas,\n        attachedDeposit: new BN(MIN_NEW_ACCOUNT)\n      });\n    } catch (e) {\n      if (!/be created by/.test(JSON.stringify(e))) {\n        throw e;\n      }\n      return handleCancelFunding(implicitAccountId);\n    } /// check\n\n    if (!(yield accountExists(newAccountId))) {\n      return logger.log(`Account ${newAccountId} could NOT be created. Please refresh the page and try again.`);\n    }\n    logger.log(`Account ${newAccountId} created successfully.`); /// drain implicit\n\n    yield account.deleteAccount(newAccountId);\n    return yield handleMapping();\n  });\n};\nconst handleCancelFunding = fundingAccountId => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    account\n  } = yield setupFromStorage(fundingAccountId);\n  const refundAccountId = window.prompt(`There was an error creating the account. You need to refund and try again. Please enter the account you funded from. MAKE SURE IT IS CORRECT. THIS CANNOT BE UNDONE.`); /// drain implicit\n\n  try {\n    yield account.deleteAccount(refundAccountId);\n  } catch (e) {\n    logger.log(\"Cannot delete implicit\");\n  } finally {\n    /// delete attempt\n    yield storage.removeItem(ATTEMPT_ACCOUNT_ID);\n    yield storage.removeItem(ATTEMPT_SECRET_KEY);\n    yield storage.removeItem(ATTEMPT_ETH_ADDRESS);\n  }\n});\nconst handleMapping = () => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    account,\n    ethAddress\n  } = yield setupFromStorage();\n  try {\n    yield account.functionCall({\n      contractId: NETWORK[networkId].MAP_ACCOUNT_ID,\n      methodName: \"set\",\n      args: {\n        eth_address: ethAddress\n      },\n      gas,\n      attachedDeposit: new BN(attachedDepositMapping)\n    });\n    logger.log(`Account mapping successful`);\n  } catch (e) {\n    logger.log(e);\n    return logger.log(`Account mapping failed`);\n  }\n  return yield handleDeployContract();\n});\nconst handleDeployContract = () => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    account\n  } = yield setupFromStorage();\n  const contractPath = window === null || window === void 0 ? void 0 : window.contractPath; // logger.log(contractPath)\n\n  const ab = yield fetch(contractPath).then(res => res.arrayBuffer());\n  const contractBytes = new Uint8Array(ab); // logger.log(\"contractBytes.length\", contractBytes.length);\n\n  try {\n    yield account.deployContract(contractBytes);\n    logger.log(`Contract deployed successfully.`);\n  } catch (e) {\n    logger.log(e);\n    return logger.log(`Contract deployment failed. ${REFRESH_MSG}`);\n  }\n  return yield handleSetupContract();\n});\nconst handleSetupContract = () => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    account,\n    ethAddress\n  } = yield setupFromStorage();\n  try {\n    yield account.functionCall({\n      contractId: account.accountId,\n      methodName: \"setup\",\n      args: {\n        eth_address: ethAddress\n      },\n      gas\n    });\n    logger.log(`Contract setup successfully.`);\n  } catch (e) {\n    logger.log(e);\n    return logger.log(`Contract setup failed. ${REFRESH_MSG}`);\n  }\n  return yield handleKeys();\n});\nconst handleKeys = () => __awaiter(void 0, void 0, void 0, function* () {\n  var _a, _b, _c;\n  const {\n    account,\n    newAccountId,\n    ethAddress\n  } = yield setupFromStorage();\n  const accessKeys = yield account.getAccessKeys(); // keys are done\n\n  if (accessKeys.length !== 1 || ((_b = (_a = accessKeys[0]) === null || _a === void 0 ? void 0 : _a.access_key) === null || _b === void 0 ? void 0 : _b.permission) !== \"FullAccess\") {\n    return;\n  }\n  const publicKey = PublicKey.from(accessKeys[0].public_key);\n  const actions = [\n  // delete the full access key\n  deleteKey(publicKey),\n  // limited to execute, unlimited allowance\n  addKey(publicKey, functionCallAccessKey(newAccountId, [\"execute\"]))];\n  try {\n    const res = yield account.signAndSendTransaction({\n      receiverId: newAccountId,\n      actions\n    });\n    if (((_c = res === null || res === void 0 ? void 0 : res.status) === null || _c === void 0 ? void 0 : _c.SuccessValue) !== \"\") {\n      return logger.log(`Key rotation failed. ${REFRESH_MSG}`);\n    }\n    logger.log(`Key rotation successful.`);\n  } catch (e) {\n    logger.log(e);\n    return logger.log(`Key rotation failed. ${REFRESH_MSG}`);\n  }\n  return yield handleCheckAccount({\n    ethAddress\n  });\n}); /// waterfall check everything about account and fill in missing pieces\n\nconst handleCheckAccount = _ref3 => {\n  let {\n    signer = null,\n    ethAddress = null,\n    fundingAccountCB = null,\n    fundingErrorCB = null,\n    postFundingCB = null\n  } = _ref3;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    var _d, _e;\n    const setup = yield setupFromStorage();\n    let {\n      newAccountId\n    } = setup;\n    const {\n      newSecretKey\n    } = setup;\n    const mapAccountId = yield getNearMap(ethAddress);\n    if (!mapAccountId) {\n      // alert(\"create account first\");\n      logger.log(\"No account mapping exists.\");\n    } else {\n      newAccountId = mapAccountId;\n    }\n    logger.log(\"Checking account created.\");\n    if (!(yield accountExists(newAccountId))) {\n      const keyPair = KeyPair.fromString(newSecretKey);\n      return createAccount({\n        signer,\n        newAccountId,\n        fundingAccountPubKey: keyPair.getPublicKey().toString(),\n        fundingAccountCB,\n        fundingErrorCB,\n        postFundingCB\n      });\n    }\n    const account = new Account(connection, newAccountId);\n    logger.log(\"Checking account address mapping.\");\n    const mapRes = yield account.viewFunction(NETWORK[networkId].MAP_ACCOUNT_ID, \"get_eth\", {\n      account_id: newAccountId\n    });\n    if (mapRes === null) {\n      return handleMapping();\n    }\n    logger.log(\"Checking contract deployed.\");\n    const state = yield account.state();\n    if (state.code_hash === \"11111111111111111111111111111111\") {\n      return handleDeployContract();\n    }\n    logger.log(\"Checking contract setup.\");\n    try {\n      const ethRes = yield account.viewFunction(newAccountId, \"get_address\"); // any reason the address wasn't set properly\n\n      if (!ethRes || !ethRes.length) {\n        return handleSetupContract();\n      }\n    } catch (e) {\n      // not set at all (wasm error unreachable storage value)\n      logger.log(e);\n      return handleSetupContract();\n    }\n    logger.log(\"Checking access keys.\");\n    const accessKeys = yield account.getAccessKeys();\n    if (accessKeys.length === 1 && ((_e = (_d = accessKeys[0]) === null || _d === void 0 ? void 0 : _d.access_key) === null || _e === void 0 ? void 0 : _e.permission) === \"FullAccess\") {\n      return handleKeys();\n    }\n    logger.log(\"Account created.\");\n    logger.log(\"Contract deployed and setup.\");\n    logger.log(\"Mapping added.\");\n    logger.log(\"Keys rotated.\");\n    yield storage.removeItem(ATTEMPT_ACCOUNT_ID);\n    yield storage.removeItem(ATTEMPT_SECRET_KEY);\n    yield storage.removeItem(ATTEMPT_ETH_ADDRESS);\n    return {\n      account\n    };\n  });\n}; /// on same domain as setup\n\nconst hasAppKey = accessKeys => accessKeys.some(k => {\n  var _a, _b;\n  const functionCallPermission = (_b = (_a = k === null || k === void 0 ? void 0 : k.access_key) === null || _a === void 0 ? void 0 : _a.permission) === null || _b === void 0 ? void 0 : _b.FunctionCall;\n  return functionCallPermission.allowance !== null && functionCallPermission.method_names[0] === \"execute\";\n});\nconst handleRefreshAppKey = (signer, ethAddress) => __awaiter(void 0, void 0, void 0, function* () {\n  var _f;\n  const {\n    account,\n    accountId\n  } = yield getUnlimitedKeyAccount(signer, ethAddress); // now refresh app key\n\n  const nonce = parseInt(yield account.viewFunction(accountId, \"get_nonce\"), 16).toString(); // new public key based on current nonce which will become the app_key_nonce in contract after this TX\n\n  const {\n    publicKey,\n    secretKey\n  } = yield keyPairFromEthSig(signer, appKeyPayload(accountId, nonce)); // logger.log(publicKey);\n\n  const public_key = pub2hex(publicKey);\n  const actions = [{\n    type: \"AddKey\",\n    public_key,\n    allowance: parseNearAmount(\"1\"),\n    receiver_id: accountId,\n    method_names: \"execute\"\n  }]; /// check keys, find old app key, delete that first\n\n  const accessKeys = yield account.getAccessKeys();\n  if (hasAppKey(accessKeys)) {\n    // old public key based on current app_key_nonce\n    const appKeyNonce = parseInt(yield account.viewFunction(accountId, \"get_app_key_nonce\"), 16).toString();\n    const {\n      publicKey: oldPublicKey\n    } = yield keyPairFromEthSig(signer, appKeyPayload(accountId, appKeyNonce));\n    const oldPublicKeyHex = pub2hex(oldPublicKey);\n    actions.unshift({\n      type: \"DeleteKey\",\n      public_key: oldPublicKeyHex\n    });\n  } /// get args for execute call\n\n  const args = yield ethSignJson(signer, {\n    nonce,\n    receivers: [accountId],\n    transactions: [{\n      actions\n    }]\n  });\n  const res = yield account.functionCall({\n    contractId: accountId,\n    methodName: \"execute\",\n    args,\n    gas\n  });\n  if (((_f = res === null || res === void 0 ? void 0 : res.status) === null || _f === void 0 ? void 0 : _f.SuccessValue) !== \"\") {\n    return logger.log(`App key rotation unsuccessful. ${REFRESH_MSG}`);\n  }\n  yield storage.removeItem(APP_KEY_SECRET);\n  yield storage.removeItem(APP_KEY_ACCOUNT_ID);\n  return {\n    publicKey: public_key,\n    secretKey\n  };\n});\nconst handleUpdateContract = (signer, ethAddress) => __awaiter(void 0, void 0, void 0, function* () {\n  var _g;\n  const {\n    account,\n    accountId\n  } = yield getUnlimitedKeyAccount(signer, ethAddress);\n  const contractPath = window === null || window === void 0 ? void 0 : window.contractPath;\n  const ab = yield fetch(contractPath).then(res => res.arrayBuffer());\n  const contractBytes = new Uint8Array(ab);\n  const actions = [{\n    type: \"DeployContract\",\n    code: buf2hex(contractBytes)\n  }];\n  const nonce = parseInt(yield account.viewFunction(accountId, \"get_nonce\"), 16).toString();\n  const args = yield ethSignJson(signer, {\n    nonce,\n    receivers: [accountId],\n    transactions: [{\n      actions\n    }]\n  });\n  const res = yield account.functionCall({\n    contractId: accountId,\n    methodName: \"execute\",\n    args,\n    gas\n  });\n  if (((_g = res === null || res === void 0 ? void 0 : res.status) === null || _g === void 0 ? void 0 : _g.SuccessValue) !== \"\") {\n    return logger.log(`Redeply contract unsuccessful. ${REFRESH_MSG}`);\n  }\n}); /// account disconnecting flow\n\nconst handleDisconnect = (signer, ethAddress) => __awaiter(void 0, void 0, void 0, function* () {\n  var _h, _j;\n  const {\n    account,\n    accountId,\n    secretKey\n  } = yield getUnlimitedKeyAccount(signer, ethAddress);\n  const {\n    seedPhrase,\n    publicKey,\n    secretKey: newSecretKey\n  } = generateSeedPhrase();\n  const _seedPhrase = window.prompt(\"Copy this down and keep it safe!!! This is your new seed phrase!!!\", seedPhrase);\n  if (seedPhrase !== _seedPhrase) {\n    return alert(\"There was an error copying seed phrase. Nothing has been done. Please try again.\");\n  }\n  const oldUnlimitedKey = KeyPair.fromString(secretKey);\n  const actions = [{\n    type: \"DeleteKey\",\n    public_key: pub2hex(oldUnlimitedKey.getPublicKey().toString())\n  }, {\n    type: \"AddKey\",\n    public_key: pub2hex(publicKey),\n    // special case will add full access key\n    allowance: \"0\"\n  }, {\n    type: \"FunctionCall\",\n    method_name: \"remove_storage\",\n    args: \"\",\n    amount: \"0\",\n    gas: halfGas\n  }, {\n    type: \"DeployContract\",\n    code: \"\"\n  }]; /// check keys, find old app key, delete that first\n\n  const accessKeys = yield account.getAccessKeys();\n  if (accessKeys.some(k => {\n    var _a, _b;\n    const functionCallPermission = (_b = (_a = k === null || k === void 0 ? void 0 : k.access_key) === null || _a === void 0 ? void 0 : _a.permission) === null || _b === void 0 ? void 0 : _b.FunctionCall;\n    return (functionCallPermission === null || functionCallPermission === void 0 ? void 0 : functionCallPermission.allowance) !== null && (functionCallPermission === null || functionCallPermission === void 0 ? void 0 : functionCallPermission.method_names[0]) === \"execute\";\n  })) {\n    const appKeyNonce = parseInt(yield account.viewFunction(accountId, \"get_app_key_nonce\"), 16).toString();\n    const {\n      publicKey: oldPublicKey\n    } = yield keyPairFromEthSig(signer, appKeyPayload(accountId, appKeyNonce));\n    const oldPublicKeyHex = pub2hex(oldPublicKey);\n    actions.unshift({\n      type: \"DeleteKey\",\n      public_key: oldPublicKeyHex\n    });\n  } /// get args for execute call\n\n  const nonce = parseInt(yield account.viewFunction(accountId, \"get_nonce\"), 16).toString();\n  const args = yield ethSignJson(signer, {\n    nonce,\n    receivers: [accountId],\n    transactions: [{\n      actions\n    }]\n  });\n  const res = yield account.functionCall({\n    contractId: accountId,\n    methodName: \"execute\",\n    args,\n    gas\n  });\n  if (((_h = res === null || res === void 0 ? void 0 : res.status) === null || _h === void 0 ? void 0 : _h.SuccessValue) !== \"\") {\n    return logger.log(\"app key rotation unsuccessful\");\n  } // remove the mapping (can do this later if user has FAK)\n\n  keyStore.setKey(networkId, accountId, newSecretKey);\n  try {\n    const mapRes = yield account.functionCall({\n      contractId: NETWORK[networkId].MAP_ACCOUNT_ID,\n      methodName: \"del\",\n      args: {},\n      gas\n    });\n    logger.log(mapRes);\n    if (((_j = mapRes === null || mapRes === void 0 ? void 0 : mapRes.status) === null || _j === void 0 ? void 0 : _j.SuccessValue) !== \"\") {\n      logger.log(\"account mapping removal failed\");\n    }\n  } catch (e) {\n    logger.log(e);\n  }\n  return {\n    account\n  };\n}); /// helpers for account creation and connection domain\n\nconst setupFromStorage = function () {\n  let accountId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const newAccountId = accountId.length > 0 ? accountId : yield storage.getItem(ATTEMPT_ACCOUNT_ID);\n    const newSecretKey = yield storage.getItem(ATTEMPT_SECRET_KEY);\n    const ethAddress = yield storage.getItem(ATTEMPT_ETH_ADDRESS);\n    const account = new Account(connection, newAccountId);\n    let keyPair;\n    if (newSecretKey) {\n      keyPair = KeyPair.fromString(newSecretKey);\n      keyStore.setKey(networkId, newAccountId, keyPair);\n    }\n    return {\n      newAccountId,\n      newSecretKey,\n      ethAddress,\n      account,\n      keyPair\n    };\n  });\n};\nconst getUnlimitedKeyAccount = function (signer, ethAddress) {\n  let tryPrevUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    let accountId,\n      secretKey = yield storage.getItem(ATTEMPT_SECRET_KEY); // if unlimited allowance access key is not in localStorage user will have to sign to generate it\n\n    if (!secretKey) {\n      // TODO remove dep on near-utils\n      // use any random near account to check mapping\n      accountId = yield getNearMap(ethAddress);\n      const {\n        secretKey: _secretKey\n      } = yield keyPairFromEthSig(signer, unlimitedKeyPayload(accountId, tryPrevUrl));\n      secretKey = _secretKey;\n    } else {\n      accountId = yield storage.getItem(ATTEMPT_ACCOUNT_ID);\n    }\n    const account = new Account(connection, accountId);\n    const keyPair = KeyPair.fromString(secretKey);\n    const publicKey = keyPair.getPublicKey().toString(); /// check if access key matches\n\n    const accessKeys = yield account.getAccessKeys();\n    if (!accessKeys.some(_ref4 => {\n      let {\n        public_key\n      } = _ref4;\n      return publicKey === public_key;\n    })) {\n      return yield getUnlimitedKeyAccount(signer, ethAddress, true);\n    }\n    keyStore.setKey(networkId, accountId, keyPair);\n    return {\n      account,\n      accountId,\n      secretKey\n    };\n  });\n};\n/**\r\n * The access key payloads, unlimited and limited\r\n */\n\nconst appKeyPayload = (accountId, appKeyNonce) => ({\n  WARNING: `Creating key for: ${accountId}`,\n  nonce: appKeyNonce,\n  description: `ONLY sign this on apps you trust! This key CAN use up to 1 N for transactions.`\n});\nconst unlimitedKeyPayload = (accountId, tryPrevUrl) => ({\n  WARNING: `Creates a key with access to your (new) paired NEAR Account: ${accountId}`,\n  description: `ONLY sign this message on this website: ${tryPrevUrl ? PREV_NETH_SITE_URL : NETH_SITE_URL}`\n});\nconst fundingKeyPayload = () => ({\n  WARNING: `This creates a full access key in your localStorage to a funding account you will be sending NEAR to.`,\n  description: `ONLY sign this message on this website: ${NETH_SITE_URL}`\n});\n/**\r\n * main domain, types and eth signTypedData method\r\n */\n\nconst domain = {\n  name: \"NETH\",\n  version: \"1\",\n  // chainId: 1, // aurora\n  chainId: 1313161554 // aurora\n};\n\nconst HEADER_OFFSET = \"NETH\";\nconst HEADER_PAD = 8;\nconst RECEIVER_MARKER = \"|~-_NETH~-_-~RECEIVER_-~|\";\nconst PREFIX = \"|NETH_\";\nconst SUFFIX = \"_NETH|\";\nconst pack = elements => elements.map(el => {\n  const str = typeof el === \"string\" ? el : Object.entries(el).map(_ref5 => {\n    let [k, v] = _ref5;\n    return `${PREFIX}${k}:${typeof v === \"string\" ? v : JSON.stringify(v)}${SUFFIX}`;\n  }).join(\"\");\n  const len = str.length.toString().padStart(HEADER_PAD, \"0\");\n  return HEADER_OFFSET + len + \"__\" + str;\n}).join(\"\");\nconst ethSignJson = (signer, json) => __awaiter(void 0, void 0, void 0, function* () {\n  const Transaction = [];\n  const types = {\n    Transaction\n  };\n  Object.entries(json).forEach(_ref6 => {\n    let [k] = _ref6;\n    types.Transaction.push({\n      type: \"string\",\n      name: k\n    });\n  }); /// convenience for devs so they can pass in JSON\n  /// hoist any functionCall args containing receiver|account in their key to top level receivers\n  /// replaces value with marker, contract fills in marker\n\n  if (json.transactions) {\n    Object.values(json.transactions).forEach((tx, i) => {\n      tx.actions.forEach(action => {\n        if (!action.args) {\n          return;\n        }\n        if (Buffer.isBuffer(action.args)) {\n          action.args = \"0x\" + action.args.toString(\"hex\");\n          return;\n        }\n        Object.entries(action.args).forEach(_ref7 => {\n          let [key, value] = _ref7;\n          /// TODO include check on value to determine valid account_id to be replaced\n          if (/receiver_id|account_id/g.test(key)) {\n            action.args[key] = RECEIVER_MARKER;\n            json.receivers.splice(i + 1, 0, value);\n          }\n        });\n      });\n    });\n    json.transactions = pack(json.transactions.map(_ref8 => {\n      let {\n        actions\n      } = _ref8;\n      return pack(actions);\n    }));\n  }\n  if (json.receivers) {\n    const numReceivers = json.receivers.length.toString();\n    json.receivers = HEADER_OFFSET + json.receivers.join(\",\").length.toString().padStart(HEADER_PAD, \"0\") + \"__\" + json.receivers.join(\",\");\n    json.receivers = json.receivers.substring(0, 4) + numReceivers.padStart(3, \"0\") + json.receivers.substring(7);\n  }\n  const sig = yield signer._signTypedData(domain, types, json);\n  const args = {\n    sig,\n    msg: json\n  }; // logger.log('\\nargs\\n', JSON.stringify(args, null, 4), '\\n');\n\n  return args;\n});\nconst keyPairFromEthSig = (signer, json) => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    sig\n  } = yield ethSignJson(signer, json);\n  const sigHash = ethers.utils.id(sig); /// use 32 bytes of entropy from hash of signature to create NEAR keyPair\n\n  return generateSeedPhrase(sigHash.substring(2, 34));\n});\n/**\r\n * Used by apps to signIn and signAndSendTransactions\r\n */\n/// ethereum\n\nconst getEthereum = () => __awaiter(void 0, void 0, void 0, function* () {\n  var _k, _l;\n  const provider = yield detectEthereumProvider();\n  if (!provider) {\n    return alert(\"Please install/activate MetaMask and try again.\");\n  }\n  try {\n    yield window.ethereum.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: \"0x\" + domain.chainId.toString(16)\n      }]\n    });\n  } catch (e) {\n    logger.log(e);\n    const code = (e === null || e === void 0 ? void 0 : e.code) || ((_l = (_k = e === null || e === void 0 ? void 0 : e.data) === null || _k === void 0 ? void 0 : _k.originalError) === null || _l === void 0 ? void 0 : _l.code);\n    if (code !== 4902) {\n      throw e;\n    }\n    try {\n      yield window.ethereum.request({\n        method: \"wallet_addEthereumChain\",\n        params: [{\n          chainId: \"0x\" + domain.chainId.toString(16),\n          chainName: \"Aurora Mainnet\",\n          nativeCurrency: {\n            name: \"Ethereum\",\n            symbol: \"ETH\",\n            decimals: 18\n          },\n          blockExplorerUrls: [\"https://explorer.mainnet.aurora.dev/\"],\n          rpcUrls: [\"https://mainnet.aurora.dev\"]\n        }]\n      });\n    } catch (e2) {\n      alert('Error adding chain. Please click \"Choose Ethereum Account\" and add the Aurora Network to continue.');\n      throw e2;\n    }\n  }\n  const ethersProvider = new ethers.providers.Web3Provider(window.ethereum);\n  const accounts = yield ethersProvider.listAccounts();\n  if (accounts.length === 0) {\n    yield ethersProvider.send(\"eth_requestAccounts\", []);\n  }\n  const signer = ethersProvider.getSigner();\n  return {\n    signer,\n    ethAddress: yield signer.getAddress()\n  };\n});\nconst switchEthereum = () => __awaiter(void 0, void 0, void 0, function* () {\n  const provider = yield detectEthereumProvider();\n  yield provider.send(\"wallet_requestPermissions\", [{\n    eth_accounts: {}\n  }]);\n  const ethersProvider = new ethers.providers.Web3Provider(window.ethereum);\n  const signer = ethersProvider.getSigner();\n  return {\n    signer,\n    ethAddress: yield signer.getAddress()\n  };\n}); /// near\n\nconst getNearMap = eth_address => __awaiter(void 0, void 0, void 0, function* () {\n  return contractAccount.viewFunction(NETWORK[networkId].MAP_ACCOUNT_ID, \"get_near\", {\n    eth_address\n  });\n});\nconst getNear = () => __awaiter(void 0, void 0, void 0, function* () {\n  const secretKey = yield storage.getItem(APP_KEY_SECRET);\n  const accountId = yield storage.getItem(APP_KEY_ACCOUNT_ID);\n  if (!secretKey || !accountId) {\n    const ethRes = yield getEthereum();\n    const res = yield getAppKey(ethRes);\n    if (!res) {\n      return false;\n    }\n    return yield getNear();\n  }\n  const account = new Account(connection, accountId);\n  const keyPair = KeyPair.fromString(secretKey);\n  keyStore.setKey(networkId, accountId, keyPair);\n  return {\n    account,\n    accountId,\n    keyPair,\n    secretKey\n  };\n});\nconst signIn = getNear;\nconst signOut = () => __awaiter(void 0, void 0, void 0, function* () {\n  const accountId = yield storage.getItem(APP_KEY_ACCOUNT_ID);\n  if (!accountId) {\n    return logger.log(\"already signed out\");\n  }\n  yield storage.removeItem(APP_KEY_SECRET);\n  yield storage.removeItem(APP_KEY_ACCOUNT_ID);\n  return {\n    accountId\n  };\n});\nconst verifyOwner = _ref9 => {\n  let {\n    message,\n    provider,\n    account\n  } = _ref9;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    let accountId;\n    if (!account) {\n      ({\n        account,\n        accountId\n      } = yield getNear());\n    } else {\n      ({\n        accountId\n      } = account);\n    }\n    if (!account) {\n      throw new Error(\"Wallet not signed in\");\n    }\n    const pubKey = yield account.connection.signer.getPublicKey(accountId, networkId);\n    const publicKey = Buffer.from(pubKey.data).toString(\"base64\");\n    const block = yield provider.block({\n      finality: \"final\"\n    });\n    const blockId = block.header.hash;\n    const data = {\n      accountId,\n      message,\n      blockId,\n      publicKey,\n      keyType: pubKey.keyType\n    };\n    const encoded = JSON.stringify(data);\n    const signed = yield account.connection.signer.signMessage(new Uint8Array(Buffer.from(encoded)), accountId, networkId);\n    return Object.assign(Object.assign({}, data), {\n      signature: Buffer.from(signed.signature).toString(\"base64\")\n    });\n  });\n};\nconst isSignedIn = () => __awaiter(void 0, void 0, void 0, function* () {\n  /// init defaultStorage here because it's not initialized until initConnection\n  const tempStorage = defaultStorage(WS_STORAGE_NAMESPACE);\n  return !!(yield tempStorage.getItem(APP_KEY_SECRET)) || !!(yield tempStorage.getItem(APP_KEY_ACCOUNT_ID));\n}); // const promptValidAccountId = async (msg) => {\n//   const newAccountId = window.prompt(msg);\n//   if (!newAccountId) {\n//     throw new Error(\"NETH Error: failed to pick valid NEAR account name\");\n//   }\n//   if (\n//     newAccountId.length < 2 ||\n//     newAccountId.indexOf(\".\") > -1 ||\n//     !ACCOUNT_REGEX.test(newAccountId) ||\n//     newAccountId.length > 64\n//   ) {\n//     return promptValidAccountId(\n//       `account is invalid (a-z, 0-9 and -,_ only; min 2; max 64; ${accountSuffix} applied automatically)`\n//     );\n//   }\n//   if (await accountExists(newAccountId)) {\n//     return promptValidAccountId(`account already exists`);\n//   }\n//   return newAccountId;\n// };\n\nconst getAppKey = _ref10 => {\n  let {\n    signer,\n    ethAddress: eth_address\n  } = _ref10;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const accountId = yield getNearMap(eth_address);\n    if (!accountId) {\n      const tryAgain = window.confirm(`Ethereum account ${eth_address} is not connected to a NETH account. Would you like to try another Ethereum account?`);\n      if (tryAgain) {\n        try {\n          const {\n            signer: _signer,\n            ethAddress\n          } = yield switchEthereum();\n          return yield getAppKey({\n            signer: _signer,\n            ethAddress\n          });\n        } catch (e) {\n          logger.log(e);\n        }\n        return;\n      }\n      const nethURL = `${NETH_SITE_URL}/${networkId === \"testnet\" ? \"?network=testnet\" : \"\"}`;\n      window.prompt(`We couldn't find a NETH account. To set up a NETH account visit`, nethURL); // throw new Error(`Ethereum account is not connected to a NETH account. To set up a NETH account visit: ${nethURL}`)\n      // /// prompt for near account name and auto deploy\n      // const newAccountId = await promptValidAccountId(\n      // \t`The Ethereum address ${eth_address} is not connected to a NEAR account yet. Select a NEAR account name and we'll create and connect one for you.`,\n      // );\n      // const { account } = await handleCreate(signer, eth_address, newAccountId + accountSuffix);\n      // accountId = account.accountId;\n    }\n\n    const appKeyNonce = parseInt(yield contractAccount.viewFunction(accountId, \"get_app_key_nonce\"), 16).toString();\n    const {\n      publicKey,\n      secretKey\n    } = yield keyPairFromEthSig(signer, appKeyPayload(accountId, appKeyNonce));\n    const account = new Account(connection, accountId); // check that app key exists on account\n\n    const accessKeys = yield account.getAccessKeys();\n    if (!hasAppKey(accessKeys)) {\n      yield handleRefreshAppKey(signer, eth_address);\n    }\n    const keyPair = KeyPair.fromString(secretKey);\n    keyStore.setKey(networkId, accountId, keyPair);\n    yield storage.setItem(APP_KEY_SECRET, secretKey);\n    yield storage.setItem(APP_KEY_ACCOUNT_ID, account.accountId);\n    return {\n      publicKey,\n      secretKey,\n      account\n    };\n  });\n};\nconst broadcastTXs = () => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    account,\n    accountId\n  } = yield getNear();\n  const args = yield storage.getItem(TX_ARGS_ATTEMPT);\n  if (!args || args.length === 0) {\n    return;\n  }\n  const res = [];\n  while (args.length > 0) {\n    const currentArgs = args.shift();\n    logger.log(\"NETH: broadcasting tx\", currentArgs);\n    try {\n      const tx = yield account.functionCall({\n        contractId: accountId,\n        methodName: \"execute\",\n        args: currentArgs,\n        gas\n      });\n      yield storage.setItem(TX_ARGS_ATTEMPT, args);\n      res.push(tx);\n    } catch (e) {\n      logger.log(\"NETH: ERROR broadcasting tx\", e);\n    }\n  }\n  yield storage.removeItem(TX_ARGS_ATTEMPT);\n  return res;\n});\nconst signAndSendTransactions = _ref11 => {\n  let {\n    transactions,\n    bundle\n  } = _ref11;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const ethRes = yield getEthereum();\n    const {\n      signer\n    } = ethRes;\n    const {\n      account,\n      accountId\n    } = yield getNear();\n    const receivers = transactions.map(_ref12 => {\n      let {\n        receiverId\n      } = _ref12;\n      return receiverId;\n    });\n    const transformedTxs = transactions.map(_ref13 => {\n      let {\n        receiverId,\n        actions\n      } = _ref13;\n      return {\n        actions: convertActions(actions, accountId, receiverId)\n      };\n    });\n    const nonce = parseInt(yield account.viewFunction(accountId, \"get_nonce\"), 16);\n    const args = [];\n    if (!bundle) {\n      for (let i = 0; i < transformedTxs.length; i++) {\n        args.push(yield ethSignJson(signer, {\n          nonce: (nonce + i).toString(),\n          receivers: [receivers[i]],\n          transactions: [transformedTxs[i]]\n        }));\n      }\n    } else {\n      args.push(yield ethSignJson(signer, {\n        nonce: nonce.toString(),\n        receivers,\n        transactions: transformedTxs\n      }));\n    }\n    yield storage.setItem(TX_ARGS_ATTEMPT, args);\n    const res = yield broadcastTXs();\n    return res;\n  });\n}; /// helpers\n\nconst convertActions = (actions, accountId, receiverId) => actions.map(_action => {\n  const {\n    enum: type\n  } = _action;\n  const {\n    gas: _gas,\n    publicKey,\n    methodName,\n    args,\n    deposit,\n    accessKey,\n    code\n  } = _action[type] || _action;\n  const action = {\n    type: type && type[0].toUpperCase() + type.substr(1) || \"FunctionCall\",\n    gas: _gas && _gas.toString() || undefined,\n    public_key: publicKey && pub2hex(publicKey) || undefined,\n    method_name: methodName,\n    args: args || undefined,\n    code: code || undefined,\n    amount: deposit && deposit.toString() || undefined,\n    permission: undefined\n  };\n  Object.keys(action).forEach(k => {\n    if (action[k] === undefined) {\n      delete action[k];\n    }\n  });\n  if (accessKey) {\n    if (receiverId === accountId) {\n      action.allowance = parseNearAmount(\"1\");\n      action.method_names = \"execute\";\n      action.receiver_id = accountId;\n    } else if (accessKey.permission.enum === \"functionCall\") {\n      const {\n        receiverId: _receiverId,\n        methodNames,\n        allowance\n      } = accessKey.permission.functionCall;\n      action.receiver_id = _receiverId;\n      action.allowance = allowance && allowance.toString() || parseNearAmount(\"0.25\");\n      action.method_names = methodNames.join(\",\");\n    }\n  }\n  return action;\n});\nconst isInstalled = () => __awaiter(void 0, void 0, void 0, function* () {\n  yield detectEthereumProvider();\n  return !!window.ethereum;\n});\nlet bundle = true;\nlet useCover = false;\nlet customGas;\nconst Neth = _ref14 => {\n  let {\n    metadata,\n    logger,\n    store,\n    storage,\n    options,\n    provider\n  } = _ref14;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const cover = initConnection({\n      network: options.network,\n      gas: customGas,\n      logger,\n      storage\n    });\n    const isValidActions = actions => {\n      return actions.every(x => x.type === \"FunctionCall\");\n    };\n    const transformActions = actions => {\n      const validActions = isValidActions(actions);\n      if (!validActions) {\n        throw new Error(`Only 'FunctionCall' actions types are supported by ${metadata.name}`);\n      }\n      return actions.map(x => x.params);\n    };\n    const signTransactions = transactions => __awaiter(void 0, void 0, void 0, function* () {\n      logger.log(\"NETH:signAndSendTransactions\", {\n        transactions\n      });\n      const {\n        contract\n      } = store.getState();\n      if (!(yield isSignedIn()) || !contract) {\n        throw new Error(\"Wallet not signed in\");\n      }\n      if (useCover) {\n        cover.style.display = \"block\";\n      }\n      const transformedTxs = transactions.map(_ref15 => {\n        let {\n          receiverId,\n          actions\n        } = _ref15;\n        return {\n          receiverId: receiverId || contract.contractId,\n          actions: transformActions(actions)\n        };\n      });\n      let res;\n      try {\n        res = yield signAndSendTransactions({\n          transactions: transformedTxs,\n          bundle\n        });\n      } catch (e) {\n        /// \"user rejected signing\" or near network error\n        logger.log(\"NETH:signAndSendTransactions Error\", e);\n        throw e;\n      }\n      if (useCover) {\n        cover.style.display = \"none\";\n      }\n      return res;\n    }); // return the wallet interface for wallet-selector\n\n    return {\n      signIn() {\n        return __awaiter(this, void 0, void 0, function* () {\n          let account;\n          try {\n            account = yield signIn();\n            if (!account) {\n              return [];\n            }\n          } catch (e) {\n            if (!/not connected/.test(e.toString())) {\n              throw e;\n            } // console.log(e);\n          }\n\n          return [account];\n        });\n      },\n      signOut() {\n        return __awaiter(this, void 0, void 0, function* () {\n          yield signOut();\n        });\n      },\n      verifyOwner(_ref16) {\n        let {\n          message\n        } = _ref16;\n        return __awaiter(this, void 0, void 0, function* () {\n          logger.log(\"NETH:verifyOwner\", {\n            message\n          });\n          return verifyOwner({\n            message,\n            provider,\n            account: null\n          });\n        });\n      },\n      getAccounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n          const {\n            accountId\n          } = yield getNear();\n          return [{\n            accountId\n          }];\n        });\n      },\n      signAndSendTransaction: _ref17 => {\n        let {\n          receiverId,\n          actions\n        } = _ref17;\n        return __awaiter(void 0, void 0, void 0, function* () {\n          return signTransactions([{\n            receiverId,\n            actions\n          }]);\n        });\n      },\n      signAndSendTransactions: _ref18 => {\n        let {\n          transactions\n        } = _ref18;\n        return __awaiter(void 0, void 0, void 0, function* () {\n          return signTransactions(transactions);\n        });\n      }\n    };\n  });\n};\nfunction setupNeth() {\n  let {\n    iconUrl = nethIcon,\n    gas,\n    useModalCover = false,\n    bundle: _bundle = true,\n    deprecated = false\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return () => __awaiter(this, void 0, void 0, function* () {\n    useCover = useModalCover;\n    customGas = gas;\n    bundle = _bundle;\n    const mobile = isMobile();\n    const installed = yield isInstalled();\n    yield waitFor(() => !!isSignedIn(), {\n      timeout: 300\n    }).catch(() => false);\n    if (mobile) {\n      return null;\n    }\n    return {\n      id: \"neth\",\n      type: \"injected\",\n      metadata: {\n        name: \"NETH Account\",\n        description: null,\n        iconUrl,\n        downloadUrl: NETH_SITE_URL,\n        deprecated: false,\n        available: installed\n      },\n      deprecated,\n      init: Neth\n    };\n  });\n}\nexport { MIN_NEW_ACCOUNT_ASK, accountExists, getConnection, getEthereum, getNear, getNearMap, handleCancelFunding, handleCheckAccount, handleCreate, handleDisconnect, handleRefreshAppKey, handleUpdateContract, hasAppKey, initConnection, isSignedIn, setupNeth, signAndSendTransactions, signIn, signOut, switchEthereum, verifyOwner };","map":{"version":3,"names":["waitFor","detectEthereumProvider","ethers","nearAPI","generateSeedPhrase","BN","isMobile","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","nethIcon","Near","Account","KeyPair","keyStores","BrowserLocalStorageKeyStore","transactions","addKey","deleteKey","functionCallAccessKey","utils","PublicKey","format","parseNearAmount","NETH_SITE_URL","PREV_NETH_SITE_URL","NETWORK","testnet","FUNDING_ACCOUNT_ID","MAP_ACCOUNT_ID","ROOT_ACCOUNT_ID","mainnet","WS_STORAGE_NAMESPACE","REFRESH_MSG","TX_ARGS_ATTEMPT","ATTEMPT_SECRET_KEY","ATTEMPT_ACCOUNT_ID","ATTEMPT_ETH_ADDRESS","APP_KEY_SECRET","APP_KEY_ACCOUNT_ID","defaultGas","halfGas","MIN_NEW_ACCOUNT","MIN_NEW_ACCOUNT_THRESH","MIN_NEW_ACCOUNT_ASK","FUNDING_CHECK_TIMEOUT","attachedDepositMapping","defaultStorage","prefix","getItem","k","v","localStorage","charAt","JSON","parse","setItem","stringify","removeItem","defaultLogger","log","args","console","near","gas","keyStore","logger","storage","connection","networkId","contractAccount","accountSuffix","initConnection","network","_gas","_logger","_storage","Object","assign","cover","document","createElement","style","display","width","height","zIndex","position","top","background","body","appendChild","broadcastTXs","getConnection","accountExists","accountId","ethAddress","account","state","mapAccountId","getNearMap","test","toString","buf2hex","buf","hexlify","substring","pub2hex","publicKey","fromString","data","handleCreate","signer","newAccountId","fundingAccountCB","fundingErrorCB","postFundingCB","indexOf","alert","fundingAccountPubKey","secretKey","new_secret_key","keyPairFromEthSig","fundingKeyPayload","createAccount","implicitAccountId","Buffer","from","checkImplicitFunded","balance","getAccountBalance","available","diff","sub","lt","abs","r","setTimeout","window","location","reload","setupFromStorage","handleCancelFunding","new_public_key","unlimitedKeyPayload","functionCall","contractId","methodName","new_account_id","attachedDeposit","deleteAccount","handleMapping","fundingAccountId","refundAccountId","prompt","eth_address","handleDeployContract","contractPath","ab","fetch","res","arrayBuffer","contractBytes","Uint8Array","deployContract","handleSetupContract","handleKeys","_a","_b","_c","accessKeys","getAccessKeys","length","access_key","permission","public_key","actions","signAndSendTransaction","receiverId","status","SuccessValue","handleCheckAccount","_d","_e","setup","newSecretKey","keyPair","getPublicKey","mapRes","viewFunction","account_id","code_hash","ethRes","hasAppKey","some","functionCallPermission","FunctionCall","allowance","method_names","handleRefreshAppKey","_f","getUnlimitedKeyAccount","nonce","parseInt","appKeyPayload","type","receiver_id","appKeyNonce","oldPublicKey","oldPublicKeyHex","unshift","ethSignJson","receivers","handleUpdateContract","_g","code","handleDisconnect","_h","_j","seedPhrase","_seedPhrase","oldUnlimitedKey","method_name","amount","setKey","tryPrevUrl","_secretKey","WARNING","description","domain","name","version","chainId","HEADER_OFFSET","HEADER_PAD","RECEIVER_MARKER","PREFIX","SUFFIX","pack","elements","map","el","str","entries","join","len","padStart","json","Transaction","types","forEach","push","values","tx","i","action","isBuffer","key","splice","numReceivers","sig","_signTypedData","msg","sigHash","id","getEthereum","_k","_l","provider","ethereum","request","method","params","originalError","chainName","nativeCurrency","symbol","decimals","blockExplorerUrls","rpcUrls","e2","ethersProvider","providers","Web3Provider","accounts","listAccounts","send","getSigner","getAddress","switchEthereum","eth_accounts","getNear","getAppKey","signIn","signOut","verifyOwner","message","Error","pubKey","block","finality","blockId","header","hash","keyType","encoded","signed","signMessage","signature","isSignedIn","tempStorage","tryAgain","confirm","_signer","nethURL","currentArgs","shift","signAndSendTransactions","bundle","transformedTxs","convertActions","_action","enum","deposit","accessKey","toUpperCase","substr","undefined","keys","_receiverId","methodNames","isInstalled","useCover","customGas","Neth","metadata","store","options","isValidActions","every","x","transformActions","validActions","signTransactions","contract","getState","getAccounts","setupNeth","iconUrl","useModalCover","_bundle","deprecated","mobile","installed","timeout","catch","downloadUrl","init"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/@near-wallet-selector/neth/index.js"],"sourcesContent":["import { waitFor } from '@near-wallet-selector/core';\nimport detectEthereumProvider from '@metamask/detect-provider';\nimport { ethers } from 'ethers';\nimport * as nearAPI from 'near-api-js';\nimport { generateSeedPhrase } from 'near-seed-phrase';\nimport BN from 'bn.js';\nimport isMobile from 'is-mobile';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nconst nethIcon = `data:image/png;base64,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`;\n\n/*eslint @typescript-eslint/no-use-before-define: 1*/\nconst {\n  Near,\n  Account,\n  KeyPair,\n  keyStores: {\n    BrowserLocalStorageKeyStore\n  },\n  transactions: {\n    addKey,\n    deleteKey,\n    functionCallAccessKey\n  },\n  utils: {\n    PublicKey,\n    format: {\n      parseNearAmount\n    }\n  }\n} = nearAPI;\nconst NETH_SITE_URL = \"https://neth.app\";\nconst PREV_NETH_SITE_URL = \"neardefi.github.io/neth\";\nconst NETWORK = {\n  testnet: {\n    FUNDING_ACCOUNT_ID: \"neth.testnet\",\n    MAP_ACCOUNT_ID: \"map.neth.testnet\",\n    ROOT_ACCOUNT_ID: \"testnet\"\n  },\n  mainnet: {\n    MAP_ACCOUNT_ID: \"nethmap.near\",\n    ROOT_ACCOUNT_ID: \"near\"\n  }\n};\nconst WS_STORAGE_NAMESPACE = \"near-wallet-selector:neth:\";\nconst REFRESH_MSG = `Please refresh the page and try again.`;\nconst TX_ARGS_ATTEMPT = \"__TX_ARGS_ATTEMPT\";\nconst ATTEMPT_SECRET_KEY = \"__ATTEMPT_SECRET_KEY\";\nconst ATTEMPT_ACCOUNT_ID = \"__ATTEMPT_ACCOUNT_ID\";\nconst ATTEMPT_ETH_ADDRESS = \"__ATTEMPT_ETH_ADDRESS\";\nconst APP_KEY_SECRET = \"__APP_KEY_SECRET\";\nconst APP_KEY_ACCOUNT_ID = \"__APP_KEY_ACCOUNT_ID\";\nconst defaultGas = \"200000000000000\";\nconst halfGas = \"50000000000000\"; /// this is the new account amount 0.21 for account name, keys, contract and 0.01 for mapping contract storage cost\n\nconst MIN_NEW_ACCOUNT = parseNearAmount(\"0.4\");\nconst MIN_NEW_ACCOUNT_THRESH = parseNearAmount(\"0.49\");\nconst MIN_NEW_ACCOUNT_ASK = parseNearAmount(\"0.5\");\nconst FUNDING_CHECK_TIMEOUT = 5000; /// lkmfawl\n\nconst attachedDepositMapping = parseNearAmount(\"0.05\"); /// Helpers\n\nconst defaultStorage = (prefix = \"\") => ({\n  getItem: k => {\n    const v = localStorage.getItem(prefix + k);\n\n    if ((v === null || v === void 0 ? void 0 : v.charAt(0)) !== \"{\") {\n      return v;\n    }\n\n    try {\n      return JSON.parse(v);\n    } catch (e) {//   logger.log(e);\n    }\n  },\n  setItem: (k, v) => localStorage.setItem(prefix + k, typeof v === \"string\" ? v : JSON.stringify(v)),\n  removeItem: k => localStorage.removeItem(prefix + k)\n});\n\nconst defaultLogger = () => ({\n  // eslint-disable-next-line\n  log: args => console.log(...args)\n}); /// NEAR setup\n\n\nlet near, gas, keyStore, logger, storage, connection, networkId, contractAccount, accountSuffix;\nconst initConnection = ({\n  network,\n  gas: _gas = defaultGas,\n  logger: _logger = defaultLogger(),\n  storage: _storage = defaultStorage()\n}) => {\n  gas = _gas;\n  logger = _logger;\n  storage = _storage;\n  keyStore = new BrowserLocalStorageKeyStore();\n  near = new Near(Object.assign(Object.assign({}, network), {\n    keyStore\n  }));\n  connection = near.connection;\n  networkId = network.networkId;\n  contractAccount = new Account(connection, networkId === \"mainnet\" ? \"near\" : networkId);\n  accountSuffix = networkId === \"mainnet\" ? \".near\" : \".\" + networkId;\n  const cover = document.createElement(\"div\");\n  cover.style.display = \"none\";\n  cover.style.width = \"100%\";\n  cover.style.height = \"100vh\";\n  cover.style.zIndex = \"999999\";\n  cover.style.position = \"fixed\";\n  cover.style.top = \"0\";\n  cover.style.background = \"rgba(0, 0, 0, 0.5)\";\n  document.body.appendChild(cover); /// recovery from unbundled TXs that haven't been broadcast yet\n\n  broadcastTXs();\n  return cover;\n};\nconst getConnection = () => {\n  return {\n    near,\n    connection,\n    keyStore,\n    networkId,\n    contractAccount,\n    accountSuffix\n  };\n}; /// helpers\n\nconst accountExists = (accountId, ethAddress = null) => __awaiter(void 0, void 0, void 0, function* () {\n  try {\n    const account = new nearAPI.Account(connection, accountId);\n    yield account.state();\n\n    if (ethAddress) {\n      const mapAccountId = yield getNearMap(ethAddress);\n\n      if (mapAccountId) {\n        return true;\n      }\n    }\n\n    return true;\n  } catch (e) {\n    if (!/no such file|does not exist/.test(e.toString())) {\n      throw e;\n    }\n\n    return false;\n  }\n});\n\nconst buf2hex = buf => ethers.utils.hexlify(buf).substring(2);\n\nconst pub2hex = publicKey => ethers.utils.hexlify(PublicKey.fromString(publicKey).data).substring(2); /// account creation and connection flow\n\n\nconst handleCreate = (signer, ethAddress, newAccountId, fundingAccountCB, fundingErrorCB, postFundingCB) => __awaiter(void 0, void 0, void 0, function* () {\n  if (networkId === \"testnet\" && newAccountId.indexOf(\".near\") > -1 || networkId === \"mainnet\" && newAccountId.indexOf(\".testnet\") > -1) {\n    return alert(\"Invalid account name. You do not need to add any .near or .testnet. Please try again.\");\n  } /// get keypair from eth sig entropy for the near-eth account\n\n\n  const {\n    publicKey: fundingAccountPubKey,\n    secretKey: new_secret_key\n  } = yield keyPairFromEthSig(signer, fundingKeyPayload()); /// store attempt in localStorage so we can recover and retry / resume contract deployment\n\n  yield storage.setItem(ATTEMPT_ACCOUNT_ID, newAccountId);\n  yield storage.setItem(ATTEMPT_SECRET_KEY, new_secret_key);\n  yield storage.setItem(ATTEMPT_ETH_ADDRESS, ethAddress);\n  return yield createAccount({\n    signer,\n    newAccountId,\n    fundingAccountPubKey,\n    fundingAccountCB,\n    fundingErrorCB,\n    postFundingCB\n  });\n});\n\nconst createAccount = ({\n  signer,\n  newAccountId,\n  fundingAccountPubKey,\n  fundingAccountCB,\n  fundingErrorCB,\n  postFundingCB\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  // const { publicKey, secretKey } = parseSeedPhrase(process.env.REACT_APP_FUNDING_SEED_PHRASE);\n  /// assumes implicit is funded, otherwise will warn and cycle here\n  const implicitAccountId = Buffer.from(PublicKey.from(fundingAccountPubKey).data).toString(\"hex\");\n\n  if (fundingAccountCB) {\n    fundingAccountCB(implicitAccountId);\n  } /// wait for implicit funding here and then continue to createAccount\n\n\n  const checkImplicitFunded = () => __awaiter(void 0, void 0, void 0, function* () {\n    logger.log(\"checking for funding of implicit account\", implicitAccountId);\n    const account = new Account(connection, implicitAccountId);\n\n    try {\n      const balance = yield account.getAccountBalance();\n      const {\n        available\n      } = balance;\n      const diff = new BN(available).sub(new BN(MIN_NEW_ACCOUNT_THRESH));\n\n      if (diff.lt(new BN(\"0\"))) {\n        // alert(`There is not enough NEAR (${formatNearAmount(MIN_NEW_ACCOUNT_ASK, 4)} minimum) to create a new account and deploy NETH contract. Please deposit more and try again.`)\n        if (fundingErrorCB) {\n          fundingErrorCB(implicitAccountId, diff.abs().toString());\n        }\n\n        yield new Promise(r => setTimeout(r, FUNDING_CHECK_TIMEOUT));\n        return yield checkImplicitFunded();\n      }\n    } catch (e) {\n      if (!/does not exist/gi.test(e.toString())) {\n        throw e;\n      }\n\n      logger.log(\"not funded, checking again\");\n      yield new Promise(r => setTimeout(r, FUNDING_CHECK_TIMEOUT));\n      return yield checkImplicitFunded();\n    }\n\n    return true;\n  }); /// if not funded properly, return and reload\n\n\n  if (!(yield checkImplicitFunded())) {\n    return window.location.reload();\n  }\n\n  logger.log(\"implicit account funded\", implicitAccountId);\n\n  if (postFundingCB) {\n    postFundingCB();\n  }\n\n  const {\n    account,\n    ethAddress\n  } = yield setupFromStorage(implicitAccountId); /// final checks, last chance to cancel funding if they fail\n\n  if (yield accountExists(newAccountId, ethAddress)) {\n    alert(`${newAccountId} already exists. Please try another.`);\n    return yield handleCancelFunding(implicitAccountId);\n  } /// create account now\n  /// get keypair from eth sig entropy for the near-eth account\n\n\n  const {\n    publicKey: new_public_key,\n    secretKey: new_secret_key\n  } = yield keyPairFromEthSig(signer, unlimitedKeyPayload(newAccountId, ethAddress));\n  yield storage.setItem(ATTEMPT_SECRET_KEY, new_secret_key); // remove any existing app key\n\n  yield storage.removeItem(APP_KEY_ACCOUNT_ID);\n  yield storage.removeItem(APP_KEY_SECRET);\n\n  try {\n    yield account.functionCall({\n      contractId: NETWORK[networkId].ROOT_ACCOUNT_ID,\n      methodName: \"create_account\",\n      args: {\n        new_account_id: newAccountId,\n        new_public_key\n      },\n      gas,\n      attachedDeposit: new BN(MIN_NEW_ACCOUNT)\n    });\n  } catch (e) {\n    if (!/be created by/.test(JSON.stringify(e))) {\n      throw e;\n    }\n\n    return handleCancelFunding(implicitAccountId);\n  } /// check\n\n\n  if (!(yield accountExists(newAccountId))) {\n    return logger.log(`Account ${newAccountId} could NOT be created. Please refresh the page and try again.`);\n  }\n\n  logger.log(`Account ${newAccountId} created successfully.`); /// drain implicit\n\n  yield account.deleteAccount(newAccountId);\n  return yield handleMapping();\n});\n\nconst handleCancelFunding = fundingAccountId => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    account\n  } = yield setupFromStorage(fundingAccountId);\n  const refundAccountId = window.prompt(`There was an error creating the account. You need to refund and try again. Please enter the account you funded from. MAKE SURE IT IS CORRECT. THIS CANNOT BE UNDONE.`); /// drain implicit\n\n  try {\n    yield account.deleteAccount(refundAccountId);\n  } catch (e) {\n    logger.log(\"Cannot delete implicit\");\n  } finally {\n    /// delete attempt\n    yield storage.removeItem(ATTEMPT_ACCOUNT_ID);\n    yield storage.removeItem(ATTEMPT_SECRET_KEY);\n    yield storage.removeItem(ATTEMPT_ETH_ADDRESS);\n  }\n});\nconst handleMapping = () => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    account,\n    ethAddress\n  } = yield setupFromStorage();\n\n  try {\n    yield account.functionCall({\n      contractId: NETWORK[networkId].MAP_ACCOUNT_ID,\n      methodName: \"set\",\n      args: {\n        eth_address: ethAddress\n      },\n      gas,\n      attachedDeposit: new BN(attachedDepositMapping)\n    });\n    logger.log(`Account mapping successful`);\n  } catch (e) {\n    logger.log(e);\n    return logger.log(`Account mapping failed`);\n  }\n\n  return yield handleDeployContract();\n});\nconst handleDeployContract = () => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    account\n  } = yield setupFromStorage();\n  const contractPath = window === null || window === void 0 ? void 0 : window.contractPath; // logger.log(contractPath)\n\n  const ab = yield fetch(contractPath).then(res => res.arrayBuffer());\n  const contractBytes = new Uint8Array(ab); // logger.log(\"contractBytes.length\", contractBytes.length);\n\n  try {\n    yield account.deployContract(contractBytes);\n    logger.log(`Contract deployed successfully.`);\n  } catch (e) {\n    logger.log(e);\n    return logger.log(`Contract deployment failed. ${REFRESH_MSG}`);\n  }\n\n  return yield handleSetupContract();\n});\nconst handleSetupContract = () => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    account,\n    ethAddress\n  } = yield setupFromStorage();\n\n  try {\n    yield account.functionCall({\n      contractId: account.accountId,\n      methodName: \"setup\",\n      args: {\n        eth_address: ethAddress\n      },\n      gas\n    });\n    logger.log(`Contract setup successfully.`);\n  } catch (e) {\n    logger.log(e);\n    return logger.log(`Contract setup failed. ${REFRESH_MSG}`);\n  }\n\n  return yield handleKeys();\n});\nconst handleKeys = () => __awaiter(void 0, void 0, void 0, function* () {\n  var _a, _b, _c;\n\n  const {\n    account,\n    newAccountId,\n    ethAddress\n  } = yield setupFromStorage();\n  const accessKeys = yield account.getAccessKeys(); // keys are done\n\n  if (accessKeys.length !== 1 || ((_b = (_a = accessKeys[0]) === null || _a === void 0 ? void 0 : _a.access_key) === null || _b === void 0 ? void 0 : _b.permission) !== \"FullAccess\") {\n    return;\n  }\n\n  const publicKey = PublicKey.from(accessKeys[0].public_key);\n  const actions = [// delete the full access key\n  deleteKey(publicKey), // limited to execute, unlimited allowance\n  addKey(publicKey, functionCallAccessKey(newAccountId, [\"execute\"]))];\n\n  try {\n    const res = yield account.signAndSendTransaction({\n      receiverId: newAccountId,\n      actions\n    });\n\n    if (((_c = res === null || res === void 0 ? void 0 : res.status) === null || _c === void 0 ? void 0 : _c.SuccessValue) !== \"\") {\n      return logger.log(`Key rotation failed. ${REFRESH_MSG}`);\n    }\n\n    logger.log(`Key rotation successful.`);\n  } catch (e) {\n    logger.log(e);\n    return logger.log(`Key rotation failed. ${REFRESH_MSG}`);\n  }\n\n  return yield handleCheckAccount({\n    ethAddress\n  });\n}); /// waterfall check everything about account and fill in missing pieces\n\nconst handleCheckAccount = ({\n  signer = null,\n  ethAddress = null,\n  fundingAccountCB = null,\n  fundingErrorCB = null,\n  postFundingCB = null\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  var _d, _e;\n\n  const setup = yield setupFromStorage();\n  let {\n    newAccountId\n  } = setup;\n  const {\n    newSecretKey\n  } = setup;\n  const mapAccountId = yield getNearMap(ethAddress);\n\n  if (!mapAccountId) {\n    // alert(\"create account first\");\n    logger.log(\"No account mapping exists.\");\n  } else {\n    newAccountId = mapAccountId;\n  }\n\n  logger.log(\"Checking account created.\");\n\n  if (!(yield accountExists(newAccountId))) {\n    const keyPair = KeyPair.fromString(newSecretKey);\n    return createAccount({\n      signer,\n      newAccountId,\n      fundingAccountPubKey: keyPair.getPublicKey().toString(),\n      fundingAccountCB,\n      fundingErrorCB,\n      postFundingCB\n    });\n  }\n\n  const account = new Account(connection, newAccountId);\n  logger.log(\"Checking account address mapping.\");\n  const mapRes = yield account.viewFunction(NETWORK[networkId].MAP_ACCOUNT_ID, \"get_eth\", {\n    account_id: newAccountId\n  });\n\n  if (mapRes === null) {\n    return handleMapping();\n  }\n\n  logger.log(\"Checking contract deployed.\");\n  const state = yield account.state();\n\n  if (state.code_hash === \"11111111111111111111111111111111\") {\n    return handleDeployContract();\n  }\n\n  logger.log(\"Checking contract setup.\");\n\n  try {\n    const ethRes = yield account.viewFunction(newAccountId, \"get_address\"); // any reason the address wasn't set properly\n\n    if (!ethRes || !ethRes.length) {\n      return handleSetupContract();\n    }\n  } catch (e) {\n    // not set at all (wasm error unreachable storage value)\n    logger.log(e);\n    return handleSetupContract();\n  }\n\n  logger.log(\"Checking access keys.\");\n  const accessKeys = yield account.getAccessKeys();\n\n  if (accessKeys.length === 1 && ((_e = (_d = accessKeys[0]) === null || _d === void 0 ? void 0 : _d.access_key) === null || _e === void 0 ? void 0 : _e.permission) === \"FullAccess\") {\n    return handleKeys();\n  }\n\n  logger.log(\"Account created.\");\n  logger.log(\"Contract deployed and setup.\");\n  logger.log(\"Mapping added.\");\n  logger.log(\"Keys rotated.\");\n  yield storage.removeItem(ATTEMPT_ACCOUNT_ID);\n  yield storage.removeItem(ATTEMPT_SECRET_KEY);\n  yield storage.removeItem(ATTEMPT_ETH_ADDRESS);\n  return {\n    account\n  };\n}); /// on same domain as setup\n\nconst hasAppKey = accessKeys => accessKeys.some(k => {\n  var _a, _b;\n\n  const functionCallPermission = (_b = (_a = k === null || k === void 0 ? void 0 : k.access_key) === null || _a === void 0 ? void 0 : _a.permission) === null || _b === void 0 ? void 0 : _b.FunctionCall;\n  return functionCallPermission.allowance !== null && functionCallPermission.method_names[0] === \"execute\";\n});\nconst handleRefreshAppKey = (signer, ethAddress) => __awaiter(void 0, void 0, void 0, function* () {\n  var _f;\n\n  const {\n    account,\n    accountId\n  } = yield getUnlimitedKeyAccount(signer, ethAddress); // now refresh app key\n\n  const nonce = parseInt(yield account.viewFunction(accountId, \"get_nonce\"), 16).toString(); // new public key based on current nonce which will become the app_key_nonce in contract after this TX\n\n  const {\n    publicKey,\n    secretKey\n  } = yield keyPairFromEthSig(signer, appKeyPayload(accountId, nonce)); // logger.log(publicKey);\n\n  const public_key = pub2hex(publicKey);\n  const actions = [{\n    type: \"AddKey\",\n    public_key,\n    allowance: parseNearAmount(\"1\"),\n    receiver_id: accountId,\n    method_names: \"execute\"\n  }]; /// check keys, find old app key, delete that first\n\n  const accessKeys = yield account.getAccessKeys();\n\n  if (hasAppKey(accessKeys)) {\n    // old public key based on current app_key_nonce\n    const appKeyNonce = parseInt(yield account.viewFunction(accountId, \"get_app_key_nonce\"), 16).toString();\n    const {\n      publicKey: oldPublicKey\n    } = yield keyPairFromEthSig(signer, appKeyPayload(accountId, appKeyNonce));\n    const oldPublicKeyHex = pub2hex(oldPublicKey);\n    actions.unshift({\n      type: \"DeleteKey\",\n      public_key: oldPublicKeyHex\n    });\n  } /// get args for execute call\n\n\n  const args = yield ethSignJson(signer, {\n    nonce,\n    receivers: [accountId],\n    transactions: [{\n      actions\n    }]\n  });\n  const res = yield account.functionCall({\n    contractId: accountId,\n    methodName: \"execute\",\n    args,\n    gas\n  });\n\n  if (((_f = res === null || res === void 0 ? void 0 : res.status) === null || _f === void 0 ? void 0 : _f.SuccessValue) !== \"\") {\n    return logger.log(`App key rotation unsuccessful. ${REFRESH_MSG}`);\n  }\n\n  yield storage.removeItem(APP_KEY_SECRET);\n  yield storage.removeItem(APP_KEY_ACCOUNT_ID);\n  return {\n    publicKey: public_key,\n    secretKey\n  };\n});\nconst handleUpdateContract = (signer, ethAddress) => __awaiter(void 0, void 0, void 0, function* () {\n  var _g;\n\n  const {\n    account,\n    accountId\n  } = yield getUnlimitedKeyAccount(signer, ethAddress);\n  const contractPath = window === null || window === void 0 ? void 0 : window.contractPath;\n  const ab = yield fetch(contractPath).then(res => res.arrayBuffer());\n  const contractBytes = new Uint8Array(ab);\n  const actions = [{\n    type: \"DeployContract\",\n    code: buf2hex(contractBytes)\n  }];\n  const nonce = parseInt(yield account.viewFunction(accountId, \"get_nonce\"), 16).toString();\n  const args = yield ethSignJson(signer, {\n    nonce,\n    receivers: [accountId],\n    transactions: [{\n      actions\n    }]\n  });\n  const res = yield account.functionCall({\n    contractId: accountId,\n    methodName: \"execute\",\n    args,\n    gas\n  });\n\n  if (((_g = res === null || res === void 0 ? void 0 : res.status) === null || _g === void 0 ? void 0 : _g.SuccessValue) !== \"\") {\n    return logger.log(`Redeply contract unsuccessful. ${REFRESH_MSG}`);\n  }\n}); /// account disconnecting flow\n\nconst handleDisconnect = (signer, ethAddress) => __awaiter(void 0, void 0, void 0, function* () {\n  var _h, _j;\n\n  const {\n    account,\n    accountId,\n    secretKey\n  } = yield getUnlimitedKeyAccount(signer, ethAddress);\n  const {\n    seedPhrase,\n    publicKey,\n    secretKey: newSecretKey\n  } = generateSeedPhrase();\n\n  const _seedPhrase = window.prompt(\"Copy this down and keep it safe!!! This is your new seed phrase!!!\", seedPhrase);\n\n  if (seedPhrase !== _seedPhrase) {\n    return alert(\"There was an error copying seed phrase. Nothing has been done. Please try again.\");\n  }\n\n  const oldUnlimitedKey = KeyPair.fromString(secretKey);\n  const actions = [{\n    type: \"DeleteKey\",\n    public_key: pub2hex(oldUnlimitedKey.getPublicKey().toString())\n  }, {\n    type: \"AddKey\",\n    public_key: pub2hex(publicKey),\n    // special case will add full access key\n    allowance: \"0\"\n  }, {\n    type: \"FunctionCall\",\n    method_name: \"remove_storage\",\n    args: \"\",\n    amount: \"0\",\n    gas: halfGas\n  }, {\n    type: \"DeployContract\",\n    code: \"\"\n  }]; /// check keys, find old app key, delete that first\n\n  const accessKeys = yield account.getAccessKeys();\n\n  if (accessKeys.some(k => {\n    var _a, _b;\n\n    const functionCallPermission = (_b = (_a = k === null || k === void 0 ? void 0 : k.access_key) === null || _a === void 0 ? void 0 : _a.permission) === null || _b === void 0 ? void 0 : _b.FunctionCall;\n    return (functionCallPermission === null || functionCallPermission === void 0 ? void 0 : functionCallPermission.allowance) !== null && (functionCallPermission === null || functionCallPermission === void 0 ? void 0 : functionCallPermission.method_names[0]) === \"execute\";\n  })) {\n    const appKeyNonce = parseInt(yield account.viewFunction(accountId, \"get_app_key_nonce\"), 16).toString();\n    const {\n      publicKey: oldPublicKey\n    } = yield keyPairFromEthSig(signer, appKeyPayload(accountId, appKeyNonce));\n    const oldPublicKeyHex = pub2hex(oldPublicKey);\n    actions.unshift({\n      type: \"DeleteKey\",\n      public_key: oldPublicKeyHex\n    });\n  } /// get args for execute call\n\n\n  const nonce = parseInt(yield account.viewFunction(accountId, \"get_nonce\"), 16).toString();\n  const args = yield ethSignJson(signer, {\n    nonce,\n    receivers: [accountId],\n    transactions: [{\n      actions\n    }]\n  });\n  const res = yield account.functionCall({\n    contractId: accountId,\n    methodName: \"execute\",\n    args,\n    gas\n  });\n\n  if (((_h = res === null || res === void 0 ? void 0 : res.status) === null || _h === void 0 ? void 0 : _h.SuccessValue) !== \"\") {\n    return logger.log(\"app key rotation unsuccessful\");\n  } // remove the mapping (can do this later if user has FAK)\n\n\n  keyStore.setKey(networkId, accountId, newSecretKey);\n\n  try {\n    const mapRes = yield account.functionCall({\n      contractId: NETWORK[networkId].MAP_ACCOUNT_ID,\n      methodName: \"del\",\n      args: {},\n      gas\n    });\n    logger.log(mapRes);\n\n    if (((_j = mapRes === null || mapRes === void 0 ? void 0 : mapRes.status) === null || _j === void 0 ? void 0 : _j.SuccessValue) !== \"\") {\n      logger.log(\"account mapping removal failed\");\n    }\n  } catch (e) {\n    logger.log(e);\n  }\n\n  return {\n    account\n  };\n}); /// helpers for account creation and connection domain\n\nconst setupFromStorage = (accountId = \"\") => __awaiter(void 0, void 0, void 0, function* () {\n  const newAccountId = accountId.length > 0 ? accountId : yield storage.getItem(ATTEMPT_ACCOUNT_ID);\n  const newSecretKey = yield storage.getItem(ATTEMPT_SECRET_KEY);\n  const ethAddress = yield storage.getItem(ATTEMPT_ETH_ADDRESS);\n  const account = new Account(connection, newAccountId);\n  let keyPair;\n\n  if (newSecretKey) {\n    keyPair = KeyPair.fromString(newSecretKey);\n    keyStore.setKey(networkId, newAccountId, keyPair);\n  }\n\n  return {\n    newAccountId,\n    newSecretKey,\n    ethAddress,\n    account,\n    keyPair\n  };\n});\n\nconst getUnlimitedKeyAccount = (signer, ethAddress, tryPrevUrl = false) => __awaiter(void 0, void 0, void 0, function* () {\n  let accountId,\n      secretKey = yield storage.getItem(ATTEMPT_SECRET_KEY); // if unlimited allowance access key is not in localStorage user will have to sign to generate it\n\n  if (!secretKey) {\n    // TODO remove dep on near-utils\n    // use any random near account to check mapping\n    accountId = yield getNearMap(ethAddress);\n    const {\n      secretKey: _secretKey\n    } = yield keyPairFromEthSig(signer, unlimitedKeyPayload(accountId, tryPrevUrl));\n    secretKey = _secretKey;\n  } else {\n    accountId = yield storage.getItem(ATTEMPT_ACCOUNT_ID);\n  }\n\n  const account = new Account(connection, accountId);\n  const keyPair = KeyPair.fromString(secretKey);\n  const publicKey = keyPair.getPublicKey().toString(); /// check if access key matches\n\n  const accessKeys = yield account.getAccessKeys();\n\n  if (!accessKeys.some(({\n    public_key\n  }) => publicKey === public_key)) {\n    return yield getUnlimitedKeyAccount(signer, ethAddress, true);\n  }\n\n  keyStore.setKey(networkId, accountId, keyPair);\n  return {\n    account,\n    accountId,\n    secretKey\n  };\n});\n/**\r\n * The access key payloads, unlimited and limited\r\n */\n\n\nconst appKeyPayload = (accountId, appKeyNonce) => ({\n  WARNING: `Creating key for: ${accountId}`,\n  nonce: appKeyNonce,\n  description: `ONLY sign this on apps you trust! This key CAN use up to 1 N for transactions.`\n});\n\nconst unlimitedKeyPayload = (accountId, tryPrevUrl) => ({\n  WARNING: `Creates a key with access to your (new) paired NEAR Account: ${accountId}`,\n  description: `ONLY sign this message on this website: ${tryPrevUrl ? PREV_NETH_SITE_URL : NETH_SITE_URL}`\n});\n\nconst fundingKeyPayload = () => ({\n  WARNING: `This creates a full access key in your localStorage to a funding account you will be sending NEAR to.`,\n  description: `ONLY sign this message on this website: ${NETH_SITE_URL}`\n});\n/**\r\n * main domain, types and eth signTypedData method\r\n */\n\n\nconst domain = {\n  name: \"NETH\",\n  version: \"1\",\n  // chainId: 1, // aurora\n  chainId: 1313161554 // aurora\n\n};\nconst HEADER_OFFSET = \"NETH\";\nconst HEADER_PAD = 8;\nconst RECEIVER_MARKER = \"|~-_NETH~-_-~RECEIVER_-~|\";\nconst PREFIX = \"|NETH_\";\nconst SUFFIX = \"_NETH|\";\n\nconst pack = elements => elements.map(el => {\n  const str = typeof el === \"string\" ? el : Object.entries(el).map(([k, v]) => `${PREFIX}${k}:${typeof v === \"string\" ? v : JSON.stringify(v)}${SUFFIX}`).join(\"\");\n  const len = str.length.toString().padStart(HEADER_PAD, \"0\");\n  return HEADER_OFFSET + len + \"__\" + str;\n}).join(\"\");\n\nconst ethSignJson = (signer, json) => __awaiter(void 0, void 0, void 0, function* () {\n  const Transaction = [];\n  const types = {\n    Transaction\n  };\n  Object.entries(json).forEach(([k]) => {\n    types.Transaction.push({\n      type: \"string\",\n      name: k\n    });\n  }); /// convenience for devs so they can pass in JSON\n  /// hoist any functionCall args containing receiver|account in their key to top level receivers\n  /// replaces value with marker, contract fills in marker\n\n  if (json.transactions) {\n    Object.values(json.transactions).forEach((tx, i) => {\n      tx.actions.forEach(action => {\n        if (!action.args) {\n          return;\n        }\n\n        if (Buffer.isBuffer(action.args)) {\n          action.args = \"0x\" + action.args.toString(\"hex\");\n          return;\n        }\n\n        Object.entries(action.args).forEach(([key, value]) => {\n          /// TODO include check on value to determine valid account_id to be replaced\n          if (/receiver_id|account_id/g.test(key)) {\n            action.args[key] = RECEIVER_MARKER;\n            json.receivers.splice(i + 1, 0, value);\n          }\n        });\n      });\n    });\n    json.transactions = pack(json.transactions.map(({\n      actions\n    }) => pack(actions)));\n  }\n\n  if (json.receivers) {\n    const numReceivers = json.receivers.length.toString();\n    json.receivers = HEADER_OFFSET + json.receivers.join(\",\").length.toString().padStart(HEADER_PAD, \"0\") + \"__\" + json.receivers.join(\",\");\n    json.receivers = json.receivers.substring(0, 4) + numReceivers.padStart(3, \"0\") + json.receivers.substring(7);\n  }\n\n  const sig = yield signer._signTypedData(domain, types, json);\n  const args = {\n    sig,\n    msg: json\n  }; // logger.log('\\nargs\\n', JSON.stringify(args, null, 4), '\\n');\n\n  return args;\n});\n\nconst keyPairFromEthSig = (signer, json) => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    sig\n  } = yield ethSignJson(signer, json);\n  const sigHash = ethers.utils.id(sig); /// use 32 bytes of entropy from hash of signature to create NEAR keyPair\n\n  return generateSeedPhrase(sigHash.substring(2, 34));\n});\n/**\r\n * Used by apps to signIn and signAndSendTransactions\r\n */\n/// ethereum\n\n\nconst getEthereum = () => __awaiter(void 0, void 0, void 0, function* () {\n  var _k, _l;\n\n  const provider = yield detectEthereumProvider();\n\n  if (!provider) {\n    return alert(\"Please install/activate MetaMask and try again.\");\n  }\n\n  try {\n    yield window.ethereum.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: \"0x\" + domain.chainId.toString(16)\n      }]\n    });\n  } catch (e) {\n    logger.log(e);\n    const code = (e === null || e === void 0 ? void 0 : e.code) || ((_l = (_k = e === null || e === void 0 ? void 0 : e.data) === null || _k === void 0 ? void 0 : _k.originalError) === null || _l === void 0 ? void 0 : _l.code);\n\n    if (code !== 4902) {\n      throw e;\n    }\n\n    try {\n      yield window.ethereum.request({\n        method: \"wallet_addEthereumChain\",\n        params: [{\n          chainId: \"0x\" + domain.chainId.toString(16),\n          chainName: \"Aurora Mainnet\",\n          nativeCurrency: {\n            name: \"Ethereum\",\n            symbol: \"ETH\",\n            decimals: 18\n          },\n          blockExplorerUrls: [\"https://explorer.mainnet.aurora.dev/\"],\n          rpcUrls: [\"https://mainnet.aurora.dev\"]\n        }]\n      });\n    } catch (e2) {\n      alert('Error adding chain. Please click \"Choose Ethereum Account\" and add the Aurora Network to continue.');\n      throw e2;\n    }\n  }\n\n  const ethersProvider = new ethers.providers.Web3Provider(window.ethereum);\n  const accounts = yield ethersProvider.listAccounts();\n\n  if (accounts.length === 0) {\n    yield ethersProvider.send(\"eth_requestAccounts\", []);\n  }\n\n  const signer = ethersProvider.getSigner();\n  return {\n    signer,\n    ethAddress: yield signer.getAddress()\n  };\n});\nconst switchEthereum = () => __awaiter(void 0, void 0, void 0, function* () {\n  const provider = yield detectEthereumProvider();\n  yield provider.send(\"wallet_requestPermissions\", [{\n    eth_accounts: {}\n  }]);\n  const ethersProvider = new ethers.providers.Web3Provider(window.ethereum);\n  const signer = ethersProvider.getSigner();\n  return {\n    signer,\n    ethAddress: yield signer.getAddress()\n  };\n}); /// near\n\nconst getNearMap = eth_address => __awaiter(void 0, void 0, void 0, function* () {\n  return contractAccount.viewFunction(NETWORK[networkId].MAP_ACCOUNT_ID, \"get_near\", {\n    eth_address\n  });\n});\nconst getNear = () => __awaiter(void 0, void 0, void 0, function* () {\n  const secretKey = yield storage.getItem(APP_KEY_SECRET);\n  const accountId = yield storage.getItem(APP_KEY_ACCOUNT_ID);\n\n  if (!secretKey || !accountId) {\n    const ethRes = yield getEthereum();\n    const res = yield getAppKey(ethRes);\n\n    if (!res) {\n      return false;\n    }\n\n    return yield getNear();\n  }\n\n  const account = new Account(connection, accountId);\n  const keyPair = KeyPair.fromString(secretKey);\n  keyStore.setKey(networkId, accountId, keyPair);\n  return {\n    account,\n    accountId,\n    keyPair,\n    secretKey\n  };\n});\nconst signIn = getNear;\nconst signOut = () => __awaiter(void 0, void 0, void 0, function* () {\n  const accountId = yield storage.getItem(APP_KEY_ACCOUNT_ID);\n\n  if (!accountId) {\n    return logger.log(\"already signed out\");\n  }\n\n  yield storage.removeItem(APP_KEY_SECRET);\n  yield storage.removeItem(APP_KEY_ACCOUNT_ID);\n  return {\n    accountId\n  };\n});\nconst verifyOwner = ({\n  message,\n  provider,\n  account\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  let accountId;\n\n  if (!account) {\n    ({\n      account,\n      accountId\n    } = yield getNear());\n  } else {\n    ({\n      accountId\n    } = account);\n  }\n\n  if (!account) {\n    throw new Error(\"Wallet not signed in\");\n  }\n\n  const pubKey = yield account.connection.signer.getPublicKey(accountId, networkId);\n  const publicKey = Buffer.from(pubKey.data).toString(\"base64\");\n  const block = yield provider.block({\n    finality: \"final\"\n  });\n  const blockId = block.header.hash;\n  const data = {\n    accountId,\n    message,\n    blockId,\n    publicKey,\n    keyType: pubKey.keyType\n  };\n  const encoded = JSON.stringify(data);\n  const signed = yield account.connection.signer.signMessage(new Uint8Array(Buffer.from(encoded)), accountId, networkId);\n  return Object.assign(Object.assign({}, data), {\n    signature: Buffer.from(signed.signature).toString(\"base64\")\n  });\n});\nconst isSignedIn = () => __awaiter(void 0, void 0, void 0, function* () {\n  /// init defaultStorage here because it's not initialized until initConnection\n  const tempStorage = defaultStorage(WS_STORAGE_NAMESPACE);\n  return !!(yield tempStorage.getItem(APP_KEY_SECRET)) || !!(yield tempStorage.getItem(APP_KEY_ACCOUNT_ID));\n}); // const promptValidAccountId = async (msg) => {\n//   const newAccountId = window.prompt(msg);\n//   if (!newAccountId) {\n//     throw new Error(\"NETH Error: failed to pick valid NEAR account name\");\n//   }\n//   if (\n//     newAccountId.length < 2 ||\n//     newAccountId.indexOf(\".\") > -1 ||\n//     !ACCOUNT_REGEX.test(newAccountId) ||\n//     newAccountId.length > 64\n//   ) {\n//     return promptValidAccountId(\n//       `account is invalid (a-z, 0-9 and -,_ only; min 2; max 64; ${accountSuffix} applied automatically)`\n//     );\n//   }\n//   if (await accountExists(newAccountId)) {\n//     return promptValidAccountId(`account already exists`);\n//   }\n//   return newAccountId;\n// };\n\nconst getAppKey = ({\n  signer,\n  ethAddress: eth_address\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const accountId = yield getNearMap(eth_address);\n\n  if (!accountId) {\n    const tryAgain = window.confirm(`Ethereum account ${eth_address} is not connected to a NETH account. Would you like to try another Ethereum account?`);\n\n    if (tryAgain) {\n      try {\n        const {\n          signer: _signer,\n          ethAddress\n        } = yield switchEthereum();\n        return yield getAppKey({\n          signer: _signer,\n          ethAddress\n        });\n      } catch (e) {\n        logger.log(e);\n      }\n\n      return;\n    }\n\n    const nethURL = `${NETH_SITE_URL}/${networkId === \"testnet\" ? \"?network=testnet\" : \"\"}`;\n    window.prompt(`We couldn't find a NETH account. To set up a NETH account visit`, nethURL); // throw new Error(`Ethereum account is not connected to a NETH account. To set up a NETH account visit: ${nethURL}`)\n    // /// prompt for near account name and auto deploy\n    // const newAccountId = await promptValidAccountId(\n    // \t`The Ethereum address ${eth_address} is not connected to a NEAR account yet. Select a NEAR account name and we'll create and connect one for you.`,\n    // );\n    // const { account } = await handleCreate(signer, eth_address, newAccountId + accountSuffix);\n    // accountId = account.accountId;\n  }\n\n  const appKeyNonce = parseInt(yield contractAccount.viewFunction(accountId, \"get_app_key_nonce\"), 16).toString();\n  const {\n    publicKey,\n    secretKey\n  } = yield keyPairFromEthSig(signer, appKeyPayload(accountId, appKeyNonce));\n  const account = new Account(connection, accountId); // check that app key exists on account\n\n  const accessKeys = yield account.getAccessKeys();\n\n  if (!hasAppKey(accessKeys)) {\n    yield handleRefreshAppKey(signer, eth_address);\n  }\n\n  const keyPair = KeyPair.fromString(secretKey);\n  keyStore.setKey(networkId, accountId, keyPair);\n  yield storage.setItem(APP_KEY_SECRET, secretKey);\n  yield storage.setItem(APP_KEY_ACCOUNT_ID, account.accountId);\n  return {\n    publicKey,\n    secretKey,\n    account\n  };\n});\n\nconst broadcastTXs = () => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    account,\n    accountId\n  } = yield getNear();\n  const args = yield storage.getItem(TX_ARGS_ATTEMPT);\n\n  if (!args || args.length === 0) {\n    return;\n  }\n\n  const res = [];\n\n  while (args.length > 0) {\n    const currentArgs = args.shift();\n    logger.log(\"NETH: broadcasting tx\", currentArgs);\n\n    try {\n      const tx = yield account.functionCall({\n        contractId: accountId,\n        methodName: \"execute\",\n        args: currentArgs,\n        gas\n      });\n      yield storage.setItem(TX_ARGS_ATTEMPT, args);\n      res.push(tx);\n    } catch (e) {\n      logger.log(\"NETH: ERROR broadcasting tx\", e);\n    }\n  }\n\n  yield storage.removeItem(TX_ARGS_ATTEMPT);\n  return res;\n});\n\nconst signAndSendTransactions = ({\n  transactions,\n  bundle\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const ethRes = yield getEthereum();\n  const {\n    signer\n  } = ethRes;\n  const {\n    account,\n    accountId\n  } = yield getNear();\n  const receivers = transactions.map(({\n    receiverId\n  }) => receiverId);\n  const transformedTxs = transactions.map(({\n    receiverId,\n    actions\n  }) => ({\n    actions: convertActions(actions, accountId, receiverId)\n  }));\n  const nonce = parseInt(yield account.viewFunction(accountId, \"get_nonce\"), 16);\n  const args = [];\n\n  if (!bundle) {\n    for (let i = 0; i < transformedTxs.length; i++) {\n      args.push(yield ethSignJson(signer, {\n        nonce: (nonce + i).toString(),\n        receivers: [receivers[i]],\n        transactions: [transformedTxs[i]]\n      }));\n    }\n  } else {\n    args.push(yield ethSignJson(signer, {\n      nonce: nonce.toString(),\n      receivers,\n      transactions: transformedTxs\n    }));\n  }\n\n  yield storage.setItem(TX_ARGS_ATTEMPT, args);\n  const res = yield broadcastTXs();\n  return res;\n}); /// helpers\n\nconst convertActions = (actions, accountId, receiverId) => actions.map(_action => {\n  const {\n    enum: type\n  } = _action;\n  const {\n    gas: _gas,\n    publicKey,\n    methodName,\n    args,\n    deposit,\n    accessKey,\n    code\n  } = _action[type] || _action;\n  const action = {\n    type: type && type[0].toUpperCase() + type.substr(1) || \"FunctionCall\",\n    gas: _gas && _gas.toString() || undefined,\n    public_key: publicKey && pub2hex(publicKey) || undefined,\n    method_name: methodName,\n    args: args || undefined,\n    code: code || undefined,\n    amount: deposit && deposit.toString() || undefined,\n    permission: undefined\n  };\n  Object.keys(action).forEach(k => {\n    if (action[k] === undefined) {\n      delete action[k];\n    }\n  });\n\n  if (accessKey) {\n    if (receiverId === accountId) {\n      action.allowance = parseNearAmount(\"1\");\n      action.method_names = \"execute\";\n      action.receiver_id = accountId;\n    } else if (accessKey.permission.enum === \"functionCall\") {\n      const {\n        receiverId: _receiverId,\n        methodNames,\n        allowance\n      } = accessKey.permission.functionCall;\n      action.receiver_id = _receiverId;\n      action.allowance = allowance && allowance.toString() || parseNearAmount(\"0.25\");\n      action.method_names = methodNames.join(\",\");\n    }\n  }\n\n  return action;\n});\n\nconst isInstalled = () => __awaiter(void 0, void 0, void 0, function* () {\n  yield detectEthereumProvider();\n  return !!window.ethereum;\n});\n\nlet bundle = true;\nlet useCover = false;\nlet customGas;\n\nconst Neth = ({\n  metadata,\n  logger,\n  store,\n  storage,\n  options,\n  provider\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const cover = initConnection({\n    network: options.network,\n    gas: customGas,\n    logger,\n    storage\n  });\n\n  const isValidActions = actions => {\n    return actions.every(x => x.type === \"FunctionCall\");\n  };\n\n  const transformActions = actions => {\n    const validActions = isValidActions(actions);\n\n    if (!validActions) {\n      throw new Error(`Only 'FunctionCall' actions types are supported by ${metadata.name}`);\n    }\n\n    return actions.map(x => x.params);\n  };\n\n  const signTransactions = transactions => __awaiter(void 0, void 0, void 0, function* () {\n    logger.log(\"NETH:signAndSendTransactions\", {\n      transactions\n    });\n    const {\n      contract\n    } = store.getState();\n\n    if (!(yield isSignedIn()) || !contract) {\n      throw new Error(\"Wallet not signed in\");\n    }\n\n    if (useCover) {\n      cover.style.display = \"block\";\n    }\n\n    const transformedTxs = transactions.map(({\n      receiverId,\n      actions\n    }) => ({\n      receiverId: receiverId || contract.contractId,\n      actions: transformActions(actions)\n    }));\n    let res;\n\n    try {\n      res = yield signAndSendTransactions({\n        transactions: transformedTxs,\n        bundle\n      });\n    } catch (e) {\n      /// \"user rejected signing\" or near network error\n      logger.log(\"NETH:signAndSendTransactions Error\", e);\n      throw e;\n    }\n\n    if (useCover) {\n      cover.style.display = \"none\";\n    }\n\n    return res;\n  }); // return the wallet interface for wallet-selector\n\n\n  return {\n    signIn() {\n      return __awaiter(this, void 0, void 0, function* () {\n        let account;\n\n        try {\n          account = yield signIn();\n\n          if (!account) {\n            return [];\n          }\n        } catch (e) {\n          if (!/not connected/.test(e.toString())) {\n            throw e;\n          } // console.log(e);\n\n        }\n\n        return [account];\n      });\n    },\n\n    signOut() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield signOut();\n      });\n    },\n\n    verifyOwner({\n      message\n    }) {\n      return __awaiter(this, void 0, void 0, function* () {\n        logger.log(\"NETH:verifyOwner\", {\n          message\n        });\n        return verifyOwner({\n          message,\n          provider,\n          account: null\n        });\n      });\n    },\n\n    getAccounts() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const {\n          accountId\n        } = yield getNear();\n        return [{\n          accountId\n        }];\n      });\n    },\n\n    signAndSendTransaction: ({\n      receiverId,\n      actions\n    }) => __awaiter(void 0, void 0, void 0, function* () {\n      return signTransactions([{\n        receiverId,\n        actions\n      }]);\n    }),\n    signAndSendTransactions: ({\n      transactions\n    }) => __awaiter(void 0, void 0, void 0, function* () {\n      return signTransactions(transactions);\n    })\n  };\n});\n\nfunction setupNeth({\n  iconUrl = nethIcon,\n  gas,\n  useModalCover = false,\n  bundle: _bundle = true,\n  deprecated = false\n} = {}) {\n  return () => __awaiter(this, void 0, void 0, function* () {\n    useCover = useModalCover;\n    customGas = gas;\n    bundle = _bundle;\n    const mobile = isMobile();\n    const installed = yield isInstalled();\n    yield waitFor(() => !!isSignedIn(), {\n      timeout: 300\n    }).catch(() => false);\n\n    if (mobile) {\n      return null;\n    }\n\n    return {\n      id: \"neth\",\n      type: \"injected\",\n      metadata: {\n        name: \"NETH Account\",\n        description: null,\n        iconUrl,\n        downloadUrl: NETH_SITE_URL,\n        deprecated: false,\n        available: installed\n      },\n      deprecated,\n      init: Neth\n    };\n  });\n}\n\nexport { MIN_NEW_ACCOUNT_ASK, accountExists, getConnection, getEthereum, getNear, getNearMap, handleCancelFunding, handleCheckAccount, handleCreate, handleDisconnect, handleRefreshAppKey, handleUpdateContract, hasAppKey, initConnection, isSignedIn, setupNeth, signAndSendTransactions, signIn, signOut, switchEthereum, verifyOwner };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}