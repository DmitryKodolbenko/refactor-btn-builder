{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeToBoc = exports.deserializeBoc = exports.deserializeCellData = exports.parseBocHeader = exports.hashCell = exports.getMaxLevel = exports.getMaxDepth = void 0;\nvar ton_crypto_1 = require(\"ton-crypto\");\nvar __1 = require(\"..\");\nvar crc32c_1 = require(\"./utils/crc32c\");\nvar topologicalSort_1 = require(\"./utils/topologicalSort\");\nvar reachBocMagicPrefix = Buffer.from('B5EE9C72', 'hex');\nvar leanBocMagicPrefix = Buffer.from('68ff65f3', 'hex');\nvar leanBocMagicPrefixCRC = Buffer.from('acc3a728', 'hex');\nvar cacheContext = null;\nfunction getCellCache(src) {\n  if (!cacheContext) {\n    throw Error('No cache context');\n  }\n  var ex = src[cacheContext];\n  if (!ex) {\n    ex = {\n      hash: null,\n      maxDepth: null\n    };\n    src[cacheContext] = ex;\n  }\n  return ex;\n}\nfunction inCache(cell, handler) {\n  var wasCreated = false;\n  if (!cacheContext) {\n    wasCreated = true;\n    cacheContext = Symbol();\n  }\n  var cache = getCellCache(cell);\n  try {\n    return handler(cache);\n  } finally {\n    if (wasCreated) {\n      cacheContext = null;\n    }\n  }\n}\n//\n// Hash Content\n//\nfunction getMaxDepth(cell) {\n  return inCache(cell, function (cache) {\n    if (cache.maxDepth !== null) {\n      return cache.maxDepth;\n    }\n    var maxDepth = 0;\n    if (cell.refs.length > 0) {\n      for (var k in cell.refs) {\n        var i = cell.refs[k];\n        if (getMaxDepth(i) > maxDepth) {\n          maxDepth = getMaxDepth(i);\n        }\n      }\n      maxDepth = maxDepth + 1;\n    }\n    cache.maxDepth = maxDepth;\n    return maxDepth;\n  });\n}\nexports.getMaxDepth = getMaxDepth;\nfunction getMaxDepthAsArray(cell) {\n  var maxDepth = getMaxDepth(cell);\n  var d = Uint8Array.from({\n    length: 2\n  }, function () {\n    return 0;\n  });\n  d[1] = maxDepth % 256;\n  d[0] = Math.floor(maxDepth / 256);\n  return Buffer.from(d);\n}\nfunction getMaxLevel(cell) {\n  //TODO level calculation differ for exotic cells\n  // let maxLevel = 0;\n  // for (let k in cell.refs) {\n  //     const i = cell.refs[k];\n  //     if (getMaxLevel(i) > maxLevel) {\n  //         maxLevel = getMaxLevel(i);\n  //     }\n  // }\n  // return maxLevel;\n  return 0;\n}\nexports.getMaxLevel = getMaxLevel;\nfunction getRefsDescriptor(cell) {\n  var d1 = Uint8Array.from({\n    length: 1\n  }, function () {\n    return 0;\n  });\n  d1[0] = cell.refs.length + (cell.isExotic ? 1 : 0) * 8 + getMaxLevel(cell) * 32;\n  return Buffer.from(d1);\n}\nfunction getBitsDescriptor(cell) {\n  var d2 = Uint8Array.from({\n    length: 1\n  }, function () {\n    return 0;\n  });\n  var len = cell.bits.cursor;\n  if (cell.isExotic) {\n    len += 8;\n  }\n  d2[0] = Math.ceil(len / 8) + Math.floor(len / 8);\n  return Buffer.from(d2);\n}\nfunction getDataWithDescriptors(cell) {\n  var d1 = getRefsDescriptor(cell);\n  var d2 = getBitsDescriptor(cell);\n  var tuBits = cell.bits.getTopUppedArray();\n  return Buffer.concat([d1, d2, tuBits]);\n}\nfunction getRepr(cell) {\n  var reprArray = [];\n  reprArray.push(getDataWithDescriptors(cell));\n  for (var k in cell.refs) {\n    var i = cell.refs[k];\n    reprArray.push(getMaxDepthAsArray(i));\n  }\n  for (var _k in cell.refs) {\n    var _i = cell.refs[_k];\n    reprArray.push(_i.hash());\n  }\n  var x = Buffer.alloc(0);\n  for (var _k2 in reprArray) {\n    var _i2 = reprArray[_k2];\n    x = Buffer.concat([x, _i2]);\n  }\n  return x;\n}\nfunction hashCell(cell) {\n  return inCache(cell, function (cache) {\n    if (cache.hash) {\n      return cache.hash;\n    }\n    var r = (0, ton_crypto_1.sha256_sync)(getRepr(cell));\n    cache.hash = r;\n    return r;\n  });\n}\nexports.hashCell = hashCell;\n//\n// Deserialize\n//\nfunction readNBytesUIntFromArray(n, ui8array) {\n  var res = 0;\n  for (var c = 0; c < n; c++) {\n    res *= 256;\n    res += ui8array[c];\n  }\n  return res;\n}\nfunction parseBocHeader(serializedBoc) {\n  // snake_case is used to match TON docs\n  // Preflight check\n  if (serializedBoc.length < 4 + 1) {\n    throw new Error('Not enough bytes for magic prefix');\n  }\n  var inputData = serializedBoc; // Save copy for crc32\n  // Parse prefix\n  var prefix = serializedBoc.slice(0, 4);\n  serializedBoc = serializedBoc.slice(4);\n  var has_idx = false;\n  var hash_crc32 = false;\n  var has_cache_bits = false;\n  var flags = 0;\n  var size_bytes = 0;\n  if (prefix.equals(reachBocMagicPrefix)) {\n    var flags_byte = serializedBoc[0];\n    has_idx = !!(flags_byte & 128);\n    hash_crc32 = !!(flags_byte & 64);\n    has_cache_bits = !!(flags_byte & 32);\n    flags = (flags_byte & 16) * 2 + (flags_byte & 8);\n    size_bytes = flags_byte % 8;\n  } else if (prefix.equals(leanBocMagicPrefix)) {\n    has_idx = true;\n    hash_crc32 = false;\n    has_cache_bits = false;\n    flags = 0;\n    size_bytes = serializedBoc[0];\n  } else if (prefix.equals(leanBocMagicPrefixCRC)) {\n    has_idx = true;\n    hash_crc32 = true;\n    has_cache_bits = false;\n    flags = 0;\n    size_bytes = serializedBoc[0];\n  } else {\n    throw Error('Unknown magic prefix');\n  }\n  // Counters\n  serializedBoc = serializedBoc.slice(1);\n  if (serializedBoc.length < 1 + 5 * size_bytes) {\n    throw new Error('Not enough bytes for encoding cells counters');\n  }\n  var offset_bytes = serializedBoc[0];\n  serializedBoc = serializedBoc.slice(1);\n  var cells_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(size_bytes);\n  var roots_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(size_bytes);\n  var absent_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(size_bytes);\n  var tot_cells_size = readNBytesUIntFromArray(offset_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(offset_bytes);\n  if (serializedBoc.length < roots_num * size_bytes) {\n    throw new Error('Not enough bytes for encoding root cells hashes');\n  }\n  // Roots\n  var root_list = [];\n  for (var c = 0; c < roots_num; c++) {\n    root_list.push(readNBytesUIntFromArray(size_bytes, serializedBoc));\n    serializedBoc = serializedBoc.slice(size_bytes);\n  }\n  // Index\n  var index = null;\n  if (has_idx) {\n    index = [];\n    if (serializedBoc.length < offset_bytes * cells_num) throw new Error(\"Not enough bytes for index encoding\");\n    for (var _c = 0; _c < cells_num; _c++) {\n      index.push(readNBytesUIntFromArray(offset_bytes, serializedBoc));\n      serializedBoc = serializedBoc.slice(offset_bytes);\n    }\n  }\n  // Cells\n  if (serializedBoc.length < tot_cells_size) {\n    throw new Error('Not enough bytes for cells data');\n  }\n  var cells_data = serializedBoc.slice(0, tot_cells_size);\n  serializedBoc = serializedBoc.slice(tot_cells_size);\n  // CRC32\n  if (hash_crc32) {\n    if (serializedBoc.length < 4) {\n      throw new Error('Not enough bytes for crc32c hashsum');\n    }\n    var length = inputData.length;\n    if (!(0, crc32c_1.crc32c)(inputData.slice(0, length - 4)).equals(serializedBoc.slice(0, 4))) {\n      throw new Error('Crc32c hashsum mismatch');\n    }\n    serializedBoc = serializedBoc.slice(4);\n  }\n  // Check if we parsed everything\n  if (serializedBoc.length) {\n    throw new Error('Too much bytes in BoC serialization');\n  }\n  return {\n    has_idx: has_idx,\n    hash_crc32: hash_crc32,\n    has_cache_bits: has_cache_bits,\n    flags: flags,\n    size_bytes: size_bytes,\n    off_bytes: offset_bytes,\n    cells_num: cells_num,\n    roots_num: roots_num,\n    absent_num: absent_num,\n    tot_cells_size: tot_cells_size,\n    root_list: root_list,\n    index: index,\n    cells_data: cells_data\n  };\n}\nexports.parseBocHeader = parseBocHeader;\nfunction deserializeCellData(cellData, referenceIndexSize) {\n  if (cellData.length < 2) {\n    throw new Error('Not enough bytes to encode cell descriptors');\n  }\n  var d1 = cellData[0],\n    d2 = cellData[1];\n  cellData = cellData.slice(2);\n  // const level = Math.floor(d1 / 32);\n  var isExotic = !!(d1 & 8);\n  var refNum = d1 % 8;\n  var dataBytesize = Math.ceil(d2 / 2);\n  var fullfilledBytes = !(d2 % 2);\n  // Build Cell\n  var bits = __1.BitString.alloc(1023);\n  var refs = [];\n  if (cellData.length < dataBytesize + referenceIndexSize * refNum) {\n    throw new Error('Not enough bytes to encode cell data');\n  }\n  // Cell data\n  var kind = 'ordinary';\n  if (isExotic) {\n    var k = cellData.readUInt8();\n    if (k === 1) {\n      kind = 'pruned';\n    } else if (k === 2) {\n      kind = 'library_reference';\n    } else if (k === 3) {\n      kind = 'merkle_proof';\n    } else if (k === 4) {\n      kind = 'merkle_update';\n    } else {\n      throw Error('Invalid cell type: ' + k);\n    }\n    cellData = cellData.slice(1);\n    dataBytesize--;\n  }\n  bits.setTopUppedArray(cellData.slice(0, dataBytesize), fullfilledBytes);\n  cellData = cellData.slice(dataBytesize);\n  // References\n  for (var r = 0; r < refNum; r++) {\n    refs.push(readNBytesUIntFromArray(referenceIndexSize, cellData));\n    cellData = cellData.slice(referenceIndexSize);\n  }\n  // Resolve kind\n  var cell = new __1.Cell(kind, bits);\n  return {\n    cell: cell,\n    refs: refs,\n    residue: cellData\n  };\n}\nexports.deserializeCellData = deserializeCellData;\nfunction deserializeBoc(serializedBoc) {\n  var header = parseBocHeader(serializedBoc);\n  var cells_data = header.cells_data;\n  var cells_array = [];\n  var refs_array = [];\n  for (var ci = 0; ci < header.cells_num; ci++) {\n    var dd = deserializeCellData(cells_data, header.size_bytes);\n    cells_data = dd.residue;\n    cells_array.push(dd.cell);\n    refs_array.push(dd.refs);\n  }\n  for (var _ci = header.cells_num - 1; _ci >= 0; _ci--) {\n    var c = refs_array[_ci];\n    for (var ri = 0; ri < c.length; ri++) {\n      var r = c[ri];\n      if (r < _ci) {\n        throw new Error('Topological order is broken');\n      }\n      cells_array[_ci].refs[ri] = cells_array[r];\n    }\n  }\n  var root_cells = [];\n  var _iterator = _createForOfIteratorHelper(header.root_list),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _ri = _step.value;\n      root_cells.push(cells_array[_ri]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return root_cells;\n}\nexports.deserializeBoc = deserializeBoc;\n//\n// Serialize\n//\nfunction serializeForBoc(cell, refs, sSize) {\n  var reprArray = [];\n  reprArray.push(getRefsDescriptor(cell));\n  reprArray.push(getBitsDescriptor(cell));\n  if (cell.isExotic) {\n    if (cell.kind === 'pruned') {\n      reprArray.push(Buffer.from([1]));\n    } else if (cell.kind === 'library_reference') {\n      reprArray.push(Buffer.from([2]));\n    } else if (cell.kind === 'merkle_proof') {\n      reprArray.push(Buffer.from([3]));\n    } else if (cell.kind === 'merkle_update') {\n      reprArray.push(Buffer.from([4]));\n    } else {\n      throw Error('Invalid cell type');\n    }\n  }\n  reprArray.push(cell.bits.getTopUppedArray());\n  var _iterator2 = _createForOfIteratorHelper(refs),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var refIndexInt = _step2.value;\n      // const i = cell.refs[k];\n      // const refHash = (await i.hash()).toString('hex');\n      // const refIndexInt = cellsIndex[refHash];\n      // refIndexInt\n      var refIndexHex = refIndexInt.toString(16);\n      while (refIndexHex.length < sSize * 2) {\n        // Add leading zeros\n        refIndexHex = '0' + refIndexHex;\n      }\n      var reference = Buffer.from(refIndexHex, 'hex');\n      reprArray.push(reference);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var x = Buffer.alloc(0);\n  for (var k in reprArray) {\n    var i = reprArray[k];\n    x = Buffer.concat([x, i]);\n  }\n  return x;\n}\nfunction serializeToBoc(cell) {\n  var has_idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var hash_crc32 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var has_cache_bits = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  return inCache(cell, function () {\n    var root_cell = cell;\n    var allCells = (0, topologicalSort_1.topologicalSort)(root_cell);\n    var cells_num = allCells.length;\n    var s = cells_num.toString(2).length; // Minimal number of bits to represent reference (unused?)\n    var s_bytes = Math.max(Math.ceil(s / 8), 1);\n    var full_size = 0;\n    var sizeIndex = [];\n    var _iterator3 = _createForOfIteratorHelper(allCells),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var cell_info = _step3.value;\n        full_size = full_size + serializeForBoc(cell_info.cell, cell_info.refs, s_bytes).length;\n        sizeIndex.push(full_size);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    var offset_bits = full_size.toString(2).length; // Minimal number of bits to offset/len (unused?)\n    var offset_bytes = Math.max(Math.ceil(offset_bits / 8), 1);\n    var serialization = __1.BitString.alloc((1023 + 32 * 4 + 32 * 3) * allCells.length);\n    serialization.writeBuffer(reachBocMagicPrefix);\n    serialization.writeBitArray([has_idx, hash_crc32, has_cache_bits]);\n    serialization.writeUint(flags, 2);\n    serialization.writeUint(s_bytes, 3);\n    serialization.writeUint8(offset_bytes);\n    serialization.writeUint(cells_num, s_bytes * 8);\n    serialization.writeUint(1, s_bytes * 8); // One root for now\n    serialization.writeUint(0, s_bytes * 8); // Complete BOCs only\n    serialization.writeUint(full_size, offset_bytes * 8);\n    serialization.writeUint(0, s_bytes * 8); // Root shoulh have index 0\n    if (has_idx) {\n      allCells.forEach(function (cell_data, index) {\n        return serialization.writeUint(sizeIndex[index], offset_bytes * 8);\n      });\n    }\n    var _iterator4 = _createForOfIteratorHelper(allCells),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _cell_info = _step4.value;\n        //TODO it should be async map or async for\n        var refcell_ser = serializeForBoc(_cell_info.cell, _cell_info.refs, s_bytes);\n        serialization.writeBuffer(refcell_ser);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    var ser_arr = serialization.getTopUppedArray();\n    if (hash_crc32) {\n      ser_arr = Buffer.concat([ser_arr, (0, crc32c_1.crc32c)(ser_arr)]);\n    }\n    return ser_arr;\n  });\n}\nexports.serializeToBoc = serializeToBoc;","map":{"version":3,"names":["Object","defineProperty","exports","value","serializeToBoc","deserializeBoc","deserializeCellData","parseBocHeader","hashCell","getMaxLevel","getMaxDepth","ton_crypto_1","require","__1","crc32c_1","topologicalSort_1","reachBocMagicPrefix","Buffer","from","leanBocMagicPrefix","leanBocMagicPrefixCRC","cacheContext","getCellCache","src","Error","ex","hash","maxDepth","inCache","cell","handler","wasCreated","Symbol","cache","refs","length","k","i","getMaxDepthAsArray","d","Uint8Array","Math","floor","getRefsDescriptor","d1","isExotic","getBitsDescriptor","d2","len","bits","cursor","ceil","getDataWithDescriptors","tuBits","getTopUppedArray","concat","getRepr","reprArray","push","x","alloc","r","sha256_sync","readNBytesUIntFromArray","n","ui8array","res","c","serializedBoc","inputData","prefix","slice","has_idx","hash_crc32","has_cache_bits","flags","size_bytes","equals","flags_byte","offset_bytes","cells_num","roots_num","absent_num","tot_cells_size","root_list","index","cells_data","crc32c","off_bytes","cellData","referenceIndexSize","refNum","dataBytesize","fullfilledBytes","BitString","kind","readUInt8","setTopUppedArray","Cell","residue","header","cells_array","refs_array","ci","dd","ri","root_cells","serializeForBoc","sSize","refIndexInt","refIndexHex","toString","reference","root_cell","allCells","topologicalSort","s","s_bytes","max","full_size","sizeIndex","cell_info","offset_bits","serialization","writeBuffer","writeBitArray","writeUint","writeUint8","forEach","cell_data","refcell_ser","ser_arr"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/boc/boc.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeToBoc = exports.deserializeBoc = exports.deserializeCellData = exports.parseBocHeader = exports.hashCell = exports.getMaxLevel = exports.getMaxDepth = void 0;\nconst ton_crypto_1 = require(\"ton-crypto\");\nconst __1 = require(\"..\");\nconst crc32c_1 = require(\"./utils/crc32c\");\nconst topologicalSort_1 = require(\"./utils/topologicalSort\");\nconst reachBocMagicPrefix = Buffer.from('B5EE9C72', 'hex');\nconst leanBocMagicPrefix = Buffer.from('68ff65f3', 'hex');\nconst leanBocMagicPrefixCRC = Buffer.from('acc3a728', 'hex');\nlet cacheContext = null;\nfunction getCellCache(src) {\n    if (!cacheContext) {\n        throw Error('No cache context');\n    }\n    let ex = src[cacheContext];\n    if (!ex) {\n        ex = { hash: null, maxDepth: null };\n        src[cacheContext] = ex;\n    }\n    return ex;\n}\nfunction inCache(cell, handler) {\n    let wasCreated = false;\n    if (!cacheContext) {\n        wasCreated = true;\n        cacheContext = Symbol();\n    }\n    let cache = getCellCache(cell);\n    try {\n        return handler(cache);\n    }\n    finally {\n        if (wasCreated) {\n            cacheContext = null;\n        }\n    }\n}\n//\n// Hash Content\n//\nfunction getMaxDepth(cell) {\n    return inCache(cell, (cache) => {\n        if (cache.maxDepth !== null) {\n            return cache.maxDepth;\n        }\n        let maxDepth = 0;\n        if (cell.refs.length > 0) {\n            for (let k in cell.refs) {\n                const i = cell.refs[k];\n                if (getMaxDepth(i) > maxDepth) {\n                    maxDepth = getMaxDepth(i);\n                }\n            }\n            maxDepth = maxDepth + 1;\n        }\n        cache.maxDepth = maxDepth;\n        return maxDepth;\n    });\n}\nexports.getMaxDepth = getMaxDepth;\nfunction getMaxDepthAsArray(cell) {\n    const maxDepth = getMaxDepth(cell);\n    const d = Uint8Array.from({ length: 2 }, () => 0);\n    d[1] = maxDepth % 256;\n    d[0] = Math.floor(maxDepth / 256);\n    return Buffer.from(d);\n}\nfunction getMaxLevel(cell) {\n    //TODO level calculation differ for exotic cells\n    // let maxLevel = 0;\n    // for (let k in cell.refs) {\n    //     const i = cell.refs[k];\n    //     if (getMaxLevel(i) > maxLevel) {\n    //         maxLevel = getMaxLevel(i);\n    //     }\n    // }\n    // return maxLevel;\n    return 0;\n}\nexports.getMaxLevel = getMaxLevel;\nfunction getRefsDescriptor(cell) {\n    const d1 = Uint8Array.from({ length: 1 }, () => 0);\n    d1[0] = cell.refs.length + (cell.isExotic ? 1 : 0) * 8 + getMaxLevel(cell) * 32;\n    return Buffer.from(d1);\n}\nfunction getBitsDescriptor(cell) {\n    const d2 = Uint8Array.from({ length: 1 }, () => 0);\n    let len = cell.bits.cursor;\n    if (cell.isExotic) {\n        len += 8;\n    }\n    d2[0] = Math.ceil(len / 8) + Math.floor(len / 8);\n    return Buffer.from(d2);\n}\nfunction getDataWithDescriptors(cell) {\n    const d1 = getRefsDescriptor(cell);\n    const d2 = getBitsDescriptor(cell);\n    const tuBits = cell.bits.getTopUppedArray();\n    return Buffer.concat([d1, d2, tuBits]);\n}\nfunction getRepr(cell) {\n    const reprArray = [];\n    reprArray.push(getDataWithDescriptors(cell));\n    for (let k in cell.refs) {\n        const i = cell.refs[k];\n        reprArray.push(getMaxDepthAsArray(i));\n    }\n    for (let k in cell.refs) {\n        const i = cell.refs[k];\n        reprArray.push(i.hash());\n    }\n    let x = Buffer.alloc(0);\n    for (let k in reprArray) {\n        const i = reprArray[k];\n        x = Buffer.concat([x, i]);\n    }\n    return x;\n}\nfunction hashCell(cell) {\n    return inCache(cell, (cache) => {\n        if (cache.hash) {\n            return cache.hash;\n        }\n        let r = (0, ton_crypto_1.sha256_sync)(getRepr(cell));\n        cache.hash = r;\n        return r;\n    });\n}\nexports.hashCell = hashCell;\n//\n// Deserialize\n//\nfunction readNBytesUIntFromArray(n, ui8array) {\n    let res = 0;\n    for (let c = 0; c < n; c++) {\n        res *= 256;\n        res += ui8array[c];\n    }\n    return res;\n}\nfunction parseBocHeader(serializedBoc) {\n    // snake_case is used to match TON docs\n    // Preflight check\n    if (serializedBoc.length < 4 + 1) {\n        throw new Error('Not enough bytes for magic prefix');\n    }\n    const inputData = serializedBoc; // Save copy for crc32\n    // Parse prefix\n    const prefix = serializedBoc.slice(0, 4);\n    serializedBoc = serializedBoc.slice(4);\n    let has_idx = false;\n    let hash_crc32 = false;\n    let has_cache_bits = false;\n    let flags = 0;\n    let size_bytes = 0;\n    if (prefix.equals(reachBocMagicPrefix)) {\n        const flags_byte = serializedBoc[0];\n        has_idx = !!(flags_byte & 128);\n        hash_crc32 = !!(flags_byte & 64);\n        has_cache_bits = !!(flags_byte & 32);\n        flags = (flags_byte & 16) * 2 + (flags_byte & 8);\n        size_bytes = flags_byte % 8;\n    }\n    else if (prefix.equals(leanBocMagicPrefix)) {\n        has_idx = true;\n        hash_crc32 = false;\n        has_cache_bits = false;\n        flags = 0;\n        size_bytes = serializedBoc[0];\n    }\n    else if (prefix.equals(leanBocMagicPrefixCRC)) {\n        has_idx = true;\n        hash_crc32 = true;\n        has_cache_bits = false;\n        flags = 0;\n        size_bytes = serializedBoc[0];\n    }\n    else {\n        throw Error('Unknown magic prefix');\n    }\n    // Counters\n    serializedBoc = serializedBoc.slice(1);\n    if (serializedBoc.length < 1 + 5 * size_bytes) {\n        throw new Error('Not enough bytes for encoding cells counters');\n    }\n    const offset_bytes = serializedBoc[0];\n    serializedBoc = serializedBoc.slice(1);\n    const cells_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(size_bytes);\n    const roots_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(size_bytes);\n    const absent_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(size_bytes);\n    const tot_cells_size = readNBytesUIntFromArray(offset_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(offset_bytes);\n    if (serializedBoc.length < roots_num * size_bytes) {\n        throw new Error('Not enough bytes for encoding root cells hashes');\n    }\n    // Roots\n    let root_list = [];\n    for (let c = 0; c < roots_num; c++) {\n        root_list.push(readNBytesUIntFromArray(size_bytes, serializedBoc));\n        serializedBoc = serializedBoc.slice(size_bytes);\n    }\n    // Index\n    let index = null;\n    if (has_idx) {\n        index = [];\n        if (serializedBoc.length < offset_bytes * cells_num)\n            throw new Error(\"Not enough bytes for index encoding\");\n        for (let c = 0; c < cells_num; c++) {\n            index.push(readNBytesUIntFromArray(offset_bytes, serializedBoc));\n            serializedBoc = serializedBoc.slice(offset_bytes);\n        }\n    }\n    // Cells\n    if (serializedBoc.length < tot_cells_size) {\n        throw new Error('Not enough bytes for cells data');\n    }\n    const cells_data = serializedBoc.slice(0, tot_cells_size);\n    serializedBoc = serializedBoc.slice(tot_cells_size);\n    // CRC32\n    if (hash_crc32) {\n        if (serializedBoc.length < 4) {\n            throw new Error('Not enough bytes for crc32c hashsum');\n        }\n        const length = inputData.length;\n        if (!(0, crc32c_1.crc32c)(inputData.slice(0, length - 4)).equals(serializedBoc.slice(0, 4))) {\n            throw new Error('Crc32c hashsum mismatch');\n        }\n        serializedBoc = serializedBoc.slice(4);\n    }\n    // Check if we parsed everything\n    if (serializedBoc.length) {\n        throw new Error('Too much bytes in BoC serialization');\n    }\n    return {\n        has_idx: has_idx,\n        hash_crc32: hash_crc32,\n        has_cache_bits: has_cache_bits,\n        flags: flags,\n        size_bytes: size_bytes,\n        off_bytes: offset_bytes,\n        cells_num: cells_num,\n        roots_num: roots_num,\n        absent_num: absent_num,\n        tot_cells_size: tot_cells_size,\n        root_list: root_list,\n        index: index,\n        cells_data: cells_data\n    };\n}\nexports.parseBocHeader = parseBocHeader;\nfunction deserializeCellData(cellData, referenceIndexSize) {\n    if (cellData.length < 2) {\n        throw new Error('Not enough bytes to encode cell descriptors');\n    }\n    const d1 = cellData[0], d2 = cellData[1];\n    cellData = cellData.slice(2);\n    // const level = Math.floor(d1 / 32);\n    const isExotic = !!(d1 & 8);\n    const refNum = d1 % 8;\n    let dataBytesize = Math.ceil(d2 / 2);\n    const fullfilledBytes = !(d2 % 2);\n    // Build Cell\n    let bits = __1.BitString.alloc(1023);\n    let refs = [];\n    if (cellData.length < dataBytesize + referenceIndexSize * refNum) {\n        throw new Error('Not enough bytes to encode cell data');\n    }\n    // Cell data\n    let kind = 'ordinary';\n    if (isExotic) {\n        let k = cellData.readUInt8();\n        if (k === 1) {\n            kind = 'pruned';\n        }\n        else if (k === 2) {\n            kind = 'library_reference';\n        }\n        else if (k === 3) {\n            kind = 'merkle_proof';\n        }\n        else if (k === 4) {\n            kind = 'merkle_update';\n        }\n        else {\n            throw Error('Invalid cell type: ' + k);\n        }\n        cellData = cellData.slice(1);\n        dataBytesize--;\n    }\n    bits.setTopUppedArray(cellData.slice(0, dataBytesize), fullfilledBytes);\n    cellData = cellData.slice(dataBytesize);\n    // References\n    for (let r = 0; r < refNum; r++) {\n        refs.push(readNBytesUIntFromArray(referenceIndexSize, cellData));\n        cellData = cellData.slice(referenceIndexSize);\n    }\n    // Resolve kind\n    let cell = new __1.Cell(kind, bits);\n    return { cell, refs, residue: cellData };\n}\nexports.deserializeCellData = deserializeCellData;\nfunction deserializeBoc(serializedBoc) {\n    const header = parseBocHeader(serializedBoc);\n    let cells_data = header.cells_data;\n    let cells_array = [];\n    let refs_array = [];\n    for (let ci = 0; ci < header.cells_num; ci++) {\n        let dd = deserializeCellData(cells_data, header.size_bytes);\n        cells_data = dd.residue;\n        cells_array.push(dd.cell);\n        refs_array.push(dd.refs);\n    }\n    for (let ci = header.cells_num - 1; ci >= 0; ci--) {\n        let c = refs_array[ci];\n        for (let ri = 0; ri < c.length; ri++) {\n            const r = c[ri];\n            if (r < ci) {\n                throw new Error('Topological order is broken');\n            }\n            cells_array[ci].refs[ri] = cells_array[r];\n        }\n    }\n    let root_cells = [];\n    for (let ri of header.root_list) {\n        root_cells.push(cells_array[ri]);\n    }\n    return root_cells;\n}\nexports.deserializeBoc = deserializeBoc;\n//\n// Serialize\n//\nfunction serializeForBoc(cell, refs, sSize) {\n    const reprArray = [];\n    reprArray.push(getRefsDescriptor(cell));\n    reprArray.push(getBitsDescriptor(cell));\n    if (cell.isExotic) {\n        if (cell.kind === 'pruned') {\n            reprArray.push(Buffer.from([1]));\n        }\n        else if (cell.kind === 'library_reference') {\n            reprArray.push(Buffer.from([2]));\n        }\n        else if (cell.kind === 'merkle_proof') {\n            reprArray.push(Buffer.from([3]));\n        }\n        else if (cell.kind === 'merkle_update') {\n            reprArray.push(Buffer.from([4]));\n        }\n        else {\n            throw Error('Invalid cell type');\n        }\n    }\n    reprArray.push(cell.bits.getTopUppedArray());\n    for (let refIndexInt of refs) {\n        // const i = cell.refs[k];\n        // const refHash = (await i.hash()).toString('hex');\n        // const refIndexInt = cellsIndex[refHash];\n        // refIndexInt\n        let refIndexHex = refIndexInt.toString(16);\n        while (refIndexHex.length < sSize * 2) {\n            // Add leading zeros\n            refIndexHex = '0' + refIndexHex;\n        }\n        const reference = Buffer.from(refIndexHex, 'hex');\n        reprArray.push(reference);\n    }\n    let x = Buffer.alloc(0);\n    for (let k in reprArray) {\n        const i = reprArray[k];\n        x = Buffer.concat([x, i]);\n    }\n    return x;\n}\nfunction serializeToBoc(cell, has_idx = true, hash_crc32 = true, has_cache_bits = false, flags = 0) {\n    return inCache(cell, () => {\n        const root_cell = cell;\n        const allCells = (0, topologicalSort_1.topologicalSort)(root_cell);\n        const cells_num = allCells.length;\n        const s = cells_num.toString(2).length; // Minimal number of bits to represent reference (unused?)\n        const s_bytes = Math.max(Math.ceil(s / 8), 1);\n        let full_size = 0;\n        let sizeIndex = [];\n        for (let cell_info of allCells) {\n            full_size = full_size + (serializeForBoc(cell_info.cell, cell_info.refs, s_bytes)).length;\n            sizeIndex.push(full_size);\n        }\n        const offset_bits = full_size.toString(2).length; // Minimal number of bits to offset/len (unused?)\n        const offset_bytes = Math.max(Math.ceil(offset_bits / 8), 1);\n        const serialization = __1.BitString.alloc((1023 + 32 * 4 + 32 * 3) * allCells.length);\n        serialization.writeBuffer(reachBocMagicPrefix);\n        serialization.writeBitArray([has_idx, hash_crc32, has_cache_bits]);\n        serialization.writeUint(flags, 2);\n        serialization.writeUint(s_bytes, 3);\n        serialization.writeUint8(offset_bytes);\n        serialization.writeUint(cells_num, s_bytes * 8);\n        serialization.writeUint(1, s_bytes * 8); // One root for now\n        serialization.writeUint(0, s_bytes * 8); // Complete BOCs only\n        serialization.writeUint(full_size, offset_bytes * 8);\n        serialization.writeUint(0, s_bytes * 8); // Root shoulh have index 0\n        if (has_idx) {\n            allCells.forEach((cell_data, index) => serialization.writeUint(sizeIndex[index], offset_bytes * 8));\n        }\n        for (let cell_info of allCells) {\n            //TODO it should be async map or async for\n            const refcell_ser = serializeForBoc(cell_info.cell, cell_info.refs, s_bytes);\n            serialization.writeBuffer(refcell_ser);\n        }\n        let ser_arr = serialization.getTopUppedArray();\n        if (hash_crc32) {\n            ser_arr = Buffer.concat([ser_arr, (0, crc32c_1.crc32c)(ser_arr)]);\n        }\n        return ser_arr;\n    });\n}\nexports.serializeToBoc = serializeToBoc;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}