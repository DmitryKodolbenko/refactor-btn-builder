{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Decimal = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n// Too large values lead to massive memory usage. Limit to something sensible.\n// The largest value we need is 18 (Ether).\nconst maxFractionalDigits = 100;\n/**\n * A type for arbitrary precision, non-negative decimals.\n *\n * Instances of this class are immutable.\n */\nclass Decimal {\n  constructor(atomics, fractionalDigits) {\n    this.data = {\n      atomics: new bn_js_1.default(atomics),\n      fractionalDigits: fractionalDigits\n    };\n  }\n  static fromUserInput(input, fractionalDigits) {\n    Decimal.verifyFractionalDigits(fractionalDigits);\n    const badCharacter = input.match(/[^0-9.]/);\n    if (badCharacter) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      throw new Error(`Invalid character at position ${badCharacter.index + 1}`);\n    }\n    let whole;\n    let fractional;\n    if (input.search(/\\./) === -1) {\n      // integer format, no separator\n      whole = input;\n      fractional = \"\";\n    } else {\n      const parts = input.split(\".\");\n      switch (parts.length) {\n        case 0:\n        case 1:\n          throw new Error(\"Fewer than two elements in split result. This must not happen here.\");\n        case 2:\n          if (!parts[1]) throw new Error(\"Fractional part missing\");\n          whole = parts[0];\n          fractional = parts[1].replace(/0+$/, \"\");\n          break;\n        default:\n          throw new Error(\"More than one separator found\");\n      }\n    }\n    if (fractional.length > fractionalDigits) {\n      throw new Error(\"Got more fractional digits than supported\");\n    }\n    const quantity = `${whole}${fractional.padEnd(fractionalDigits, \"0\")}`;\n    return new Decimal(quantity, fractionalDigits);\n  }\n  static fromAtomics(atomics, fractionalDigits) {\n    Decimal.verifyFractionalDigits(fractionalDigits);\n    return new Decimal(atomics, fractionalDigits);\n  }\n  /**\n   * Creates a Decimal with value 0.0 and the given number of fractial digits.\n   *\n   * Fractional digits are not relevant for the value but needed to be able\n   * to perform arithmetic operations with other decimals.\n   */\n  static zero(fractionalDigits) {\n    Decimal.verifyFractionalDigits(fractionalDigits);\n    return new Decimal(\"0\", fractionalDigits);\n  }\n  /**\n   * Creates a Decimal with value 1.0 and the given number of fractial digits.\n   *\n   * Fractional digits are not relevant for the value but needed to be able\n   * to perform arithmetic operations with other decimals.\n   */\n  static one(fractionalDigits) {\n    Decimal.verifyFractionalDigits(fractionalDigits);\n    return new Decimal(\"1\" + \"0\".repeat(fractionalDigits), fractionalDigits);\n  }\n  static verifyFractionalDigits(fractionalDigits) {\n    if (!Number.isInteger(fractionalDigits)) throw new Error(\"Fractional digits is not an integer\");\n    if (fractionalDigits < 0) throw new Error(\"Fractional digits must not be negative\");\n    if (fractionalDigits > maxFractionalDigits) {\n      throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);\n    }\n  }\n  static compare(a, b) {\n    if (a.fractionalDigits !== b.fractionalDigits) throw new Error(\"Fractional digits do not match\");\n    return a.data.atomics.cmp(new bn_js_1.default(b.atomics));\n  }\n  get atomics() {\n    return this.data.atomics.toString();\n  }\n  get fractionalDigits() {\n    return this.data.fractionalDigits;\n  }\n  /** Creates a new instance with the same value */\n  clone() {\n    return new Decimal(this.atomics, this.fractionalDigits);\n  }\n  /** Returns the greatest decimal <= this which has no fractional part (rounding down) */\n  floor() {\n    const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n    const whole = this.data.atomics.div(factor);\n    const fractional = this.data.atomics.mod(factor);\n    if (fractional.isZero()) {\n      return this.clone();\n    } else {\n      return Decimal.fromAtomics(whole.mul(factor).toString(), this.fractionalDigits);\n    }\n  }\n  /** Returns the smallest decimal >= this which has no fractional part (rounding up) */\n  ceil() {\n    const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n    const whole = this.data.atomics.div(factor);\n    const fractional = this.data.atomics.mod(factor);\n    if (fractional.isZero()) {\n      return this.clone();\n    } else {\n      return Decimal.fromAtomics(whole.addn(1).mul(factor).toString(), this.fractionalDigits);\n    }\n  }\n  toString() {\n    const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n    const whole = this.data.atomics.div(factor);\n    const fractional = this.data.atomics.mod(factor);\n    if (fractional.isZero()) {\n      return whole.toString();\n    } else {\n      const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, \"0\");\n      const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, \"\");\n      return `${whole.toString()}.${trimmedFractionalPart}`;\n    }\n  }\n  /**\n   * Returns an approximation as a float type. Only use this if no\n   * exact calculation is required.\n   */\n  toFloatApproximation() {\n    const out = Number(this.toString());\n    if (Number.isNaN(out)) throw new Error(\"Conversion to number failed\");\n    return out;\n  }\n  /**\n   * a.plus(b) returns a+b.\n   *\n   * Both values need to have the same fractional digits.\n   */\n  plus(b) {\n    if (this.fractionalDigits !== b.fractionalDigits) throw new Error(\"Fractional digits do not match\");\n    const sum = this.data.atomics.add(new bn_js_1.default(b.atomics));\n    return new Decimal(sum.toString(), this.fractionalDigits);\n  }\n  /**\n   * a.minus(b) returns a-b.\n   *\n   * Both values need to have the same fractional digits.\n   * The resulting difference needs to be non-negative.\n   */\n  minus(b) {\n    if (this.fractionalDigits !== b.fractionalDigits) throw new Error(\"Fractional digits do not match\");\n    const difference = this.data.atomics.sub(new bn_js_1.default(b.atomics));\n    if (difference.ltn(0)) throw new Error(\"Difference must not be negative\");\n    return new Decimal(difference.toString(), this.fractionalDigits);\n  }\n  /**\n   * a.multiply(b) returns a*b.\n   *\n   * We only allow multiplication by unsigned integers to avoid rounding errors.\n   */\n  multiply(b) {\n    const product = this.data.atomics.mul(new bn_js_1.default(b.toString()));\n    return new Decimal(product.toString(), this.fractionalDigits);\n  }\n  equals(b) {\n    return Decimal.compare(this, b) === 0;\n  }\n  isLessThan(b) {\n    return Decimal.compare(this, b) < 0;\n  }\n  isLessThanOrEqual(b) {\n    return Decimal.compare(this, b) <= 0;\n  }\n  isGreaterThan(b) {\n    return Decimal.compare(this, b) > 0;\n  }\n  isGreaterThanOrEqual(b) {\n    return Decimal.compare(this, b) >= 0;\n  }\n}\nexports.Decimal = Decimal;","map":{"version":3,"sources":["../src/decimal.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;AAIA;AACA;AACA,MAAM,mBAAmB,GAAG,GAAG;AAE/B;;;;AAIG;AACH,MAAa,OAAO,CAAA;EA+FlB,WAAA,CAAoB,OAAe,EAAE,gBAAwB,EAAA;IAC3D,IAAI,CAAC,IAAI,GAAG;MACV,OAAO,EAAE,IAAI,OAAA,CAAA,OAAE,CAAC,OAAO,CAAC;MACxB,gBAAgB,EAAE;KACnB;EACH;EAnGO,OAAO,aAAa,CAAC,KAAa,EAAE,gBAAwB,EAAA;IACjE,OAAO,CAAC,sBAAsB,CAAC,gBAAgB,CAAC;IAEhD,MAAM,YAAY,GAAG,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC;IAC3C,IAAI,YAAY,EAAE;MAChB;MACA,MAAM,IAAI,KAAK,CAAC,iCAAiC,YAAY,CAAC,KAAM,GAAG,CAAC,EAAE,CAAC;IAC5E;IAED,IAAI,KAAa;IACjB,IAAI,UAAkB;IAEtB,IAAI,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;MAC7B;MACA,KAAK,GAAG,KAAK;MACb,UAAU,GAAG,EAAE;KAChB,MAAM;MACL,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC;MAC9B,QAAQ,KAAK,CAAC,MAAM;QAClB,KAAK,CAAC;QACN,KAAK,CAAC;UACJ,MAAM,IAAI,KAAK,CAAC,qEAAqE,CAAC;QACxF,KAAK,CAAC;UACJ,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC;UACzD,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC;UAChB,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;UACxC;QACF;UACE,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC;MAAC;IAEtD;IAED,IAAI,UAAU,CAAC,MAAM,GAAG,gBAAgB,EAAE;MACxC,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC;IAC7D;IAED,MAAM,QAAQ,GAAG,GAAG,KAAK,GAAG,UAAU,CAAC,MAAM,CAAC,gBAAgB,EAAE,GAAG,CAAC,EAAE;IAEtE,OAAO,IAAI,OAAO,CAAC,QAAQ,EAAE,gBAAgB,CAAC;EAChD;EAEO,OAAO,WAAW,CAAC,OAAe,EAAE,gBAAwB,EAAA;IACjE,OAAO,CAAC,sBAAsB,CAAC,gBAAgB,CAAC;IAChD,OAAO,IAAI,OAAO,CAAC,OAAO,EAAE,gBAAgB,CAAC;EAC/C;EAEA;;;;;AAKG;EACI,OAAO,IAAI,CAAC,gBAAwB,EAAA;IACzC,OAAO,CAAC,sBAAsB,CAAC,gBAAgB,CAAC;IAChD,OAAO,IAAI,OAAO,CAAC,GAAG,EAAE,gBAAgB,CAAC;EAC3C;EAEA;;;;;AAKG;EACI,OAAO,GAAG,CAAC,gBAAwB,EAAA;IACxC,OAAO,CAAC,sBAAsB,CAAC,gBAAgB,CAAC;IAChD,OAAO,IAAI,OAAO,CAAC,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,gBAAgB,CAAC,EAAE,gBAAgB,CAAC;EAC1E;EAEQ,OAAO,sBAAsB,CAAC,gBAAwB,EAAA;IAC5D,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC;IAC/F,IAAI,gBAAgB,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC;IACnF,IAAI,gBAAgB,GAAG,mBAAmB,EAAE;MAC1C,MAAM,IAAI,KAAK,CAAC,qCAAqC,mBAAmB,EAAE,CAAC;IAC5E;EACH;EAEO,OAAO,OAAO,CAAC,CAAU,EAAE,CAAU,EAAA;IAC1C,IAAI,CAAC,CAAC,gBAAgB,KAAK,CAAC,CAAC,gBAAgB,EAAE,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC;IAChG,OAAO,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,OAAA,CAAA,OAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;EAC9C;EAEA,IAAW,OAAO,GAAA;IAChB,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE;EACrC;EAEA,IAAW,gBAAgB,GAAA;IACzB,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAgB;EACnC;EAcA;EACQ,KAAK,GAAA;IACX,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,gBAAgB,CAAC;EACzD;EAEA;EACO,KAAK,GAAA;IACV,MAAM,MAAM,GAAG,IAAI,OAAA,CAAA,OAAE,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,OAAA,CAAA,OAAE,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACjE,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;IAC3C,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;IAEhD,IAAI,UAAU,CAAC,MAAM,EAAE,EAAE;MACvB,OAAO,IAAI,CAAC,KAAK,EAAE;KACpB,MAAM;MACL,OAAO,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,gBAAgB,CAAC;IAChF;EACH;EAEA;EACO,IAAI,GAAA;IACT,MAAM,MAAM,GAAG,IAAI,OAAA,CAAA,OAAE,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,OAAA,CAAA,OAAE,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACjE,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;IAC3C,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;IAEhD,IAAI,UAAU,CAAC,MAAM,EAAE,EAAE;MACvB,OAAO,IAAI,CAAC,KAAK,EAAE;KACpB,MAAM;MACL,OAAO,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,gBAAgB,CAAC;IACxF;EACH;EAEO,QAAQ,GAAA;IACb,MAAM,MAAM,GAAG,IAAI,OAAA,CAAA,OAAE,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,OAAA,CAAA,OAAE,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACjE,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;IAC3C,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;IAEhD,IAAI,UAAU,CAAC,MAAM,EAAE,EAAE;MACvB,OAAO,KAAK,CAAC,QAAQ,EAAE;KACxB,MAAM;MACL,MAAM,kBAAkB,GAAG,UAAU,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,GAAG,CAAC;MAC1F,MAAM,qBAAqB,GAAG,kBAAkB,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;MACnE,OAAO,GAAG,KAAK,CAAC,QAAQ,EAAE,IAAI,qBAAqB,EAAE;IACtD;EACH;EAEA;;;AAGG;EACI,oBAAoB,GAAA;IACzB,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;IACnC,IAAI,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC;IACrE,OAAO,GAAG;EACZ;EAEA;;;;AAIG;EACI,IAAI,CAAC,CAAU,EAAA;IACpB,IAAI,IAAI,CAAC,gBAAgB,KAAK,CAAC,CAAC,gBAAgB,EAAE,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC;IACnG,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,OAAA,CAAA,OAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;IACpD,OAAO,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,gBAAgB,CAAC;EAC3D;EAEA;;;;;AAKG;EACI,KAAK,CAAC,CAAU,EAAA;IACrB,IAAI,IAAI,CAAC,gBAAgB,KAAK,CAAC,CAAC,gBAAgB,EAAE,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC;IACnG,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,OAAA,CAAA,OAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;IAC3D,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC;IACzE,OAAO,IAAI,OAAO,CAAC,UAAU,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,gBAAgB,CAAC;EAClE;EAEA;;;;AAIG;EACI,QAAQ,CAAC,CAA2B,EAAA;IACzC,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,OAAA,CAAA,OAAE,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC3D,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,gBAAgB,CAAC;EAC/D;EAEO,MAAM,CAAC,CAAU,EAAA;IACtB,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,CAAC;EACvC;EAEO,UAAU,CAAC,CAAU,EAAA;IAC1B,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC;EACrC;EAEO,iBAAiB,CAAC,CAAU,EAAA;IACjC,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC;EACtC;EAEO,aAAa,CAAC,CAAU,EAAA;IAC7B,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC;EACrC;EAEO,oBAAoB,CAAC,CAAU,EAAA;IACpC,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC;EACtC;AACD;AAlND,OAAA,CAAA,OAAA,GAAA,OAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Decimal = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n// Too large values lead to massive memory usage. Limit to something sensible.\n// The largest value we need is 18 (Ether).\nconst maxFractionalDigits = 100;\n/**\n * A type for arbitrary precision, non-negative decimals.\n *\n * Instances of this class are immutable.\n */\nclass Decimal {\n    constructor(atomics, fractionalDigits) {\n        this.data = {\n            atomics: new bn_js_1.default(atomics),\n            fractionalDigits: fractionalDigits,\n        };\n    }\n    static fromUserInput(input, fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        const badCharacter = input.match(/[^0-9.]/);\n        if (badCharacter) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            throw new Error(`Invalid character at position ${badCharacter.index + 1}`);\n        }\n        let whole;\n        let fractional;\n        if (input.search(/\\./) === -1) {\n            // integer format, no separator\n            whole = input;\n            fractional = \"\";\n        }\n        else {\n            const parts = input.split(\".\");\n            switch (parts.length) {\n                case 0:\n                case 1:\n                    throw new Error(\"Fewer than two elements in split result. This must not happen here.\");\n                case 2:\n                    if (!parts[1])\n                        throw new Error(\"Fractional part missing\");\n                    whole = parts[0];\n                    fractional = parts[1].replace(/0+$/, \"\");\n                    break;\n                default:\n                    throw new Error(\"More than one separator found\");\n            }\n        }\n        if (fractional.length > fractionalDigits) {\n            throw new Error(\"Got more fractional digits than supported\");\n        }\n        const quantity = `${whole}${fractional.padEnd(fractionalDigits, \"0\")}`;\n        return new Decimal(quantity, fractionalDigits);\n    }\n    static fromAtomics(atomics, fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(atomics, fractionalDigits);\n    }\n    /**\n     * Creates a Decimal with value 0.0 and the given number of fractial digits.\n     *\n     * Fractional digits are not relevant for the value but needed to be able\n     * to perform arithmetic operations with other decimals.\n     */\n    static zero(fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(\"0\", fractionalDigits);\n    }\n    /**\n     * Creates a Decimal with value 1.0 and the given number of fractial digits.\n     *\n     * Fractional digits are not relevant for the value but needed to be able\n     * to perform arithmetic operations with other decimals.\n     */\n    static one(fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(\"1\" + \"0\".repeat(fractionalDigits), fractionalDigits);\n    }\n    static verifyFractionalDigits(fractionalDigits) {\n        if (!Number.isInteger(fractionalDigits))\n            throw new Error(\"Fractional digits is not an integer\");\n        if (fractionalDigits < 0)\n            throw new Error(\"Fractional digits must not be negative\");\n        if (fractionalDigits > maxFractionalDigits) {\n            throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);\n        }\n    }\n    static compare(a, b) {\n        if (a.fractionalDigits !== b.fractionalDigits)\n            throw new Error(\"Fractional digits do not match\");\n        return a.data.atomics.cmp(new bn_js_1.default(b.atomics));\n    }\n    get atomics() {\n        return this.data.atomics.toString();\n    }\n    get fractionalDigits() {\n        return this.data.fractionalDigits;\n    }\n    /** Creates a new instance with the same value */\n    clone() {\n        return new Decimal(this.atomics, this.fractionalDigits);\n    }\n    /** Returns the greatest decimal <= this which has no fractional part (rounding down) */\n    floor() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return this.clone();\n        }\n        else {\n            return Decimal.fromAtomics(whole.mul(factor).toString(), this.fractionalDigits);\n        }\n    }\n    /** Returns the smallest decimal >= this which has no fractional part (rounding up) */\n    ceil() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return this.clone();\n        }\n        else {\n            return Decimal.fromAtomics(whole.addn(1).mul(factor).toString(), this.fractionalDigits);\n        }\n    }\n    toString() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return whole.toString();\n        }\n        else {\n            const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, \"0\");\n            const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, \"\");\n            return `${whole.toString()}.${trimmedFractionalPart}`;\n        }\n    }\n    /**\n     * Returns an approximation as a float type. Only use this if no\n     * exact calculation is required.\n     */\n    toFloatApproximation() {\n        const out = Number(this.toString());\n        if (Number.isNaN(out))\n            throw new Error(\"Conversion to number failed\");\n        return out;\n    }\n    /**\n     * a.plus(b) returns a+b.\n     *\n     * Both values need to have the same fractional digits.\n     */\n    plus(b) {\n        if (this.fractionalDigits !== b.fractionalDigits)\n            throw new Error(\"Fractional digits do not match\");\n        const sum = this.data.atomics.add(new bn_js_1.default(b.atomics));\n        return new Decimal(sum.toString(), this.fractionalDigits);\n    }\n    /**\n     * a.minus(b) returns a-b.\n     *\n     * Both values need to have the same fractional digits.\n     * The resulting difference needs to be non-negative.\n     */\n    minus(b) {\n        if (this.fractionalDigits !== b.fractionalDigits)\n            throw new Error(\"Fractional digits do not match\");\n        const difference = this.data.atomics.sub(new bn_js_1.default(b.atomics));\n        if (difference.ltn(0))\n            throw new Error(\"Difference must not be negative\");\n        return new Decimal(difference.toString(), this.fractionalDigits);\n    }\n    /**\n     * a.multiply(b) returns a*b.\n     *\n     * We only allow multiplication by unsigned integers to avoid rounding errors.\n     */\n    multiply(b) {\n        const product = this.data.atomics.mul(new bn_js_1.default(b.toString()));\n        return new Decimal(product.toString(), this.fractionalDigits);\n    }\n    equals(b) {\n        return Decimal.compare(this, b) === 0;\n    }\n    isLessThan(b) {\n        return Decimal.compare(this, b) < 0;\n    }\n    isLessThanOrEqual(b) {\n        return Decimal.compare(this, b) <= 0;\n    }\n    isGreaterThan(b) {\n        return Decimal.compare(this, b) > 0;\n    }\n    isGreaterThanOrEqual(b) {\n        return Decimal.compare(this, b) >= 0;\n    }\n}\nexports.Decimal = Decimal;\n//# sourceMappingURL=decimal.js.map"]},"metadata":{},"sourceType":"script"}