{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseShardStateUnsplit = exports.parseMasterchainStateExtra = exports.parseShardAccounts = exports.parseDepthBalanceInfo = exports.parseShardAccount = exports.parseShardIdent = exports.parseAccount = exports.parseAccountStorage = exports.parseAccountState = exports.parseStorageInfo = exports.parseStorageUsed = exports.parseTransaction = exports.parseTransactionDescription = exports.parseBouncePhase = exports.parseActionPhase = exports.parseComputePhase = exports.parseCreditPhase = exports.parseStoragePhase = exports.parseStorageUsedShort = exports.parseAccountChange = exports.parseHashUpdate = exports.parseMessage = exports.parseStateInit = exports.parseRawTickTock = exports.parseCommonMsgInfo = exports.parseCurrencyCollection = exports.parseAccountStatus = void 0;\nvar __1 = require(\"..\");\nvar parseDict_1 = require(\"../boc/dict/parseDict\");\nfunction parseAccountStatus(slice) {\n  var status = slice.readUintNumber(2);\n  if (status === 0x00) {\n    return 'uninitialized';\n  }\n  if (status === 0x01) {\n    return 'frozen';\n  }\n  if (status === 0x02) {\n    return 'active';\n  }\n  if (status === 0x03) {\n    return 'non-existing';\n  }\n  throw Error('Invalid data');\n}\nexports.parseAccountStatus = parseAccountStatus;\nfunction parseCurrencyCollection(slice) {\n  var coins = slice.readCoins();\n  // Read extra currencies\n  var extraCurrencies = null;\n  if (slice.readBit()) {\n    var dc = slice.readCell();\n    if (!dc.isExotic) {\n      var pd = (0, parseDict_1.parseDict)(dc.beginParse(), 32, function (s) {\n        return s.readVarUIntNumber(5);\n      });\n      extraCurrencies = new Map();\n      var _iterator = _createForOfIteratorHelper(pd),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var e = _step.value;\n          extraCurrencies.set(parseInt(e[0], 10), e[1]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  return {\n    extraCurrencies: extraCurrencies,\n    coins: coins\n  };\n}\nexports.parseCurrencyCollection = parseCurrencyCollection;\nfunction parseCommonMsgInfo(slice) {\n  if (!slice.readBit()) {\n    // Internal\n    var ihrDisabled = slice.readBit();\n    var bounce = slice.readBit();\n    var bounced = slice.readBit();\n    var src = slice.readAddress();\n    var dest = slice.readAddress();\n    var value = parseCurrencyCollection(slice);\n    var ihrFee = slice.readCoins();\n    var fwdFee = slice.readCoins();\n    var createdLt = slice.readUint(64);\n    var createdAt = slice.readUintNumber(32);\n    return {\n      type: 'internal',\n      ihrDisabled: ihrDisabled,\n      bounce: bounce,\n      bounced: bounced,\n      src: src,\n      dest: dest,\n      value: value,\n      ihrFee: ihrFee,\n      fwdFee: fwdFee,\n      createdLt: createdLt,\n      createdAt: createdAt\n    };\n  } else if (slice.readBit()) {\n    // Outgoing external\n    var _src = slice.readAddress();\n    var _dest = slice.readAddress();\n    var _createdLt = slice.readUint(64);\n    var _createdAt = slice.readUintNumber(32);\n    return {\n      type: 'external-out',\n      src: _src,\n      dest: _dest,\n      createdLt: _createdLt,\n      createdAt: _createdAt\n    };\n  } else {\n    // Incoming external\n    var _src2 = slice.readAddress();\n    var _dest2 = slice.readAddress();\n    var importFee = slice.readCoins();\n    return {\n      type: 'external-in',\n      src: _src2,\n      dest: _dest2,\n      importFee: importFee\n    };\n  }\n}\nexports.parseCommonMsgInfo = parseCommonMsgInfo;\nfunction parseRawTickTock(slice) {\n  return {\n    tick: slice.readBit(),\n    tock: slice.readBit()\n  };\n}\nexports.parseRawTickTock = parseRawTickTock;\nfunction parseStateInit(slice) {\n  var raw = slice.toCell();\n  var splitDepth = null;\n  if (slice.readBit()) {\n    splitDepth = slice.readUintNumber(5);\n  }\n  var special = slice.readBit() ? parseRawTickTock(slice) : null;\n  var hasCode = slice.readBit();\n  var code = hasCode ? slice.readCell() : null;\n  var hasData = slice.readBit();\n  var data = hasData ? slice.readCell() : null;\n  if (slice.readBit()) {\n    slice.readCell(); // Skip libraries for now\n  }\n\n  return {\n    splitDepth: splitDepth,\n    data: data,\n    code: code,\n    special: special,\n    raw: raw\n  };\n}\nexports.parseStateInit = parseStateInit;\nfunction parseMessage(slice) {\n  var raw = slice.toCell();\n  var info = parseCommonMsgInfo(slice);\n  var hasInit = slice.readBit();\n  var init = null;\n  if (hasInit) {\n    if (!slice.readBit()) {\n      init = parseStateInit(slice);\n    } else {\n      init = parseStateInit(slice.readRef());\n    }\n  }\n  var body = slice.readBit() ? slice.readRef().toCell() : slice.toCell();\n  return {\n    info: info,\n    init: init,\n    body: body,\n    raw: raw\n  };\n}\nexports.parseMessage = parseMessage;\nfunction parseHashUpdate(slice) {\n  if (slice.readUintNumber(8) !== 0x72) {\n    throw Error('Invalid data');\n  }\n  var oldHash = slice.readBuffer(32);\n  var newHash = slice.readBuffer(32);\n  return {\n    oldHash: oldHash,\n    newHash: newHash\n  };\n}\nexports.parseHashUpdate = parseHashUpdate;\nfunction parseAccountChange(slice) {\n  if (!slice.readBit()) {\n    return 'unchanged';\n  }\n  if (slice.readBit()) {\n    return 'frozen';\n  } else {\n    return 'deleted';\n  }\n}\nexports.parseAccountChange = parseAccountChange;\nfunction parseStorageUsedShort(slice) {\n  return {\n    cells: slice.readVarUIntNumber(3),\n    bits: slice.readVarUIntNumber(3)\n  };\n}\nexports.parseStorageUsedShort = parseStorageUsedShort;\nfunction parseStoragePhase(slice) {\n  var storageFeesCollected = slice.readCoins();\n  var storageFeesDue = null;\n  if (slice.readBit()) {\n    storageFeesDue = slice.readCoins();\n  }\n  var statusChange = parseAccountChange(slice);\n  return {\n    storageFeesCollected: storageFeesCollected,\n    storageFeesDue: storageFeesDue,\n    statusChange: statusChange\n  };\n}\nexports.parseStoragePhase = parseStoragePhase;\nfunction parseCreditPhase(slice) {\n  var dueFeesColelcted = slice.readBit() ? slice.readCoins() : null;\n  var credit = parseCurrencyCollection(slice);\n  return {\n    dueFeesColelcted: dueFeesColelcted,\n    credit: credit\n  };\n}\nexports.parseCreditPhase = parseCreditPhase;\nfunction parseComputePhase(slice) {\n  if (!slice.readBit()) {\n    var skipReason = slice.readUintNumber(2);\n    if (skipReason === 0x00) {\n      return {\n        type: 'skipped',\n        reason: 'no-state'\n      };\n    }\n    if (skipReason === 0x01) {\n      return {\n        type: 'skipped',\n        reason: 'bad-state'\n      };\n    }\n    if (skipReason === 0x02) {\n      return {\n        type: 'skipped',\n        reason: 'no-gas'\n      };\n    }\n  }\n  var success = slice.readBit();\n  var messageStateUsed = slice.readBit();\n  var accountActivated = slice.readBit();\n  var gasFees = slice.readCoins();\n  var vmState = slice.readRef();\n  var gasUsed = vmState.readVarUInt(3);\n  var gasLimit = vmState.readVarUInt(3);\n  var gasCredit = vmState.readBit() ? vmState.readVarUInt(2) : null;\n  var mode = vmState.readUintNumber(8);\n  var exitCode = vmState.readUintNumber(32);\n  var exitArg = vmState.readBit() ? vmState.readUintNumber(32) : null; // TODO: change to int\n  var vmSteps = vmState.readUintNumber(32);\n  var vmInitStateHash = vmState.readBuffer(32);\n  var vmFinalStateHash = vmState.readBuffer(32);\n  return {\n    type: 'computed',\n    success: success,\n    messageStateUsed: messageStateUsed,\n    accountActivated: accountActivated,\n    gasFees: gasFees,\n    gasUsed: gasUsed,\n    gasLimit: gasLimit,\n    gasCredit: gasCredit,\n    mode: mode,\n    exitCode: exitCode,\n    exitArg: exitArg,\n    vmSteps: vmSteps,\n    vmInitStateHash: vmInitStateHash,\n    vmFinalStateHash: vmFinalStateHash\n  };\n}\nexports.parseComputePhase = parseComputePhase;\nfunction parseActionPhase(slice) {\n  var success = slice.readBit();\n  var valid = slice.readBit();\n  var noFunds = slice.readBit();\n  var statusChange = parseAccountChange(slice);\n  var totalFwdFees = slice.readBit() ? slice.readCoins() : null;\n  var totalActionFees = slice.readBit() ? slice.readCoins() : null;\n  var resultCode = slice.readUintNumber(32); // TODO: Change to int32\n  var resultArg = slice.readBit() ? slice.readUintNumber(32) : null; // TODO: Change to int32\n  var totalActions = slice.readUintNumber(16);\n  var specialActions = slice.readUintNumber(16);\n  var skippedActions = slice.readUintNumber(16);\n  var messagesCreated = slice.readUintNumber(16);\n  var actionListHash = slice.readBuffer(32);\n  var totalMessageSizes = parseStorageUsedShort(slice);\n  return {\n    success: success,\n    valid: valid,\n    noFunds: noFunds,\n    statusChange: statusChange,\n    totalFwdFees: totalFwdFees,\n    totalActionFees: totalActionFees,\n    resultCode: resultCode,\n    resultArg: resultArg,\n    totalActions: totalActions,\n    specialActions: specialActions,\n    skippedActions: skippedActions,\n    messagesCreated: messagesCreated,\n    actionListHash: actionListHash,\n    totalMessageSizes: totalMessageSizes\n  };\n}\nexports.parseActionPhase = parseActionPhase;\nfunction parseBouncePhase(slice) {\n  // Is OK\n  if (slice.readBit()) {\n    var msgSize = parseStorageUsedShort(slice);\n    var msgFees = slice.readCoins();\n    var fwdFees = slice.readCoins();\n    return {\n      type: 'ok',\n      msgSize: msgSize,\n      msgFees: msgFees,\n      fwdFees: fwdFees\n    };\n  }\n  // No funds\n  if (slice.readBit()) {\n    var _msgSize = parseStorageUsedShort(slice);\n    var _fwdFees = slice.readCoins();\n    return {\n      type: 'no-funds',\n      msgSize: _msgSize,\n      fwdFees: _fwdFees\n    };\n  }\n  return {\n    type: 'negative-funds'\n  };\n}\nexports.parseBouncePhase = parseBouncePhase;\nfunction parseTransactionDescription(slice) {\n  var type = slice.readUintNumber(4);\n  if (type === 0x00) {\n    var creditFirst = slice.readBit();\n    var storagePhase = null;\n    var creditPhase = null;\n    if (slice.readBit()) {\n      storagePhase = parseStoragePhase(slice);\n    }\n    if (slice.readBit()) {\n      creditPhase = parseCreditPhase(slice);\n    }\n    var computePhase = parseComputePhase(slice);\n    var actionPhase = null;\n    if (slice.readBit()) {\n      actionPhase = parseActionPhase(slice.readRef());\n    }\n    var aborted = slice.readBit();\n    var bouncePhase = null;\n    if (slice.readBit()) {\n      bouncePhase = parseBouncePhase(slice);\n    }\n    var destroyed = slice.readBit();\n    return {\n      type: 'generic',\n      creditFirst: creditFirst,\n      storagePhase: storagePhase,\n      creditPhase: creditPhase,\n      computePhase: computePhase,\n      actionPhase: actionPhase,\n      bouncePhase: bouncePhase,\n      aborted: aborted,\n      destroyed: destroyed\n    };\n  }\n  if (type === 0x01) {\n    var _storagePhase = parseStoragePhase(slice);\n    return {\n      type: 'storage',\n      storagePhase: _storagePhase\n    };\n  }\n  if (type === 0x2 || type === 0x03) {\n    var isTock = type === 0x03;\n    var _storagePhase2 = parseStoragePhase(slice);\n    var _computePhase = parseComputePhase(slice);\n    var _actionPhase = null;\n    if (slice.readBit()) {\n      _actionPhase = parseActionPhase(slice.readRef());\n    }\n    var _aborted = slice.readBit();\n    var _destroyed = slice.readBit();\n    return {\n      type: 'tick-tock',\n      isTock: isTock,\n      storagePhase: _storagePhase2,\n      computePhase: _computePhase,\n      actionPhase: _actionPhase,\n      aborted: _aborted,\n      destroyed: _destroyed\n    };\n  }\n  throw Error('Unsupported transaction type');\n}\nexports.parseTransactionDescription = parseTransactionDescription;\nfunction parseTransaction(workchain, slice) {\n  if (slice.readUintNumber(4) !== 0x07) {\n    throw Error('Invalid data');\n  }\n  // Read address\n  var addressHash = slice.readBuffer(32);\n  var address = new __1.Address(workchain, addressHash);\n  // Read lt\n  var lt = slice.readUint(64);\n  // Read prevTrans\n  var prevTransHash = slice.readBuffer(32);\n  var prevTransLt = slice.readUint(64);\n  // Read time\n  var time = slice.readUintNumber(32);\n  // Output messages\n  var outMessagesCount = slice.readUintNumber(15);\n  // Status\n  var oldStatus = parseAccountStatus(slice);\n  var newStatus = parseAccountStatus(slice);\n  // Messages ref\n  var messages = slice.readRef();\n  var hasInMessage = messages.readBit();\n  var hasOutMessages = messages.readBit();\n  var inMessage = null;\n  if (hasInMessage) {\n    inMessage = parseMessage(messages.readRef());\n  }\n  var outMessages = [];\n  if (hasOutMessages) {\n    var dict = messages.readDict(15, function (slice) {\n      return parseMessage(slice.readRef());\n    });\n    for (var _i = 0, _Array$from = Array.from(dict.values()); _i < _Array$from.length; _i++) {\n      var msg = _Array$from[_i];\n      outMessages.push(msg);\n    }\n  }\n  // Currency collections\n  var fees = parseCurrencyCollection(slice);\n  // Hash update\n  var update = parseHashUpdate(slice.readRef());\n  // Description\n  var description = parseTransactionDescription(slice.readRef());\n  return {\n    address: address,\n    lt: lt,\n    time: time,\n    outMessagesCount: outMessagesCount,\n    oldStatus: oldStatus,\n    newStatus: newStatus,\n    fees: fees,\n    update: update,\n    description: description,\n    inMessage: inMessage,\n    outMessages: outMessages,\n    prevTransaction: {\n      hash: prevTransHash,\n      lt: prevTransLt\n    }\n  };\n}\nexports.parseTransaction = parseTransaction;\nfunction parseStorageUsed(cs) {\n  return {\n    cells: cs.readVarUIntNumber(3),\n    bits: cs.readVarUIntNumber(3),\n    publicCells: cs.readVarUIntNumber(3)\n  };\n}\nexports.parseStorageUsed = parseStorageUsed;\nfunction parseStorageInfo(cs) {\n  return {\n    used: parseStorageUsed(cs),\n    lastPaid: cs.readUintNumber(32),\n    duePayment: cs.readBit() ? cs.readCoins() : null\n  };\n}\nexports.parseStorageInfo = parseStorageInfo;\nfunction parseAccountState(cs) {\n  if (cs.readBit()) {\n    return {\n      type: 'active',\n      state: parseStateInit(cs)\n    };\n  } else if (cs.readBit()) {\n    return {\n      type: 'frozen',\n      stateHash: cs.readBuffer(32)\n    };\n  } else {\n    return {\n      type: 'uninit'\n    };\n  }\n}\nexports.parseAccountState = parseAccountState;\nfunction parseAccountStorage(cs) {\n  return {\n    lastTransLt: cs.readUint(64),\n    balance: parseCurrencyCollection(cs),\n    state: parseAccountState(cs)\n  };\n}\nexports.parseAccountStorage = parseAccountStorage;\nfunction parseAccount(cs) {\n  if (cs.readBit()) {\n    return {\n      address: cs.readAddress(),\n      storageStat: parseStorageInfo(cs),\n      storage: parseAccountStorage(cs)\n    };\n  } else {\n    return null;\n  }\n}\nexports.parseAccount = parseAccount;\nfunction parseShardIdent(cs) {\n  if (cs.readUintNumber(2) !== 0) {\n    throw Error('Invalid data');\n  }\n  var shardPrefixBits = cs.readUintNumber(6);\n  var workchainId = cs.readIntNumber(32);\n  var shardPrefix = cs.readUint(64);\n  return {\n    shardPrefixBits: shardPrefixBits,\n    workchainId: workchainId,\n    shardPrefix: shardPrefix\n  };\n}\nexports.parseShardIdent = parseShardIdent;\nfunction parseShardAccount(cs) {\n  var accountCell = cs.readCell();\n  var address = null;\n  if (!accountCell.isExotic) {\n    address = accountCell.beginParse().readAddress();\n  }\n  return {\n    address: address,\n    lastTransHash: cs.readBuffer(32),\n    lastTransLt: cs.readUint(64)\n  };\n}\nexports.parseShardAccount = parseShardAccount;\nfunction parseDepthBalanceInfo(cs) {\n  return {\n    splitDepth: cs.readUintNumber(5),\n    balance: parseCurrencyCollection(cs)\n  };\n}\nexports.parseDepthBalanceInfo = parseDepthBalanceInfo;\nfunction parseShardAccounts(cs) {\n  if (!cs.readBit()) {\n    return new Map();\n  }\n  return (0, parseDict_1.parseDict)(cs.readRef(), 256, function (cs2) {\n    var depthBalanceInfo = parseDepthBalanceInfo(cs2);\n    var shardAccount = parseShardAccount(cs2);\n    return {\n      depthBalanceInfo: depthBalanceInfo,\n      shardAccount: shardAccount\n    };\n  });\n}\nexports.parseShardAccounts = parseShardAccounts;\nfunction parseMasterchainStateExtra(cs) {\n  // Check magic\n  if (cs.readUintNumber(16) !== 0xcc26) {\n    throw Error('Invalid data');\n  }\n  // Skip shard_hashes\n  if (cs.readBit()) {\n    cs.readCell();\n  }\n  // Read config\n  var configAddress = new __1.Address(-1, cs.readBuffer(32));\n  var config = cs.readCell();\n  // Rad global balance\n  var globalBalance = parseCurrencyCollection(cs);\n  return {\n    config: config,\n    configAddress: configAddress,\n    globalBalance: globalBalance\n  };\n}\nexports.parseMasterchainStateExtra = parseMasterchainStateExtra;\nfunction parseShardStateUnsplit(cs) {\n  if (cs.readUintNumber(32) !== 0x9023afe2) {\n    throw Error('Invalid data');\n  }\n  var globalId = cs.readIntNumber(32);\n  var shardId = parseShardIdent(cs);\n  var seqno = cs.readUintNumber(32);\n  var vertSeqNo = cs.readUintNumber(32);\n  var genUtime = cs.readUintNumber(32);\n  var genLt = cs.readUint(64);\n  var minRefSeqno = cs.readUintNumber(32);\n  // Skip OutMsgQueueInfo: usually exotic\n  cs.readCell();\n  var beforeSplit = cs.readBit();\n  // Parse accounts\n  var accounts;\n  var accountsCell = cs.readCell();\n  if (accountsCell.isExotic) {\n    accounts = new Map();\n  } else {\n    accounts = parseShardAccounts(accountsCell.beginParse());\n  }\n  // Skip (not used by apps)\n  cs.readCell();\n  // Parse extras\n  var mcStateExtra = cs.readBit();\n  var extras = null;\n  if (mcStateExtra) {\n    var cell = cs.readCell();\n    if (!cell.isExotic) {\n      extras = parseMasterchainStateExtra(cell.beginParse());\n    }\n  }\n  ;\n  return {\n    globalId: globalId,\n    shardId: shardId,\n    seqno: seqno,\n    vertSeqNo: vertSeqNo,\n    genUtime: genUtime,\n    genLt: genLt,\n    minRefSeqno: minRefSeqno,\n    beforeSplit: beforeSplit,\n    accounts: accounts,\n    extras: extras\n  };\n}\nexports.parseShardStateUnsplit = parseShardStateUnsplit;","map":{"version":3,"names":["Object","defineProperty","exports","value","parseShardStateUnsplit","parseMasterchainStateExtra","parseShardAccounts","parseDepthBalanceInfo","parseShardAccount","parseShardIdent","parseAccount","parseAccountStorage","parseAccountState","parseStorageInfo","parseStorageUsed","parseTransaction","parseTransactionDescription","parseBouncePhase","parseActionPhase","parseComputePhase","parseCreditPhase","parseStoragePhase","parseStorageUsedShort","parseAccountChange","parseHashUpdate","parseMessage","parseStateInit","parseRawTickTock","parseCommonMsgInfo","parseCurrencyCollection","parseAccountStatus","__1","require","parseDict_1","slice","status","readUintNumber","Error","coins","readCoins","extraCurrencies","readBit","dc","readCell","isExotic","pd","parseDict","beginParse","s","readVarUIntNumber","Map","e","set","parseInt","ihrDisabled","bounce","bounced","src","readAddress","dest","ihrFee","fwdFee","createdLt","readUint","createdAt","type","importFee","tick","tock","raw","toCell","splitDepth","special","hasCode","code","hasData","data","info","hasInit","init","readRef","body","oldHash","readBuffer","newHash","cells","bits","storageFeesCollected","storageFeesDue","statusChange","dueFeesColelcted","credit","skipReason","reason","success","messageStateUsed","accountActivated","gasFees","vmState","gasUsed","readVarUInt","gasLimit","gasCredit","mode","exitCode","exitArg","vmSteps","vmInitStateHash","vmFinalStateHash","valid","noFunds","totalFwdFees","totalActionFees","resultCode","resultArg","totalActions","specialActions","skippedActions","messagesCreated","actionListHash","totalMessageSizes","msgSize","msgFees","fwdFees","creditFirst","storagePhase","creditPhase","computePhase","actionPhase","aborted","bouncePhase","destroyed","isTock","workchain","addressHash","address","Address","lt","prevTransHash","prevTransLt","time","outMessagesCount","oldStatus","newStatus","messages","hasInMessage","hasOutMessages","inMessage","outMessages","dict","readDict","Array","from","values","msg","push","fees","update","description","prevTransaction","hash","cs","publicCells","used","lastPaid","duePayment","state","stateHash","lastTransLt","balance","storageStat","storage","shardPrefixBits","workchainId","readIntNumber","shardPrefix","accountCell","lastTransHash","cs2","depthBalanceInfo","shardAccount","configAddress","config","globalBalance","globalId","shardId","seqno","vertSeqNo","genUtime","genLt","minRefSeqno","beforeSplit","accounts","accountsCell","mcStateExtra","extras","cell"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/block/parse.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseShardStateUnsplit = exports.parseMasterchainStateExtra = exports.parseShardAccounts = exports.parseDepthBalanceInfo = exports.parseShardAccount = exports.parseShardIdent = exports.parseAccount = exports.parseAccountStorage = exports.parseAccountState = exports.parseStorageInfo = exports.parseStorageUsed = exports.parseTransaction = exports.parseTransactionDescription = exports.parseBouncePhase = exports.parseActionPhase = exports.parseComputePhase = exports.parseCreditPhase = exports.parseStoragePhase = exports.parseStorageUsedShort = exports.parseAccountChange = exports.parseHashUpdate = exports.parseMessage = exports.parseStateInit = exports.parseRawTickTock = exports.parseCommonMsgInfo = exports.parseCurrencyCollection = exports.parseAccountStatus = void 0;\nconst __1 = require(\"..\");\nconst parseDict_1 = require(\"../boc/dict/parseDict\");\nfunction parseAccountStatus(slice) {\n    const status = slice.readUintNumber(2);\n    if (status === 0x00) {\n        return 'uninitialized';\n    }\n    if (status === 0x01) {\n        return 'frozen';\n    }\n    if (status === 0x02) {\n        return 'active';\n    }\n    if (status === 0x03) {\n        return 'non-existing';\n    }\n    throw Error('Invalid data');\n}\nexports.parseAccountStatus = parseAccountStatus;\nfunction parseCurrencyCollection(slice) {\n    const coins = slice.readCoins();\n    // Read extra currencies\n    let extraCurrencies = null;\n    if (slice.readBit()) {\n        let dc = slice.readCell();\n        if (!dc.isExotic) {\n            let pd = (0, parseDict_1.parseDict)(dc.beginParse(), 32, (s) => s.readVarUIntNumber(5));\n            extraCurrencies = new Map();\n            for (let e of pd) {\n                extraCurrencies.set(parseInt(e[0], 10), e[1]);\n            }\n        }\n    }\n    return { extraCurrencies, coins };\n}\nexports.parseCurrencyCollection = parseCurrencyCollection;\nfunction parseCommonMsgInfo(slice) {\n    if (!slice.readBit()) {\n        // Internal\n        let ihrDisabled = slice.readBit();\n        let bounce = slice.readBit();\n        let bounced = slice.readBit();\n        let src = slice.readAddress();\n        let dest = slice.readAddress();\n        let value = parseCurrencyCollection(slice);\n        let ihrFee = slice.readCoins();\n        let fwdFee = slice.readCoins();\n        let createdLt = slice.readUint(64);\n        let createdAt = slice.readUintNumber(32);\n        return {\n            type: 'internal',\n            ihrDisabled,\n            bounce,\n            bounced,\n            src,\n            dest,\n            value,\n            ihrFee,\n            fwdFee,\n            createdLt,\n            createdAt\n        };\n    }\n    else if (slice.readBit()) {\n        // Outgoing external\n        let src = slice.readAddress();\n        let dest = slice.readAddress();\n        let createdLt = slice.readUint(64);\n        let createdAt = slice.readUintNumber(32);\n        return {\n            type: 'external-out',\n            src,\n            dest,\n            createdLt,\n            createdAt\n        };\n    }\n    else {\n        // Incoming external\n        let src = slice.readAddress();\n        let dest = slice.readAddress();\n        let importFee = slice.readCoins();\n        return {\n            type: 'external-in',\n            src,\n            dest,\n            importFee\n        };\n    }\n}\nexports.parseCommonMsgInfo = parseCommonMsgInfo;\nfunction parseRawTickTock(slice) {\n    return {\n        tick: slice.readBit(),\n        tock: slice.readBit()\n    };\n}\nexports.parseRawTickTock = parseRawTickTock;\nfunction parseStateInit(slice) {\n    let raw = slice.toCell();\n    let splitDepth = null;\n    if (slice.readBit()) {\n        splitDepth = slice.readUintNumber(5);\n    }\n    const special = slice.readBit() ? parseRawTickTock(slice) : null;\n    const hasCode = slice.readBit();\n    const code = hasCode ? slice.readCell() : null;\n    const hasData = slice.readBit();\n    const data = hasData ? slice.readCell() : null;\n    if (slice.readBit()) {\n        slice.readCell(); // Skip libraries for now\n    }\n    return { splitDepth, data, code, special, raw };\n}\nexports.parseStateInit = parseStateInit;\nfunction parseMessage(slice) {\n    const raw = slice.toCell();\n    const info = parseCommonMsgInfo(slice);\n    const hasInit = slice.readBit();\n    let init = null;\n    if (hasInit) {\n        if (!slice.readBit()) {\n            init = parseStateInit(slice);\n        }\n        else {\n            init = parseStateInit(slice.readRef());\n        }\n    }\n    const body = slice.readBit() ? slice.readRef().toCell() : slice.toCell();\n    return {\n        info,\n        init,\n        body,\n        raw\n    };\n}\nexports.parseMessage = parseMessage;\nfunction parseHashUpdate(slice) {\n    if (slice.readUintNumber(8) !== 0x72) {\n        throw Error('Invalid data');\n    }\n    const oldHash = slice.readBuffer(32);\n    const newHash = slice.readBuffer(32);\n    return { oldHash, newHash };\n}\nexports.parseHashUpdate = parseHashUpdate;\nfunction parseAccountChange(slice) {\n    if (!slice.readBit()) {\n        return 'unchanged';\n    }\n    if (slice.readBit()) {\n        return 'frozen';\n    }\n    else {\n        return 'deleted';\n    }\n}\nexports.parseAccountChange = parseAccountChange;\nfunction parseStorageUsedShort(slice) {\n    return {\n        cells: slice.readVarUIntNumber(3),\n        bits: slice.readVarUIntNumber(3)\n    };\n}\nexports.parseStorageUsedShort = parseStorageUsedShort;\nfunction parseStoragePhase(slice) {\n    const storageFeesCollected = slice.readCoins();\n    let storageFeesDue = null;\n    if (slice.readBit()) {\n        storageFeesDue = slice.readCoins();\n    }\n    const statusChange = parseAccountChange(slice);\n    return {\n        storageFeesCollected,\n        storageFeesDue,\n        statusChange\n    };\n}\nexports.parseStoragePhase = parseStoragePhase;\nfunction parseCreditPhase(slice) {\n    let dueFeesColelcted = slice.readBit() ? slice.readCoins() : null;\n    const credit = parseCurrencyCollection(slice);\n    return {\n        dueFeesColelcted,\n        credit\n    };\n}\nexports.parseCreditPhase = parseCreditPhase;\nfunction parseComputePhase(slice) {\n    if (!slice.readBit()) {\n        const skipReason = slice.readUintNumber(2);\n        if (skipReason === 0x00) {\n            return {\n                type: 'skipped',\n                reason: 'no-state'\n            };\n        }\n        if (skipReason === 0x01) {\n            return {\n                type: 'skipped',\n                reason: 'bad-state'\n            };\n        }\n        if (skipReason === 0x02) {\n            return {\n                type: 'skipped',\n                reason: 'no-gas'\n            };\n        }\n    }\n    const success = slice.readBit();\n    const messageStateUsed = slice.readBit();\n    const accountActivated = slice.readBit();\n    let gasFees = slice.readCoins();\n    const vmState = slice.readRef();\n    let gasUsed = vmState.readVarUInt(3);\n    let gasLimit = vmState.readVarUInt(3);\n    let gasCredit = vmState.readBit() ? vmState.readVarUInt(2) : null;\n    let mode = vmState.readUintNumber(8);\n    let exitCode = vmState.readUintNumber(32);\n    let exitArg = vmState.readBit() ? vmState.readUintNumber(32) : null; // TODO: change to int\n    let vmSteps = vmState.readUintNumber(32);\n    let vmInitStateHash = vmState.readBuffer(32);\n    let vmFinalStateHash = vmState.readBuffer(32);\n    return {\n        type: 'computed',\n        success,\n        messageStateUsed,\n        accountActivated,\n        gasFees,\n        gasUsed,\n        gasLimit,\n        gasCredit,\n        mode,\n        exitCode,\n        exitArg,\n        vmSteps,\n        vmInitStateHash,\n        vmFinalStateHash\n    };\n}\nexports.parseComputePhase = parseComputePhase;\nfunction parseActionPhase(slice) {\n    const success = slice.readBit();\n    const valid = slice.readBit();\n    const noFunds = slice.readBit();\n    const statusChange = parseAccountChange(slice);\n    const totalFwdFees = slice.readBit() ? slice.readCoins() : null;\n    const totalActionFees = slice.readBit() ? slice.readCoins() : null;\n    const resultCode = slice.readUintNumber(32); // TODO: Change to int32\n    const resultArg = slice.readBit() ? slice.readUintNumber(32) : null; // TODO: Change to int32\n    const totalActions = slice.readUintNumber(16);\n    const specialActions = slice.readUintNumber(16);\n    const skippedActions = slice.readUintNumber(16);\n    const messagesCreated = slice.readUintNumber(16);\n    const actionListHash = slice.readBuffer(32);\n    const totalMessageSizes = parseStorageUsedShort(slice);\n    return {\n        success,\n        valid,\n        noFunds,\n        statusChange,\n        totalFwdFees,\n        totalActionFees,\n        resultCode,\n        resultArg,\n        totalActions,\n        specialActions,\n        skippedActions,\n        messagesCreated,\n        actionListHash,\n        totalMessageSizes\n    };\n}\nexports.parseActionPhase = parseActionPhase;\nfunction parseBouncePhase(slice) {\n    // Is OK\n    if (slice.readBit()) {\n        const msgSize = parseStorageUsedShort(slice);\n        const msgFees = slice.readCoins();\n        const fwdFees = slice.readCoins();\n        return {\n            type: 'ok',\n            msgSize,\n            msgFees,\n            fwdFees\n        };\n    }\n    // No funds\n    if (slice.readBit()) {\n        const msgSize = parseStorageUsedShort(slice);\n        const fwdFees = slice.readCoins();\n        return {\n            type: 'no-funds',\n            msgSize,\n            fwdFees\n        };\n    }\n    return {\n        type: 'negative-funds'\n    };\n}\nexports.parseBouncePhase = parseBouncePhase;\nfunction parseTransactionDescription(slice) {\n    const type = slice.readUintNumber(4);\n    if (type === 0x00) {\n        const creditFirst = slice.readBit();\n        let storagePhase = null;\n        let creditPhase = null;\n        if (slice.readBit()) {\n            storagePhase = parseStoragePhase(slice);\n        }\n        if (slice.readBit()) {\n            creditPhase = parseCreditPhase(slice);\n        }\n        let computePhase = parseComputePhase(slice);\n        let actionPhase = null;\n        if (slice.readBit()) {\n            actionPhase = parseActionPhase(slice.readRef());\n        }\n        let aborted = slice.readBit();\n        let bouncePhase = null;\n        if (slice.readBit()) {\n            bouncePhase = parseBouncePhase(slice);\n        }\n        const destroyed = slice.readBit();\n        return {\n            type: 'generic',\n            creditFirst,\n            storagePhase,\n            creditPhase,\n            computePhase,\n            actionPhase,\n            bouncePhase,\n            aborted,\n            destroyed\n        };\n    }\n    if (type === 0x01) {\n        let storagePhase = parseStoragePhase(slice);\n        return {\n            type: 'storage',\n            storagePhase\n        };\n    }\n    if (type === 0x2 || type === 0x03) {\n        const isTock = type === 0x03;\n        let storagePhase = parseStoragePhase(slice);\n        let computePhase = parseComputePhase(slice);\n        let actionPhase = null;\n        if (slice.readBit()) {\n            actionPhase = parseActionPhase(slice.readRef());\n        }\n        const aborted = slice.readBit();\n        const destroyed = slice.readBit();\n        return {\n            type: 'tick-tock',\n            isTock,\n            storagePhase,\n            computePhase,\n            actionPhase,\n            aborted,\n            destroyed\n        };\n    }\n    throw Error('Unsupported transaction type');\n}\nexports.parseTransactionDescription = parseTransactionDescription;\nfunction parseTransaction(workchain, slice) {\n    if (slice.readUintNumber(4) !== 0x07) {\n        throw Error('Invalid data');\n    }\n    // Read address\n    const addressHash = slice.readBuffer(32);\n    const address = new __1.Address(workchain, addressHash);\n    // Read lt\n    const lt = slice.readUint(64);\n    // Read prevTrans\n    const prevTransHash = slice.readBuffer(32);\n    const prevTransLt = slice.readUint(64);\n    // Read time\n    const time = slice.readUintNumber(32);\n    // Output messages\n    const outMessagesCount = slice.readUintNumber(15);\n    // Status\n    const oldStatus = parseAccountStatus(slice);\n    const newStatus = parseAccountStatus(slice);\n    // Messages ref\n    const messages = slice.readRef();\n    let hasInMessage = messages.readBit();\n    let hasOutMessages = messages.readBit();\n    let inMessage = null;\n    if (hasInMessage) {\n        inMessage = parseMessage(messages.readRef());\n    }\n    let outMessages = [];\n    if (hasOutMessages) {\n        let dict = messages.readDict(15, (slice) => parseMessage(slice.readRef()));\n        for (let msg of Array.from(dict.values())) {\n            outMessages.push(msg);\n        }\n    }\n    // Currency collections\n    let fees = parseCurrencyCollection(slice);\n    // Hash update\n    let update = parseHashUpdate(slice.readRef());\n    // Description\n    let description = parseTransactionDescription(slice.readRef());\n    return {\n        address,\n        lt,\n        time,\n        outMessagesCount,\n        oldStatus,\n        newStatus,\n        fees,\n        update,\n        description,\n        inMessage,\n        outMessages,\n        prevTransaction: {\n            hash: prevTransHash,\n            lt: prevTransLt\n        }\n    };\n}\nexports.parseTransaction = parseTransaction;\nfunction parseStorageUsed(cs) {\n    return {\n        cells: cs.readVarUIntNumber(3),\n        bits: cs.readVarUIntNumber(3),\n        publicCells: cs.readVarUIntNumber(3),\n    };\n}\nexports.parseStorageUsed = parseStorageUsed;\nfunction parseStorageInfo(cs) {\n    return {\n        used: parseStorageUsed(cs),\n        lastPaid: cs.readUintNumber(32),\n        duePayment: cs.readBit() ? cs.readCoins() : null\n    };\n}\nexports.parseStorageInfo = parseStorageInfo;\nfunction parseAccountState(cs) {\n    if (cs.readBit()) {\n        return { type: 'active', state: parseStateInit(cs) };\n    }\n    else if (cs.readBit()) {\n        return { type: 'frozen', stateHash: cs.readBuffer(32) };\n    }\n    else {\n        return { type: 'uninit' };\n    }\n}\nexports.parseAccountState = parseAccountState;\nfunction parseAccountStorage(cs) {\n    return { lastTransLt: cs.readUint(64), balance: parseCurrencyCollection(cs), state: parseAccountState(cs) };\n}\nexports.parseAccountStorage = parseAccountStorage;\nfunction parseAccount(cs) {\n    if (cs.readBit()) {\n        return {\n            address: cs.readAddress(),\n            storageStat: parseStorageInfo(cs),\n            storage: parseAccountStorage(cs)\n        };\n    }\n    else {\n        return null;\n    }\n}\nexports.parseAccount = parseAccount;\nfunction parseShardIdent(cs) {\n    if (cs.readUintNumber(2) !== 0) {\n        throw Error('Invalid data');\n    }\n    let shardPrefixBits = cs.readUintNumber(6);\n    let workchainId = cs.readIntNumber(32);\n    let shardPrefix = cs.readUint(64);\n    return {\n        shardPrefixBits,\n        workchainId,\n        shardPrefix\n    };\n}\nexports.parseShardIdent = parseShardIdent;\nfunction parseShardAccount(cs) {\n    let accountCell = cs.readCell();\n    let address = null;\n    if (!accountCell.isExotic) {\n        address = accountCell.beginParse().readAddress();\n    }\n    return {\n        address,\n        lastTransHash: cs.readBuffer(32),\n        lastTransLt: cs.readUint(64)\n    };\n}\nexports.parseShardAccount = parseShardAccount;\nfunction parseDepthBalanceInfo(cs) {\n    return {\n        splitDepth: cs.readUintNumber(5),\n        balance: parseCurrencyCollection(cs)\n    };\n}\nexports.parseDepthBalanceInfo = parseDepthBalanceInfo;\nfunction parseShardAccounts(cs) {\n    if (!cs.readBit()) {\n        return new Map();\n    }\n    return (0, parseDict_1.parseDict)(cs.readRef(), 256, (cs2) => {\n        let depthBalanceInfo = parseDepthBalanceInfo(cs2);\n        let shardAccount = parseShardAccount(cs2);\n        return {\n            depthBalanceInfo,\n            shardAccount\n        };\n    });\n}\nexports.parseShardAccounts = parseShardAccounts;\nfunction parseMasterchainStateExtra(cs) {\n    // Check magic\n    if (cs.readUintNumber(16) !== 0xcc26) {\n        throw Error('Invalid data');\n    }\n    // Skip shard_hashes\n    if (cs.readBit()) {\n        cs.readCell();\n    }\n    // Read config\n    let configAddress = new __1.Address(-1, cs.readBuffer(32));\n    let config = cs.readCell();\n    // Rad global balance\n    const globalBalance = parseCurrencyCollection(cs);\n    return {\n        config,\n        configAddress,\n        globalBalance\n    };\n}\nexports.parseMasterchainStateExtra = parseMasterchainStateExtra;\nfunction parseShardStateUnsplit(cs) {\n    if (cs.readUintNumber(32) !== 0x9023afe2) {\n        throw Error('Invalid data');\n    }\n    let globalId = cs.readIntNumber(32);\n    let shardId = parseShardIdent(cs);\n    let seqno = cs.readUintNumber(32);\n    let vertSeqNo = cs.readUintNumber(32);\n    let genUtime = cs.readUintNumber(32);\n    let genLt = cs.readUint(64);\n    let minRefSeqno = cs.readUintNumber(32);\n    // Skip OutMsgQueueInfo: usually exotic\n    cs.readCell();\n    let beforeSplit = cs.readBit();\n    // Parse accounts\n    let accounts;\n    let accountsCell = cs.readCell();\n    if (accountsCell.isExotic) {\n        accounts = new Map();\n    }\n    else {\n        accounts = parseShardAccounts(accountsCell.beginParse());\n    }\n    // Skip (not used by apps)\n    cs.readCell();\n    // Parse extras\n    let mcStateExtra = cs.readBit();\n    let extras = null;\n    if (mcStateExtra) {\n        let cell = cs.readCell();\n        if (!cell.isExotic) {\n            extras = parseMasterchainStateExtra(cell.beginParse());\n        }\n    }\n    ;\n    return {\n        globalId,\n        shardId,\n        seqno,\n        vertSeqNo,\n        genUtime,\n        genLt,\n        minRefSeqno,\n        beforeSplit,\n        accounts,\n        extras\n    };\n}\nexports.parseShardStateUnsplit = parseShardStateUnsplit;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}