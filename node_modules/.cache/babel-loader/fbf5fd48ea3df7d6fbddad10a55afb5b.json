{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReconnectingSocket = void 0;\nvar xstream_1 = require(\"xstream\");\nvar queueingstreamingsocket_1 = require(\"./queueingstreamingsocket\");\n/**\n * A wrapper around QueueingStreamingSocket that reconnects automatically.\n */\nvar ReconnectingSocket = /*#__PURE__*/function () {\n  function ReconnectingSocket(url) {\n    var _this = this;\n    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    var reconnectedHandler = arguments.length > 2 ? arguments[2] : undefined;\n    _classCallCheck(this, ReconnectingSocket);\n    this.unconnected = true;\n    this.disconnected = false;\n    this.timeoutIndex = 0;\n    this.reconnectTimeout = null;\n    var eventProducer = {\n      start: function start(listener) {\n        return _this.eventProducerListener = listener;\n      },\n      stop: function stop() {\n        return _this.eventProducerListener = undefined;\n      }\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n    this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);\n    this.socket.events.subscribe({\n      next: function next(event) {\n        if (_this.eventProducerListener) {\n          _this.eventProducerListener.next(event);\n        }\n      },\n      error: function error(_error) {\n        if (_this.eventProducerListener) {\n          _this.eventProducerListener.error(_error);\n        }\n      }\n    });\n    this.connectionStatus = this.socket.connectionStatus;\n    this.connectionStatus.updates.subscribe({\n      next: function next(status) {\n        if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {\n          _this.timeoutIndex = 0;\n        }\n        if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {\n          if (_this.reconnectTimeout) {\n            clearTimeout(_this.reconnectTimeout);\n            _this.reconnectTimeout = null;\n          }\n          _this.reconnectTimeout = setTimeout(function () {\n            return _this.socket.reconnect();\n          }, ReconnectingSocket.calculateTimeout(_this.timeoutIndex++));\n        }\n      }\n    });\n  }\n  /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */\n  _createClass(ReconnectingSocket, [{\n    key: \"connect\",\n    value: function connect() {\n      if (!this.unconnected) {\n        throw new Error(\"Cannot connect: socket has already connected\");\n      }\n      this.socket.connect();\n      this.unconnected = false;\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this.unconnected) {\n        throw new Error(\"Cannot disconnect: socket has not yet connected\");\n      }\n      this.socket.disconnect();\n      if (this.eventProducerListener) {\n        this.eventProducerListener.complete();\n      }\n      this.disconnected = true;\n    }\n  }, {\n    key: \"queueRequest\",\n    value: function queueRequest(request) {\n      if (this.disconnected) {\n        throw new Error(\"Cannot queue request: socket has disconnected\");\n      }\n      this.socket.queueRequest(request);\n    }\n  }], [{\n    key: \"calculateTimeout\",\n    value: function calculateTimeout(index) {\n      return Math.min(Math.pow(2, index) * 100, 5000);\n    }\n  }]);\n  return ReconnectingSocket;\n}();\nexports.ReconnectingSocket = ReconnectingSocket;","map":{"version":3,"sources":["../src/reconnectingsocket.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReconnectingSocket = void 0;\nconst xstream_1 = require(\"xstream\");\nconst queueingstreamingsocket_1 = require(\"./queueingstreamingsocket\");\n/**\n * A wrapper around QueueingStreamingSocket that reconnects automatically.\n */\nclass ReconnectingSocket {\n    constructor(url, timeout = 10000, reconnectedHandler) {\n        this.unconnected = true;\n        this.disconnected = false;\n        this.timeoutIndex = 0;\n        this.reconnectTimeout = null;\n        const eventProducer = {\n            start: (listener) => (this.eventProducerListener = listener),\n            stop: () => (this.eventProducerListener = undefined),\n        };\n        this.events = xstream_1.Stream.create(eventProducer);\n        this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);\n        this.socket.events.subscribe({\n            next: (event) => {\n                if (this.eventProducerListener) {\n                    this.eventProducerListener.next(event);\n                }\n            },\n            error: (error) => {\n                if (this.eventProducerListener) {\n                    this.eventProducerListener.error(error);\n                }\n            },\n        });\n        this.connectionStatus = this.socket.connectionStatus;\n        this.connectionStatus.updates.subscribe({\n            next: (status) => {\n                if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {\n                    this.timeoutIndex = 0;\n                }\n                if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {\n                    if (this.reconnectTimeout) {\n                        clearTimeout(this.reconnectTimeout);\n                        this.reconnectTimeout = null;\n                    }\n                    this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), ReconnectingSocket.calculateTimeout(this.timeoutIndex++));\n                }\n            },\n        });\n    }\n    /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */\n    static calculateTimeout(index) {\n        return Math.min(2 ** index * 100, 5000);\n    }\n    connect() {\n        if (!this.unconnected) {\n            throw new Error(\"Cannot connect: socket has already connected\");\n        }\n        this.socket.connect();\n        this.unconnected = false;\n    }\n    disconnect() {\n        if (this.unconnected) {\n            throw new Error(\"Cannot disconnect: socket has not yet connected\");\n        }\n        this.socket.disconnect();\n        if (this.eventProducerListener) {\n            this.eventProducerListener.complete();\n        }\n        this.disconnected = true;\n    }\n    queueRequest(request) {\n        if (this.disconnected) {\n            throw new Error(\"Cannot queue request: socket has disconnected\");\n        }\n        this.socket.queueRequest(request);\n    }\n}\nexports.ReconnectingSocket = ReconnectingSocket;\n//# sourceMappingURL=reconnectingsocket.js.map"]},"metadata":{},"sourceType":"script"}