{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ADNLAddress = void 0;\nvar symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\nvar base32_1 = require(\"../utils/base32\");\nvar crc16_1 = require(\"../utils/crc16\");\nvar ADNLAddress = /*#__PURE__*/function () {\n  function ADNLAddress(address) {\n    var _this = this;\n    _classCallCheck(this, ADNLAddress);\n    this.toString = function () {\n      return _this.toFriendly();\n    };\n    this.toRaw = function () {\n      return _this.address.toString('hex').toUpperCase();\n    };\n    this.toFriendly = function () {\n      var data = Buffer.concat([Buffer.from([0x2D]), _this.address]);\n      var hash = (0, crc16_1.crc16)(data);\n      data = Buffer.concat([data, hash]);\n      return (0, base32_1.base32Encode)(data).slice(1);\n    };\n    this[_a] = function () {\n      return _this.toFriendly();\n    };\n    if (address.length !== 32) {\n      throw Error('Invalid address');\n    }\n    this.address = address;\n  }\n  _createClass(ADNLAddress, [{\n    key: \"equals\",\n    value: function equals(b) {\n      return this.address.equals(b.address);\n    }\n  }], [{\n    key: \"parseFriendly\",\n    value: function parseFriendly(src) {\n      if (src.length !== 55) {\n        throw Error('Invalid address');\n      }\n      // Decoding\n      src = 'f' + src;\n      var decoded = (0, base32_1.base32Decode)(src);\n      if (decoded[0] !== 0x2d) {\n        throw Error('Invalid address');\n      }\n      var gotHash = decoded.slice(33);\n      var hash = (0, crc16_1.crc16)(decoded.slice(0, 33));\n      if (!hash.equals(gotHash)) {\n        throw Error('Invalid address');\n      }\n      return new ADNLAddress(decoded.slice(1, 33));\n    }\n  }, {\n    key: \"parseRaw\",\n    value: function parseRaw(src) {\n      var data = Buffer.from(src, 'base64');\n      return new ADNLAddress(data);\n    }\n  }]);\n  return ADNLAddress;\n}();\nexports.ADNLAddress = ADNLAddress;\n_a = symbol_inspect_1.default;","map":{"version":3,"names":["__importDefault","mod","__esModule","_a","Object","defineProperty","exports","value","ADNLAddress","symbol_inspect_1","require","base32_1","crc16_1","address","toString","toFriendly","toRaw","toUpperCase","data","Buffer","concat","from","hash","crc16","base32Encode","slice","length","Error","b","equals","src","decoded","base32Decode","gotHash","default"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/address/ADNLAddress.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ADNLAddress = void 0;\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\nconst base32_1 = require(\"../utils/base32\");\nconst crc16_1 = require(\"../utils/crc16\");\nclass ADNLAddress {\n    constructor(address) {\n        this.toString = () => {\n            return this.toFriendly();\n        };\n        this.toRaw = () => {\n            return this.address.toString('hex').toUpperCase();\n        };\n        this.toFriendly = () => {\n            let data = Buffer.concat([Buffer.from([0x2D]), this.address]);\n            let hash = (0, crc16_1.crc16)(data);\n            data = Buffer.concat([data, hash]);\n            return (0, base32_1.base32Encode)(data).slice(1);\n        };\n        this[_a] = () => this.toFriendly();\n        if (address.length !== 32) {\n            throw Error('Invalid address');\n        }\n        this.address = address;\n    }\n    static parseFriendly(src) {\n        if (src.length !== 55) {\n            throw Error('Invalid address');\n        }\n        // Decoding\n        src = 'f' + src;\n        let decoded = (0, base32_1.base32Decode)(src);\n        if (decoded[0] !== 0x2d) {\n            throw Error('Invalid address');\n        }\n        let gotHash = decoded.slice(33);\n        let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));\n        if (!hash.equals(gotHash)) {\n            throw Error('Invalid address');\n        }\n        return new ADNLAddress(decoded.slice(1, 33));\n    }\n    static parseRaw(src) {\n        const data = Buffer.from(src, 'base64');\n        return new ADNLAddress(data);\n    }\n    equals(b) {\n        return this.address.equals(b.address);\n    }\n}\nexports.ADNLAddress = ADNLAddress;\n_a = symbol_inspect_1.default;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}