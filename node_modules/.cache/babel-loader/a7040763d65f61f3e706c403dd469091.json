{"ast":null,"code":"var randomBytes;\nif (typeof window !== 'undefined' && window.crypto) {\n  randomBytes = function randomBytes(len) {\n    var array = new Uint32Array(len);\n    return Buffer.from(window.crypto.getRandomValues(array));\n  };\n} else {\n  randomBytes = require('crypto').randomBytes;\n}\nvar createHash = require('create-hash');\nvar pbkdf2 = require('pbkdf2').pbkdf2Sync;\nvar ENGLISH_WORDLIST = require('./wordlists/english.json');\nvar DEFAULT_WORDLIST = ENGLISH_WORDLIST;\nvar INVALID_MNEMONIC = 'Invalid mnemonic';\nvar INVALID_ENTROPY = 'Invalid entropy';\nvar INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nfunction lpad(str, padString, length) {\n  while (str.length < length) {\n    str = padString + str;\n  }\n  return str;\n}\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n  return bytes.map(function (x) {\n    return lpad(x.toString(2), '0', 8);\n  }).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n  var ENT = entropyBuffer.length * 8;\n  var CS = ENT / 32;\n  var hash = createHash('sha256').update(entropyBuffer).digest();\n  return bytesToBinary([].slice.call(hash)).slice(0, CS);\n}\nfunction salt(password) {\n  return 'mnemonic' + (password || '');\n}\nfunction mnemonicToSeed(mnemonic, password) {\n  var mnemonicBuffer = Buffer.from(mnemonic, 'utf8');\n  var saltBuffer = Buffer.from(salt(password), 'utf8');\n  return pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\nfunction mnemonicToSeedHex(mnemonic, password) {\n  return mnemonicToSeed(mnemonic, password).toString('hex');\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  wordlist = wordlist || DEFAULT_WORDLIST;\n  var words = mnemonic.split(' ');\n  if (words.length % 3 !== 0) throw new Error(INVALID_MNEMONIC);\n\n  // convert word indices to 11 bit binary strings\n  var bits = words.map(function (word) {\n    var index = wordlist.indexOf(word);\n    if (index === -1) throw new Error(INVALID_MNEMONIC);\n    return lpad(index.toString(2), '0', 11);\n  }).join('');\n\n  // split the binary string into ENT/CS\n  var dividerIndex = Math.floor(bits.length / 33) * 32;\n  var entropyBits = bits.slice(0, dividerIndex);\n  var checksumBits = bits.slice(dividerIndex);\n\n  // calculate the checksum and compare\n  var entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n  if (entropyBytes.length < 16) throw new Error(INVALID_ENTROPY);\n  if (entropyBytes.length > 32) throw new Error(INVALID_ENTROPY);\n  if (entropyBytes.length % 4 !== 0) throw new Error(INVALID_ENTROPY);\n  var entropy = Buffer.from(entropyBytes);\n  var newChecksum = deriveChecksumBits(entropy);\n  if (newChecksum !== checksumBits) throw new Error(INVALID_CHECKSUM);\n  return entropy.toString('hex');\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n  if (!Buffer.isBuffer(entropy)) entropy = Buffer.from(entropy, 'hex');\n  wordlist = wordlist || DEFAULT_WORDLIST;\n\n  // 128 <= ENT <= 256\n  if (entropy.length < 16) throw new TypeError(INVALID_ENTROPY);\n  if (entropy.length > 32) throw new TypeError(INVALID_ENTROPY);\n  if (entropy.length % 4 !== 0) throw new TypeError(INVALID_ENTROPY);\n  var entropyBits = bytesToBinary([].slice.call(entropy));\n  var checksumBits = deriveChecksumBits(entropy);\n  var bits = entropyBits + checksumBits;\n  var chunks = bits.match(/(.{1,11})/g);\n  var words = chunks.map(function (binary) {\n    var index = binaryToByte(binary);\n    return wordlist[index];\n  });\n  return words.join(' ');\n}\nfunction generateMnemonic(strength, rng, wordlist) {\n  strength = strength || 128;\n  if (strength % 32 !== 0) throw new TypeError(INVALID_ENTROPY);\n  rng = rng || randomBytes;\n  return entropyToMnemonic(rng(strength / 8), wordlist);\n}\nfunction validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\nmodule.exports = {\n  mnemonicToSeed: mnemonicToSeed,\n  mnemonicToSeedHex: mnemonicToSeedHex,\n  mnemonicToEntropy: mnemonicToEntropy,\n  entropyToMnemonic: entropyToMnemonic,\n  generateMnemonic: generateMnemonic,\n  validateMnemonic: validateMnemonic,\n  wordlists: {\n    EN: ENGLISH_WORDLIST\n  }\n};","map":{"version":3,"names":["randomBytes","window","crypto","len","array","Uint32Array","Buffer","from","getRandomValues","require","createHash","pbkdf2","pbkdf2Sync","ENGLISH_WORDLIST","DEFAULT_WORDLIST","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","lpad","str","padString","length","binaryToByte","bin","parseInt","bytesToBinary","bytes","map","x","toString","join","deriveChecksumBits","entropyBuffer","ENT","CS","hash","update","digest","slice","call","salt","password","mnemonicToSeed","mnemonic","mnemonicBuffer","saltBuffer","mnemonicToSeedHex","mnemonicToEntropy","wordlist","words","split","Error","bits","word","index","indexOf","dividerIndex","Math","floor","entropyBits","checksumBits","entropyBytes","match","entropy","newChecksum","entropyToMnemonic","isBuffer","TypeError","chunks","binary","generateMnemonic","strength","rng","validateMnemonic","e","module","exports","wordlists","EN"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/bip39-light/index.js"],"sourcesContent":["var randomBytes\nif (typeof window !== 'undefined' && window.crypto) {\n  randomBytes = function (len) {\n    var array = new Uint32Array(len)\n    return Buffer.from(window.crypto.getRandomValues(array))\n  }\n} else {\n  randomBytes = require('crypto').randomBytes\n}\nvar createHash = require('create-hash')\nvar pbkdf2 = require('pbkdf2').pbkdf2Sync\n\nvar ENGLISH_WORDLIST = require('./wordlists/english.json')\nvar DEFAULT_WORDLIST = ENGLISH_WORDLIST\n\nvar INVALID_MNEMONIC = 'Invalid mnemonic'\nvar INVALID_ENTROPY = 'Invalid entropy'\nvar INVALID_CHECKSUM = 'Invalid mnemonic checksum'\n\nfunction lpad (str, padString, length) {\n  while (str.length < length) str = padString + str\n  return str\n}\n\nfunction binaryToByte (bin) {\n  return parseInt(bin, 2)\n}\n\nfunction bytesToBinary (bytes) {\n  return bytes.map(function (x) {\n    return lpad(x.toString(2), '0', 8)\n  }).join('')\n}\n\nfunction deriveChecksumBits (entropyBuffer) {\n  var ENT = entropyBuffer.length * 8\n  var CS = ENT / 32\n  var hash = createHash('sha256').update(entropyBuffer).digest()\n\n  return bytesToBinary([].slice.call(hash)).slice(0, CS)\n}\n\nfunction salt (password) {\n  return 'mnemonic' + (password || '')\n}\n\nfunction mnemonicToSeed (mnemonic, password) {\n  var mnemonicBuffer = Buffer.from(mnemonic, 'utf8')\n  var saltBuffer = Buffer.from(salt(password), 'utf8')\n\n  return pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512')\n}\n\nfunction mnemonicToSeedHex (mnemonic, password) {\n  return mnemonicToSeed(mnemonic, password).toString('hex')\n}\n\nfunction mnemonicToEntropy (mnemonic, wordlist) {\n  wordlist = wordlist || DEFAULT_WORDLIST\n\n  var words = mnemonic.split(' ')\n  if (words.length % 3 !== 0) throw new Error(INVALID_MNEMONIC)\n\n  // convert word indices to 11 bit binary strings\n  var bits = words.map(function (word) {\n    var index = wordlist.indexOf(word)\n    if (index === -1) throw new Error(INVALID_MNEMONIC)\n\n    return lpad(index.toString(2), '0', 11)\n  }).join('')\n\n  // split the binary string into ENT/CS\n  var dividerIndex = Math.floor(bits.length / 33) * 32\n  var entropyBits = bits.slice(0, dividerIndex)\n  var checksumBits = bits.slice(dividerIndex)\n\n  // calculate the checksum and compare\n  var entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte)\n  if (entropyBytes.length < 16) throw new Error(INVALID_ENTROPY)\n  if (entropyBytes.length > 32) throw new Error(INVALID_ENTROPY)\n  if (entropyBytes.length % 4 !== 0) throw new Error(INVALID_ENTROPY)\n\n  var entropy = Buffer.from(entropyBytes)\n  var newChecksum = deriveChecksumBits(entropy)\n  if (newChecksum !== checksumBits) throw new Error(INVALID_CHECKSUM)\n\n  return entropy.toString('hex')\n}\n\nfunction entropyToMnemonic (entropy, wordlist) {\n  if (!Buffer.isBuffer(entropy)) entropy = Buffer.from(entropy, 'hex')\n  wordlist = wordlist || DEFAULT_WORDLIST\n\n  // 128 <= ENT <= 256\n  if (entropy.length < 16) throw new TypeError(INVALID_ENTROPY)\n  if (entropy.length > 32) throw new TypeError(INVALID_ENTROPY)\n  if (entropy.length % 4 !== 0) throw new TypeError(INVALID_ENTROPY)\n\n  var entropyBits = bytesToBinary([].slice.call(entropy))\n  var checksumBits = deriveChecksumBits(entropy)\n\n  var bits = entropyBits + checksumBits\n  var chunks = bits.match(/(.{1,11})/g)\n  var words = chunks.map(function (binary) {\n    var index = binaryToByte(binary)\n    return wordlist[index]\n  })\n\n  return words.join(' ')\n}\n\nfunction generateMnemonic (strength, rng, wordlist) {\n  strength = strength || 128\n  if (strength % 32 !== 0) throw new TypeError(INVALID_ENTROPY)\n  rng = rng || randomBytes\n\n  return entropyToMnemonic(rng(strength / 8), wordlist)\n}\n\nfunction validateMnemonic (mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist)\n  } catch (e) {\n    return false\n  }\n\n  return true\n}\n\nmodule.exports = {\n  mnemonicToSeed: mnemonicToSeed,\n  mnemonicToSeedHex: mnemonicToSeedHex,\n  mnemonicToEntropy: mnemonicToEntropy,\n  entropyToMnemonic: entropyToMnemonic,\n  generateMnemonic: generateMnemonic,\n  validateMnemonic: validateMnemonic,\n  wordlists: {\n    EN: ENGLISH_WORDLIST\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}