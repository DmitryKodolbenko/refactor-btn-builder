{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamingSocket = void 0;\nconst xstream_1 = require(\"xstream\");\nconst socketwrapper_1 = require(\"./socketwrapper\");\n/**\n * A WebSocket wrapper that exposes all events as a stream.\n *\n * This underlying socket will not be closed when the stream has no listeners\n */\nclass StreamingSocket {\n  constructor(url) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    this.socket = new socketwrapper_1.SocketWrapper(url, event => {\n      if (this.eventProducerListener) {\n        this.eventProducerListener.next(event);\n      }\n    }, errorEvent => {\n      if (this.eventProducerListener) {\n        this.eventProducerListener.error(errorEvent);\n      }\n    }, () => {\n      // socket opened\n    }, closeEvent => {\n      if (this.eventProducerListener) {\n        if (closeEvent.wasClean) {\n          this.eventProducerListener.complete();\n        } else {\n          this.eventProducerListener.error(\"Socket was closed unclean\");\n        }\n      }\n    }, timeout);\n    this.connected = this.socket.connected;\n    const eventProducer = {\n      start: listener => this.eventProducerListener = listener,\n      stop: () => this.eventProducerListener = undefined\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n  }\n  connect() {\n    this.socket.connect();\n  }\n  disconnect() {\n    this.socket.disconnect();\n  }\n  async send(data) {\n    return this.socket.send(data);\n  }\n}\nexports.StreamingSocket = StreamingSocket;","map":{"version":3,"sources":["../src/streamingsocket.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA,MAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;AAEA;;;;AAIG;AACH,MAAa,eAAe,CAAA;EAM1B,WAAA,CAAmB,GAAW,EAAkB;IAAA,IAAhB,OAAO,uEAAG,KAAM;IAC9C,IAAI,CAAC,MAAM,GAAG,IAAI,eAAA,CAAA,aAAa,CAC7B,GAAG,EACF,KAAK,IAAI;MACR,IAAI,IAAI,CAAC,qBAAqB,EAAE;QAC9B,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,KAAK,CAAC;MACvC;IACH,CAAC,EACA,UAAU,IAAI;MACb,IAAI,IAAI,CAAC,qBAAqB,EAAE;QAC9B,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,UAAU,CAAC;MAC7C;IACH,CAAC,EACD,MAAK;MACH;IAAA,CACD,EACA,UAAU,IAAI;MACb,IAAI,IAAI,CAAC,qBAAqB,EAAE;QAC9B,IAAI,UAAU,CAAC,QAAQ,EAAE;UACvB,IAAI,CAAC,qBAAqB,CAAC,QAAQ,EAAE;SACtC,MAAM;UACL,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,2BAA2B,CAAC;QAC9D;MACF;IACH,CAAC,EACD,OAAO,CACR;IACD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS;IAEtC,MAAM,aAAa,GAAkB;MACnC,KAAK,EAAG,QAAQ,IAAM,IAAI,CAAC,qBAAqB,GAAG,QAAS;MAC5D,IAAI,EAAE,MAAO,IAAI,CAAC,qBAAqB,GAAG;KAC3C;IACD,IAAI,CAAC,MAAM,GAAG,SAAA,CAAA,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC;EAC5C;EAEO,OAAO,GAAA;IACZ,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;EACvB;EAEO,UAAU,GAAA;IACf,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE;EAC1B;EAEO,MAAM,IAAI,CAAC,IAAY,EAAA;IAC5B,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;EAC/B;AACD;AArDD,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StreamingSocket = void 0;\nconst xstream_1 = require(\"xstream\");\nconst socketwrapper_1 = require(\"./socketwrapper\");\n/**\n * A WebSocket wrapper that exposes all events as a stream.\n *\n * This underlying socket will not be closed when the stream has no listeners\n */\nclass StreamingSocket {\n    constructor(url, timeout = 10000) {\n        this.socket = new socketwrapper_1.SocketWrapper(url, (event) => {\n            if (this.eventProducerListener) {\n                this.eventProducerListener.next(event);\n            }\n        }, (errorEvent) => {\n            if (this.eventProducerListener) {\n                this.eventProducerListener.error(errorEvent);\n            }\n        }, () => {\n            // socket opened\n        }, (closeEvent) => {\n            if (this.eventProducerListener) {\n                if (closeEvent.wasClean) {\n                    this.eventProducerListener.complete();\n                }\n                else {\n                    this.eventProducerListener.error(\"Socket was closed unclean\");\n                }\n            }\n        }, timeout);\n        this.connected = this.socket.connected;\n        const eventProducer = {\n            start: (listener) => (this.eventProducerListener = listener),\n            stop: () => (this.eventProducerListener = undefined),\n        };\n        this.events = xstream_1.Stream.create(eventProducer);\n    }\n    connect() {\n        this.socket.connect();\n    }\n    disconnect() {\n        this.socket.disconnect();\n    }\n    async send(data) {\n        return this.socket.send(data);\n    }\n}\nexports.StreamingSocket = StreamingSocket;\n//# sourceMappingURL=streamingsocket.js.map"]},"metadata":{},"sourceType":"script"}