{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConnectedMeteorWalletAccount = exports.MeteorWallet = void 0;\nconst near_api_js_1 = require(\"near-api-js\");\n// import { Action, createTransaction, Transaction } from \"near-api-js/lib/transaction\";\nconst ExternalActionTypes_1 = require(\"../../meteor-common/src/models/external_actions/ExternalActionTypes\");\nconst borsh_1 = require(\"borsh\");\nconst StringUtils_1 = require(\"../../meteor-common/src/utils/StringUtils\");\n// import { PublicKey } from \"near-api-js/lib/utils\";\nconst EnvironmentStorageUtils_1 = require(\"../../meteor-common/src/utils/EnvironmentStorageUtils\");\nconst TransactionSchema_1 = require(\"./near-schema/TransactionSchema\");\nconst MeteorSdkUtils_1 = require(\"./utils/MeteorSdkUtils\");\nconst MeteorPostMessenger_1 = require(\"./postMessage/MeteorPostMessenger\");\nconst LOGIN_WALLET_URL_SUFFIX = \"/login/\";\nconst SIGN_WALLET_URL_SUFFIX = \"/sign/\";\nconst MULTISIG_HAS_METHOD = \"add_request_and_confirm\";\nconst LOCAL_STORAGE_KEY_SUFFIX = \"_meteor_wallet_auth_key\";\nconst PENDING_ACCESS_KEY_PREFIX = \"pending_key\"; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\nconst localStorageAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({\n  getString: key => window.localStorage.getItem(key),\n  setString: (key, value) => window.localStorage.setItem(key, value),\n  clear: key => window.localStorage.removeItem(key)\n});\nconst sessionAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({\n  getString: key => window.sessionStorage.getItem(key),\n  setString: (key, value) => window.sessionStorage.setItem(key, value),\n  clear: key => window.sessionStorage.removeItem(key)\n});\n/**\r\n * This class is used in conjunction with `near-api-js` and `BrowserLocalStorageKeyStore`.\r\n * It directs users to the Meteor Extension or (if not available) a popup of the Meteor Wallet website for key management.\r\n *\r\n * @example\r\n * ```js\r\n * import { MeteorWallet } from \"@meteorwallet/sdk\";\r\n *\r\n * // create new MeteorWallet instance (passing in your initialized Near connection)\r\n * const meteorWallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });\r\n *\r\n * // -- or -- (for a quick and default Near connection config)\r\n * const meteorWallet = MeteorWallet.init({ networkId: \"testnet\" });\r\n *\r\n * // If not signed in, start the sign-in flow with Meteor Wallet.\r\n * // Keys will be stored in the BrowserLocalStorageKeyStore\r\n * if(!meteorWallet.isSignedIn()) {\r\n *   const { accountId } = await meteorWallet.requestSignIn();\r\n * }\r\n * ```\r\n */\nclass MeteorWallet {\n  /**\r\n   * Construct MeteorWallet. If you'd a quick and default way, you can also use {@link MeteorWallet.init}\r\n   *\r\n   * @example\r\n   * ```js\r\n   * // create new MeteorWallet instance (passing in your initialized Near connection)\r\n   * const meteorWallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });\r\n   *\r\n   * if(!meteorWallet.isSignedIn()) {\r\n   *   const { accountId } = await meteorWallet.requestSignIn();\r\n   * }\r\n   * ```\r\n   */\n  constructor(_a) {\n    var _b, _c;\n    var {\n      near,\n      appKeyPrefix = (_b = near.config.contractName) !== null && _b !== void 0 ? _b : \"default\"\n    } = _a;\n    /** @hidden */\n    this._initializationPromises = [];\n    this._near = near;\n    const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n    this._authDataKey = authDataKey;\n    this._authData = (_c = localStorageAdapter.getJson(authDataKey)) !== null && _c !== void 0 ? _c : {\n      allKeys: []\n    };\n    this._networkId = near.config.networkId;\n    this._walletBaseUrl = near.config.walletUrl;\n    this._keyStore = near.connection.signer.keyStore;\n    /*\r\n    console.log(\"Initialized wallet- checking if signed in\");\r\n          if (!this.isSignedIn()) {\r\n      console.log(\"Completing sign-in process, if its available\");\r\n      this._initializationPromises.push(this._completeSignInWithAccessKey());\r\n    }*/\n  }\n  /**\r\n   * The easiest way to set up the SDK. Returns an instance of MeteorWallet, automatically connected to the Near API.\r\n   *\r\n   * If you need more control over the Near Network configuration- rather use {@link MeteorWallet:constructor}\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const wallet = await MeteorWallet.init({ networkId: \"testnet\" });\r\n   * ```\r\n   */\n  static async init(_ref) {\n    let {\n      walletUrl,\n      ...config\n    } = _ref;\n    const keyStore = new near_api_js_1.keyStores.BrowserLocalStorageKeyStore();\n    const near = await (0, near_api_js_1.connect)({\n      keyStore,\n      headers: {},\n      walletUrl: (0, MeteorSdkUtils_1.resolveWalletUrl)(config.networkId, walletUrl),\n      ...(0, MeteorSdkUtils_1.getNetworkPreset)(config.networkId),\n      ...config\n    });\n    const wallet = new MeteorWallet({\n      near,\n      appKeyPrefix: \"near_app\"\n    });\n    // Cleanup up any pending keys (cancelled logins).\n    if (!wallet.isSignedIn()) {\n      await keyStore.clear();\n    }\n    return wallet;\n  }\n  /* async initialize() {\r\n     await Promise.all(this._initializationPromises);\r\n   }*/\n  isExtensionInstalled() {\n    return window.meteorWallet != null;\n  }\n  /**\r\n   * Returns true, if this app is authorized with an account in the wallet.\r\n   * @example\r\n   * ```js\r\n   * const wallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });\r\n   * wallet.isSignedIn();\r\n   * ```\r\n   */\n  isSignedIn() {\n    return !!this._authData.accountId;\n  }\n  /**\r\n   * Returns authorized Account ID.\r\n   * @example\r\n   * ```js\r\n   * const wallet = new MeteorWallet(near, 'my-app');\r\n   * const accountId = wallet.getAccountId();\r\n   * ```\r\n   */\n  getAccountId() {\n    return this._authData.accountId;\n  }\n  /**\r\n   * Verifies that the user is the owner of a specific Near account, available in the wallet.\r\n   * Removes the need to do blockchain operations for simple Dapp actions.\r\n   * Signs a payload with the wallet's private key. Will return a promise with a payload like so:\r\n   *\r\n   * ```ts\r\n   * interface VerifiedOwner {\r\n   *   accountId: string;\r\n   *   message: string;                 // The same passed message, unencrypted\r\n   *   blockId: string;\r\n   *   publicKey: string;               // The public key which should be verified as belonging to this account\r\n   *   signature: string;               // The signed payload (this exact same object JSON stringified, excluding this \"signature\" property)\r\n   *   keyType: utils.key_pair.KeyType; // Type from inside the near-api-js package\r\n   * }\r\n   * ```\r\n   *\r\n   * or throw a {@link MeteorActionError} error if the verification failed for whatever reason.\r\n   * */\n  async verifyOwner(options) {\n    var _a;\n    const accountId = (_a = options.accountId) !== null && _a !== void 0 ? _a : this.getAccountId();\n    const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\n      actionType: ExternalActionTypes_1.EWalletExternalActionType.verify_owner,\n      inputs: {\n        accountId,\n        message: options.message\n      },\n      network: this._networkId\n    });\n    if (response.success) {\n      return response;\n    } else {\n      throw new ExternalActionTypes_1.MeteorActionError({\n        endTags: response.endTags,\n        message: response.message\n      });\n    }\n  }\n  /**\r\n   * Requests a sign-in using Meteor Wallet. Will return a promise with the `accountId` of the\r\n   * signed-in account, or throw a {@link MeteorActionError} error if the sign-in failed for whatever reason.\r\n   * */\n  async requestSignIn(options) {\n    const {\n      keyPair,\n      ...restOptions\n    } = options;\n    const accessKey = keyPair !== null && keyPair !== void 0 ? keyPair : near_api_js_1.KeyPair.fromRandom(\"ed25519\");\n    let usingPublicKey = accessKey.getPublicKey().toString();\n    const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\n      actionType: ExternalActionTypes_1.EWalletExternalActionType.login,\n      inputs: {\n        public_key: usingPublicKey,\n        ...restOptions\n      },\n      network: this._networkId\n    });\n    if (response.success) {\n      const {\n        allKeys,\n        accountId\n      } = response.payload;\n      this._authData = {\n        accountId,\n        allKeys,\n        signedInContract: {\n          contract_id: restOptions.contract_id,\n          public_key: usingPublicKey\n        }\n      };\n      localStorageAdapter.setJson(this._authDataKey, this._authData);\n      await this._keyStore.setKey(this._networkId, accountId, accessKey);\n      return {\n        success: true,\n        endTags: [],\n        payload: {\n          accessKey,\n          accountId\n        }\n      };\n    } else {\n      throw new ExternalActionTypes_1.MeteorActionError({\n        endTags: response.endTags,\n        message: response.message\n      });\n    }\n  }\n  /**\r\n   * Sign out from the current account\r\n   */\n  async signOut() {\n    const accountId = this.getAccountId();\n    if (this._authData.signedInContract != null && accountId != null) {\n      const inputs = {\n        accountId,\n        contractInfo: this._authData.signedInContract\n      };\n      const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\n        actionType: ExternalActionTypes_1.EWalletExternalActionType.logout,\n        inputs,\n        network: this._networkId\n      });\n    }\n    this._authData = {\n      allKeys: []\n    };\n    localStorageAdapter.clear(this._authDataKey);\n  }\n  /**\r\n   * Sign transactions using Meteor Wallet. Will return a promise with an array of `FinalExecutionOutcome`\r\n   * of the given transactions.\r\n   * */\n  async requestSignTransactions(inputs) {\n    const {\n      transactions\n    } = inputs;\n    const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\n      actionType: ExternalActionTypes_1.EWalletExternalActionType.sign,\n      inputs: {\n        transactions: transactions.map(transaction => (0, borsh_1.serialize)(TransactionSchema_1.SCHEMA, transaction)).map(serialized => Buffer.from(serialized).toString(\"base64\")).join(\",\")\n      },\n      // inputs: { public_key: usingPublicKey, ...options },\n      network: this._networkId\n    });\n    // console.log(\"Finished sign-in request\", response);\n    if (response.success) {\n      return response.payload.executionOutcomes;\n    } else {\n      throw new ExternalActionTypes_1.MeteorActionError({\n        endTags: response.endTags,\n        message: response.message\n      });\n    }\n    return [];\n  }\n  /**\r\n   * Returns the current connected wallet account\r\n   */\n  account() {\n    const currentAccountId = this.getAccountId();\n    if (!this._connectedAccount && (0, StringUtils_1.notNullEmpty)(currentAccountId)) {\n      this._connectedAccount = new ConnectedMeteorWalletAccount(this, this._near.connection, currentAccountId);\n    }\n    return this._connectedAccount;\n  }\n}\nexports.MeteorWallet = MeteorWallet;\n/**\r\n * Near Account implementation which makes use of {@link MeteorWallet} when no local key is available.\r\n *\r\n * Generally won't be created directly- can be obtained by using {@link MeteorWallet.account}\r\n *\r\n * @example\r\n * ```js\r\n * const account = meteorWallet.account();\r\n *\r\n * // uses Meteor Wallet to sign the transaction using this account\r\n * const response = await account.requestSignTransaction({\r\n *   actions: transactionActions,\r\n *   receiverId: \"my-contract\"\r\n * });\r\n * ```\r\n */\nclass ConnectedMeteorWalletAccount extends near_api_js_1.Account {\n  /** @hidden */\n  constructor(walletConnection, connection, accountId) {\n    super(connection, accountId);\n    this.meteorWallet = walletConnection;\n  }\n  /**\r\n   * Sign a transaction using Meteor Wallet. Overrides the Near Account API method of the same name, makes use of {@link ConnectedMeteorWalletAccount.signAndSendTransaction_direct}\r\n   */\n  async signAndSendTransaction() {\n    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === \"string\") {\n      return this.signAndSendTransaction_direct({\n        receiverId: arguments.length <= 0 ? undefined : arguments[0],\n        actions: arguments.length <= 1 ? undefined : arguments[1]\n      });\n    }\n    return this.signAndSendTransaction_direct(arguments.length <= 0 ? undefined : arguments[0]);\n  }\n  /** @hidden */\n  async trySendOrCreateTransaction(_ref2) {\n    let {\n      receiverId,\n      actions\n    } = _ref2;\n    const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n    let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);\n    if (!accessKey) {\n      throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\n    }\n    if (localKey && localKey.toString() === accessKey.public_key) {\n      try {\n        return {\n          executionOutcome: await super.signAndSendTransaction({\n            receiverId,\n            actions\n          }),\n          sent: true\n        };\n      } catch (e) {\n        if (e.type === \"NotEnoughAllowance\") {\n          accessKey = await this.accessKeyForTransaction(receiverId, actions);\n        } else {\n          throw e;\n        }\n      }\n    }\n    const block = await this.connection.provider.block({\n      finality: \"final\"\n    });\n    const blockHash = (0, borsh_1.baseDecode)(block.header.hash);\n    const publicKey = near_api_js_1.utils.PublicKey.from(accessKey.public_key);\n    // TODO: Cache & listen for nonce updates for given access key\n    const nonce = accessKey.access_key.nonce + 1;\n    const transaction = near_api_js_1.transactions.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n    return {\n      sent: false,\n      transaction\n    };\n  }\n  /**\r\n   * Sign a transaction using Meteor Wallet\r\n   * @see {@link MeteorWallet.requestSignTransactions}\r\n   */\n  async signAndSendTransaction_direct(_ref3) {\n    let {\n      receiverId,\n      actions\n    } = _ref3;\n    const {\n      transaction,\n      sent,\n      executionOutcome\n    } = await this.trySendOrCreateTransaction({\n      receiverId,\n      actions\n    });\n    if (sent) {\n      return executionOutcome;\n    }\n    return (await this.meteorWallet.requestSignTransactions({\n      transactions: [transaction]\n    }))[0];\n  }\n  /** @hidden */\n  /*async signAndSendTransaction_redirect({\r\n    receiverId,\r\n    actions,\r\n    walletMeta,\r\n    walletCallbackUrl = window.location.href,\r\n  }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome> {\r\n    const { transaction, sent, executionOutcome } = await this.trySendOrCreateTransaction({ receiverId, actions });\r\n        if (sent) {\r\n      return executionOutcome!;\r\n    }\r\n        await this.meteorWallet.requestSignTransactions_redirect({\r\n      transactions: [transaction!],\r\n      meta: walletMeta,\r\n      callback_url: walletCallbackUrl,\r\n    });\r\n        return new Promise((resolve, reject) => {\r\n      setTimeout(() => {\r\n        reject(new Error(\"Failed to redirect to sign transaction\"));\r\n      }, 1000);\r\n    });\r\n  }*/\n  /**\r\n   * Check if given access key allows the function call or method attempted in transaction\r\n   * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\r\n   * @param receiverId The NEAR account attempting to have access\r\n   * @param actions The action(s) needed to be checked for access\r\n   */\n  async accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n    const {\n      access_key: {\n        permission\n      }\n    } = accessKey;\n    if (permission === \"FullAccess\") {\n      return true;\n    }\n    if (permission.FunctionCall) {\n      const {\n        receiver_id: allowedReceiverId,\n        method_names: allowedMethods\n      } = permission.FunctionCall;\n      /********************************\r\n       Accept multisig access keys and let wallets attempt to signAndSendTransaction\r\n       If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\r\n       ********************************/\n      if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\n        return true;\n      }\n      if (allowedReceiverId === receiverId) {\n        if (actions.length !== 1) {\n          return false;\n        }\n        const [{\n          functionCall\n        }] = actions;\n        return functionCall && (!functionCall.deposit || functionCall.deposit.toString() === \"0\") && (\n        // TODO: Should support charging amount smaller than allowance?\n        allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));\n        // TODO: Handle cases when allowance doesn't have enough to pay for gas\n      }\n    }\n    // TODO: Support other permissions than FunctionCall\n    return false;\n  }\n  /**\r\n   * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\r\n   * @param receiverId The NEAR account seeking the access key for a transaction\r\n   * @param actions The action(s) sought to gain access to\r\n   * @param localKey A local public key provided to check for access\r\n   * @returns Promise<any>\r\n   */\n  async accessKeyForTransaction(receiverId, actions, localKey) {\n    const accessKeys = await this.getAccessKeys();\n    if (localKey) {\n      const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());\n      if (accessKey && (await this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n        return accessKey;\n      }\n    }\n    const walletKeys = this.meteorWallet._authData.allKeys;\n    for (const accessKey of accessKeys) {\n      if (walletKeys.indexOf(accessKey.public_key) !== -1 && (await this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n        return accessKey;\n      }\n    }\n    return null;\n  }\n}\nexports.ConnectedMeteorWalletAccount = ConnectedMeteorWalletAccount;","map":{"version":3,"sources":["meteor-sdk/src/MeteorWallet.ts"],"names":[],"mappings":"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","sourceRoot":"./src/","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ConnectedMeteorWalletAccount = exports.MeteorWallet = void 0;\r\nconst near_api_js_1 = require(\"near-api-js\");\r\n// import { Action, createTransaction, Transaction } from \"near-api-js/lib/transaction\";\r\nconst ExternalActionTypes_1 = require(\"../../meteor-common/src/models/external_actions/ExternalActionTypes\");\r\nconst borsh_1 = require(\"borsh\");\r\nconst StringUtils_1 = require(\"../../meteor-common/src/utils/StringUtils\");\r\n// import { PublicKey } from \"near-api-js/lib/utils\";\r\nconst EnvironmentStorageUtils_1 = require(\"../../meteor-common/src/utils/EnvironmentStorageUtils\");\r\nconst TransactionSchema_1 = require(\"./near-schema/TransactionSchema\");\r\nconst MeteorSdkUtils_1 = require(\"./utils/MeteorSdkUtils\");\r\nconst MeteorPostMessenger_1 = require(\"./postMessage/MeteorPostMessenger\");\r\nconst LOGIN_WALLET_URL_SUFFIX = \"/login/\";\r\nconst SIGN_WALLET_URL_SUFFIX = \"/sign/\";\r\nconst MULTISIG_HAS_METHOD = \"add_request_and_confirm\";\r\nconst LOCAL_STORAGE_KEY_SUFFIX = \"_meteor_wallet_auth_key\";\r\nconst PENDING_ACCESS_KEY_PREFIX = \"pending_key\"; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\r\nconst localStorageAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({\r\n    getString: (key) => window.localStorage.getItem(key),\r\n    setString: (key, value) => window.localStorage.setItem(key, value),\r\n    clear: (key) => window.localStorage.removeItem(key),\r\n});\r\nconst sessionAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({\r\n    getString: (key) => window.sessionStorage.getItem(key),\r\n    setString: (key, value) => window.sessionStorage.setItem(key, value),\r\n    clear: (key) => window.sessionStorage.removeItem(key),\r\n});\r\n/**\r\n * This class is used in conjunction with `near-api-js` and `BrowserLocalStorageKeyStore`.\r\n * It directs users to the Meteor Extension or (if not available) a popup of the Meteor Wallet website for key management.\r\n *\r\n * @example\r\n * ```js\r\n * import { MeteorWallet } from \"@meteorwallet/sdk\";\r\n *\r\n * // create new MeteorWallet instance (passing in your initialized Near connection)\r\n * const meteorWallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });\r\n *\r\n * // -- or -- (for a quick and default Near connection config)\r\n * const meteorWallet = MeteorWallet.init({ networkId: \"testnet\" });\r\n *\r\n * // If not signed in, start the sign-in flow with Meteor Wallet.\r\n * // Keys will be stored in the BrowserLocalStorageKeyStore\r\n * if(!meteorWallet.isSignedIn()) {\r\n *   const { accountId } = await meteorWallet.requestSignIn();\r\n * }\r\n * ```\r\n */\r\nclass MeteorWallet {\r\n    /**\r\n     * Construct MeteorWallet. If you'd a quick and default way, you can also use {@link MeteorWallet.init}\r\n     *\r\n     * @example\r\n     * ```js\r\n     * // create new MeteorWallet instance (passing in your initialized Near connection)\r\n     * const meteorWallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });\r\n     *\r\n     * if(!meteorWallet.isSignedIn()) {\r\n     *   const { accountId } = await meteorWallet.requestSignIn();\r\n     * }\r\n     * ```\r\n     */\r\n    constructor(_a) {\r\n        var _b, _c;\r\n        var { near, appKeyPrefix = (_b = near.config.contractName) !== null && _b !== void 0 ? _b : \"default\" } = _a;\r\n        /** @hidden */\r\n        this._initializationPromises = [];\r\n        this._near = near;\r\n        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\r\n        this._authDataKey = authDataKey;\r\n        this._authData = (_c = localStorageAdapter.getJson(authDataKey)) !== null && _c !== void 0 ? _c : { allKeys: [] };\r\n        this._networkId = near.config.networkId;\r\n        this._walletBaseUrl = near.config.walletUrl;\r\n        this._keyStore = near.connection.signer.keyStore;\r\n        /*\r\n        console.log(\"Initialized wallet- checking if signed in\");\r\n    \r\n        if (!this.isSignedIn()) {\r\n          console.log(\"Completing sign-in process, if its available\");\r\n          this._initializationPromises.push(this._completeSignInWithAccessKey());\r\n        }*/\r\n    }\r\n    /**\r\n     * The easiest way to set up the SDK. Returns an instance of MeteorWallet, automatically connected to the Near API.\r\n     *\r\n     * If you need more control over the Near Network configuration- rather use {@link MeteorWallet:constructor}\r\n     *\r\n     * @example\r\n     * ```js\r\n     * const wallet = await MeteorWallet.init({ networkId: \"testnet\" });\r\n     * ```\r\n     */\r\n    static async init({ walletUrl, ...config }) {\r\n        const keyStore = new near_api_js_1.keyStores.BrowserLocalStorageKeyStore();\r\n        const near = await (0, near_api_js_1.connect)({\r\n            keyStore,\r\n            headers: {},\r\n            walletUrl: (0, MeteorSdkUtils_1.resolveWalletUrl)(config.networkId, walletUrl),\r\n            ...(0, MeteorSdkUtils_1.getNetworkPreset)(config.networkId),\r\n            ...config,\r\n        });\r\n        const wallet = new MeteorWallet({ near, appKeyPrefix: \"near_app\" });\r\n        // Cleanup up any pending keys (cancelled logins).\r\n        if (!wallet.isSignedIn()) {\r\n            await keyStore.clear();\r\n        }\r\n        return wallet;\r\n    }\r\n    /* async initialize() {\r\n       await Promise.all(this._initializationPromises);\r\n     }*/\r\n    isExtensionInstalled() {\r\n        return window.meteorWallet != null;\r\n    }\r\n    /**\r\n     * Returns true, if this app is authorized with an account in the wallet.\r\n     * @example\r\n     * ```js\r\n     * const wallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });\r\n     * wallet.isSignedIn();\r\n     * ```\r\n     */\r\n    isSignedIn() {\r\n        return !!this._authData.accountId;\r\n    }\r\n    /**\r\n     * Returns authorized Account ID.\r\n     * @example\r\n     * ```js\r\n     * const wallet = new MeteorWallet(near, 'my-app');\r\n     * const accountId = wallet.getAccountId();\r\n     * ```\r\n     */\r\n    getAccountId() {\r\n        return this._authData.accountId;\r\n    }\r\n    /**\r\n     * Verifies that the user is the owner of a specific Near account, available in the wallet.\r\n     * Removes the need to do blockchain operations for simple Dapp actions.\r\n     * Signs a payload with the wallet's private key. Will return a promise with a payload like so:\r\n     *\r\n     * ```ts\r\n     * interface VerifiedOwner {\r\n     *   accountId: string;\r\n     *   message: string;                 // The same passed message, unencrypted\r\n     *   blockId: string;\r\n     *   publicKey: string;               // The public key which should be verified as belonging to this account\r\n     *   signature: string;               // The signed payload (this exact same object JSON stringified, excluding this \"signature\" property)\r\n     *   keyType: utils.key_pair.KeyType; // Type from inside the near-api-js package\r\n     * }\r\n     * ```\r\n     *\r\n     * or throw a {@link MeteorActionError} error if the verification failed for whatever reason.\r\n     * */\r\n    async verifyOwner(options) {\r\n        var _a;\r\n        const accountId = (_a = options.accountId) !== null && _a !== void 0 ? _a : this.getAccountId();\r\n        const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\r\n            actionType: ExternalActionTypes_1.EWalletExternalActionType.verify_owner,\r\n            inputs: {\r\n                accountId,\r\n                message: options.message,\r\n            },\r\n            network: this._networkId,\r\n        });\r\n        if (response.success) {\r\n            return response;\r\n        }\r\n        else {\r\n            throw new ExternalActionTypes_1.MeteorActionError({\r\n                endTags: response.endTags,\r\n                message: response.message,\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Requests a sign-in using Meteor Wallet. Will return a promise with the `accountId` of the\r\n     * signed-in account, or throw a {@link MeteorActionError} error if the sign-in failed for whatever reason.\r\n     * */\r\n    async requestSignIn(options) {\r\n        const { keyPair, ...restOptions } = options;\r\n        const accessKey = keyPair !== null && keyPair !== void 0 ? keyPair : near_api_js_1.KeyPair.fromRandom(\"ed25519\");\r\n        let usingPublicKey = accessKey.getPublicKey().toString();\r\n        const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\r\n            actionType: ExternalActionTypes_1.EWalletExternalActionType.login,\r\n            inputs: { public_key: usingPublicKey, ...restOptions },\r\n            network: this._networkId,\r\n        });\r\n        if (response.success) {\r\n            const { allKeys, accountId } = response.payload;\r\n            this._authData = {\r\n                accountId,\r\n                allKeys,\r\n                signedInContract: {\r\n                    contract_id: restOptions.contract_id,\r\n                    public_key: usingPublicKey,\r\n                },\r\n            };\r\n            localStorageAdapter.setJson(this._authDataKey, this._authData);\r\n            await this._keyStore.setKey(this._networkId, accountId, accessKey);\r\n            return {\r\n                success: true,\r\n                endTags: [],\r\n                payload: {\r\n                    accessKey,\r\n                    accountId,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            throw new ExternalActionTypes_1.MeteorActionError({\r\n                endTags: response.endTags,\r\n                message: response.message,\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Sign out from the current account\r\n     */\r\n    async signOut() {\r\n        const accountId = this.getAccountId();\r\n        if (this._authData.signedInContract != null && accountId != null) {\r\n            const inputs = {\r\n                accountId,\r\n                contractInfo: this._authData.signedInContract,\r\n            };\r\n            const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\r\n                actionType: ExternalActionTypes_1.EWalletExternalActionType.logout,\r\n                inputs,\r\n                network: this._networkId,\r\n            });\r\n        }\r\n        this._authData = { allKeys: [] };\r\n        localStorageAdapter.clear(this._authDataKey);\r\n    }\r\n    /**\r\n     * Sign transactions using Meteor Wallet. Will return a promise with an array of `FinalExecutionOutcome`\r\n     * of the given transactions.\r\n     * */\r\n    async requestSignTransactions(inputs) {\r\n        const { transactions } = inputs;\r\n        const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({\r\n            actionType: ExternalActionTypes_1.EWalletExternalActionType.sign,\r\n            inputs: {\r\n                transactions: transactions\r\n                    .map((transaction) => (0, borsh_1.serialize)(TransactionSchema_1.SCHEMA, transaction))\r\n                    .map((serialized) => Buffer.from(serialized).toString(\"base64\"))\r\n                    .join(\",\"),\r\n            },\r\n            // inputs: { public_key: usingPublicKey, ...options },\r\n            network: this._networkId,\r\n        });\r\n        // console.log(\"Finished sign-in request\", response);\r\n        if (response.success) {\r\n            return response.payload.executionOutcomes;\r\n        }\r\n        else {\r\n            throw new ExternalActionTypes_1.MeteorActionError({\r\n                endTags: response.endTags,\r\n                message: response.message,\r\n            });\r\n        }\r\n        return [];\r\n    }\r\n    /**\r\n     * Returns the current connected wallet account\r\n     */\r\n    account() {\r\n        const currentAccountId = this.getAccountId();\r\n        if (!this._connectedAccount && (0, StringUtils_1.notNullEmpty)(currentAccountId)) {\r\n            this._connectedAccount = new ConnectedMeteorWalletAccount(this, this._near.connection, currentAccountId);\r\n        }\r\n        return this._connectedAccount;\r\n    }\r\n}\r\nexports.MeteorWallet = MeteorWallet;\r\n/**\r\n * Near Account implementation which makes use of {@link MeteorWallet} when no local key is available.\r\n *\r\n * Generally won't be created directly- can be obtained by using {@link MeteorWallet.account}\r\n *\r\n * @example\r\n * ```js\r\n * const account = meteorWallet.account();\r\n *\r\n * // uses Meteor Wallet to sign the transaction using this account\r\n * const response = await account.requestSignTransaction({\r\n *   actions: transactionActions,\r\n *   receiverId: \"my-contract\"\r\n * });\r\n * ```\r\n */\r\nclass ConnectedMeteorWalletAccount extends near_api_js_1.Account {\r\n    /** @hidden */\r\n    constructor(walletConnection, connection, accountId) {\r\n        super(connection, accountId);\r\n        this.meteorWallet = walletConnection;\r\n    }\r\n    /**\r\n     * Sign a transaction using Meteor Wallet. Overrides the Near Account API method of the same name, makes use of {@link ConnectedMeteorWalletAccount.signAndSendTransaction_direct}\r\n     */\r\n    async signAndSendTransaction(...args) {\r\n        if (typeof args[0] === \"string\") {\r\n            return this.signAndSendTransaction_direct({ receiverId: args[0], actions: args[1] });\r\n        }\r\n        return this.signAndSendTransaction_direct(args[0]);\r\n    }\r\n    /** @hidden */\r\n    async trySendOrCreateTransaction({ receiverId, actions, }) {\r\n        const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\r\n        let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);\r\n        if (!accessKey) {\r\n            throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\r\n        }\r\n        if (localKey && localKey.toString() === accessKey.public_key) {\r\n            try {\r\n                return { executionOutcome: await super.signAndSendTransaction({ receiverId, actions }), sent: true };\r\n            }\r\n            catch (e) {\r\n                if (e.type === \"NotEnoughAllowance\") {\r\n                    accessKey = await this.accessKeyForTransaction(receiverId, actions);\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        const block = await this.connection.provider.block({ finality: \"final\" });\r\n        const blockHash = (0, borsh_1.baseDecode)(block.header.hash);\r\n        const publicKey = near_api_js_1.utils.PublicKey.from(accessKey.public_key);\r\n        // TODO: Cache & listen for nonce updates for given access key\r\n        const nonce = accessKey.access_key.nonce + 1;\r\n        const transaction = near_api_js_1.transactions.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\r\n        return {\r\n            sent: false,\r\n            transaction,\r\n        };\r\n    }\r\n    /**\r\n     * Sign a transaction using Meteor Wallet\r\n     * @see {@link MeteorWallet.requestSignTransactions}\r\n     */\r\n    async signAndSendTransaction_direct({ receiverId, actions, }) {\r\n        const { transaction, sent, executionOutcome } = await this.trySendOrCreateTransaction({ receiverId, actions });\r\n        if (sent) {\r\n            return executionOutcome;\r\n        }\r\n        return (await this.meteorWallet.requestSignTransactions({ transactions: [transaction] }))[0];\r\n    }\r\n    /** @hidden */\r\n    /*async signAndSendTransaction_redirect({\r\n      receiverId,\r\n      actions,\r\n      walletMeta,\r\n      walletCallbackUrl = window.location.href,\r\n    }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome> {\r\n      const { transaction, sent, executionOutcome } = await this.trySendOrCreateTransaction({ receiverId, actions });\r\n  \r\n      if (sent) {\r\n        return executionOutcome!;\r\n      }\r\n  \r\n      await this.meteorWallet.requestSignTransactions_redirect({\r\n        transactions: [transaction!],\r\n        meta: walletMeta,\r\n        callback_url: walletCallbackUrl,\r\n      });\r\n  \r\n      return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n          reject(new Error(\"Failed to redirect to sign transaction\"));\r\n        }, 1000);\r\n      });\r\n    }*/\r\n    /**\r\n     * Check if given access key allows the function call or method attempted in transaction\r\n     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\r\n     * @param receiverId The NEAR account attempting to have access\r\n     * @param actions The action(s) needed to be checked for access\r\n     */\r\n    async accessKeyMatchesTransaction(accessKey, receiverId, actions) {\r\n        const { access_key: { permission }, } = accessKey;\r\n        if (permission === \"FullAccess\") {\r\n            return true;\r\n        }\r\n        if (permission.FunctionCall) {\r\n            const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;\r\n            /********************************\r\n             Accept multisig access keys and let wallets attempt to signAndSendTransaction\r\n             If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\r\n             ********************************/\r\n            if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\r\n                return true;\r\n            }\r\n            if (allowedReceiverId === receiverId) {\r\n                if (actions.length !== 1) {\r\n                    return false;\r\n                }\r\n                const [{ functionCall }] = actions;\r\n                return (functionCall &&\r\n                    (!functionCall.deposit || functionCall.deposit.toString() === \"0\") && // TODO: Should support charging amount smaller than allowance?\r\n                    (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName)));\r\n                // TODO: Handle cases when allowance doesn't have enough to pay for gas\r\n            }\r\n        }\r\n        // TODO: Support other permissions than FunctionCall\r\n        return false;\r\n    }\r\n    /**\r\n     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\r\n     * @param receiverId The NEAR account seeking the access key for a transaction\r\n     * @param actions The action(s) sought to gain access to\r\n     * @param localKey A local public key provided to check for access\r\n     * @returns Promise<any>\r\n     */\r\n    async accessKeyForTransaction(receiverId, actions, localKey) {\r\n        const accessKeys = await this.getAccessKeys();\r\n        if (localKey) {\r\n            const accessKey = accessKeys.find((key) => key.public_key.toString() === localKey.toString());\r\n            if (accessKey && (await this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\r\n                return accessKey;\r\n            }\r\n        }\r\n        const walletKeys = this.meteorWallet._authData.allKeys;\r\n        for (const accessKey of accessKeys) {\r\n            if (walletKeys.indexOf(accessKey.public_key) !== -1 &&\r\n                (await this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\r\n                return accessKey;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\nexports.ConnectedMeteorWalletAccount = ConnectedMeteorWalletAccount;\r\n//# sourceMappingURL=MeteorWallet.js.map"]},"metadata":{},"sourceType":"script"}