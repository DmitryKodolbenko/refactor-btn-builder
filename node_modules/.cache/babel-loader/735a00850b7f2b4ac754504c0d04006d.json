{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ADNLAddress = void 0;\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\nconst base32_1 = require(\"../utils/base32\");\nconst crc16_1 = require(\"../utils/crc16\");\nclass ADNLAddress {\n  constructor(address) {\n    this.toString = () => {\n      return this.toFriendly();\n    };\n    this.toRaw = () => {\n      return this.address.toString('hex').toUpperCase();\n    };\n    this.toFriendly = () => {\n      let data = Buffer.concat([Buffer.from([0x2D]), this.address]);\n      let hash = (0, crc16_1.crc16)(data);\n      data = Buffer.concat([data, hash]);\n      return (0, base32_1.base32Encode)(data).slice(1);\n    };\n    this[_a] = () => this.toFriendly();\n    if (address.length !== 32) {\n      throw Error('Invalid address');\n    }\n    this.address = address;\n  }\n  static parseFriendly(src) {\n    if (src.length !== 55) {\n      throw Error('Invalid address');\n    }\n    // Decoding\n    src = 'f' + src;\n    let decoded = (0, base32_1.base32Decode)(src);\n    if (decoded[0] !== 0x2d) {\n      throw Error('Invalid address');\n    }\n    let gotHash = decoded.slice(33);\n    let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));\n    if (!hash.equals(gotHash)) {\n      throw Error('Invalid address');\n    }\n    return new ADNLAddress(decoded.slice(1, 33));\n  }\n  static parseRaw(src) {\n    const data = Buffer.from(src, 'base64');\n    return new ADNLAddress(data);\n  }\n  equals(b) {\n    return this.address.equals(b.address);\n  }\n}\nexports.ADNLAddress = ADNLAddress;\n_a = symbol_inspect_1.default;","map":{"version":3,"names":["__importDefault","mod","__esModule","_a","Object","defineProperty","exports","value","ADNLAddress","symbol_inspect_1","require","base32_1","crc16_1","constructor","address","toString","toFriendly","toRaw","toUpperCase","data","Buffer","concat","from","hash","crc16","base32Encode","slice","length","Error","parseFriendly","src","decoded","base32Decode","gotHash","equals","parseRaw","b","default"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/ton/dist/address/ADNLAddress.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ADNLAddress = void 0;\nconst symbol_inspect_1 = __importDefault(require(\"symbol.inspect\"));\nconst base32_1 = require(\"../utils/base32\");\nconst crc16_1 = require(\"../utils/crc16\");\nclass ADNLAddress {\n    constructor(address) {\n        this.toString = () => {\n            return this.toFriendly();\n        };\n        this.toRaw = () => {\n            return this.address.toString('hex').toUpperCase();\n        };\n        this.toFriendly = () => {\n            let data = Buffer.concat([Buffer.from([0x2D]), this.address]);\n            let hash = (0, crc16_1.crc16)(data);\n            data = Buffer.concat([data, hash]);\n            return (0, base32_1.base32Encode)(data).slice(1);\n        };\n        this[_a] = () => this.toFriendly();\n        if (address.length !== 32) {\n            throw Error('Invalid address');\n        }\n        this.address = address;\n    }\n    static parseFriendly(src) {\n        if (src.length !== 55) {\n            throw Error('Invalid address');\n        }\n        // Decoding\n        src = 'f' + src;\n        let decoded = (0, base32_1.base32Decode)(src);\n        if (decoded[0] !== 0x2d) {\n            throw Error('Invalid address');\n        }\n        let gotHash = decoded.slice(33);\n        let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));\n        if (!hash.equals(gotHash)) {\n            throw Error('Invalid address');\n        }\n        return new ADNLAddress(decoded.slice(1, 33));\n    }\n    static parseRaw(src) {\n        const data = Buffer.from(src, 'base64');\n        return new ADNLAddress(data);\n    }\n    equals(b) {\n        return this.address.equals(b.address);\n    }\n}\nexports.ADNLAddress = ADNLAddress;\n_a = symbol_inspect_1.default;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}