{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/sepezho/Work/tonana/fe/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcClient = void 0;\nvar stream_1 = require(\"@cosmjs/stream\");\nvar types_1 = require(\"./types\");\n/**\n * A thin wrapper that is used to bring together requests and responses by ID.\n *\n * Using this class is only advised for continous communication channels like\n * WebSockets or WebWorker messaging.\n */\nvar JsonRpcClient = /*#__PURE__*/function () {\n  function JsonRpcClient(connection) {\n    _classCallCheck(this, JsonRpcClient);\n    this.connection = connection;\n  }\n  _createClass(JsonRpcClient, [{\n    key: \"run\",\n    value: function () {\n      var _run = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {\n        var filteredStream, pendingResponses, response, error;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                filteredStream = this.connection.responseStream.filter(function (r) {\n                  return r.id === request.id;\n                });\n                pendingResponses = (0, stream_1.firstEvent)(filteredStream);\n                this.connection.sendRequest(request);\n                _context.next = 5;\n                return pendingResponses;\n              case 5:\n                response = _context.sent;\n                if (!(0, types_1.isJsonRpcErrorResponse)(response)) {\n                  _context.next = 9;\n                  break;\n                }\n                error = response.error;\n                throw new Error(\"JSON RPC error: code=\".concat(error.code, \"; message='\").concat(error.message, \"'\"));\n              case 9:\n                return _context.abrupt(\"return\", response);\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function run(_x) {\n        return _run.apply(this, arguments);\n      }\n      return run;\n    }()\n  }]);\n  return JsonRpcClient;\n}();\nexports.JsonRpcClient = JsonRpcClient;","map":{"version":3,"sources":["../src/jsonrpcclient.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;AAGA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAOA;;;;;AAKG;AALH,IAMa,aAAa;EAGxB,uBAAmB,UAAsE,EAAA;IAAA;IACvF,IAAI,CAAC,UAAU,GAAG,UAAU;EAC9B;EAAC;IAAA;IAAA;MAAA,sEAEM,iBAAU,OAAuB;QAAA;QAAA;UAAA;YAAA;cAAA;gBAChC,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,MAAM,CAAC,UAAC,CAAC;kBAAA,OAAK,CAAC,CAAC,EAAE,KAAK,OAAO,CAAC,EAAE;gBAAA,EAAC;gBAClF,gBAAgB,GAAG,CAAA,CAAA,EAAA,QAAA,CAAA,UAAU,EAAC,cAAc,CAAC;gBACnD,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,OAAO,CAAC;gBAAC;gBAAA,OAEd,gBAAgB;cAAA;gBAAjC,QAAQ;gBAAA,KACV,CAAA,CAAA,EAAA,OAAA,CAAA,sBAAsB,EAAC,QAAQ,CAAC;kBAAA;kBAAA;gBAAA;gBAC5B,KAAK,GAAG,QAAQ,CAAC,KAAK;gBAAA,MACtB,IAAI,KAAK,gCAAyB,KAAK,CAAC,IAAI,wBAAc,KAAK,CAAC,OAAO,OAAI;cAAA;gBAAA,iCAG5E,QAAQ;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAChB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA;AAnBH,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonRpcClient = void 0;\nconst stream_1 = require(\"@cosmjs/stream\");\nconst types_1 = require(\"./types\");\n/**\n * A thin wrapper that is used to bring together requests and responses by ID.\n *\n * Using this class is only advised for continous communication channels like\n * WebSockets or WebWorker messaging.\n */\nclass JsonRpcClient {\n    constructor(connection) {\n        this.connection = connection;\n    }\n    async run(request) {\n        const filteredStream = this.connection.responseStream.filter((r) => r.id === request.id);\n        const pendingResponses = (0, stream_1.firstEvent)(filteredStream);\n        this.connection.sendRequest(request);\n        const response = await pendingResponses;\n        if ((0, types_1.isJsonRpcErrorResponse)(response)) {\n            const error = response.error;\n            throw new Error(`JSON RPC error: code=${error.code}; message='${error.message}'`);\n        }\n        return response;\n    }\n}\nexports.JsonRpcClient = JsonRpcClient;\n//# sourceMappingURL=jsonrpcclient.js.map"]},"metadata":{},"sourceType":"script"}