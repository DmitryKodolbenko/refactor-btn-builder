{"ast":null,"code":"const {\n  Cell\n} = require(\"../../boc\");\nconst {\n  Address,\n  BN,\n  toNano,\n  bytesToHex,\n  hexToBytes,\n  nacl,\n  stringToBytes,\n  bytesToBase64,\n  base64ToBytes\n} = require(\"../../utils\");\nconst {\n  Contract\n} = require(\"../index.js\");\nconst {\n  WalletContract\n} = require(\"../wallet/WalletContract\");\nconst WALLET_ID_BASE = 698983191;\nclass LockupWalletV1 extends WalletContract {\n  /**\n   * @param provider    {HttpProvider}\n   * @param options {{publicKey?: Uint8Array, address?: Address | string, wc?: number, config: any}}\n   *\n   * Config json is {config}\n   */\n  constructor(provider, options) {\n    // options.config:\n    // {\n    //     wallet_type: \"lockup-0.1\",\n    //     config_pubkey: <base64-encoded pubkey>,\n    //     allowed_destinations: [ \"addr1\", \"addr2\", ... ]\n    // }\n\n    options.code = Cell.oneFromBoc(\"B5EE9C7241021E01000261000114FF00F4A413F4BCF2C80B010201200203020148040501F2F28308D71820D31FD31FD31F802403F823BB13F2F2F003802251A9BA1AF2F4802351B7BA1BF2F4801F0BF9015410C5F9101AF2F4F8005057F823F0065098F823F0062071289320D74A8E8BD30731D4511BDB3C12B001E8309229A0DF72FB02069320D74A96D307D402FB00E8D103A4476814154330F004ED541D0202CD0607020120131402012008090201200F100201200A0B002D5ED44D0D31FD31FD3FFD3FFF404FA00F404FA00F404D1803F7007434C0C05C6C2497C0F83E900C0871C02497C0F80074C7C87040A497C1383C00D46D3C00608420BABE7114AC2F6C2497C338200A208420BABE7106EE86BCBD20084AE0840EE6B2802FBCBD01E0C235C62008087E4055040DBE4404BCBD34C7E00A60840DCEAA7D04EE84BCBD34C034C7CC0078C3C412040DD78CA00C0D0E00130875D27D2A1BE95B0C60000C1039480AF00500161037410AF0050810575056001010244300F004ED540201201112004548E1E228020F4966FA520933023BB9131E2209835FA00D113A14013926C21E2B3E6308003502323287C5F287C572FFC4F2FFFD00007E80BD00007E80BD00326000431448A814C4E0083D039BE865BE803444E800A44C38B21400FE809004E0083D10C06002012015160015BDE9F780188242F847800C02012017180201481B1C002DB5187E006D88868A82609E00C6207E00C63F04EDE20B30020158191A0017ADCE76A268699F98EB85FFC00017AC78F6A268698F98EB858FC00011B325FB513435C2C7E00017B1D1BE08E0804230FB50F620002801D0D3030178B0925B7FE0FA4031FA403001F001A80EDAA4\");\n    super(provider, options);\n    if (!this.options.walletId) this.options.walletId = WALLET_ID_BASE + this.options.wc;\n    this.methods.getPublicKey = this.getPublicKey.bind(this);\n    this.methods.getWalletId = this.getWalletId.bind(this);\n    this.methods.getLiquidBalance = this.getLiquidBalance.bind(this);\n    this.methods.getNominalRestrictedBalance = this.getNominalRestrictedBalance.bind(this);\n    this.methods.getNominalLockedBalance = this.getNominalLockedBalance.bind(this);\n  }\n  getName() {\n    return 'lockup-0.1';\n  }\n\n  /**\n   * @override\n   * @private\n   * @param   seqno?   {number}\n   * @param   withoutOp? {boolean}\n   * @return {Cell}\n   */\n  createSigningMessage(seqno, withoutOp) {\n    seqno = seqno || 0;\n    const message = new Cell();\n    message.bits.writeUint(this.options.walletId, 32);\n    if (seqno === 0) {\n      // message.bits.writeInt(-1, 32);// todo: dont work\n      for (let i = 0; i < 32; i++) {\n        message.bits.writeBit(1);\n      }\n    } else {\n      const date = new Date();\n      const timestamp = Math.floor(date.getTime() / 1e3);\n      message.bits.writeUint(timestamp + 60, 32);\n    }\n    message.bits.writeUint(seqno, 32);\n    return message;\n  }\n\n  /**\n   * @override\n   * @return {Cell} cell contains wallet data\n   */\n  createDataCell() {\n    // from restricted.fc:\n    // .store_int(seqno, 32)\n    // .store_int(subwallet_id, 32)\n    // .store_uint(public_key, 256)\n    // .store_uint(config_public_key, 256)\n    // .store_dict(allowed_destinations)\n    // .store_grams(total_locked_value)\n    // .store_dict(locked)\n    // .store_grams(total_restricted_value)\n    // .store_dict(restricted).end_cell();\n\n    const cell = new Cell();\n    cell.bits.writeUint(0, 32); // seqno\n    cell.bits.writeUint(this.options.walletId, 32);\n    cell.bits.writeBytes(this.options.publicKey);\n\n    // TODO: write config.config_public_key (need to sort out encoding - the params come in base64),\n    // TODO: write the dict of allowed destinations (address is a key to an empty value).\n    cell.bits.writeBytes(base64ToBytes(this.options.config.config_public_key));\n    if (this.options.config.allowed_destinations) {\n      cell.bits.writeUint(1, 1);\n      cell.refs.push(Cell.oneFromBoc(base64ToBytes(this.options.config.allowed_destinations)));\n    } else {\n      cell.bits.writeUint(0, 1);\n    }\n    cell.bits.writeGrams(0); // .store_grams(total_locked_value)\n    cell.bits.writeUint(0, 1); // empty locked dict\n    cell.bits.writeGrams(0); // .store_grams(total_restricted_value)\n    cell.bits.writeUint(0, 1); // empty locked dict\n    return cell;\n  }\n\n  /**\n   * @return {Promise<number>}\n   */\n  async getWalletId() {\n    const myAddress = await this.getAddress();\n    const id = await this.provider.call2(myAddress.toString(), 'get_subwallet_id');\n    return id.toNumber();\n  }\n\n  /**\n   * @return {Promise<BN>}\n   */\n  async getPublicKey() {\n    const myAddress = await this.getAddress();\n    return this.provider.call2(myAddress.toString(), 'get_public_key');\n  }\n\n  /**\n   * @return {Promise<BN>} Amount of nanotoncoins that can be spent immediately.\n   */\n  async getLiquidBalance() {\n    const balances = await this.getBalances();\n    return balances[0] - balances[1] - balances[2];\n  }\n  /**\n   * @return {Promise<BN>} Amount of nanotoncoins that can be spent after the timelock OR to the whitelisted addresses.\n   */\n  async getNominalRestrictedBalance() {\n    return await this.getBalances()[1];\n  }\n\n  /**\n   * @return {Promise<BN>} Amount of nanotoncoins that can be spent after the timelock only (whitelisted addresses not used).\n   */\n  async getNominalLockedBalance() {\n    return await this.getBalances()[2];\n  }\n  /**\n   * @return {Promise<[BN,BN,BN]>} Total amount of nanotoncoins on the contract,\n   * nominal restricted value\n   * nominal locked value\n   */\n  async getBalances() {\n    const myAddress = await this.getAddress();\n    return this.provider.call2(myAddress.toString(), 'get_balances');\n  }\n}\nmodule.exports.default = {\n  LockupWalletV1,\n  all: {\n    'lockup-0.1': LockupWalletV1\n  },\n  list: [LockupWalletV1]\n};","map":{"version":3,"names":["Cell","require","Address","BN","toNano","bytesToHex","hexToBytes","nacl","stringToBytes","bytesToBase64","base64ToBytes","Contract","WalletContract","WALLET_ID_BASE","LockupWalletV1","constructor","provider","options","code","oneFromBoc","walletId","wc","methods","getPublicKey","bind","getWalletId","getLiquidBalance","getNominalRestrictedBalance","getNominalLockedBalance","getName","createSigningMessage","seqno","withoutOp","message","bits","writeUint","i","writeBit","date","Date","timestamp","Math","floor","getTime","createDataCell","cell","writeBytes","publicKey","config","config_public_key","allowed_destinations","refs","push","writeGrams","myAddress","getAddress","id","call2","toString","toNumber","balances","getBalances","module","exports","default","all","list"],"sources":["/Users/sepezho/Work/tonana/fe/node_modules/tonweb/src/contract/lockup/index.js"],"sourcesContent":["const {Cell} = require(\"../../boc\");\nconst {Address, BN, toNano, bytesToHex, hexToBytes, nacl, stringToBytes, bytesToBase64, base64ToBytes} = require(\"../../utils\");\nconst {Contract} = require(\"../index.js\");\nconst {WalletContract} = require(\"../wallet/WalletContract\");\n\nconst WALLET_ID_BASE = 698983191;\n\nclass LockupWalletV1 extends WalletContract {\n\n    /**\n     * @param provider    {HttpProvider}\n     * @param options {{publicKey?: Uint8Array, address?: Address | string, wc?: number, config: any}}\n     *\n     * Config json is {config}\n     */\n    constructor(provider, options) {\n        // options.config:\n        // {\n        //     wallet_type: \"lockup-0.1\",\n        //     config_pubkey: <base64-encoded pubkey>,\n        //     allowed_destinations: [ \"addr1\", \"addr2\", ... ]\n        // }\n\n        options.code = Cell.oneFromBoc(\"B5EE9C7241021E01000261000114FF00F4A413F4BCF2C80B010201200203020148040501F2F28308D71820D31FD31FD31F802403F823BB13F2F2F003802251A9BA1AF2F4802351B7BA1BF2F4801F0BF9015410C5F9101AF2F4F8005057F823F0065098F823F0062071289320D74A8E8BD30731D4511BDB3C12B001E8309229A0DF72FB02069320D74A96D307D402FB00E8D103A4476814154330F004ED541D0202CD0607020120131402012008090201200F100201200A0B002D5ED44D0D31FD31FD3FFD3FFF404FA00F404FA00F404D1803F7007434C0C05C6C2497C0F83E900C0871C02497C0F80074C7C87040A497C1383C00D46D3C00608420BABE7114AC2F6C2497C338200A208420BABE7106EE86BCBD20084AE0840EE6B2802FBCBD01E0C235C62008087E4055040DBE4404BCBD34C7E00A60840DCEAA7D04EE84BCBD34C034C7CC0078C3C412040DD78CA00C0D0E00130875D27D2A1BE95B0C60000C1039480AF00500161037410AF0050810575056001010244300F004ED540201201112004548E1E228020F4966FA520933023BB9131E2209835FA00D113A14013926C21E2B3E6308003502323287C5F287C572FFC4F2FFFD00007E80BD00007E80BD00326000431448A814C4E0083D039BE865BE803444E800A44C38B21400FE809004E0083D10C06002012015160015BDE9F780188242F847800C02012017180201481B1C002DB5187E006D88868A82609E00C6207E00C63F04EDE20B30020158191A0017ADCE76A268699F98EB85FFC00017AC78F6A268698F98EB858FC00011B325FB513435C2C7E00017B1D1BE08E0804230FB50F620002801D0D3030178B0925B7FE0FA4031FA403001F001A80EDAA4\");\n        super(provider, options);\n        if (!this.options.walletId) this.options.walletId = WALLET_ID_BASE + this.options.wc;\n\n        this.methods.getPublicKey = this.getPublicKey.bind(this);\n        this.methods.getWalletId = this.getWalletId.bind(this);\n        this.methods.getLiquidBalance = this.getLiquidBalance.bind(this);\n        this.methods.getNominalRestrictedBalance = this.getNominalRestrictedBalance.bind(this);\n        this.methods.getNominalLockedBalance = this.getNominalLockedBalance.bind(this);\n    }\n\n    getName() {\n        return 'lockup-0.1';\n    }\n\n    /**\n     * @override\n     * @private\n     * @param   seqno?   {number}\n     * @param   withoutOp? {boolean}\n     * @return {Cell}\n     */\n    createSigningMessage(seqno, withoutOp) {\n        seqno = seqno || 0;\n        const message = new Cell();\n        message.bits.writeUint(this.options.walletId, 32);\n        if (seqno === 0) {\n            // message.bits.writeInt(-1, 32);// todo: dont work\n            for (let i = 0; i < 32; i++) {\n                message.bits.writeBit(1);\n            }\n        } else {\n            const date = new Date();\n            const timestamp = Math.floor(date.getTime() / 1e3);\n            message.bits.writeUint(timestamp + 60, 32);\n        }\n        message.bits.writeUint(seqno, 32);\n        return message;\n    }\n\n    /**\n     * @override\n     * @return {Cell} cell contains wallet data\n     */\n    createDataCell() {\n        // from restricted.fc:\n        // .store_int(seqno, 32)\n        // .store_int(subwallet_id, 32)\n        // .store_uint(public_key, 256)\n        // .store_uint(config_public_key, 256)\n        // .store_dict(allowed_destinations)\n        // .store_grams(total_locked_value)\n        // .store_dict(locked)\n        // .store_grams(total_restricted_value)\n        // .store_dict(restricted).end_cell();\n\n        const cell = new Cell();\n        cell.bits.writeUint(0, 32); // seqno\n        cell.bits.writeUint(this.options.walletId, 32);\n        cell.bits.writeBytes(this.options.publicKey);\n\n        // TODO: write config.config_public_key (need to sort out encoding - the params come in base64),\n        // TODO: write the dict of allowed destinations (address is a key to an empty value).\n        cell.bits.writeBytes(base64ToBytes(this.options.config.config_public_key));\n        if (this.options.config.allowed_destinations) {\n            cell.bits.writeUint(1, 1);\n            cell.refs.push(Cell.oneFromBoc(base64ToBytes(this.options.config.allowed_destinations)));\n        } else {\n            cell.bits.writeUint(0, 1);\n        }\n\n        cell.bits.writeGrams(0);   // .store_grams(total_locked_value)\n        cell.bits.writeUint(0, 1); // empty locked dict\n        cell.bits.writeGrams(0);   // .store_grams(total_restricted_value)\n        cell.bits.writeUint(0, 1); // empty locked dict\n        return cell;\n    }\n\n    /**\n     * @return {Promise<number>}\n     */\n    async getWalletId() {\n        const myAddress = await this.getAddress();\n        const id = await this.provider.call2(myAddress.toString(), 'get_subwallet_id');\n        return id.toNumber();\n    }\n\n    /**\n     * @return {Promise<BN>}\n     */\n    async getPublicKey() {\n        const myAddress = await this.getAddress();\n        return this.provider.call2(myAddress.toString(), 'get_public_key');\n    }\n\n\n    /**\n     * @return {Promise<BN>} Amount of nanotoncoins that can be spent immediately.\n     */\n    async getLiquidBalance() {\n        const balances = await this.getBalances();\n        return balances[0]-balances[1]-balances[2];\n    }\n    /**\n     * @return {Promise<BN>} Amount of nanotoncoins that can be spent after the timelock OR to the whitelisted addresses.\n     */\n     async getNominalRestrictedBalance() {\n        return await this.getBalances()[1];\n    }\n\n    /**\n     * @return {Promise<BN>} Amount of nanotoncoins that can be spent after the timelock only (whitelisted addresses not used).\n     */\n     async getNominalLockedBalance() {\n        return await this.getBalances()[2];\n    }\n    /**\n     * @return {Promise<[BN,BN,BN]>} Total amount of nanotoncoins on the contract,\n     * nominal restricted value\n     * nominal locked value\n     */\n     async getBalances() {\n        const myAddress = await this.getAddress();\n        return this.provider.call2(myAddress.toString(), 'get_balances');\n    }\n}\n\nmodule.exports.default = {\n    LockupWalletV1,\n    all: {\n        'lockup-0.1': LockupWalletV1,\n    },\n    list: [LockupWalletV1]\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}