"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ton_1 = require("ton");
const NominatorPoolSource_1 = require("./NominatorPoolSource");
const fs = __importStar(require("fs"));
const NominatorPool_1 = require("./NominatorPool");
const topUpAddress_1 = require("./tests/topUpAddress");
const awaitCondition_1 = require("ton/dist/tests/awaitCondition");
const awaitSeqno_1 = require("./tests/awaitSeqno");
const client = new ton_1.TonClient({ endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC' });
function parseData(data) {
    let res = ton_1.Cell.fromBoc(data)[0];
    const slice = ton_1.Slice.fromCell(res);
    const seqno = slice.readUint(32);
    const owner = slice.readAddress();
    const seed = slice.readBuffer(32);
    const acceptStakes = slice.readBit();
    const workingCoins = slice.readCoins();
    const lockedCoins = slice.readCoins();
    const nominators = slice.readOptDict(256, (slice) => ({ stake: (0, ton_1.fromNano)(slice.readCoins()), locked: (0, ton_1.fromNano)(slice.readCoins()) }));
    console.warn(nominators);
}
describe('NominatorPool', () => {
    it('should conform to sources', () => {
        let source = fs.readFileSync(__dirname + '/../../contracts/nominator-pool.cell');
        expect(NominatorPoolSource_1.NominatorPoolSource.SOURCE.toString('base64')).toEqual(source.toString('base64'));
    });
    it('should parse data', () => {
        parseData(Buffer.from('te6cckEBAgEAdwABlQAAAAGABdKDBKoKIeylvKMvkrzd8kx/u3fPQlnrZfq6Osh4kyfgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQ7msoADAEATaAfbgG48KMsJCzkEIf/7nVUBtm8+QWadeayjUryqCULc6juaygAELxkHPM=', 'base64'));
    });
    it('should accept stake', async () => {
        // Create wallet
        let ownerWallet = await client.createNewWallet({ workchain: 0 });
        // Create pool
        const pool = await NominatorPool_1.NominatorPool.create(client, NominatorPoolSource_1.NominatorPoolSource.create({ owner: ownerWallet.wallet.address, workchain: 0 }));
        console.warn('Deploying to ' + pool.address.toFriendly());
        await (0, topUpAddress_1.topUpAddress)(client, pool.address, (0, ton_1.toNano)(1));
        await pool.deploy();
        await (0, awaitCondition_1.awaitCondition)(10000, () => client.isContractDeployed(pool.address));
        parseData((await client.getContractState(pool.address)).data);
        // Create nominator wallet
        let nominatorWallet = await client.createNewWallet({ workchain: 0 });
        console.warn('Creating wallet ' + nominatorWallet.wallet.address.toFriendly());
        await (0, topUpAddress_1.topUpAddress)(client, nominatorWallet.wallet.address, (0, ton_1.toNano)(3));
        // Send stake
        console.warn('Sending stake...');
        await nominatorWallet.wallet.transfer({
            seqno: 0,
            to: pool.address,
            bounce: true,
            payload: 'stake',
            sendMode: ton_1.SendMode.PAY_GAS_SEPARATLY | ton_1.SendMode.IGNORE_ERRORS,
            value: (0, ton_1.toNano)(2),
            secretKey: nominatorWallet.key.secretKey
        });
        await (0, awaitSeqno_1.awaitSeqno)(nominatorWallet.wallet, 1);
        parseData((await client.getContractState(pool.address)).data);
        // Checking nominators
    }, 120000);
});
