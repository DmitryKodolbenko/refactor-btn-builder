"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggerContractSource = void 0;
const ton_1 = require("ton");
class LoggerContractSource {
    static SOURCE = Buffer.from('te6ccgEBBgEAdgABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQBq8vkB7UTQ0x+DCNcY9AQwUzCDB/QOb6ExkvIA3nHIywBARIMH9EP4AAGkyMsfWM8W9ADJ7VQANtAw7UTQ0x+DCNcY9AQwAqTIyx8Bzxb0AMntVAARoJkv2omhrhY/', 'base64');
    static create(opts) {
        // Sanity check
        if (opts.seed.length !== 64) {
            throw Error('Seed must be 64 bytes long');
        }
        // Resolve parameters
        let workchain = opts.workchain;
        let seed = opts.seed;
        // Build initial code and data
        let initialCode = ton_1.Cell.fromBoc(LoggerContractSource.SOURCE)[0];
        let initialData = new ton_1.Cell();
        initialData.bits.writeUint(0, 32);
        initialData.bits.writeBuffer(opts.seed);
        initialData.bits.writeBit(0);
        return new LoggerContractSource({ initialCode, initialData, workchain, seed });
    }
    static restore(backup) {
        const store = new ton_1.ConfigStore(backup);
        return LoggerContractSource.create({
            workchain: store.getInt('wc'),
            seed: store.getBuffer('seed')
        });
    }
    initialCode;
    initialData;
    workchain;
    seed;
    type = 'org.ton.logger';
    constructor(args) {
        this.initialCode = args.initialCode;
        this.initialData = args.initialData;
        this.workchain = args.workchain;
        this.seed = args.seed;
    }
    describe() {
        return 'Logger Contract #' + this.seed.toString('hex');
    }
    backup() {
        const config = new ton_1.ConfigStore();
        config.setBuffer('seed', this.seed);
        config.setInt('wc', this.workchain);
        return config.save();
    }
}
exports.LoggerContractSource = LoggerContractSource;
