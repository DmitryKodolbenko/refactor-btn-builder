/// <reference types="node" />
import BN from "bn.js";
import { Address, Contract, UnknownContractSource, TonClient, Cell, ExternalMessage, Slice } from "ton";
export declare type ParsedMiningMessage = {
    op: 'mine';
    bounce: boolean;
    expire: number;
    address: Address;
    random: Buffer;
    seed: Buffer;
};
export declare class PowGiverContract implements Contract {
    static create(address: Address, client: TonClient): Promise<PowGiverContract>;
    static parseMiningMessage(slice: Slice): ParsedMiningMessage | null;
    /**
     * Extracts pow params from contract state without need to invoke get pow_params. This is faster, more predictable and allows to handle
     * race conditions when poling from multiple sources
     * @param cell state cell
     * @returns seed and complexity
     */
    static extractPowParamsFromState(cell: Cell): {
        seqno: BN;
        publicKey: Buffer;
        seed: Buffer;
        complexity: Buffer;
        lastSuccess: number;
        target: BN;
        targetDelta: number;
        minComplexity: Buffer;
        minComplexityShift: number;
        maxComplexity: Buffer;
        maxComplexityShift: number;
    };
    /**
     * Creates header of mining job. Just apply random, seed and random again to make a full job.
     * @param wallet wallet to mine to
     * @param expiresSec job expiration unixtime in seconds
     * @returns Buffer of job header
     */
    static createMiningJobHeader(wallet: Address, expiresSec: number): Buffer;
    /**
     * Creates full mining job
     * @param args.seed giver's current seed
     * @param args.random random value
     * @param args.wallet wallt to mine to
     * @param args.expiresSec job expiration unixtime in seconds
     * @returns Buffer of job
     */
    static createMiningJob(args: {
        seed: Buffer;
        random: Buffer;
        wallet: Address;
        expiresSec: number;
    }): Buffer;
    /**
     * Checks if mining result is valid
     * @param args.seed giver's current seed
     * @param args.random random value
     * @param args.wallet wallt to mine to
     * @param args.expiresSec job expiration unixtime in seconds
     * @param args.hash computed hash
     * @returns
     */
    static checkMiningJobHash(args: {
        seed: Buffer;
        random: Buffer;
        wallet: Address;
        expiresSec: number;
        hash: Buffer;
    }): Promise<boolean>;
    /**
     * Creates mining message to send to giver
     * @param args.giver giver address
     * @param args.seed giver seed
     * @param args.random giver random
     * @param args.wallet wallet to mine to
     * @param args.expiresSec expires in seconds
     * @returns
     */
    static createMiningMessage(args: {
        giver: Address;
        seed: Buffer;
        random: Buffer;
        wallet: Address;
        expiresSec: number;
    }): ExternalMessage;
    readonly client: TonClient;
    readonly address: Address;
    readonly source: UnknownContractSource;
    private constructor();
    getPowParams: () => Promise<{
        seed: Buffer;
        complexity: Buffer;
    }>;
}
