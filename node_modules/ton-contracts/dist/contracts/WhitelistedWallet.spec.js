"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const ton_1 = require("ton");
const openTestTreasure_1 = require("ton/dist/tests/openTestTreasure");
const awaitBalance_1 = require("ton/dist/tests/awaitBalance");
const bn_js_1 = require("bn.js");
const createWalletKey_1 = require("./tests/createWalletKey");
const patterns_1 = require("@openland/patterns");
const __1 = require("..");
describe('WhitelistedWallet', () => {
    it('should conform to sources', () => {
        let source = fs.readFileSync(__dirname + '/../../contracts/whitelisted-wallet.cell');
        expect(__1.WhitelistedWalletSource.SOURCE.toString('base64')).toEqual(source.toString('base64'));
    });
    it('should backup and restore', async () => {
        let masterKey = await (0, createWalletKey_1.createWalletKey)();
        let restrictedKey = await (0, createWalletKey_1.createWalletKey)();
        // Whitelisted wallet key
        const client = new ton_1.TonClient({ endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC' });
        let whitelistedWallet = await client.createNewWallet({ workchain: 0 });
        const wallet = __1.WhitelistedWalletSource.create({
            masterKey: masterKey.publicKey,
            restrictedKey: restrictedKey.publicKey,
            workchain: 0,
            whitelistedAddress: whitelistedWallet.wallet.address
        });
        let backup = wallet.backup();
        __1.WhitelistedWalletSource.restore(backup);
        __1.WhitelistedWalletSource.restore(backup);
        __1.WhitelistedWalletSource.restore(backup);
    });
    it('should work', async () => {
        const client = new ton_1.TonClient({ endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC' });
        // Open Treasure
        let treasure = await (0, openTestTreasure_1.openTestTreasure)(client);
        // Whitelisted wallet key
        let whitelistedWallet = await client.createNewWallet({ workchain: 0 });
        // Wallet that is allowed only for non-restricted key
        let foreignWallet = await client.createNewWallet({ workchain: 0 });
        // Wallet Keys
        let masterKey = await (0, createWalletKey_1.createWalletKey)();
        let invalidKey = await (0, createWalletKey_1.createWalletKey)();
        let restrictedKey = await (0, createWalletKey_1.createWalletKey)();
        // Wallet
        const wallet = await client.openWalletFromCustomContract(__1.WhitelistedWalletSource.create({
            masterKey: masterKey.publicKey,
            restrictedKey: restrictedKey.publicKey,
            workchain: 0,
            whitelistedAddress: whitelistedWallet.wallet.address
        }));
        // Requirements
        expect((await client.getBalance(wallet.address)).toNumber()).toBe(0);
        expect((await client.getBalance(whitelistedWallet.wallet.address)).toNumber()).toBe(0);
        // Fill wallet
        const seqno = await treasure.wallet.getSeqNo();
        await treasure.wallet.transfer({
            to: wallet.address,
            seqno: seqno,
            bounce: false,
            value: (0, ton_1.toNano)(0.1),
            secretKey: treasure.secretKey
        });
        await (0, awaitBalance_1.awaitBalance)(client, wallet.address, new bn_js_1.BN(0));
        // Send transfer via master key
        expect(await wallet.getSeqNo()).toBe(0);
        await wallet.transfer({
            seqno: 0,
            to: foreignWallet.wallet.address,
            value: (0, ton_1.toNano)(0.001),
            secretKey: masterKey.secretKey,
            bounce: false
        });
        await (0, awaitBalance_1.awaitBalance)(client, foreignWallet.wallet.address, new bn_js_1.BN(0));
        let cooldown = parseInt((await client.callGetMethod(wallet.address, 'restricted_cooldown')).stack[0][1], 16);
        expect(cooldown).toBe(0);
        // Send transfer via invalid key
        expect(await wallet.getSeqNo()).toBe(1);
        let initial = await client.getBalance(wallet.address);
        await wallet.transfer({
            seqno: 1,
            to: whitelistedWallet.wallet.address,
            value: (0, ton_1.toNano)(0.002),
            secretKey: invalidKey.secretKey,
            bounce: false
        });
        await (0, patterns_1.delay)(15000);
        expect((await client.getBalance(wallet.address)).eq(initial)).toBe(true);
        cooldown = parseInt((await client.callGetMethod(wallet.address, 'restricted_cooldown')).stack[0][1], 16);
        expect(cooldown).toBe(0);
        // Send transfer via restireted key to non-whitelisted
        expect(await wallet.getSeqNo()).toBe(1);
        initial = await client.getBalance(wallet.address);
        await wallet.transfer({
            seqno: 1,
            to: foreignWallet.wallet.address,
            value: (0, ton_1.toNano)(0.003),
            secretKey: restrictedKey.secretKey,
            bounce: false
        });
        await (0, patterns_1.delay)(15000);
        expect((await client.getBalance(wallet.address)).eq(initial)).toBe(true);
        cooldown = parseInt((await client.callGetMethod(wallet.address, 'restricted_cooldown')).stack[0][1], 16);
        expect(cooldown).toBe(0);
        // Result seqno
        expect(await wallet.getSeqNo()).toBe(1);
        // Send transfer via restricted key
        expect(await wallet.getSeqNo()).toBe(1);
        await wallet.transfer({
            seqno: 1,
            to: whitelistedWallet.wallet.address,
            value: (0, ton_1.toNano)(0.004),
            secretKey: restrictedKey.secretKey,
            bounce: false
        });
        await (0, awaitBalance_1.awaitBalance)(client, whitelistedWallet.wallet.address, new bn_js_1.BN(0));
        cooldown = parseInt((await client.callGetMethod(wallet.address, 'restricted_cooldown')).stack[0][1], 16);
        await (0, patterns_1.delay)(5000); // Race condition?
        expect(cooldown).toBeGreaterThan(0);
        // If sent too often it must be ignored
        initial = await client.getBalance(whitelistedWallet.wallet.address);
        expect(await wallet.getSeqNo()).toBe(2);
        await wallet.transfer({
            seqno: 2,
            to: whitelistedWallet.wallet.address,
            value: (0, ton_1.toNano)(0.005),
            secretKey: restrictedKey.secretKey,
            bounce: false
        });
        await (0, patterns_1.delay)(15000);
        expect((await client.getBalance(whitelistedWallet.wallet.address)).eq(initial)).toBe(true);
        cooldown = parseInt((await client.callGetMethod(wallet.address, 'restricted_cooldown')).stack[0][1], 16);
        expect(cooldown).toBeGreaterThan(0);
    }, 120000);
});
