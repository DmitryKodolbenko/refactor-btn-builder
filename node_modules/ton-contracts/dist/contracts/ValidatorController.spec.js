"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const ton_1 = require("ton");
const awaitBalance_1 = require("ton/dist/tests/awaitBalance");
const bn_js_1 = require("bn.js");
const createWalletKey_1 = require("./tests/createWalletKey");
const ValidatorControllerSource_1 = require("./ValidatorControllerSource");
const topUpAddress_1 = require("./tests/topUpAddress");
const awaitSeqno_1 = require("./tests/awaitSeqno");
const client = new ton_1.TonClient({ endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC' });
async function createNewWallets() {
    let masterKey = await (0, createWalletKey_1.createWalletKey)();
    let restrictedKey = await (0, createWalletKey_1.createWalletKey)();
    // Wallet that is allowed only for non-restricted key
    let foreignWallet = await client.createNewWallet({ workchain: 0 });
    // Whitelisted wallet key
    let whitelistedWallet = await client.createNewWallet({ workchain: 0 });
    // Create wallet
    const wallet = await client.openWalletFromCustomContract(ValidatorControllerSource_1.ValidatorControllerSource.create({
        masterKey: masterKey.publicKey,
        restrictedKey: restrictedKey.publicKey,
        workchain: 0,
        whitelistedAddress: whitelistedWallet.wallet.address
    }));
    console.warn('Created wallet ' + wallet.address.toFriendly());
    // Top up contract
    await (0, topUpAddress_1.topUpAddress)(client, wallet.address, (0, ton_1.toNano)(0.1));
    return {
        wallet,
        masterKey,
        restrictedKey,
        whitelistedWallet,
        foreignWallet
    };
}
describe('ValidatorController', () => {
    it('should conform to sources', () => {
        let source = fs.readFileSync(__dirname + '/../../contracts/validator-controller.cell');
        expect(ValidatorControllerSource_1.ValidatorControllerSource.SOURCE.toString('base64')).toEqual(source.toString('base64'));
    });
    it('should backup and restore', async () => {
        let masterKey = await (0, createWalletKey_1.createWalletKey)();
        let restrictedKey = await (0, createWalletKey_1.createWalletKey)();
        // Whitelisted wallet key
        let whitelistedWallet = await client.createNewWallet({ workchain: 0 });
        const wallet = ValidatorControllerSource_1.ValidatorControllerSource.create({
            masterKey: masterKey.publicKey,
            restrictedKey: restrictedKey.publicKey,
            workchain: 0,
            whitelistedAddress: whitelistedWallet.wallet.address
        });
        let backup = wallet.backup();
        ValidatorControllerSource_1.ValidatorControllerSource.restore(backup);
        ValidatorControllerSource_1.ValidatorControllerSource.restore(backup);
        ValidatorControllerSource_1.ValidatorControllerSource.restore(backup);
    });
    it('should transfer via master key', async () => {
        let state = await createNewWallets();
        // Transfer to whitelisted to init
        expect(await state.wallet.getSeqNo()).toBe(0);
        await state.wallet.transfer({
            seqno: 0,
            to: state.foreignWallet.wallet.address,
            value: (0, ton_1.toNano)(0.001),
            secretKey: state.masterKey.secretKey,
            bounce: false
        });
        await (0, awaitBalance_1.awaitBalance)(client, state.foreignWallet.wallet.address, new bn_js_1.BN(0));
        // Check balances
        expect((await client.getBalance(state.wallet.address)).toNumber()).toBeGreaterThan(0);
        expect((await client.getBalance(state.foreignWallet.wallet.address)).toNumber()).toBeGreaterThan(0);
        // Check cooldown
        let cooldown = parseInt((await client.callGetMethod(state.wallet.address, 'restricted_cooldown')).stack[0][1], 16);
        expect(cooldown).toBeGreaterThan(0);
    }, 120000);
    it('should transfer via master key with big payload', async () => {
        let state = await createNewWallets();
        // Transfer to whitelisted to init
        expect(await state.wallet.getSeqNo()).toBe(0);
        await state.wallet.transfer({
            seqno: 0,
            to: state.foreignWallet.wallet.address,
            value: (0, ton_1.toNano)(0.001),
            secretKey: state.masterKey.secretKey,
            bounce: false,
            payload: Buffer.from([
                0x52, 0x67, 0x43, 0x70,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0
            ])
        });
        await (0, awaitBalance_1.awaitBalance)(client, state.foreignWallet.wallet.address, new bn_js_1.BN(0));
        // Check balances
        expect((await client.getBalance(state.wallet.address)).toNumber()).toBeGreaterThan(0);
        expect((await client.getBalance(state.foreignWallet.wallet.address)).toNumber()).toBeGreaterThan(0);
        // Check cooldown
        let cooldown = parseInt((await client.callGetMethod(state.wallet.address, 'restricted_cooldown')).stack[0][1], 16);
        expect(cooldown).toBeGreaterThan(0);
    }, 120000);
    it('should transfer via restricted key to whitelisted', async () => {
        let state = await createNewWallets();
        expect(await state.wallet.getSeqNo()).toBe(0);
        await state.wallet.transfer({
            seqno: 0,
            to: state.whitelistedWallet.wallet.address,
            value: (0, ton_1.toNano)(0.001),
            secretKey: state.restrictedKey.secretKey,
            bounce: true,
            payload: Buffer.from([0x52, 0x67, 0x43, 0x70]) // Required
        });
        await (0, awaitSeqno_1.awaitSeqno)(state.wallet, 1);
        let cooldown = parseInt((await client.callGetMethod(state.wallet.address, 'restricted_cooldown')).stack[0][1], 16);
        expect(cooldown).toBeGreaterThan(0);
    }, 120000);
    it('should transfer via restricted key to whitelisted with large payload', async () => {
        let state = await createNewWallets();
        expect(await state.wallet.getSeqNo()).toBe(0);
        await state.wallet.transfer({
            seqno: 0,
            to: state.whitelistedWallet.wallet.address,
            value: (0, ton_1.toNano)(0.001),
            secretKey: state.restrictedKey.secretKey,
            bounce: true,
            payload: Buffer.from([
                0x52, 0x67, 0x43, 0x70,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0
            ]) // Required
        });
        await (0, awaitSeqno_1.awaitSeqno)(state.wallet, 1);
        let cooldown = parseInt((await client.callGetMethod(state.wallet.address, 'restricted_cooldown')).stack[0][1], 16);
        expect(cooldown).toBeGreaterThan(0);
    }, 120000);
    it('should NOT transfer via restricted key to whitelisted if payload is invalid', async () => {
        let state = await createNewWallets();
        expect(await state.wallet.getSeqNo()).toBe(0);
        await state.wallet.transfer({
            seqno: 0,
            to: state.whitelistedWallet.wallet.address,
            value: (0, ton_1.toNano)(0.001),
            secretKey: state.restrictedKey.secretKey,
            bounce: true
        });
        await expect((0, awaitSeqno_1.awaitSeqno)(state.wallet, 1)).rejects.toThrowError();
    }, 120000);
    it('should NOT transfer via restricted key to whitelisted if bounce is invalid', async () => {
        let state = await createNewWallets();
        expect(await state.wallet.getSeqNo()).toBe(0);
        await state.wallet.transfer({
            seqno: 0,
            to: state.whitelistedWallet.wallet.address,
            value: (0, ton_1.toNano)(0.001),
            secretKey: state.restrictedKey.secretKey,
            bounce: false,
            payload: Buffer.from([0x52, 0x67, 0x43, 0x70]) // Required
        });
        await expect((0, awaitSeqno_1.awaitSeqno)(state.wallet, 1)).rejects.toThrowError();
    }, 120000);
});
